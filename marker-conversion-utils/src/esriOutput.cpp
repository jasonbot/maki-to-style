// This source is all automatically generated. Editing it may very
// well be an exercise in futility and frustration.
#include "Python.h"
#include "datetime.h"

// imports
#import "ArcGISVersion.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids, rename("esriProductCode", "esriVersionProductCode"), rename("VersionManager", "ArcGISVersionManager")
#import "esriSystem.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("OLE_COLOR", "OLE_HANDLE", "VARTYPE")
#import "esriSystemUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeometry.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsCore.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsSymbols.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDisplay.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriServer.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriOutput.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabase.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseDistributed.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseExtensions.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabasePS.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGISClient.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesFile.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesGDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesOleDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRaster.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesNetCDF.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRasterUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriCarto.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("UINT_PTR")


// Globals we need to keep around -- a reference to the UUID class for mapping
// GUIDs to Python-usable UUIDs and the IUnknown type we'll be using across the
// board.
static PyObject* g_pUUID_type = NULL;
static PyObject* g_pUnk_type = NULL;
static PyObject* g_pIIDMap = NULL;
static PyObject* g_pCLSIDMap = NULL;
static PyObject* g_pRecordMap = NULL;

// PyObject destructor for PyCObjects that hold IUnknown* in them
static void
destr_unknown(void* pvUnk)
{
    IUnknown* pUnk = (IUnknown*)pvUnk;
    if (pUnk)
        pUnk->Release();
}

// Checker/caster to see if we can get a GUID from a Python object, either
// by  checking if the object is an instance of the uuid.UUID type, or if
// it is a string, coercing it with the constructor and seeing if it accepts
// it.
//
// def GuidFromPyObject(potentialIID, GUID*):
//     if isinstance(potentialIID, basestring):
//         try:
//             potentialIID = uuid.UUID(potentialIID)
//         except:
//             return False
//     if isinstance(potentialIID, uuid.UUID):
//         if (<copy raw bytes of UUID data in object to out GUID*>):
//             return True
//     return False
//
static bool
GuidFromPyObject(PyObject* potentialIID, GUID* pOutGUID)
{
    if (!g_pUUID_type)
        return false;

    // See if we can cast a string into a UUID instance, if that's what we've got.
    if (PyString_Check(potentialIID) || PyUnicode_Check(potentialIID))
    {
        PyObject* piid_object = PyObject_CallFunction(g_pUUID_type, "O", potentialIID);
        bool retval = (piid_object)?GuidFromPyObject(piid_object, pOutGUID): false;
        Py_XDECREF(piid_object);
        if (!piid_object || PyErr_Occurred())
        {
            PyErr_Clear();
            PyObject* unicodearg = NULL;
            if (PyString_Check(potentialIID))
                unicodearg = PyUnicode_FromObject(potentialIID);
            else if (PyUnicode_Check(potentialIID))
            {
                unicodearg = potentialIID;
                Py_INCREF(unicodearg);
            }
            if (unicodearg)
            {
                BSTR classname = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodearg),
                                                     (UINT)PyUnicode_GET_SIZE(unicodearg));
                CLSID clsid;
                if (CLSIDFromProgID(classname, &clsid) == S_OK)
                {
                    retval = true;
                    if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)&clsid, 16))
                        retval = false;
                }
                ::SysFreeString(classname);
            }
            Py_XDECREF(unicodearg);
        }
        return retval;
    }
    else if (PyObject_IsInstance(potentialIID, g_pUUID_type))
    {
        // Fetch raw bytes string -- need to fetch "bytes" on big-endian, 
        // "bytes_le" on little-endian architectures
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )        
            pBytes = PyObject_GetAttrString(potentialIID, "bytes");
        else
            pBytes = PyObject_GetAttrString(potentialIID, "bytes_le");
        if (pBytes)
        {
            bool retval = true;
            // Pointer to raw data
            char* pRawBytes = PyString_AsString(pBytes);
            if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)pRawBytes, 16))
                retval = false;
            Py_XDECREF(pBytes);
            return retval;
        }
        PyErr_Clear();
    }
    return false;
}

static PyObject*
GUIDToPythonUUID(const GUID* UUID)
{
    if (UUID)
    {
        // Lie to Python and tell it that our GUID is a 16-byte string
        PyObject* PyUUIDString = PyString_FromStringAndSize((char *)UUID, sizeof(GUID));
        if (!PyUUIDString)
            return NULL;
        // Args, varargs
        PyObject* PyArgs = PyTuple_New(0);
        PyObject* PyKWArgs = PyDict_New();
        PyObject* RetVal = NULL;
        // Dict with single value: the keyword argument bytes_le.
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )
            PyDict_SetItemString(PyKWArgs, "bytes", PyUUIDString);
        else
            PyDict_SetItemString(PyKWArgs, "bytes_le", PyUUIDString);
        // New UUID with KW
        if (g_pUUID_type)
            RetVal = PyObject_Call(g_pUUID_type, PyArgs, PyKWArgs);
        else
            PyErr_SetString(PyExc_ImportError, "UUID module import failed");

        Py_DECREF(PyUUIDString);
        Py_DECREF(PyArgs);
        Py_DECREF(PyKWArgs);
        return RetVal;
    }
    else
    {
        PyErr_SetString(PyExc_ValueError, "Bad GUID");
        return NULL;
    }
}

static PyObject*
IUnknownToPythonIIDObject(IUnknown* pUnk, const GUID* IID)
{
    PyObject* RetVal = NULL;
    pUnk->AddRef();
    PyObject* PyUnk = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    //return PyUnk;

    PyObject* pCall = NULL;

    PyObject* pGuidObject = GUIDToPythonUUID(IID);
    if (!pGuidObject || !g_pIIDMap)
        return PyUnk;

    if (PyDict_Contains(g_pIIDMap, pGuidObject) == 1)
        pCall = PyDict_GetItem(g_pIIDMap, pGuidObject);
    if (!pCall)
        pCall = g_pUnk_type;
    if (pCall)
        RetVal = PyObject_CallFunction(pCall, "O", PyUnk);

    if (!RetVal)
        RetVal = PyUnk;
    else
        Py_DECREF(PyUnk);

    Py_XDECREF(pGuidObject);
    return RetVal;
}

static PyObject*
DATE_AsPyObject(DATE in_date)
{
  PyDateTime_IMPORT;
  // Round to even number of days
  int days = (int)in_date;
  // Convert what's left (after the decimal) to seconds; 86400 seconds per day.
  int seconds = (int)((in_date - (double)days) * 86400.0);
  if (in_date < 0)
    seconds *= -1;
  // TimeDelta to add to the date representing the start of all Variant VT_DATEs
  PyObject* pDelta = PyDelta_FromDSU(days, seconds, 0);
  // Midnight 30 December 1899
  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  // Do addition of computed delta to 1899-12-30 00:00:00
  PyObject* pRetVal = PyObject_CallMethod(pStartOfVariantTime, "__add__", "O", pDelta);

  Py_XDECREF(pDelta);
  Py_XDECREF(pStartOfVariantTime);

  return pRetVal;
}

static DATE
PyObject_AsDATE(PyObject* in_date)
{
  PyDateTime_IMPORT;
  if (!PyDateTime_Check(in_date))
  {
    PyErr_SetString(PyExc_ValueError, "Cannot convert this Python object to a datetime");
    return (DATE)0.0;
  }

  double out_date;

  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  PyDateTime_Delta* pDelta = (PyDateTime_Delta *)PyObject_CallMethod(in_date, "__sub__", "O", pStartOfVariantTime);
  Py_XDECREF(pStartOfVariantTime);
  
  if (pDelta && PyDelta_Check((PyObject *)pDelta))
  {
    out_date = (double)pDelta->days;
    out_date += (double)(pDelta->seconds) / 86400.0;
  }
  
  Py_XDECREF(pDelta);
  return (DATE)out_date;
}

static bool
PyObject_AsVariant(PyObject* in_object, VARIANT* out_variant)
{
  ::VariantClear(out_variant);
  PyDateTime_IMPORT;

  if (in_object == Py_None)
    return true;
  else if (PyUnicode_Check(in_object))
  {
    out_variant->vt = VT_BSTR;
    BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(in_object), 
                                          (UINT)PyUnicode_GET_SIZE(in_object));
    out_variant->bstrVal = out_string;
    return true;
  }
  else if (PyString_Check(in_object))
  {
    PyObject* pUnicode = PyUnicode_FromObject(in_object);
    if (pUnicode)
    {
      out_variant->vt = VT_BSTR;
      BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(pUnicode), 
                                            (UINT)PyUnicode_GET_SIZE(pUnicode));
      out_variant->bstrVal = out_string;
      Py_DECREF(pUnicode);
      return true;
    }
    return false;
  }
  else if (PyFloat_Check(in_object))
  {
    out_variant->vt = VT_R8;
    out_variant->dblVal = PyFloat_AsDouble(in_object);
    return true;
  }
  else if (PyInt_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyInt_AsLong(in_object);
    return true;
  }
  else if (PyLong_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyLong_AsLongLong(in_object);
    if (PyErr_Occurred())
    {
      PyErr_Clear();
      PyObject* strval = PyObject_Str(in_object);
      if (strval)
      {
        PyObject* unival = PyUnicode_FromObject(strval);
        out_variant->vt = VT_BSTR;
        BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unival), 
                                              (UINT)PyUnicode_GET_SIZE(unival));
        out_variant->bstrVal = out_string;
        Py_DecRef(unival);
        Py_DecRef(strval);
        return true;
      }
      return false;
    }
    else
      return true;
  }
  else if (PyDateTime_Check(in_object))
  {
    out_variant->vt = VT_DATE;
    out_variant->date = PyObject_AsDATE(in_object);

    return true;
  }
  else if (PyObject_HasAttrString(in_object, "_pUnk"))
  {
    PyObject* pUnk = PyObject_GetAttrString(in_object, "_pUnk");
    if (pUnk && PyCObject_Check(pUnk))
    {
      IUnknown* pIUnknown = (IUnknown*)PyCObject_AsVoidPtr(pUnk);
      pIUnknown->AddRef();
      out_variant->vt = VT_UNKNOWN;
      out_variant->punkVal = pIUnknown;
      Py_DecRef(pUnk);
      return true;
    }
    Py_XDECREF(pUnk);
  }
  PyObject* repr = PyObject_Repr(in_object);
  PyErr_Format(PyExc_ValueError, "Can't convert %s to Variant.", repr?PyString_AsString(repr):"<Undef>", NULL);
  Py_XDECREF(repr);
  return false;
}

// Forward decl!
static PyObject* SAFEARRAYToPyObject(SAFEARRAY*, VARTYPE);

static PyObject*
Variant_AsPyObject(VARIANT* in_variant)
{
  if (in_variant->vt == VT_EMPTY)
    Py_RETURN_NONE;
  else if (in_variant->vt  == (VT_BYREF|VT_I1))
    return PyInt_FromLong(*(in_variant->pcVal)); //CHAR                *
  else if (in_variant->vt == (VT_BYREF|VT_UI2))
    return PyInt_FromLong(*(in_variant->puiVal)); //USHORT              *
  else if (in_variant->vt == (VT_BYREF|VT_UI4))
    return PyInt_FromLong(*(in_variant->pulVal)); //ULONG               *
  else if (in_variant->vt == (VT_BYREF|VT_UI8))
    return PyLong_FromUnsignedLongLong(*(in_variant->pullVal)); //ULONGLONG           *
  else if (in_variant->vt == (VT_BYREF|VT_INT))
    return PyInt_FromLong(*(in_variant->pintVal)); //INT                 *
  else if (in_variant->vt == (VT_BYREF|VT_UINT))
    return PyInt_FromLong(*(in_variant->puintVal)); //UINT                *
  else if (in_variant->vt == (VT_BYREF|VT_UI1))
    return PyInt_FromLong(*(in_variant->pbVal)); //BYTE                *
  else if (in_variant->vt == (VT_BYREF|VT_I2))
    return PyInt_FromLong(*(in_variant->piVal)); //SHORT               *
  else if (in_variant->vt == (VT_BYREF|VT_I4))
    return PyInt_FromLong(*(in_variant->plVal)); //LONG                *
  else if (in_variant->vt == (VT_BYREF|VT_I8))
    return PyLong_FromLongLong(*(in_variant->pllVal)); //LONGLONG            *
  else if (in_variant->vt == (VT_BYREF|VT_R4))
    return PyFloat_FromDouble((double)*(in_variant->pfltVal)); //FLOAT               *
  else if (in_variant->vt == (VT_BYREF|VT_R8))
    return PyFloat_FromDouble((double)*(in_variant->pdblVal)); //DOUBLE              *
  else if (in_variant->vt == (VT_BYREF|VT_BOOL))
    if ((*(in_variant->pboolVal)) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;
  else if (in_variant->vt == (VT_BYREF|VT_BSTR))
    return PyUnicode_FromWideChar(*(in_variant->pbstrVal),::SysStringLen(*(in_variant->pbstrVal)));  //BSTR                *
  else if (in_variant->vt == (VT_BYREF|VT_UNKNOWN))
  {
    IUnknown* pUnk = *(in_variant->ppunkVal);
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_DISPATCH))
  {
    IDispatch* pDisp = *(in_variant->ppdispVal);
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_VARIANT))
    return Variant_AsPyObject(in_variant->pvarVal); //VARIANT             *
  else if (in_variant->vt  == VT_I8)
    return PyLong_FromLongLong(in_variant->llVal); //LONGLONG           
  else if (in_variant->vt == VT_I4)
    return PyInt_FromLong(in_variant->lVal); //LONG               
  else if (in_variant->vt == VT_UI1)
    return PyInt_FromLong((unsigned)in_variant->bVal); //BYTE               
  else if (in_variant->vt == VT_I2)
    return PyInt_FromLong(in_variant->iVal); //SHORT              
  else if (in_variant->vt == VT_R4)
    return PyFloat_FromDouble((double)(in_variant->fltVal)); //FLOAT              
  else if (in_variant->vt == VT_R8)
    return PyFloat_FromDouble((double)(in_variant->dblVal)); //DOUBLE             
  else if (in_variant->vt == VT_BOOL)
    if ((in_variant->boolVal) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;              
  else if (in_variant->vt == VT_BSTR)
    return PyUnicode_FromWideChar(in_variant->bstrVal, ::SysStringLen(in_variant->bstrVal)); //BSTR               
  else if (in_variant->vt == VT_UNKNOWN)
  {
    IUnknown* pUnk = in_variant->punkVal;
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_DISPATCH)
  {
    IDispatch* pDisp = in_variant->pdispVal;
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_I1)
    return PyInt_FromLong(in_variant->cVal); //CHAR               
  else if (in_variant->vt == VT_UI2)
    return PyInt_FromLong(in_variant->uiVal); //USHORT             
  else if (in_variant->vt == VT_UI4)
    return PyInt_FromLong(in_variant->ulVal); //ULONG              
  else if (in_variant->vt == VT_UI8)
    return PyLong_FromUnsignedLongLong(in_variant->ullVal); //ULONGLONG          
  else if (in_variant->vt == VT_INT)
    return PyInt_FromLong(in_variant->intVal); //INT                
  else if (in_variant->vt == VT_UINT)
    return PyInt_FromLong(in_variant->uintVal); //UINT               
  else if ((in_variant->vt & VT_DATE) == VT_DATE)
  {
    DATE in_date = (in_variant->vt & VT_BYREF)?(*(in_variant->pdate)):in_variant->date;
    return DATE_AsPyObject(in_date);
  }
  else if (in_variant->vt & VT_ARRAY)
  {
    return SAFEARRAYToPyObject((in_variant->vt & VT_BYREF) ? 
                                        *(in_variant->pparray) : 
                                        in_variant->parray,
                                (in_variant->vt));
  }

  PyErr_SetString(PyExc_ValueError, "Cannot convert this variant to a Python object");
  return NULL;
}

static PyObject*
SAFEARRAYToPyObject(SAFEARRAY* pArray, VARTYPE vt)
{
  if (!pArray)
    Py_RETURN_NONE;
  PyObject* return_array(NULL);
  long entry_count(1);
  for (ssize_t dimension(0); dimension < pArray->cDims; ++dimension)
    entry_count *= (pArray->rgsabound[dimension]).cElements;
  if (pArray->fFeatures & FADF_BSTR)
  {
    return_array = PyList_New(0);
    BSTR* barray = (BSTR*)pArray->pvData;
    for (long string_index = 0; string_index < entry_count; ++string_index)
    {
      PyObject* new_string = PyUnicode_FromWideChar(barray[string_index], ::SysStringLen(barray[string_index]));
      PyList_Append(return_array, new_string);
      Py_DECREF(new_string);
    }
  }
  else if (pArray->fFeatures & FADF_VARIANT)
  {
    return_array = PyList_New(0);
    VARIANT* varray = (VARIANT*)pArray->pvData;
    for (long variant_index(0); variant_index < entry_count; ++variant_index)
    {
      PyObject* new_variant = Variant_AsPyObject(&varray[variant_index]);
      if (new_variant)
      {
        PyList_Append(return_array, new_variant);
        Py_DECREF(new_variant);
      }
      else
      {
        PyErr_Clear();
        PyList_Append(return_array, Py_None);
      }
    }
  }
  else if (pArray->fFeatures & FADF_UNKNOWN)
  {
    return_array = PyList_New(0);
    IUnknown** oarray = (IUnknown**)pArray->pvData;
    for (long object_index(0); object_index < entry_count; ++object_index)
    {
      PyObject* new_object = IUnknownToPythonIIDObject(oarray[object_index], &IID_IUnknown);
      PyList_Append(return_array, new_object);
      Py_DECREF(new_object);
    }
  }
  else if (vt == (VT_UI1 | VT_ARRAY))
  {
    return_array = PyByteArray_FromStringAndSize((char*)(pArray->pvData), entry_count);
  }

  if (!return_array)
  {
    if (PyErr_WarnEx(PyExc_Warning, "conversion for this error type not implemented", -1) != 0)
      return 0;

    return_array = Py_BuildValue("(HHNK)", (unsigned short)vt,
                                           (unsigned short)pArray->fFeatures,
                                           PyByteArray_FromStringAndSize((char*)(pArray->pvData), 
                                                                         sizeof(pArray->pvData)),
                                           (unsigned long long)pArray->pvData);
  }
  return return_array;
}

// Attempt to get an interface pointer from a Python object
static bool
IFaceFromPyObject(PyObject* pIn, const GUID* pOutGuid, void** pOutIFace)
{
    IUnknown* pUnk = NULL;

    if (pIn == Py_None)
    {
        *pOutIFace = NULL;
        return true;
    }
    else if (PyCObject_Check(pIn))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(pIn);
    }
    else
    {
        bool need_decref(false);
        if (PyObject_HasAttrString(pIn, "_arc_object"))
        {
          pIn = PyObject_GetAttrString(pIn, "_arc_object");
          if (pIn)
            need_decref = true;
        }
        PyObject* pObject = PyObject_GetAttrString(pIn, "_pUnk");
        if (!pObject)
            return false;
        if (!PyCObject_Check(pObject))
            return false;
        else
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(pObject);
        if (need_decref)
            Py_DECREF(pIn);
        Py_XDECREF(pObject);
    }
    if (pUnk && SUCCEEDED(pUnk->QueryInterface(*pOutGuid, pOutIFace)))
        return true;

    return false;
}



// Every module implements this IUnknown thing but only one reference to the 
// _Type struct will be used between them, so type checking will still work.
// This has the happy side effect of letting us pick and choose which of the
// OLBs that are offered as wrappers (and just plain remove them) without 
// needing to worry about it. Whichever of the C modules in the suite that gets
// imported first is fully capable and will do its best to bootstrap the system.

typedef struct IUnknownObject {
    PyObject_HEAD
    IUnknown* m_pUnk;
} IUnknownObject;

static PyObject*
IUnknownObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    IUnknownObject* self;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {        
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUnknown with provided CLSID");
            return NULL;
        }
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        pUnk->AddRef();
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUnknown");
            return NULL;
        }
        if (!PyCObject_Check(argument))
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUnknown");
            return NULL;
        }
        else
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
            pUnk->AddRef();
        }
        if (argument)
            Py_DECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    if (!(self = ((IUnknownObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUnknown");
        return NULL;
    }

    self->m_pUnk = pUnk;
    return (PyObject *)self;
}

static void
IUnknownObject_dealloc(IUnknownObject* self)
{
    if (self->m_pUnk)
        self->m_pUnk->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
IUnknown_GetpUnk(IUnknownObject* self)
{
    if (!self->m_pUnk)
        Py_RETURN_NONE;
    self->m_pUnk->AddRef();
    return PyCObject_FromVoidPtr((void*)self->m_pUnk, destr_unknown);
}

static PyObject*
IUnknown_GetPointer(IUnknownObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pUnk);
}

static PyObject*
IUnknown_GetIID(IUnknownObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
IUnknown_SupportsInterface(IUnknownObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pUnk->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}

PyMethodDef IUnknownMethods[] = {
    {"supports", (PyCFunction)IUnknown_SupportsInterface, METH_O, ""},
};

PyGetSetDef IUnknownGetSet[] = {
  {"_IID", (getter)IUnknown_GetIID, NULL, "Get IID for Unknown", NULL},
  {"_pUnk", (getter)IUnknown_GetpUnk, NULL, "Get opaque pointer to Unknown", NULL},
  {"_pointer", (getter)IUnknown_GetPointer, NULL, "Get long pointer to Unknown", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject IUnknownObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "cartocomutils.IUnknown",
                                              /* tp_name */
  sizeof(IUnknownObject),                     /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)IUnknownObject_dealloc,         /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "IUnknown",                                 /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  IUnknownMethods,                            /* tp_methods */
  0,                                          /* tp_members */
  IUnknownGetSet,                             /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  IUnknownObject_new,                         /* tp_new */
};




// Interface IFontMap

typedef struct PyIFontMapObject {
    PyObject_HEAD
    IFontMap* m_pIFontMap;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIFontMapObject;

static PyObject*
PyIFontMapObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIFontMapObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IFontMap* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IFontMap, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IFontMap with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIFontMapObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IFontMap");
            return NULL;
        }
        self->m_pIFontMap = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IFontMap");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IFontMap");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IFontMap* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IFontMap, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IFontMap");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIFontMapObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IFontMap");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIFontMap = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIFontMapObject_dealloc(PyIFontMapObject* self)
{
    if (self->m_pIFontMap)
        self->m_pIFontMap->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIFontMap_GetpUnk(PyIFontMapObject* self)
{
    if (!self->m_pIFontMap)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIFontMap->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IFontMap to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIFontMap_GetPointer(PyIFontMapObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIFontMap);
}

static PyObject*
PyIFontMap_GetIID(PyIFontMapObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7539e7dc-2d89-11d3-9fc6-00c04f6bc8dd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIFontMap_GetHR(PyIFontMapObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIFontMap_GetIgnoreFailures(PyIFontMapObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIFontMap_SetIgnoreFailures(PyIFontMapObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIFontMap_SupportsInterface(PyIFontMapObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIFontMap->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IFontMapMethod_get_TrueTypeFont(PyIFontMapObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfont;
    PyObject* pyvar_font = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for font

    // Call method on actual COM interface
    hr = self->m_pIFontMap->get_TrueTypeFont(&bsfont);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMap->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMap) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMap.get_TrueTypeFont() returned %ld", (long)hr);
        goto ifontmap_get_truetypefont_method_cleanup;
    }

    // Set up return values as needed
    pyvar_font = PyUnicode_FromWideChar(bsfont,::SysStringLen(bsfont));
    ::SysFreeString(bsfont);
    
    if (PyErr_Occurred())
      goto ifontmap_get_truetypefont_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_font);
    goto ifontmap_get_truetypefont_method_cleanup;

    ifontmap_get_truetypefont_method_cleanup:
    self->m_HR = hr;
    if (pyvar_font != Py_None)
        Py_XDECREF(pyvar_font);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMap.get_TrueTypeFont");
    return return_tuple;
}

static PyObject*
IFontMapMethod_get_MappedFont(PyIFontMapObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfont;
    PyObject* pyvar_font = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for font

    // Call method on actual COM interface
    hr = self->m_pIFontMap->get_MappedFont(&bsfont);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMap->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMap) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMap.get_MappedFont() returned %ld", (long)hr);
        goto ifontmap_get_mappedfont_method_cleanup;
    }

    // Set up return values as needed
    pyvar_font = PyUnicode_FromWideChar(bsfont,::SysStringLen(bsfont));
    ::SysFreeString(bsfont);
    
    if (PyErr_Occurred())
      goto ifontmap_get_mappedfont_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_font);
    goto ifontmap_get_mappedfont_method_cleanup;

    ifontmap_get_mappedfont_method_cleanup:
    self->m_HR = hr;
    if (pyvar_font != Py_None)
        Py_XDECREF(pyvar_font);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMap.get_MappedFont");
    return return_tuple;
}

static PyObject*
IFontMapMethod_put_Mapping(PyIFontMapObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTrueTypeFont = 0;
    PyObject* pyvar_TrueTypeFont;
    PyObject* unicodeTrueTypeFont = NULL;
    BSTR bs_arg2 = 0;
    PyObject* pyvar__arg2;
    PyObject* unicode_arg2 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_TrueTypeFont, &pyvar__arg2))
      goto ifontmap_put_mapping_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_TrueTypeFont))
        unicodeTrueTypeFont = PyUnicode_FromObject(pyvar_TrueTypeFont);
    else if (PyUnicode_Check(pyvar_TrueTypeFont))
    {
        unicodeTrueTypeFont = pyvar_TrueTypeFont;
        Py_INCREF(unicodeTrueTypeFont);
    }
    else if (pyvar_TrueTypeFont != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter TrueTypeFont at index 0");
    if (unicodeTrueTypeFont)
        bsTrueTypeFont = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTrueTypeFont), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTrueTypeFont));
    
    if (PyErr_Occurred())
      goto ifontmap_put_mapping_method_cleanup;
    
    if (PyString_Check(pyvar__arg2))
        unicode_arg2 = PyUnicode_FromObject(pyvar__arg2);
    else if (PyUnicode_Check(pyvar__arg2))
    {
        unicode_arg2 = pyvar__arg2;
        Py_INCREF(unicode_arg2);
    }
    else if (pyvar__arg2 != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter _arg2 at index 1");
    if (unicode_arg2)
        bs_arg2 = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicode_arg2), 
                                            (UINT)PyUnicode_GET_SIZE(unicode_arg2));
    
    if (PyErr_Occurred())
      goto ifontmap_put_mapping_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMap->put_Mapping(bsTrueTypeFont, bs_arg2);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMap->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMap) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMap.put_Mapping() returned %ld", (long)hr);
        goto ifontmap_put_mapping_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TrueTypeFont
    // No teardown for _arg2

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmap_put_mapping_method_cleanup;

    ifontmap_put_mapping_method_cleanup:
    self->m_HR = hr;
    if (bsTrueTypeFont)
        ::SysFreeString(bsTrueTypeFont);
    
    if (bs_arg2)
        ::SysFreeString(bs_arg2);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMap.put_Mapping");
    return return_tuple;
}


PyMethodDef PyIFontMapMethods[] = {
    {"supports", (PyCFunction)PyIFontMap_SupportsInterface, METH_O, ""},
    {"get_TrueTypeFont", (PyCFunction)IFontMapMethod_get_TrueTypeFont, METH_VARARGS, ""},
    {"get_MappedFont", (PyCFunction)IFontMapMethod_get_MappedFont, METH_VARARGS, ""},
    {"put_Mapping", (PyCFunction)IFontMapMethod_put_Mapping, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIFontMapGetSet[] = {
  {"_pUnk", (getter)PyIFontMap_GetpUnk, NULL, "Get opaque pointer to an Unknown from IFontMap", NULL},
  {"_pointer", (getter)PyIFontMap_GetPointer, NULL, "Get memory address for IFontMap", NULL},
  {"_IID", (getter)PyIFontMap_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIFontMap_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIFontMap_GetIgnoreFailures, (setter)PyIFontMap_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIFontMapObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IFontMapObject",                          
                                              /* tp_name */
  sizeof(PyIFontMapObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIFontMapObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIFontMapMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIFontMapGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIFontMapObject_new,                      
                                              /* tp_new */
};

// Interface IFontMap2

typedef struct PyIFontMap2Object {
    PyObject_HEAD
    IFontMap2* m_pIFontMap2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIFontMap2Object;

static PyObject*
PyIFontMap2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIFontMap2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IFontMap2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IFontMap2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IFontMap2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIFontMap2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IFontMap2");
            return NULL;
        }
        self->m_pIFontMap2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IFontMap2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IFontMap2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IFontMap2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IFontMap2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IFontMap2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIFontMap2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IFontMap2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIFontMap2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIFontMap2Object_dealloc(PyIFontMap2Object* self)
{
    if (self->m_pIFontMap2)
        self->m_pIFontMap2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIFontMap2_GetpUnk(PyIFontMap2Object* self)
{
    if (!self->m_pIFontMap2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIFontMap2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IFontMap2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIFontMap2_GetPointer(PyIFontMap2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIFontMap2);
}

static PyObject*
PyIFontMap2_GetIID(PyIFontMap2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e4f70d20-046d-490d-a5e3-066e681ab5b1");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIFontMap2_GetHR(PyIFontMap2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIFontMap2_GetIgnoreFailures(PyIFontMap2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIFontMap2_SetIgnoreFailures(PyIFontMap2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIFontMap2_SupportsInterface(PyIFontMap2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIFontMap2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IFontMap2Method_SetMapping(PyIFontMap2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTrueTypeFont = 0;
    PyObject* pyvar_TrueTypeFont;
    PyObject* unicodeTrueTypeFont = NULL;
    BSTR bsMappedFont = 0;
    PyObject* pyvar_MappedFont;
    PyObject* unicodeMappedFont = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_TrueTypeFont, &pyvar_MappedFont))
      goto ifontmap2_setmapping_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_TrueTypeFont))
        unicodeTrueTypeFont = PyUnicode_FromObject(pyvar_TrueTypeFont);
    else if (PyUnicode_Check(pyvar_TrueTypeFont))
    {
        unicodeTrueTypeFont = pyvar_TrueTypeFont;
        Py_INCREF(unicodeTrueTypeFont);
    }
    else if (pyvar_TrueTypeFont != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter TrueTypeFont at index 0");
    if (unicodeTrueTypeFont)
        bsTrueTypeFont = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTrueTypeFont), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTrueTypeFont));
    
    if (PyErr_Occurred())
      goto ifontmap2_setmapping_method_cleanup;
    
    if (PyString_Check(pyvar_MappedFont))
        unicodeMappedFont = PyUnicode_FromObject(pyvar_MappedFont);
    else if (PyUnicode_Check(pyvar_MappedFont))
    {
        unicodeMappedFont = pyvar_MappedFont;
        Py_INCREF(unicodeMappedFont);
    }
    else if (pyvar_MappedFont != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter MappedFont at index 1");
    if (unicodeMappedFont)
        bsMappedFont = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeMappedFont), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeMappedFont));
    
    if (PyErr_Occurred())
      goto ifontmap2_setmapping_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMap2->SetMapping(bsTrueTypeFont, bsMappedFont);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMap2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMap2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMap2.SetMapping() returned %ld", (long)hr);
        goto ifontmap2_setmapping_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TrueTypeFont
    // No teardown for MappedFont

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmap2_setmapping_method_cleanup;

    ifontmap2_setmapping_method_cleanup:
    self->m_HR = hr;
    if (bsTrueTypeFont)
        ::SysFreeString(bsTrueTypeFont);
    
    if (bsMappedFont)
        ::SysFreeString(bsMappedFont);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMap2.SetMapping");
    return return_tuple;
}

static PyObject*
IFontMap2Method_get_TrueTypeFont(PyIFontMap2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfont;
    PyObject* pyvar_font = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for font

    // Call method on actual COM interface
    hr = self->m_pIFontMap2->get_TrueTypeFont(&bsfont);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMap2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMap2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMap2.get_TrueTypeFont() returned %ld", (long)hr);
        goto ifontmap2_get_truetypefont_method_cleanup;
    }

    // Set up return values as needed
    pyvar_font = PyUnicode_FromWideChar(bsfont,::SysStringLen(bsfont));
    ::SysFreeString(bsfont);
    
    if (PyErr_Occurred())
      goto ifontmap2_get_truetypefont_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_font);
    goto ifontmap2_get_truetypefont_method_cleanup;

    ifontmap2_get_truetypefont_method_cleanup:
    self->m_HR = hr;
    if (pyvar_font != Py_None)
        Py_XDECREF(pyvar_font);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMap2.get_TrueTypeFont");
    return return_tuple;
}

static PyObject*
IFontMap2Method_get_MappedFont(PyIFontMap2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfont;
    PyObject* pyvar_font = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for font

    // Call method on actual COM interface
    hr = self->m_pIFontMap2->get_MappedFont(&bsfont);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMap2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMap2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMap2.get_MappedFont() returned %ld", (long)hr);
        goto ifontmap2_get_mappedfont_method_cleanup;
    }

    // Set up return values as needed
    pyvar_font = PyUnicode_FromWideChar(bsfont,::SysStringLen(bsfont));
    ::SysFreeString(bsfont);
    
    if (PyErr_Occurred())
      goto ifontmap2_get_mappedfont_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_font);
    goto ifontmap2_get_mappedfont_method_cleanup;

    ifontmap2_get_mappedfont_method_cleanup:
    self->m_HR = hr;
    if (pyvar_font != Py_None)
        Py_XDECREF(pyvar_font);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMap2.get_MappedFont");
    return return_tuple;
}

static PyObject*
IFontMap2Method_put_Mapping(PyIFontMap2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTrueTypeFont = 0;
    PyObject* pyvar_TrueTypeFont;
    PyObject* unicodeTrueTypeFont = NULL;
    BSTR bs_arg2 = 0;
    PyObject* pyvar__arg2;
    PyObject* unicode_arg2 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_TrueTypeFont, &pyvar__arg2))
      goto ifontmap2_put_mapping_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_TrueTypeFont))
        unicodeTrueTypeFont = PyUnicode_FromObject(pyvar_TrueTypeFont);
    else if (PyUnicode_Check(pyvar_TrueTypeFont))
    {
        unicodeTrueTypeFont = pyvar_TrueTypeFont;
        Py_INCREF(unicodeTrueTypeFont);
    }
    else if (pyvar_TrueTypeFont != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter TrueTypeFont at index 0");
    if (unicodeTrueTypeFont)
        bsTrueTypeFont = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTrueTypeFont), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTrueTypeFont));
    
    if (PyErr_Occurred())
      goto ifontmap2_put_mapping_method_cleanup;
    
    if (PyString_Check(pyvar__arg2))
        unicode_arg2 = PyUnicode_FromObject(pyvar__arg2);
    else if (PyUnicode_Check(pyvar__arg2))
    {
        unicode_arg2 = pyvar__arg2;
        Py_INCREF(unicode_arg2);
    }
    else if (pyvar__arg2 != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter _arg2 at index 1");
    if (unicode_arg2)
        bs_arg2 = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicode_arg2), 
                                            (UINT)PyUnicode_GET_SIZE(unicode_arg2));
    
    if (PyErr_Occurred())
      goto ifontmap2_put_mapping_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMap2->put_Mapping(bsTrueTypeFont, bs_arg2);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMap2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMap2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMap2.put_Mapping() returned %ld", (long)hr);
        goto ifontmap2_put_mapping_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TrueTypeFont
    // No teardown for _arg2

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmap2_put_mapping_method_cleanup;

    ifontmap2_put_mapping_method_cleanup:
    self->m_HR = hr;
    if (bsTrueTypeFont)
        ::SysFreeString(bsTrueTypeFont);
    
    if (bs_arg2)
        ::SysFreeString(bs_arg2);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMap2.put_Mapping");
    return return_tuple;
}


PyMethodDef PyIFontMap2Methods[] = {
    {"supports", (PyCFunction)PyIFontMap2_SupportsInterface, METH_O, ""},
    {"SetMapping", (PyCFunction)IFontMap2Method_SetMapping, METH_VARARGS, ""},
    {"get_TrueTypeFont", (PyCFunction)IFontMap2Method_get_TrueTypeFont, METH_VARARGS, ""},
    {"get_MappedFont", (PyCFunction)IFontMap2Method_get_MappedFont, METH_VARARGS, ""},
    {"put_Mapping", (PyCFunction)IFontMap2Method_put_Mapping, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIFontMap2GetSet[] = {
  {"_pUnk", (getter)PyIFontMap2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IFontMap2", NULL},
  {"_pointer", (getter)PyIFontMap2_GetPointer, NULL, "Get memory address for IFontMap2", NULL},
  {"_IID", (getter)PyIFontMap2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIFontMap2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIFontMap2_GetIgnoreFailures, (setter)PyIFontMap2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIFontMap2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IFontMap2Object",                          
                                              /* tp_name */
  sizeof(PyIFontMap2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIFontMap2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIFontMap2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIFontMap2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIFontMap2Object_new,                      
                                              /* tp_new */
};

// Interface IFontMapCollection

typedef struct PyIFontMapCollectionObject {
    PyObject_HEAD
    IFontMapCollection* m_pIFontMapCollection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIFontMapCollectionObject;

static PyObject*
PyIFontMapCollectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIFontMapCollectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IFontMapCollection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IFontMapCollection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IFontMapCollection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIFontMapCollectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IFontMapCollection");
            return NULL;
        }
        self->m_pIFontMapCollection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IFontMapCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IFontMapCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IFontMapCollection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IFontMapCollection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IFontMapCollection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIFontMapCollectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IFontMapCollection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIFontMapCollection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIFontMapCollectionObject_dealloc(PyIFontMapCollectionObject* self)
{
    if (self->m_pIFontMapCollection)
        self->m_pIFontMapCollection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIFontMapCollection_GetpUnk(PyIFontMapCollectionObject* self)
{
    if (!self->m_pIFontMapCollection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIFontMapCollection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IFontMapCollection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIFontMapCollection_GetPointer(PyIFontMapCollectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIFontMapCollection);
}

static PyObject*
PyIFontMapCollection_GetIID(PyIFontMapCollectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7539e7dd-2d89-11d3-9fc6-00c04f6bc8dd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIFontMapCollection_GetHR(PyIFontMapCollectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIFontMapCollection_GetIgnoreFailures(PyIFontMapCollectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIFontMapCollection_SetIgnoreFailures(PyIFontMapCollectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIFontMapCollection_SupportsInterface(PyIFontMapCollectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIFontMapCollection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IFontMapCollectionMethod_get_Count(PyIFontMapCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIFontMapCollection->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapCollection.get_Count() returned %ld", (long)hr);
        goto ifontmapcollection_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto ifontmapcollection_get_count_method_cleanup;

    ifontmapcollection_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapCollection.get_Count");
    return return_tuple;
}

static PyObject*
IFontMapCollectionMethod_get_FontMap(PyIFontMapCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IFontMap* ipFontMap = NULL;
    PyObject* py_FontMap = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ifontmapcollection_get_fontmap_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for FontMap

    // Call method on actual COM interface
    hr = self->m_pIFontMapCollection->get_FontMap(lindex, &ipFontMap);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapCollection.get_FontMap() returned %ld", (long)hr);
        goto ifontmapcollection_get_fontmap_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_FontMap);
    if (ipFontMap)
    {
        IUnknown* pUnk = NULL;
        ipFontMap->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FontMap = IUnknownToPythonIIDObject(pUnk, &IID_IFontMap);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FontMap)
    {
        if (py_FontMap)
           Py_DECREF(py_FontMap);
        py_FontMap = Py_None;
        Py_INCREF(py_FontMap);
    }
    if (PyErr_Occurred())
      goto ifontmapcollection_get_fontmap_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FontMap);
    goto ifontmapcollection_get_fontmap_method_cleanup;

    ifontmapcollection_get_fontmap_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_FontMap);
    if (ipFontMap)
      ipFontMap->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapCollection.get_FontMap");
    return return_tuple;
}

static PyObject*
IFontMapCollectionMethod_Add(PyIFontMapCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFontMap* ipFontMap = NULL;
    PyObject* py_FontMap;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_FontMap))
      goto ifontmapcollection_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_FontMap, &IID_IFontMap, (void**)&ipFontMap))
        PyErr_SetString(PyExc_TypeError, "Argument FontMap (position 0) is not IFontMap");
    
    if (PyErr_Occurred())
      goto ifontmapcollection_add_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMapCollection->Add(ipFontMap);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapCollection.Add() returned %ld", (long)hr);
        goto ifontmapcollection_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FontMap

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmapcollection_add_method_cleanup;

    ifontmapcollection_add_method_cleanup:
    self->m_HR = hr;
    if (ipFontMap)
      ipFontMap->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapCollection.Add");
    return return_tuple;
}

static PyObject*
IFontMapCollectionMethod_Insert(PyIFontMapCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IFontMap* ipFontMap = NULL;
    PyObject* py_FontMap;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lindex, &py_FontMap))
      goto ifontmapcollection_insert_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_FontMap, &IID_IFontMap, (void**)&ipFontMap))
        PyErr_SetString(PyExc_TypeError, "Argument FontMap (position 1) is not IFontMap");
    
    if (PyErr_Occurred())
      goto ifontmapcollection_insert_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMapCollection->Insert(lindex, ipFontMap);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapCollection.Insert() returned %ld", (long)hr);
        goto ifontmapcollection_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for FontMap

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmapcollection_insert_method_cleanup;

    ifontmapcollection_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ipFontMap)
      ipFontMap->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapCollection.Insert");
    return return_tuple;
}

static PyObject*
IFontMapCollectionMethod_Remove(PyIFontMapCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ifontmapcollection_remove_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pIFontMapCollection->Remove(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapCollection.Remove() returned %ld", (long)hr);
        goto ifontmapcollection_remove_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmapcollection_remove_method_cleanup;

    ifontmapcollection_remove_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapCollection.Remove");
    return return_tuple;
}

static PyObject*
IFontMapCollectionMethod_RemoveAll(PyIFontMapCollectionObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIFontMapCollection->RemoveAll();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapCollection.RemoveAll() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIFontMapCollectionMethods[] = {
    {"supports", (PyCFunction)PyIFontMapCollection_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)IFontMapCollectionMethod_get_Count, METH_VARARGS, ""},
    {"get_FontMap", (PyCFunction)IFontMapCollectionMethod_get_FontMap, METH_VARARGS, ""},
    {"Add", (PyCFunction)IFontMapCollectionMethod_Add, METH_VARARGS, ""},
    {"Insert", (PyCFunction)IFontMapCollectionMethod_Insert, METH_VARARGS, ""},
    {"Remove", (PyCFunction)IFontMapCollectionMethod_Remove, METH_VARARGS, ""},
    {"RemoveAll", (PyCFunction)IFontMapCollectionMethod_RemoveAll, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIFontMapCollectionGetSet[] = {
  {"_pUnk", (getter)PyIFontMapCollection_GetpUnk, NULL, "Get opaque pointer to an Unknown from IFontMapCollection", NULL},
  {"_pointer", (getter)PyIFontMapCollection_GetPointer, NULL, "Get memory address for IFontMapCollection", NULL},
  {"_IID", (getter)PyIFontMapCollection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIFontMapCollection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIFontMapCollection_GetIgnoreFailures, (setter)PyIFontMapCollection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIFontMapCollectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IFontMapCollectionObject",                          
                                              /* tp_name */
  sizeof(PyIFontMapCollectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIFontMapCollectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIFontMapCollectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIFontMapCollectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIFontMapCollectionObject_new,                      
                                              /* tp_new */
};

// Interface IFontMapEnvironment

typedef struct PyIFontMapEnvironmentObject {
    PyObject_HEAD
    IFontMapEnvironment* m_pIFontMapEnvironment;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIFontMapEnvironmentObject;

static PyObject*
PyIFontMapEnvironmentObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIFontMapEnvironmentObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IFontMapEnvironment* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IFontMapEnvironment, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IFontMapEnvironment with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIFontMapEnvironmentObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IFontMapEnvironment");
            return NULL;
        }
        self->m_pIFontMapEnvironment = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IFontMapEnvironment");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IFontMapEnvironment");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IFontMapEnvironment* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IFontMapEnvironment, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IFontMapEnvironment");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIFontMapEnvironmentObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IFontMapEnvironment");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIFontMapEnvironment = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIFontMapEnvironmentObject_dealloc(PyIFontMapEnvironmentObject* self)
{
    if (self->m_pIFontMapEnvironment)
        self->m_pIFontMapEnvironment->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIFontMapEnvironment_GetpUnk(PyIFontMapEnvironmentObject* self)
{
    if (!self->m_pIFontMapEnvironment)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIFontMapEnvironment->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IFontMapEnvironment to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIFontMapEnvironment_GetPointer(PyIFontMapEnvironmentObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIFontMapEnvironment);
}

static PyObject*
PyIFontMapEnvironment_GetIID(PyIFontMapEnvironmentObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "9ecb85b2-6caa-11d3-b685-0080c8ea4fd5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIFontMapEnvironment_GetHR(PyIFontMapEnvironmentObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIFontMapEnvironment_GetIgnoreFailures(PyIFontMapEnvironmentObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIFontMapEnvironment_SetIgnoreFailures(PyIFontMapEnvironmentObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIFontMapEnvironment_SupportsInterface(PyIFontMapEnvironmentObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IFontMapEnvironmentMethod_put_SaveMappings(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_SaveMappings = VARIANT_FALSE;
    PyObject* pyvar_SaveMappings = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_SaveMappings))
      goto ifontmapenvironment_put_savemappings_method_cleanup;

    // Set up initial variable values as needed
    b_SaveMappings = ((PyObject_IsTrue(pyvar_SaveMappings) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ifontmapenvironment_put_savemappings_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->put_SaveMappings(b_SaveMappings);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.put_SaveMappings() returned %ld", (long)hr);
        goto ifontmapenvironment_put_savemappings_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SaveMappings

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmapenvironment_put_savemappings_method_cleanup;

    ifontmapenvironment_put_savemappings_method_cleanup:
    self->m_HR = hr;
    // No cleanup for SaveMappings
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.put_SaveMappings");
    return return_tuple;
}

static PyObject*
IFontMapEnvironmentMethod_get_SaveMappings(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_SaveMappings = VARIANT_FALSE;
    PyObject* pyvar_SaveMappings = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SaveMappings

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->get_SaveMappings(&b_SaveMappings);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.get_SaveMappings() returned %ld", (long)hr);
        goto ifontmapenvironment_get_savemappings_method_cleanup;
    }

    // Set up return values as needed
    pyvar_SaveMappings = ((b_SaveMappings == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ifontmapenvironment_get_savemappings_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_SaveMappings);
    goto ifontmapenvironment_get_savemappings_method_cleanup;

    ifontmapenvironment_get_savemappings_method_cleanup:
    self->m_HR = hr;
    // No cleanup for SaveMappings
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.get_SaveMappings");
    return return_tuple;
}

static PyObject*
IFontMapEnvironmentMethod_get_FontMapCollection(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFontMapCollection* ipFontMapCollection = NULL;
    PyObject* py_FontMapCollection = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FontMapCollection

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->get_FontMapCollection(&ipFontMapCollection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.get_FontMapCollection() returned %ld", (long)hr);
        goto ifontmapenvironment_get_fontmapcollection_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_FontMapCollection);
    if (ipFontMapCollection)
    {
        IUnknown* pUnk = NULL;
        ipFontMapCollection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FontMapCollection = IUnknownToPythonIIDObject(pUnk, &IID_IFontMapCollection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FontMapCollection)
    {
        if (py_FontMapCollection)
           Py_DECREF(py_FontMapCollection);
        py_FontMapCollection = Py_None;
        Py_INCREF(py_FontMapCollection);
    }
    if (PyErr_Occurred())
      goto ifontmapenvironment_get_fontmapcollection_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FontMapCollection);
    goto ifontmapenvironment_get_fontmapcollection_method_cleanup;

    ifontmapenvironment_get_fontmapcollection_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_FontMapCollection);
    if (ipFontMapCollection)
      ipFontMapCollection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.get_FontMapCollection");
    return return_tuple;
}

static PyObject*
IFontMapEnvironmentMethod_put_DefaultMappingsChoices(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vdefaultMappingChoices;
    ::VariantInit(&vdefaultMappingChoices);
    PyObject* pyvar_defaultMappingChoices = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_defaultMappingChoices))
      goto ifontmapenvironment_put_defaultmappingschoices_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_defaultMappingChoices, &vdefaultMappingChoices);
    
    if (PyErr_Occurred())
      goto ifontmapenvironment_put_defaultmappingschoices_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->put_DefaultMappingsChoices(vdefaultMappingChoices);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.put_DefaultMappingsChoices() returned %ld", (long)hr);
        goto ifontmapenvironment_put_defaultmappingschoices_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for defaultMappingChoices

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmapenvironment_put_defaultmappingschoices_method_cleanup;

    ifontmapenvironment_put_defaultmappingschoices_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vdefaultMappingChoices);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.put_DefaultMappingsChoices");
    return return_tuple;
}

static PyObject*
IFontMapEnvironmentMethod_get_DefaultMappingsChoices(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vdefaultMappingChoices;
    ::VariantInit(&vdefaultMappingChoices);
    PyObject* pyvar_defaultMappingChoices = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for defaultMappingChoices

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->get_DefaultMappingsChoices(&vdefaultMappingChoices);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.get_DefaultMappingsChoices() returned %ld", (long)hr);
        goto ifontmapenvironment_get_defaultmappingschoices_method_cleanup;
    }

    // Set up return values as needed
    pyvar_defaultMappingChoices = Variant_AsPyObject(&vdefaultMappingChoices);
    if (PyErr_Occurred())
      goto ifontmapenvironment_get_defaultmappingschoices_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_defaultMappingChoices);
    goto ifontmapenvironment_get_defaultmappingschoices_method_cleanup;

    ifontmapenvironment_get_defaultmappingschoices_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vdefaultMappingChoices);
    Py_XDECREF(pyvar_defaultMappingChoices);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.get_DefaultMappingsChoices");
    return return_tuple;
}

static PyObject*
IFontMapEnvironmentMethod_put_DefaultMapping(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDefaultMapping = 0;
    PyObject* pyvar_DefaultMapping;
    PyObject* unicodeDefaultMapping = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_DefaultMapping))
      goto ifontmapenvironment_put_defaultmapping_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_DefaultMapping))
        unicodeDefaultMapping = PyUnicode_FromObject(pyvar_DefaultMapping);
    else if (PyUnicode_Check(pyvar_DefaultMapping))
    {
        unicodeDefaultMapping = pyvar_DefaultMapping;
        Py_INCREF(unicodeDefaultMapping);
    }
    else if (pyvar_DefaultMapping != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter DefaultMapping at index 0");
    if (unicodeDefaultMapping)
        bsDefaultMapping = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDefaultMapping), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDefaultMapping));
    
    if (PyErr_Occurred())
      goto ifontmapenvironment_put_defaultmapping_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->put_DefaultMapping(bsDefaultMapping);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.put_DefaultMapping() returned %ld", (long)hr);
        goto ifontmapenvironment_put_defaultmapping_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for DefaultMapping

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmapenvironment_put_defaultmapping_method_cleanup;

    ifontmapenvironment_put_defaultmapping_method_cleanup:
    self->m_HR = hr;
    if (bsDefaultMapping)
        ::SysFreeString(bsDefaultMapping);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.put_DefaultMapping");
    return return_tuple;
}

static PyObject*
IFontMapEnvironmentMethod_get_DefaultMapping(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDefaultMapping;
    PyObject* pyvar_DefaultMapping = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for DefaultMapping

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->get_DefaultMapping(&bsDefaultMapping);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.get_DefaultMapping() returned %ld", (long)hr);
        goto ifontmapenvironment_get_defaultmapping_method_cleanup;
    }

    // Set up return values as needed
    pyvar_DefaultMapping = PyUnicode_FromWideChar(bsDefaultMapping,::SysStringLen(bsDefaultMapping));
    ::SysFreeString(bsDefaultMapping);
    
    if (PyErr_Occurred())
      goto ifontmapenvironment_get_defaultmapping_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_DefaultMapping);
    goto ifontmapenvironment_get_defaultmapping_method_cleanup;

    ifontmapenvironment_get_defaultmapping_method_cleanup:
    self->m_HR = hr;
    if (pyvar_DefaultMapping != Py_None)
        Py_XDECREF(pyvar_DefaultMapping);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.get_DefaultMapping");
    return return_tuple;
}

static PyObject*
IFontMapEnvironmentMethod_put_ApplyDefaultMappingDesc(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsApplyDefaultMappingDesc = 0;
    PyObject* pyvar_ApplyDefaultMappingDesc;
    PyObject* unicodeApplyDefaultMappingDesc = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ApplyDefaultMappingDesc))
      goto ifontmapenvironment_put_applydefaultmappingdesc_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ApplyDefaultMappingDesc))
        unicodeApplyDefaultMappingDesc = PyUnicode_FromObject(pyvar_ApplyDefaultMappingDesc);
    else if (PyUnicode_Check(pyvar_ApplyDefaultMappingDesc))
    {
        unicodeApplyDefaultMappingDesc = pyvar_ApplyDefaultMappingDesc;
        Py_INCREF(unicodeApplyDefaultMappingDesc);
    }
    else if (pyvar_ApplyDefaultMappingDesc != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ApplyDefaultMappingDesc at index 0");
    if (unicodeApplyDefaultMappingDesc)
        bsApplyDefaultMappingDesc = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeApplyDefaultMappingDesc), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeApplyDefaultMappingDesc));
    
    if (PyErr_Occurred())
      goto ifontmapenvironment_put_applydefaultmappingdesc_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->put_ApplyDefaultMappingDesc(bsApplyDefaultMappingDesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.put_ApplyDefaultMappingDesc() returned %ld", (long)hr);
        goto ifontmapenvironment_put_applydefaultmappingdesc_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ApplyDefaultMappingDesc

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifontmapenvironment_put_applydefaultmappingdesc_method_cleanup;

    ifontmapenvironment_put_applydefaultmappingdesc_method_cleanup:
    self->m_HR = hr;
    if (bsApplyDefaultMappingDesc)
        ::SysFreeString(bsApplyDefaultMappingDesc);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.put_ApplyDefaultMappingDesc");
    return return_tuple;
}

static PyObject*
IFontMapEnvironmentMethod_get_ApplyDefaultMappingDesc(PyIFontMapEnvironmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsApplyDefaultMappingDesc;
    PyObject* pyvar_ApplyDefaultMappingDesc = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ApplyDefaultMappingDesc

    // Call method on actual COM interface
    hr = self->m_pIFontMapEnvironment->get_ApplyDefaultMappingDesc(&bsApplyDefaultMappingDesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFontMapEnvironment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFontMapEnvironment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFontMapEnvironment.get_ApplyDefaultMappingDesc() returned %ld", (long)hr);
        goto ifontmapenvironment_get_applydefaultmappingdesc_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ApplyDefaultMappingDesc = PyUnicode_FromWideChar(bsApplyDefaultMappingDesc,::SysStringLen(bsApplyDefaultMappingDesc));
    ::SysFreeString(bsApplyDefaultMappingDesc);
    
    if (PyErr_Occurred())
      goto ifontmapenvironment_get_applydefaultmappingdesc_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ApplyDefaultMappingDesc);
    goto ifontmapenvironment_get_applydefaultmappingdesc_method_cleanup;

    ifontmapenvironment_get_applydefaultmappingdesc_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ApplyDefaultMappingDesc != Py_None)
        Py_XDECREF(pyvar_ApplyDefaultMappingDesc);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFontMapEnvironment.get_ApplyDefaultMappingDesc");
    return return_tuple;
}


PyMethodDef PyIFontMapEnvironmentMethods[] = {
    {"supports", (PyCFunction)PyIFontMapEnvironment_SupportsInterface, METH_O, ""},
    {"put_SaveMappings", (PyCFunction)IFontMapEnvironmentMethod_put_SaveMappings, METH_VARARGS, ""},
    {"get_SaveMappings", (PyCFunction)IFontMapEnvironmentMethod_get_SaveMappings, METH_VARARGS, ""},
    {"get_FontMapCollection", (PyCFunction)IFontMapEnvironmentMethod_get_FontMapCollection, METH_VARARGS, ""},
    {"put_DefaultMappingsChoices", (PyCFunction)IFontMapEnvironmentMethod_put_DefaultMappingsChoices, METH_VARARGS, ""},
    {"get_DefaultMappingsChoices", (PyCFunction)IFontMapEnvironmentMethod_get_DefaultMappingsChoices, METH_VARARGS, ""},
    {"put_DefaultMapping", (PyCFunction)IFontMapEnvironmentMethod_put_DefaultMapping, METH_VARARGS, ""},
    {"get_DefaultMapping", (PyCFunction)IFontMapEnvironmentMethod_get_DefaultMapping, METH_VARARGS, ""},
    {"put_ApplyDefaultMappingDesc", (PyCFunction)IFontMapEnvironmentMethod_put_ApplyDefaultMappingDesc, METH_VARARGS, ""},
    {"get_ApplyDefaultMappingDesc", (PyCFunction)IFontMapEnvironmentMethod_get_ApplyDefaultMappingDesc, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIFontMapEnvironmentGetSet[] = {
  {"_pUnk", (getter)PyIFontMapEnvironment_GetpUnk, NULL, "Get opaque pointer to an Unknown from IFontMapEnvironment", NULL},
  {"_pointer", (getter)PyIFontMapEnvironment_GetPointer, NULL, "Get memory address for IFontMapEnvironment", NULL},
  {"_IID", (getter)PyIFontMapEnvironment_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIFontMapEnvironment_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIFontMapEnvironment_GetIgnoreFailures, (setter)PyIFontMapEnvironment_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIFontMapEnvironmentObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IFontMapEnvironmentObject",                          
                                              /* tp_name */
  sizeof(PyIFontMapEnvironmentObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIFontMapEnvironmentObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIFontMapEnvironmentMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIFontMapEnvironmentGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIFontMapEnvironmentObject_new,                      
                                              /* tp_new */
};

// Interface IExporter

typedef struct PyIExporterObject {
    PyObject_HEAD
    IExporter* m_pIExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExporterObject;

static PyObject*
PyIExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExporter");
            return NULL;
        }
        self->m_pIExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExporterObject_dealloc(PyIExporterObject* self)
{
    if (self->m_pIExporter)
        self->m_pIExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExporter_GetpUnk(PyIExporterObject* self)
{
    if (!self->m_pIExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExporter_GetPointer(PyIExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExporter);
}

static PyObject*
PyIExporter_GetIID(PyIExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7d4881e2-57c6-11d1-945e-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExporter_GetHR(PyIExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExporter_GetIgnoreFailures(PyIExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExporter_SetIgnoreFailures(PyIExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExporter_SupportsInterface(PyIExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExporterMethod_get_Name(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIExporter->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.get_Name() returned %ld", (long)hr);
        goto iexporter_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iexporter_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iexporter_get_name_method_cleanup;

    iexporter_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.get_Name");
    return return_tuple;
}

static PyObject*
IExporterMethod_get_Filter(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFilter;
    PyObject* pyvar_Filter = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Filter

    // Call method on actual COM interface
    hr = self->m_pIExporter->get_Filter(&bsFilter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.get_Filter() returned %ld", (long)hr);
        goto iexporter_get_filter_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Filter = PyUnicode_FromWideChar(bsFilter,::SysStringLen(bsFilter));
    ::SysFreeString(bsFilter);
    
    if (PyErr_Occurred())
      goto iexporter_get_filter_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Filter);
    goto iexporter_get_filter_method_cleanup;

    iexporter_get_filter_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Filter != Py_None)
        Py_XDECREF(pyvar_Filter);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.get_Filter");
    return return_tuple;
}

static PyObject*
IExporterMethod_get_FileExtension(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIExporter->get_FileExtension(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.get_FileExtension() returned %ld", (long)hr);
        goto iexporter_get_fileextension_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iexporter_get_fileextension_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iexporter_get_fileextension_method_cleanup;

    iexporter_get_fileextension_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.get_FileExtension");
    return return_tuple;
}

static PyObject*
IExporterMethod_put_PixelBounds(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipPixelBounds = NULL;
    PyObject* py_PixelBounds;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_PixelBounds))
      goto iexporter_put_pixelbounds_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_PixelBounds, &IID_IEnvelope, (void**)&ipPixelBounds))
        PyErr_SetString(PyExc_TypeError, "Argument PixelBounds (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iexporter_put_pixelbounds_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExporter->put_PixelBounds(ipPixelBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.put_PixelBounds() returned %ld", (long)hr);
        goto iexporter_put_pixelbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PixelBounds

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter_put_pixelbounds_method_cleanup;

    iexporter_put_pixelbounds_method_cleanup:
    self->m_HR = hr;
    if (ipPixelBounds)
      ipPixelBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.put_PixelBounds");
    return return_tuple;
}

static PyObject*
IExporterMethod_get_PixelBounds(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipPixelBounds = NULL;
    PyObject* py_PixelBounds = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for PixelBounds

    // Call method on actual COM interface
    hr = self->m_pIExporter->get_PixelBounds(&ipPixelBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.get_PixelBounds() returned %ld", (long)hr);
        goto iexporter_get_pixelbounds_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_PixelBounds);
    if (ipPixelBounds)
    {
        IUnknown* pUnk = NULL;
        ipPixelBounds->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_PixelBounds = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_PixelBounds)
    {
        if (py_PixelBounds)
           Py_DECREF(py_PixelBounds);
        py_PixelBounds = Py_None;
        Py_INCREF(py_PixelBounds);
    }
    if (PyErr_Occurred())
      goto iexporter_get_pixelbounds_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_PixelBounds);
    goto iexporter_get_pixelbounds_method_cleanup;

    iexporter_get_pixelbounds_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_PixelBounds);
    if (ipPixelBounds)
      ipPixelBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.get_PixelBounds");
    return return_tuple;
}

static PyObject*
IExporterMethod_put_ExportFileName(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iexporter_put_exportfilename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iexporter_put_exportfilename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExporter->put_ExportFileName(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.put_ExportFileName() returned %ld", (long)hr);
        goto iexporter_put_exportfilename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter_put_exportfilename_method_cleanup;

    iexporter_put_exportfilename_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.put_ExportFileName");
    return return_tuple;
}

static PyObject*
IExporterMethod_get_ExportFileName(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName;
    PyObject* pyvar_fileName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for fileName

    // Call method on actual COM interface
    hr = self->m_pIExporter->get_ExportFileName(&bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.get_ExportFileName() returned %ld", (long)hr);
        goto iexporter_get_exportfilename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_fileName = PyUnicode_FromWideChar(bsfileName,::SysStringLen(bsfileName));
    ::SysFreeString(bsfileName);
    
    if (PyErr_Occurred())
      goto iexporter_get_exportfilename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_fileName);
    goto iexporter_get_exportfilename_method_cleanup;

    iexporter_get_exportfilename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_fileName != Py_None)
        Py_XDECREF(pyvar_fileName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.get_ExportFileName");
    return return_tuple;
}

static PyObject*
IExporterMethod_get_Resolution(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sres = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for res

    // Call method on actual COM interface
    hr = self->m_pIExporter->get_Resolution(&sres);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.get_Resolution() returned %ld", (long)hr);
        goto iexporter_get_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for res

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sres);
    goto iexporter_get_resolution_method_cleanup;

    iexporter_get_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for res
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.get_Resolution");
    return return_tuple;
}

static PyObject*
IExporterMethod_put_Resolution(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sres = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sres))
      goto iexporter_put_resolution_method_cleanup;

    // Set up initial variable values as needed
    // No setup for res

    // Call method on actual COM interface
    hr = self->m_pIExporter->put_Resolution(sres);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.put_Resolution() returned %ld", (long)hr);
        goto iexporter_put_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for res

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter_put_resolution_method_cleanup;

    iexporter_put_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for res
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.put_Resolution");
    return return_tuple;
}

static PyObject*
IExporterMethod_get_ClipToGraphicExtent(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_clipToGraphicsExtent = VARIANT_FALSE;
    PyObject* pyvar_clipToGraphicsExtent = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for clipToGraphicsExtent

    // Call method on actual COM interface
    hr = self->m_pIExporter->get_ClipToGraphicExtent(&b_clipToGraphicsExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.get_ClipToGraphicExtent() returned %ld", (long)hr);
        goto iexporter_get_cliptographicextent_method_cleanup;
    }

    // Set up return values as needed
    pyvar_clipToGraphicsExtent = ((b_clipToGraphicsExtent == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexporter_get_cliptographicextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_clipToGraphicsExtent);
    goto iexporter_get_cliptographicextent_method_cleanup;

    iexporter_get_cliptographicextent_method_cleanup:
    self->m_HR = hr;
    // No cleanup for clipToGraphicsExtent
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.get_ClipToGraphicExtent");
    return return_tuple;
}

static PyObject*
IExporterMethod_put_ClipToGraphicExtent(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_clipToGraphicsExtent = VARIANT_FALSE;
    PyObject* pyvar_clipToGraphicsExtent = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_clipToGraphicsExtent))
      goto iexporter_put_cliptographicextent_method_cleanup;

    // Set up initial variable values as needed
    b_clipToGraphicsExtent = ((PyObject_IsTrue(pyvar_clipToGraphicsExtent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexporter_put_cliptographicextent_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExporter->put_ClipToGraphicExtent(b_clipToGraphicsExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.put_ClipToGraphicExtent() returned %ld", (long)hr);
        goto iexporter_put_cliptographicextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for clipToGraphicsExtent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter_put_cliptographicextent_method_cleanup;

    iexporter_put_cliptographicextent_method_cleanup:
    self->m_HR = hr;
    // No cleanup for clipToGraphicsExtent
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.put_ClipToGraphicExtent");
    return return_tuple;
}

static PyObject*
IExporterMethod_StartExporting(PyIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhDC = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hDC

    // Call method on actual COM interface
    hr = self->m_pIExporter->StartExporting(&HhDC);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.StartExporting() returned %ld", (long)hr);
        goto iexporter_startexporting_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hDC

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhDC);
    goto iexporter_startexporting_method_cleanup;

    iexporter_startexporting_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hDC
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter.StartExporting");
    return return_tuple;
}

static PyObject*
IExporterMethod_FinishExporting(PyIExporterObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIExporter->FinishExporting();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter.FinishExporting() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIExporterMethods[] = {
    {"supports", (PyCFunction)PyIExporter_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IExporterMethod_get_Name, METH_VARARGS, ""},
    {"get_Filter", (PyCFunction)IExporterMethod_get_Filter, METH_VARARGS, ""},
    {"get_FileExtension", (PyCFunction)IExporterMethod_get_FileExtension, METH_VARARGS, ""},
    {"put_PixelBounds", (PyCFunction)IExporterMethod_put_PixelBounds, METH_VARARGS, ""},
    {"get_PixelBounds", (PyCFunction)IExporterMethod_get_PixelBounds, METH_VARARGS, ""},
    {"put_ExportFileName", (PyCFunction)IExporterMethod_put_ExportFileName, METH_VARARGS, ""},
    {"get_ExportFileName", (PyCFunction)IExporterMethod_get_ExportFileName, METH_VARARGS, ""},
    {"get_Resolution", (PyCFunction)IExporterMethod_get_Resolution, METH_VARARGS, ""},
    {"put_Resolution", (PyCFunction)IExporterMethod_put_Resolution, METH_VARARGS, ""},
    {"get_ClipToGraphicExtent", (PyCFunction)IExporterMethod_get_ClipToGraphicExtent, METH_VARARGS, ""},
    {"put_ClipToGraphicExtent", (PyCFunction)IExporterMethod_put_ClipToGraphicExtent, METH_VARARGS, ""},
    {"StartExporting", (PyCFunction)IExporterMethod_StartExporting, METH_VARARGS, ""},
    {"FinishExporting", (PyCFunction)IExporterMethod_FinishExporting, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExporterGetSet[] = {
  {"_pUnk", (getter)PyIExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExporter", NULL},
  {"_pointer", (getter)PyIExporter_GetPointer, NULL, "Get memory address for IExporter", NULL},
  {"_IID", (getter)PyIExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExporter_GetIgnoreFailures, (setter)PyIExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExporterObject",                          
                                              /* tp_name */
  sizeof(PyIExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExporterObject_new,                      
                                              /* tp_new */
};

// Interface IExporter2

typedef struct PyIExporter2Object {
    PyObject_HEAD
    IExporter2* m_pIExporter2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExporter2Object;

static PyObject*
PyIExporter2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExporter2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExporter2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExporter2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExporter2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExporter2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExporter2");
            return NULL;
        }
        self->m_pIExporter2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExporter2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExporter2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExporter2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExporter2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExporter2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExporter2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExporter2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExporter2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExporter2Object_dealloc(PyIExporter2Object* self)
{
    if (self->m_pIExporter2)
        self->m_pIExporter2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExporter2_GetpUnk(PyIExporter2Object* self)
{
    if (!self->m_pIExporter2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExporter2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExporter2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExporter2_GetPointer(PyIExporter2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExporter2);
}

static PyObject*
PyIExporter2_GetIID(PyIExporter2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b87ad35e-1242-4c30-b67f-ff3cfa2f1928");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExporter2_GetHR(PyIExporter2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExporter2_GetIgnoreFailures(PyIExporter2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExporter2_SetIgnoreFailures(PyIExporter2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExporter2_SupportsInterface(PyIExporter2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExporter2Method_putref_ExportExtent(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto iexporter2_putref_exportextent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IEnvelope, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iexporter2_putref_exportextent_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExporter2->putref_ExportExtent(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.putref_ExportExtent() returned %ld", (long)hr);
        goto iexporter2_putref_exportextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter2_putref_exportextent_method_cleanup;

    iexporter2_putref_exportextent_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.putref_ExportExtent");
    return return_tuple;
}

static PyObject*
IExporter2Method_get_Name(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIExporter2->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.get_Name() returned %ld", (long)hr);
        goto iexporter2_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iexporter2_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iexporter2_get_name_method_cleanup;

    iexporter2_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.get_Name");
    return return_tuple;
}

static PyObject*
IExporter2Method_get_Filter(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFilter;
    PyObject* pyvar_Filter = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Filter

    // Call method on actual COM interface
    hr = self->m_pIExporter2->get_Filter(&bsFilter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.get_Filter() returned %ld", (long)hr);
        goto iexporter2_get_filter_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Filter = PyUnicode_FromWideChar(bsFilter,::SysStringLen(bsFilter));
    ::SysFreeString(bsFilter);
    
    if (PyErr_Occurred())
      goto iexporter2_get_filter_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Filter);
    goto iexporter2_get_filter_method_cleanup;

    iexporter2_get_filter_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Filter != Py_None)
        Py_XDECREF(pyvar_Filter);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.get_Filter");
    return return_tuple;
}

static PyObject*
IExporter2Method_get_FileExtension(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIExporter2->get_FileExtension(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.get_FileExtension() returned %ld", (long)hr);
        goto iexporter2_get_fileextension_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iexporter2_get_fileextension_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iexporter2_get_fileextension_method_cleanup;

    iexporter2_get_fileextension_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.get_FileExtension");
    return return_tuple;
}

static PyObject*
IExporter2Method_put_PixelBounds(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipPixelBounds = NULL;
    PyObject* py_PixelBounds;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_PixelBounds))
      goto iexporter2_put_pixelbounds_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_PixelBounds, &IID_IEnvelope, (void**)&ipPixelBounds))
        PyErr_SetString(PyExc_TypeError, "Argument PixelBounds (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iexporter2_put_pixelbounds_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExporter2->put_PixelBounds(ipPixelBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.put_PixelBounds() returned %ld", (long)hr);
        goto iexporter2_put_pixelbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PixelBounds

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter2_put_pixelbounds_method_cleanup;

    iexporter2_put_pixelbounds_method_cleanup:
    self->m_HR = hr;
    if (ipPixelBounds)
      ipPixelBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.put_PixelBounds");
    return return_tuple;
}

static PyObject*
IExporter2Method_get_PixelBounds(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipPixelBounds = NULL;
    PyObject* py_PixelBounds = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for PixelBounds

    // Call method on actual COM interface
    hr = self->m_pIExporter2->get_PixelBounds(&ipPixelBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.get_PixelBounds() returned %ld", (long)hr);
        goto iexporter2_get_pixelbounds_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_PixelBounds);
    if (ipPixelBounds)
    {
        IUnknown* pUnk = NULL;
        ipPixelBounds->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_PixelBounds = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_PixelBounds)
    {
        if (py_PixelBounds)
           Py_DECREF(py_PixelBounds);
        py_PixelBounds = Py_None;
        Py_INCREF(py_PixelBounds);
    }
    if (PyErr_Occurred())
      goto iexporter2_get_pixelbounds_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_PixelBounds);
    goto iexporter2_get_pixelbounds_method_cleanup;

    iexporter2_get_pixelbounds_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_PixelBounds);
    if (ipPixelBounds)
      ipPixelBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.get_PixelBounds");
    return return_tuple;
}

static PyObject*
IExporter2Method_put_ExportFileName(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iexporter2_put_exportfilename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iexporter2_put_exportfilename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExporter2->put_ExportFileName(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.put_ExportFileName() returned %ld", (long)hr);
        goto iexporter2_put_exportfilename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter2_put_exportfilename_method_cleanup;

    iexporter2_put_exportfilename_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.put_ExportFileName");
    return return_tuple;
}

static PyObject*
IExporter2Method_get_ExportFileName(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName;
    PyObject* pyvar_fileName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for fileName

    // Call method on actual COM interface
    hr = self->m_pIExporter2->get_ExportFileName(&bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.get_ExportFileName() returned %ld", (long)hr);
        goto iexporter2_get_exportfilename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_fileName = PyUnicode_FromWideChar(bsfileName,::SysStringLen(bsfileName));
    ::SysFreeString(bsfileName);
    
    if (PyErr_Occurred())
      goto iexporter2_get_exportfilename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_fileName);
    goto iexporter2_get_exportfilename_method_cleanup;

    iexporter2_get_exportfilename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_fileName != Py_None)
        Py_XDECREF(pyvar_fileName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.get_ExportFileName");
    return return_tuple;
}

static PyObject*
IExporter2Method_get_Resolution(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sres = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for res

    // Call method on actual COM interface
    hr = self->m_pIExporter2->get_Resolution(&sres);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.get_Resolution() returned %ld", (long)hr);
        goto iexporter2_get_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for res

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sres);
    goto iexporter2_get_resolution_method_cleanup;

    iexporter2_get_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for res
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.get_Resolution");
    return return_tuple;
}

static PyObject*
IExporter2Method_put_Resolution(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sres = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sres))
      goto iexporter2_put_resolution_method_cleanup;

    // Set up initial variable values as needed
    // No setup for res

    // Call method on actual COM interface
    hr = self->m_pIExporter2->put_Resolution(sres);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.put_Resolution() returned %ld", (long)hr);
        goto iexporter2_put_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for res

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter2_put_resolution_method_cleanup;

    iexporter2_put_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for res
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.put_Resolution");
    return return_tuple;
}

static PyObject*
IExporter2Method_get_ClipToGraphicExtent(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_clipToGraphicsExtent = VARIANT_FALSE;
    PyObject* pyvar_clipToGraphicsExtent = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for clipToGraphicsExtent

    // Call method on actual COM interface
    hr = self->m_pIExporter2->get_ClipToGraphicExtent(&b_clipToGraphicsExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.get_ClipToGraphicExtent() returned %ld", (long)hr);
        goto iexporter2_get_cliptographicextent_method_cleanup;
    }

    // Set up return values as needed
    pyvar_clipToGraphicsExtent = ((b_clipToGraphicsExtent == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexporter2_get_cliptographicextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_clipToGraphicsExtent);
    goto iexporter2_get_cliptographicextent_method_cleanup;

    iexporter2_get_cliptographicextent_method_cleanup:
    self->m_HR = hr;
    // No cleanup for clipToGraphicsExtent
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.get_ClipToGraphicExtent");
    return return_tuple;
}

static PyObject*
IExporter2Method_put_ClipToGraphicExtent(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_clipToGraphicsExtent = VARIANT_FALSE;
    PyObject* pyvar_clipToGraphicsExtent = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_clipToGraphicsExtent))
      goto iexporter2_put_cliptographicextent_method_cleanup;

    // Set up initial variable values as needed
    b_clipToGraphicsExtent = ((PyObject_IsTrue(pyvar_clipToGraphicsExtent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexporter2_put_cliptographicextent_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExporter2->put_ClipToGraphicExtent(b_clipToGraphicsExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.put_ClipToGraphicExtent() returned %ld", (long)hr);
        goto iexporter2_put_cliptographicextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for clipToGraphicsExtent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporter2_put_cliptographicextent_method_cleanup;

    iexporter2_put_cliptographicextent_method_cleanup:
    self->m_HR = hr;
    // No cleanup for clipToGraphicsExtent
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.put_ClipToGraphicExtent");
    return return_tuple;
}

static PyObject*
IExporter2Method_StartExporting(PyIExporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhDC = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hDC

    // Call method on actual COM interface
    hr = self->m_pIExporter2->StartExporting(&HhDC);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.StartExporting() returned %ld", (long)hr);
        goto iexporter2_startexporting_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hDC

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhDC);
    goto iexporter2_startexporting_method_cleanup;

    iexporter2_startexporting_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hDC
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporter2.StartExporting");
    return return_tuple;
}

static PyObject*
IExporter2Method_FinishExporting(PyIExporter2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIExporter2->FinishExporting();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporter2.FinishExporting() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIExporter2Methods[] = {
    {"supports", (PyCFunction)PyIExporter2_SupportsInterface, METH_O, ""},
    {"putref_ExportExtent", (PyCFunction)IExporter2Method_putref_ExportExtent, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IExporter2Method_get_Name, METH_VARARGS, ""},
    {"get_Filter", (PyCFunction)IExporter2Method_get_Filter, METH_VARARGS, ""},
    {"get_FileExtension", (PyCFunction)IExporter2Method_get_FileExtension, METH_VARARGS, ""},
    {"put_PixelBounds", (PyCFunction)IExporter2Method_put_PixelBounds, METH_VARARGS, ""},
    {"get_PixelBounds", (PyCFunction)IExporter2Method_get_PixelBounds, METH_VARARGS, ""},
    {"put_ExportFileName", (PyCFunction)IExporter2Method_put_ExportFileName, METH_VARARGS, ""},
    {"get_ExportFileName", (PyCFunction)IExporter2Method_get_ExportFileName, METH_VARARGS, ""},
    {"get_Resolution", (PyCFunction)IExporter2Method_get_Resolution, METH_VARARGS, ""},
    {"put_Resolution", (PyCFunction)IExporter2Method_put_Resolution, METH_VARARGS, ""},
    {"get_ClipToGraphicExtent", (PyCFunction)IExporter2Method_get_ClipToGraphicExtent, METH_VARARGS, ""},
    {"put_ClipToGraphicExtent", (PyCFunction)IExporter2Method_put_ClipToGraphicExtent, METH_VARARGS, ""},
    {"StartExporting", (PyCFunction)IExporter2Method_StartExporting, METH_VARARGS, ""},
    {"FinishExporting", (PyCFunction)IExporter2Method_FinishExporting, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExporter2GetSet[] = {
  {"_pUnk", (getter)PyIExporter2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExporter2", NULL},
  {"_pointer", (getter)PyIExporter2_GetPointer, NULL, "Get memory address for IExporter2", NULL},
  {"_IID", (getter)PyIExporter2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExporter2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExporter2_GetIgnoreFailures, (setter)PyIExporter2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExporter2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExporter2Object",                          
                                              /* tp_name */
  sizeof(PyIExporter2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExporter2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExporter2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExporter2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExporter2Object_new,                      
                                              /* tp_new */
};

// Interface IExporterPriority

typedef struct PyIExporterPriorityObject {
    PyObject_HEAD
    IExporterPriority* m_pIExporterPriority;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExporterPriorityObject;

static PyObject*
PyIExporterPriorityObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExporterPriorityObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExporterPriority* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExporterPriority, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExporterPriority with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExporterPriorityObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExporterPriority");
            return NULL;
        }
        self->m_pIExporterPriority = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExporterPriority");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExporterPriority");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExporterPriority* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExporterPriority, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExporterPriority");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExporterPriorityObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExporterPriority");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExporterPriority = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExporterPriorityObject_dealloc(PyIExporterPriorityObject* self)
{
    if (self->m_pIExporterPriority)
        self->m_pIExporterPriority->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExporterPriority_GetpUnk(PyIExporterPriorityObject* self)
{
    if (!self->m_pIExporterPriority)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExporterPriority->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExporterPriority to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExporterPriority_GetPointer(PyIExporterPriorityObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExporterPriority);
}

static PyObject*
PyIExporterPriority_GetIID(PyIExporterPriorityObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "10aae67f-d5ab-4905-a0bf-82636ba2ed02");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExporterPriority_GetHR(PyIExporterPriorityObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExporterPriority_GetIgnoreFailures(PyIExporterPriorityObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExporterPriority_SetIgnoreFailures(PyIExporterPriorityObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExporterPriority_SupportsInterface(PyIExporterPriorityObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExporterPriority->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExporterPriorityMethod_get_Priority(PyIExporterPriorityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpPriority = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPriority

    // Call method on actual COM interface
    hr = self->m_pIExporterPriority->get_Priority(&lpPriority);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExporterPriority->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExporterPriority) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExporterPriority.get_Priority() returned %ld", (long)hr);
        goto iexporterpriority_get_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPriority

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpPriority);
    goto iexporterpriority_get_priority_method_cleanup;

    iexporterpriority_get_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPriority
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExporterPriority.get_Priority");
    return return_tuple;
}


PyMethodDef PyIExporterPriorityMethods[] = {
    {"supports", (PyCFunction)PyIExporterPriority_SupportsInterface, METH_O, ""},
    {"get_Priority", (PyCFunction)IExporterPriorityMethod_get_Priority, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExporterPriorityGetSet[] = {
  {"_pUnk", (getter)PyIExporterPriority_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExporterPriority", NULL},
  {"_pointer", (getter)PyIExporterPriority_GetPointer, NULL, "Get memory address for IExporterPriority", NULL},
  {"_IID", (getter)PyIExporterPriority_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExporterPriority_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExporterPriority_GetIgnoreFailures, (setter)PyIExporterPriority_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExporterPriorityObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExporterPriorityObject",                          
                                              /* tp_name */
  sizeof(PyIExporterPriorityObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExporterPriorityObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExporterPriorityMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExporterPriorityGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExporterPriorityObject_new,                      
                                              /* tp_new */
};

// Interface IOutputCleanup

typedef struct PyIOutputCleanupObject {
    PyObject_HEAD
    IOutputCleanup* m_pIOutputCleanup;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIOutputCleanupObject;

static PyObject*
PyIOutputCleanupObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIOutputCleanupObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IOutputCleanup* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IOutputCleanup, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IOutputCleanup with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIOutputCleanupObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IOutputCleanup");
            return NULL;
        }
        self->m_pIOutputCleanup = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IOutputCleanup");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IOutputCleanup");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IOutputCleanup* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IOutputCleanup, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IOutputCleanup");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIOutputCleanupObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IOutputCleanup");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIOutputCleanup = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIOutputCleanupObject_dealloc(PyIOutputCleanupObject* self)
{
    if (self->m_pIOutputCleanup)
        self->m_pIOutputCleanup->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIOutputCleanup_GetpUnk(PyIOutputCleanupObject* self)
{
    if (!self->m_pIOutputCleanup)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIOutputCleanup->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IOutputCleanup to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIOutputCleanup_GetPointer(PyIOutputCleanupObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIOutputCleanup);
}

static PyObject*
PyIOutputCleanup_GetIID(PyIOutputCleanupObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2b8765ec-8808-474c-8fd3-869d08df20f6");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIOutputCleanup_GetHR(PyIOutputCleanupObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIOutputCleanup_GetIgnoreFailures(PyIOutputCleanupObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIOutputCleanup_SetIgnoreFailures(PyIOutputCleanupObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIOutputCleanup_SupportsInterface(PyIOutputCleanupObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIOutputCleanup->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IOutputCleanupMethod_Cleanup(PyIOutputCleanupObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIOutputCleanup->Cleanup();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputCleanup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputCleanup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputCleanup.Cleanup() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIOutputCleanupMethods[] = {
    {"supports", (PyCFunction)PyIOutputCleanup_SupportsInterface, METH_O, ""},
    {"Cleanup", (PyCFunction)IOutputCleanupMethod_Cleanup, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIOutputCleanupGetSet[] = {
  {"_pUnk", (getter)PyIOutputCleanup_GetpUnk, NULL, "Get opaque pointer to an Unknown from IOutputCleanup", NULL},
  {"_pointer", (getter)PyIOutputCleanup_GetPointer, NULL, "Get memory address for IOutputCleanup", NULL},
  {"_IID", (getter)PyIOutputCleanup_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIOutputCleanup_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIOutputCleanup_GetIgnoreFailures, (setter)PyIOutputCleanup_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIOutputCleanupObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IOutputCleanupObject",                          
                                              /* tp_name */
  sizeof(PyIOutputCleanupObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIOutputCleanupObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIOutputCleanupMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIOutputCleanupGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIOutputCleanupObject_new,                      
                                              /* tp_new */
};

// Interface IWorldFileSettings

typedef struct PyIWorldFileSettingsObject {
    PyObject_HEAD
    IWorldFileSettings* m_pIWorldFileSettings;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWorldFileSettingsObject;

static PyObject*
PyIWorldFileSettingsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWorldFileSettingsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWorldFileSettings* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWorldFileSettings, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWorldFileSettings with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWorldFileSettingsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWorldFileSettings");
            return NULL;
        }
        self->m_pIWorldFileSettings = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWorldFileSettings");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWorldFileSettings");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWorldFileSettings* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWorldFileSettings, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWorldFileSettings");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWorldFileSettingsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWorldFileSettings");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWorldFileSettings = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWorldFileSettingsObject_dealloc(PyIWorldFileSettingsObject* self)
{
    if (self->m_pIWorldFileSettings)
        self->m_pIWorldFileSettings->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWorldFileSettings_GetpUnk(PyIWorldFileSettingsObject* self)
{
    if (!self->m_pIWorldFileSettings)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWorldFileSettings->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWorldFileSettings to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWorldFileSettings_GetPointer(PyIWorldFileSettingsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWorldFileSettings);
}

static PyObject*
PyIWorldFileSettings_GetIID(PyIWorldFileSettingsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "27bf29ca-71a8-422a-a66d-ff875a9de13b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWorldFileSettings_GetHR(PyIWorldFileSettingsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWorldFileSettings_GetIgnoreFailures(PyIWorldFileSettingsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWorldFileSettings_SetIgnoreFailures(PyIWorldFileSettingsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWorldFileSettings_SupportsInterface(PyIWorldFileSettingsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWorldFileSettings->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWorldFileSettingsMethod_put_MapExtent(PyIWorldFileSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipMapExtent = NULL;
    PyObject* py_MapExtent;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_MapExtent))
      goto iworldfilesettings_put_mapextent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_MapExtent, &IID_IEnvelope, (void**)&ipMapExtent))
        PyErr_SetString(PyExc_TypeError, "Argument MapExtent (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iworldfilesettings_put_mapextent_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWorldFileSettings->put_MapExtent(ipMapExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWorldFileSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWorldFileSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWorldFileSettings.put_MapExtent() returned %ld", (long)hr);
        goto iworldfilesettings_put_mapextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MapExtent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iworldfilesettings_put_mapextent_method_cleanup;

    iworldfilesettings_put_mapextent_method_cleanup:
    self->m_HR = hr;
    if (ipMapExtent)
      ipMapExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWorldFileSettings.put_MapExtent");
    return return_tuple;
}

static PyObject*
IWorldFileSettingsMethod_get_MapExtent(PyIWorldFileSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipMapExtent = NULL;
    PyObject* py_MapExtent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MapExtent

    // Call method on actual COM interface
    hr = self->m_pIWorldFileSettings->get_MapExtent(&ipMapExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWorldFileSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWorldFileSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWorldFileSettings.get_MapExtent() returned %ld", (long)hr);
        goto iworldfilesettings_get_mapextent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_MapExtent);
    if (ipMapExtent)
    {
        IUnknown* pUnk = NULL;
        ipMapExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_MapExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_MapExtent)
    {
        if (py_MapExtent)
           Py_DECREF(py_MapExtent);
        py_MapExtent = Py_None;
        Py_INCREF(py_MapExtent);
    }
    if (PyErr_Occurred())
      goto iworldfilesettings_get_mapextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_MapExtent);
    goto iworldfilesettings_get_mapextent_method_cleanup;

    iworldfilesettings_get_mapextent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_MapExtent);
    if (ipMapExtent)
      ipMapExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWorldFileSettings.get_MapExtent");
    return return_tuple;
}

static PyObject*
IWorldFileSettingsMethod_put_OutputWorldFile(PyIWorldFileSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_OutputWorldFile = VARIANT_FALSE;
    PyObject* pyvar_OutputWorldFile = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_OutputWorldFile))
      goto iworldfilesettings_put_outputworldfile_method_cleanup;

    // Set up initial variable values as needed
    b_OutputWorldFile = ((PyObject_IsTrue(pyvar_OutputWorldFile) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iworldfilesettings_put_outputworldfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWorldFileSettings->put_OutputWorldFile(b_OutputWorldFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWorldFileSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWorldFileSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWorldFileSettings.put_OutputWorldFile() returned %ld", (long)hr);
        goto iworldfilesettings_put_outputworldfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OutputWorldFile

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iworldfilesettings_put_outputworldfile_method_cleanup;

    iworldfilesettings_put_outputworldfile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OutputWorldFile
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWorldFileSettings.put_OutputWorldFile");
    return return_tuple;
}

static PyObject*
IWorldFileSettingsMethod_get_OutputWorldFile(PyIWorldFileSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_OutputWorldFile = VARIANT_FALSE;
    PyObject* pyvar_OutputWorldFile = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for OutputWorldFile

    // Call method on actual COM interface
    hr = self->m_pIWorldFileSettings->get_OutputWorldFile(&b_OutputWorldFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWorldFileSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWorldFileSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWorldFileSettings.get_OutputWorldFile() returned %ld", (long)hr);
        goto iworldfilesettings_get_outputworldfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_OutputWorldFile = ((b_OutputWorldFile == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iworldfilesettings_get_outputworldfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_OutputWorldFile);
    goto iworldfilesettings_get_outputworldfile_method_cleanup;

    iworldfilesettings_get_outputworldfile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OutputWorldFile
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWorldFileSettings.get_OutputWorldFile");
    return return_tuple;
}


PyMethodDef PyIWorldFileSettingsMethods[] = {
    {"supports", (PyCFunction)PyIWorldFileSettings_SupportsInterface, METH_O, ""},
    {"put_MapExtent", (PyCFunction)IWorldFileSettingsMethod_put_MapExtent, METH_VARARGS, ""},
    {"get_MapExtent", (PyCFunction)IWorldFileSettingsMethod_get_MapExtent, METH_VARARGS, ""},
    {"put_OutputWorldFile", (PyCFunction)IWorldFileSettingsMethod_put_OutputWorldFile, METH_VARARGS, ""},
    {"get_OutputWorldFile", (PyCFunction)IWorldFileSettingsMethod_get_OutputWorldFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWorldFileSettingsGetSet[] = {
  {"_pUnk", (getter)PyIWorldFileSettings_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWorldFileSettings", NULL},
  {"_pointer", (getter)PyIWorldFileSettings_GetPointer, NULL, "Get memory address for IWorldFileSettings", NULL},
  {"_IID", (getter)PyIWorldFileSettings_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWorldFileSettings_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWorldFileSettings_GetIgnoreFailures, (setter)PyIWorldFileSettings_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWorldFileSettingsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IWorldFileSettingsObject",                          
                                              /* tp_name */
  sizeof(PyIWorldFileSettingsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWorldFileSettingsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWorldFileSettingsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWorldFileSettingsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWorldFileSettingsObject_new,                      
                                              /* tp_new */
};

// Interface IWorldFileSettings2

typedef struct PyIWorldFileSettings2Object {
    PyObject_HEAD
    IWorldFileSettings2* m_pIWorldFileSettings2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWorldFileSettings2Object;

static PyObject*
PyIWorldFileSettings2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWorldFileSettings2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWorldFileSettings2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWorldFileSettings2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWorldFileSettings2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWorldFileSettings2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWorldFileSettings2");
            return NULL;
        }
        self->m_pIWorldFileSettings2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWorldFileSettings2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWorldFileSettings2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWorldFileSettings2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWorldFileSettings2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWorldFileSettings2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWorldFileSettings2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWorldFileSettings2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWorldFileSettings2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWorldFileSettings2Object_dealloc(PyIWorldFileSettings2Object* self)
{
    if (self->m_pIWorldFileSettings2)
        self->m_pIWorldFileSettings2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWorldFileSettings2_GetpUnk(PyIWorldFileSettings2Object* self)
{
    if (!self->m_pIWorldFileSettings2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWorldFileSettings2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWorldFileSettings2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWorldFileSettings2_GetPointer(PyIWorldFileSettings2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWorldFileSettings2);
}

static PyObject*
PyIWorldFileSettings2_GetIID(PyIWorldFileSettings2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "167806fc-6bcb-491e-9fb0-827baf2c3dec");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWorldFileSettings2_GetHR(PyIWorldFileSettings2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWorldFileSettings2_GetIgnoreFailures(PyIWorldFileSettings2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWorldFileSettings2_SetIgnoreFailures(PyIWorldFileSettings2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWorldFileSettings2_SupportsInterface(PyIWorldFileSettings2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWorldFileSettings2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWorldFileSettings2Method_put_MapRotation(PyIWorldFileSettings2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dmapRotAngle = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dmapRotAngle))
      goto iworldfilesettings2_put_maprotation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for mapRotAngle

    // Call method on actual COM interface
    hr = self->m_pIWorldFileSettings2->put_MapRotation(dmapRotAngle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWorldFileSettings2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWorldFileSettings2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWorldFileSettings2.put_MapRotation() returned %ld", (long)hr);
        goto iworldfilesettings2_put_maprotation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for mapRotAngle

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iworldfilesettings2_put_maprotation_method_cleanup;

    iworldfilesettings2_put_maprotation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for mapRotAngle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWorldFileSettings2.put_MapRotation");
    return return_tuple;
}

static PyObject*
IWorldFileSettings2Method_get_MapRotation(PyIWorldFileSettings2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dmapRotAngle = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for mapRotAngle

    // Call method on actual COM interface
    hr = self->m_pIWorldFileSettings2->get_MapRotation(&dmapRotAngle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWorldFileSettings2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWorldFileSettings2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWorldFileSettings2.get_MapRotation() returned %ld", (long)hr);
        goto iworldfilesettings2_get_maprotation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for mapRotAngle

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dmapRotAngle);
    goto iworldfilesettings2_get_maprotation_method_cleanup;

    iworldfilesettings2_get_maprotation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for mapRotAngle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWorldFileSettings2.get_MapRotation");
    return return_tuple;
}


PyMethodDef PyIWorldFileSettings2Methods[] = {
    {"supports", (PyCFunction)PyIWorldFileSettings2_SupportsInterface, METH_O, ""},
    {"put_MapRotation", (PyCFunction)IWorldFileSettings2Method_put_MapRotation, METH_VARARGS, ""},
    {"get_MapRotation", (PyCFunction)IWorldFileSettings2Method_get_MapRotation, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWorldFileSettings2GetSet[] = {
  {"_pUnk", (getter)PyIWorldFileSettings2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWorldFileSettings2", NULL},
  {"_pointer", (getter)PyIWorldFileSettings2_GetPointer, NULL, "Get memory address for IWorldFileSettings2", NULL},
  {"_IID", (getter)PyIWorldFileSettings2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWorldFileSettings2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWorldFileSettings2_GetIgnoreFailures, (setter)PyIWorldFileSettings2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWorldFileSettings2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IWorldFileSettings2Object",                          
                                              /* tp_name */
  sizeof(PyIWorldFileSettings2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWorldFileSettings2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWorldFileSettings2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWorldFileSettings2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWorldFileSettings2Object_new,                      
                                              /* tp_new */
};

// Interface IStepProgressorSetup

typedef struct PyIStepProgressorSetupObject {
    PyObject_HEAD
    IStepProgressorSetup* m_pIStepProgressorSetup;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIStepProgressorSetupObject;

static PyObject*
PyIStepProgressorSetupObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIStepProgressorSetupObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IStepProgressorSetup* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IStepProgressorSetup, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IStepProgressorSetup with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIStepProgressorSetupObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IStepProgressorSetup");
            return NULL;
        }
        self->m_pIStepProgressorSetup = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IStepProgressorSetup");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IStepProgressorSetup");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IStepProgressorSetup* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IStepProgressorSetup, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IStepProgressorSetup");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIStepProgressorSetupObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IStepProgressorSetup");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIStepProgressorSetup = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIStepProgressorSetupObject_dealloc(PyIStepProgressorSetupObject* self)
{
    if (self->m_pIStepProgressorSetup)
        self->m_pIStepProgressorSetup->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIStepProgressorSetup_GetpUnk(PyIStepProgressorSetupObject* self)
{
    if (!self->m_pIStepProgressorSetup)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIStepProgressorSetup->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IStepProgressorSetup to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIStepProgressorSetup_GetPointer(PyIStepProgressorSetupObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIStepProgressorSetup);
}

static PyObject*
PyIStepProgressorSetup_GetIID(PyIStepProgressorSetupObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1c538193-8806-489c-8a79-4b54c8c18b37");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIStepProgressorSetup_GetHR(PyIStepProgressorSetupObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIStepProgressorSetup_GetIgnoreFailures(PyIStepProgressorSetupObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIStepProgressorSetup_SetIgnoreFailures(PyIStepProgressorSetupObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIStepProgressorSetup_SupportsInterface(PyIStepProgressorSetupObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIStepProgressorSetup->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IStepProgressorSetupMethod_put_StepProgressor(PyIStepProgressorSetupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStepProgressor* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto istepprogressorsetup_put_stepprogressor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IStepProgressor, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IStepProgressor");
    
    if (PyErr_Occurred())
      goto istepprogressorsetup_put_stepprogressor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIStepProgressorSetup->put_StepProgressor(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIStepProgressorSetup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IStepProgressorSetup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IStepProgressorSetup.put_StepProgressor() returned %ld", (long)hr);
        goto istepprogressorsetup_put_stepprogressor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto istepprogressorsetup_put_stepprogressor_method_cleanup;

    istepprogressorsetup_put_stepprogressor_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IStepProgressorSetup.put_StepProgressor");
    return return_tuple;
}


PyMethodDef PyIStepProgressorSetupMethods[] = {
    {"supports", (PyCFunction)PyIStepProgressorSetup_SupportsInterface, METH_O, ""},
    {"put_StepProgressor", (PyCFunction)IStepProgressorSetupMethod_put_StepProgressor, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIStepProgressorSetupGetSet[] = {
  {"_pUnk", (getter)PyIStepProgressorSetup_GetpUnk, NULL, "Get opaque pointer to an Unknown from IStepProgressorSetup", NULL},
  {"_pointer", (getter)PyIStepProgressorSetup_GetPointer, NULL, "Get memory address for IStepProgressorSetup", NULL},
  {"_IID", (getter)PyIStepProgressorSetup_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIStepProgressorSetup_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIStepProgressorSetup_GetIgnoreFailures, (setter)PyIStepProgressorSetup_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIStepProgressorSetupObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IStepProgressorSetupObject",                          
                                              /* tp_name */
  sizeof(PyIStepProgressorSetupObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIStepProgressorSetupObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIStepProgressorSetupMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIStepProgressorSetupGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIStepProgressorSetupObject_new,                      
                                              /* tp_new */
};

// Interface ITrackCancelSetup

typedef struct PyITrackCancelSetupObject {
    PyObject_HEAD
    ITrackCancelSetup* m_pITrackCancelSetup;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITrackCancelSetupObject;

static PyObject*
PyITrackCancelSetupObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITrackCancelSetupObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITrackCancelSetup* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITrackCancelSetup, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITrackCancelSetup with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITrackCancelSetupObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITrackCancelSetup");
            return NULL;
        }
        self->m_pITrackCancelSetup = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITrackCancelSetup");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITrackCancelSetup");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITrackCancelSetup* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITrackCancelSetup, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITrackCancelSetup");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITrackCancelSetupObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITrackCancelSetup");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITrackCancelSetup = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITrackCancelSetupObject_dealloc(PyITrackCancelSetupObject* self)
{
    if (self->m_pITrackCancelSetup)
        self->m_pITrackCancelSetup->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITrackCancelSetup_GetpUnk(PyITrackCancelSetupObject* self)
{
    if (!self->m_pITrackCancelSetup)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITrackCancelSetup->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITrackCancelSetup to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITrackCancelSetup_GetPointer(PyITrackCancelSetupObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITrackCancelSetup);
}

static PyObject*
PyITrackCancelSetup_GetIID(PyITrackCancelSetupObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5e091c46-d015-471f-8187-f774c7ad9d48");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITrackCancelSetup_GetHR(PyITrackCancelSetupObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITrackCancelSetup_GetIgnoreFailures(PyITrackCancelSetupObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITrackCancelSetup_SetIgnoreFailures(PyITrackCancelSetupObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITrackCancelSetup_SupportsInterface(PyITrackCancelSetupObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITrackCancelSetup->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITrackCancelSetupMethod_put_TrackCancel(PyITrackCancelSetupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto itrackcancelsetup_put_trackcancel_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_ITrackCancel, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto itrackcancelsetup_put_trackcancel_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITrackCancelSetup->put_TrackCancel(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackCancelSetup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackCancelSetup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackCancelSetup.put_TrackCancel() returned %ld", (long)hr);
        goto itrackcancelsetup_put_trackcancel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itrackcancelsetup_put_trackcancel_method_cleanup;

    itrackcancelsetup_put_trackcancel_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackCancelSetup.put_TrackCancel");
    return return_tuple;
}


PyMethodDef PyITrackCancelSetupMethods[] = {
    {"supports", (PyCFunction)PyITrackCancelSetup_SupportsInterface, METH_O, ""},
    {"put_TrackCancel", (PyCFunction)ITrackCancelSetupMethod_put_TrackCancel, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITrackCancelSetupGetSet[] = {
  {"_pUnk", (getter)PyITrackCancelSetup_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITrackCancelSetup", NULL},
  {"_pointer", (getter)PyITrackCancelSetup_GetPointer, NULL, "Get memory address for ITrackCancelSetup", NULL},
  {"_IID", (getter)PyITrackCancelSetup_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITrackCancelSetup_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITrackCancelSetup_GetIgnoreFailures, (setter)PyITrackCancelSetup_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITrackCancelSetupObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.ITrackCancelSetupObject",                          
                                              /* tp_name */
  sizeof(PyITrackCancelSetupObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITrackCancelSetupObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITrackCancelSetupMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITrackCancelSetupGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITrackCancelSetupObject_new,                      
                                              /* tp_new */
};

// Interface ISettingsInRegistry

typedef struct PyISettingsInRegistryObject {
    PyObject_HEAD
    ISettingsInRegistry* m_pISettingsInRegistry;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISettingsInRegistryObject;

static PyObject*
PyISettingsInRegistryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISettingsInRegistryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISettingsInRegistry* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISettingsInRegistry, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISettingsInRegistry with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISettingsInRegistryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISettingsInRegistry");
            return NULL;
        }
        self->m_pISettingsInRegistry = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISettingsInRegistry");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISettingsInRegistry");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISettingsInRegistry* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISettingsInRegistry, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISettingsInRegistry");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISettingsInRegistryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISettingsInRegistry");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISettingsInRegistry = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISettingsInRegistryObject_dealloc(PyISettingsInRegistryObject* self)
{
    if (self->m_pISettingsInRegistry)
        self->m_pISettingsInRegistry->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISettingsInRegistry_GetpUnk(PyISettingsInRegistryObject* self)
{
    if (!self->m_pISettingsInRegistry)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISettingsInRegistry->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISettingsInRegistry to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISettingsInRegistry_GetPointer(PyISettingsInRegistryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISettingsInRegistry);
}

static PyObject*
PyISettingsInRegistry_GetIID(PyISettingsInRegistryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "bb518176-e7e3-420a-9787-ae6e3487eb68");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISettingsInRegistry_GetHR(PyISettingsInRegistryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISettingsInRegistry_GetIgnoreFailures(PyISettingsInRegistryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISettingsInRegistry_SetIgnoreFailures(PyISettingsInRegistryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISettingsInRegistry_SupportsInterface(PyISettingsInRegistryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISettingsInRegistry->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISettingsInRegistryMethod_RestoreForCurrentUser(PyISettingsInRegistryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsbstrRegPath = 0;
    PyObject* pyvar_bstrRegPath;
    PyObject* unicodebstrRegPath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bstrRegPath))
      goto isettingsinregistry_restoreforcurrentuser_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_bstrRegPath))
        unicodebstrRegPath = PyUnicode_FromObject(pyvar_bstrRegPath);
    else if (PyUnicode_Check(pyvar_bstrRegPath))
    {
        unicodebstrRegPath = pyvar_bstrRegPath;
        Py_INCREF(unicodebstrRegPath);
    }
    else if (pyvar_bstrRegPath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter bstrRegPath at index 0");
    if (unicodebstrRegPath)
        bsbstrRegPath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodebstrRegPath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodebstrRegPath));
    
    if (PyErr_Occurred())
      goto isettingsinregistry_restoreforcurrentuser_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISettingsInRegistry->RestoreForCurrentUser(bsbstrRegPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISettingsInRegistry->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISettingsInRegistry) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISettingsInRegistry.RestoreForCurrentUser() returned %ld", (long)hr);
        goto isettingsinregistry_restoreforcurrentuser_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bstrRegPath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto isettingsinregistry_restoreforcurrentuser_method_cleanup;

    isettingsinregistry_restoreforcurrentuser_method_cleanup:
    self->m_HR = hr;
    if (bsbstrRegPath)
        ::SysFreeString(bsbstrRegPath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISettingsInRegistry.RestoreForCurrentUser");
    return return_tuple;
}

static PyObject*
ISettingsInRegistryMethod_StoreForCurrentUser(PyISettingsInRegistryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsbstrRegPath = 0;
    PyObject* pyvar_bstrRegPath;
    PyObject* unicodebstrRegPath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bstrRegPath))
      goto isettingsinregistry_storeforcurrentuser_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_bstrRegPath))
        unicodebstrRegPath = PyUnicode_FromObject(pyvar_bstrRegPath);
    else if (PyUnicode_Check(pyvar_bstrRegPath))
    {
        unicodebstrRegPath = pyvar_bstrRegPath;
        Py_INCREF(unicodebstrRegPath);
    }
    else if (pyvar_bstrRegPath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter bstrRegPath at index 0");
    if (unicodebstrRegPath)
        bsbstrRegPath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodebstrRegPath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodebstrRegPath));
    
    if (PyErr_Occurred())
      goto isettingsinregistry_storeforcurrentuser_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISettingsInRegistry->StoreForCurrentUser(bsbstrRegPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISettingsInRegistry->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISettingsInRegistry) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISettingsInRegistry.StoreForCurrentUser() returned %ld", (long)hr);
        goto isettingsinregistry_storeforcurrentuser_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bstrRegPath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto isettingsinregistry_storeforcurrentuser_method_cleanup;

    isettingsinregistry_storeforcurrentuser_method_cleanup:
    self->m_HR = hr;
    if (bsbstrRegPath)
        ::SysFreeString(bsbstrRegPath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISettingsInRegistry.StoreForCurrentUser");
    return return_tuple;
}

static PyObject*
ISettingsInRegistryMethod_RestoreDefault(PyISettingsInRegistryObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pISettingsInRegistry->RestoreDefault();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISettingsInRegistry->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISettingsInRegistry) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISettingsInRegistry.RestoreDefault() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyISettingsInRegistryMethods[] = {
    {"supports", (PyCFunction)PyISettingsInRegistry_SupportsInterface, METH_O, ""},
    {"RestoreForCurrentUser", (PyCFunction)ISettingsInRegistryMethod_RestoreForCurrentUser, METH_VARARGS, ""},
    {"StoreForCurrentUser", (PyCFunction)ISettingsInRegistryMethod_StoreForCurrentUser, METH_VARARGS, ""},
    {"RestoreDefault", (PyCFunction)ISettingsInRegistryMethod_RestoreDefault, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISettingsInRegistryGetSet[] = {
  {"_pUnk", (getter)PyISettingsInRegistry_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISettingsInRegistry", NULL},
  {"_pointer", (getter)PyISettingsInRegistry_GetPointer, NULL, "Get memory address for ISettingsInRegistry", NULL},
  {"_IID", (getter)PyISettingsInRegistry_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISettingsInRegistry_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISettingsInRegistry_GetIgnoreFailures, (setter)PyISettingsInRegistry_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISettingsInRegistryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.ISettingsInRegistryObject",                          
                                              /* tp_name */
  sizeof(PyISettingsInRegistryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISettingsInRegistryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISettingsInRegistryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISettingsInRegistryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISettingsInRegistryObject_new,                      
                                              /* tp_new */
};

// Interface IExportColorspaceSettings

typedef struct PyIExportColorspaceSettingsObject {
    PyObject_HEAD
    IExportColorspaceSettings* m_pIExportColorspaceSettings;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportColorspaceSettingsObject;

static PyObject*
PyIExportColorspaceSettingsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportColorspaceSettingsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportColorspaceSettings* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportColorspaceSettings, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportColorspaceSettings with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportColorspaceSettingsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportColorspaceSettings");
            return NULL;
        }
        self->m_pIExportColorspaceSettings = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportColorspaceSettings");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportColorspaceSettings");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportColorspaceSettings* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportColorspaceSettings, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportColorspaceSettings");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportColorspaceSettingsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportColorspaceSettings");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportColorspaceSettings = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportColorspaceSettingsObject_dealloc(PyIExportColorspaceSettingsObject* self)
{
    if (self->m_pIExportColorspaceSettings)
        self->m_pIExportColorspaceSettings->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportColorspaceSettings_GetpUnk(PyIExportColorspaceSettingsObject* self)
{
    if (!self->m_pIExportColorspaceSettings)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportColorspaceSettings->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportColorspaceSettings to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportColorspaceSettings_GetPointer(PyIExportColorspaceSettingsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportColorspaceSettings);
}

static PyObject*
PyIExportColorspaceSettings_GetIID(PyIExportColorspaceSettingsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c42431dc-237a-4628-996a-39a89af74158");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportColorspaceSettings_GetHR(PyIExportColorspaceSettingsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportColorspaceSettings_GetIgnoreFailures(PyIExportColorspaceSettingsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportColorspaceSettings_SetIgnoreFailures(PyIExportColorspaceSettingsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportColorspaceSettings_SupportsInterface(PyIExportColorspaceSettingsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportColorspaceSettings->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportColorspaceSettingsMethod_put_Colorspace(PyIExportColorspaceSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportColorspace epcolorspace;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epcolorspace))
      goto iexportcolorspacesettings_put_colorspace_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pcolorspace

    // Call method on actual COM interface
    hr = self->m_pIExportColorspaceSettings->put_Colorspace(epcolorspace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportColorspaceSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportColorspaceSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportColorspaceSettings.put_Colorspace() returned %ld", (long)hr);
        goto iexportcolorspacesettings_put_colorspace_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcolorspace

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportcolorspacesettings_put_colorspace_method_cleanup;

    iexportcolorspacesettings_put_colorspace_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcolorspace
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportColorspaceSettings.put_Colorspace");
    return return_tuple;
}

static PyObject*
IExportColorspaceSettingsMethod_get_Colorspace(PyIExportColorspaceSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportColorspace epcolorspace;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcolorspace

    // Call method on actual COM interface
    hr = self->m_pIExportColorspaceSettings->get_Colorspace(&epcolorspace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportColorspaceSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportColorspaceSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportColorspaceSettings.get_Colorspace() returned %ld", (long)hr);
        goto iexportcolorspacesettings_get_colorspace_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcolorspace

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epcolorspace);
    goto iexportcolorspacesettings_get_colorspace_method_cleanup;

    iexportcolorspacesettings_get_colorspace_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcolorspace
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportColorspaceSettings.get_Colorspace");
    return return_tuple;
}


PyMethodDef PyIExportColorspaceSettingsMethods[] = {
    {"supports", (PyCFunction)PyIExportColorspaceSettings_SupportsInterface, METH_O, ""},
    {"put_Colorspace", (PyCFunction)IExportColorspaceSettingsMethod_put_Colorspace, METH_VARARGS, ""},
    {"get_Colorspace", (PyCFunction)IExportColorspaceSettingsMethod_get_Colorspace, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportColorspaceSettingsGetSet[] = {
  {"_pUnk", (getter)PyIExportColorspaceSettings_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportColorspaceSettings", NULL},
  {"_pointer", (getter)PyIExportColorspaceSettings_GetPointer, NULL, "Get memory address for IExportColorspaceSettings", NULL},
  {"_IID", (getter)PyIExportColorspaceSettings_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportColorspaceSettings_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportColorspaceSettings_GetIgnoreFailures, (setter)PyIExportColorspaceSettings_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportColorspaceSettingsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportColorspaceSettingsObject",                          
                                              /* tp_name */
  sizeof(PyIExportColorspaceSettingsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportColorspaceSettingsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportColorspaceSettingsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportColorspaceSettingsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportColorspaceSettingsObject_new,                      
                                              /* tp_new */
};

// Interface IPrintAndExportPageOptions

typedef struct PyIPrintAndExportPageOptionsObject {
    PyObject_HEAD
    IPrintAndExportPageOptions* m_pIPrintAndExportPageOptions;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPrintAndExportPageOptionsObject;

static PyObject*
PyIPrintAndExportPageOptionsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPrintAndExportPageOptionsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPrintAndExportPageOptions* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPrintAndExportPageOptions, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPrintAndExportPageOptions with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPrintAndExportPageOptionsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPrintAndExportPageOptions");
            return NULL;
        }
        self->m_pIPrintAndExportPageOptions = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPrintAndExportPageOptions");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPrintAndExportPageOptions");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPrintAndExportPageOptions* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPrintAndExportPageOptions, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPrintAndExportPageOptions");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPrintAndExportPageOptionsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPrintAndExportPageOptions");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPrintAndExportPageOptions = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPrintAndExportPageOptionsObject_dealloc(PyIPrintAndExportPageOptionsObject* self)
{
    if (self->m_pIPrintAndExportPageOptions)
        self->m_pIPrintAndExportPageOptions->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPrintAndExportPageOptions_GetpUnk(PyIPrintAndExportPageOptionsObject* self)
{
    if (!self->m_pIPrintAndExportPageOptions)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPrintAndExportPageOptions->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPrintAndExportPageOptions to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPrintAndExportPageOptions_GetPointer(PyIPrintAndExportPageOptionsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPrintAndExportPageOptions);
}

static PyObject*
PyIPrintAndExportPageOptions_GetIID(PyIPrintAndExportPageOptionsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1f685f17-704a-4755-834f-4c0d67303a2f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPrintAndExportPageOptions_GetHR(PyIPrintAndExportPageOptionsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPrintAndExportPageOptions_GetIgnoreFailures(PyIPrintAndExportPageOptionsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPrintAndExportPageOptions_SetIgnoreFailures(PyIPrintAndExportPageOptionsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPrintAndExportPageOptions_SupportsInterface(PyIPrintAndExportPageOptionsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPrintAndExportPageOptions->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPrintAndExportPageOptionsMethod_put_OutputSelection(PyIPrintAndExportPageOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriOutputSelection epOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epOption))
      goto iprintandexportpageoptions_put_outputselection_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pOption

    // Call method on actual COM interface
    hr = self->m_pIPrintAndExportPageOptions->put_OutputSelection(epOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrintAndExportPageOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrintAndExportPageOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrintAndExportPageOptions.put_OutputSelection() returned %ld", (long)hr);
        goto iprintandexportpageoptions_put_outputselection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprintandexportpageoptions_put_outputselection_method_cleanup;

    iprintandexportpageoptions_put_outputselection_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrintAndExportPageOptions.put_OutputSelection");
    return return_tuple;
}

static PyObject*
IPrintAndExportPageOptionsMethod_get_OutputSelection(PyIPrintAndExportPageOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriOutputSelection epOption;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pOption

    // Call method on actual COM interface
    hr = self->m_pIPrintAndExportPageOptions->get_OutputSelection(&epOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrintAndExportPageOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrintAndExportPageOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrintAndExportPageOptions.get_OutputSelection() returned %ld", (long)hr);
        goto iprintandexportpageoptions_get_outputselection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOption

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epOption);
    goto iprintandexportpageoptions_get_outputselection_method_cleanup;

    iprintandexportpageoptions_get_outputselection_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrintAndExportPageOptions.get_OutputSelection");
    return return_tuple;
}

static PyObject*
IPrintAndExportPageOptionsMethod_put_PageRange(PyIPrintAndExportPageOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsrange = 0;
    PyObject* pyvar_range;
    PyObject* unicoderange = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_range))
      goto iprintandexportpageoptions_put_pagerange_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_range))
        unicoderange = PyUnicode_FromObject(pyvar_range);
    else if (PyUnicode_Check(pyvar_range))
    {
        unicoderange = pyvar_range;
        Py_INCREF(unicoderange);
    }
    else if (pyvar_range != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter range at index 0");
    if (unicoderange)
        bsrange = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderange), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderange));
    
    if (PyErr_Occurred())
      goto iprintandexportpageoptions_put_pagerange_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPrintAndExportPageOptions->put_PageRange(bsrange);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrintAndExportPageOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrintAndExportPageOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrintAndExportPageOptions.put_PageRange() returned %ld", (long)hr);
        goto iprintandexportpageoptions_put_pagerange_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for range

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprintandexportpageoptions_put_pagerange_method_cleanup;

    iprintandexportpageoptions_put_pagerange_method_cleanup:
    self->m_HR = hr;
    if (bsrange)
        ::SysFreeString(bsrange);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrintAndExportPageOptions.put_PageRange");
    return return_tuple;
}

static PyObject*
IPrintAndExportPageOptionsMethod_get_PageRange(PyIPrintAndExportPageOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsrange;
    PyObject* pyvar_range = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for range

    // Call method on actual COM interface
    hr = self->m_pIPrintAndExportPageOptions->get_PageRange(&bsrange);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrintAndExportPageOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrintAndExportPageOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrintAndExportPageOptions.get_PageRange() returned %ld", (long)hr);
        goto iprintandexportpageoptions_get_pagerange_method_cleanup;
    }

    // Set up return values as needed
    pyvar_range = PyUnicode_FromWideChar(bsrange,::SysStringLen(bsrange));
    ::SysFreeString(bsrange);
    
    if (PyErr_Occurred())
      goto iprintandexportpageoptions_get_pagerange_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_range);
    goto iprintandexportpageoptions_get_pagerange_method_cleanup;

    iprintandexportpageoptions_get_pagerange_method_cleanup:
    self->m_HR = hr;
    if (pyvar_range != Py_None)
        Py_XDECREF(pyvar_range);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrintAndExportPageOptions.get_PageRange");
    return return_tuple;
}

static PyObject*
IPrintAndExportPageOptionsMethod_get_OutputPageSelection(PyIPrintAndExportPageOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_flag = VARIANT_FALSE;
    PyObject* pyvar_flag = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for flag

    // Call method on actual COM interface
    hr = self->m_pIPrintAndExportPageOptions->get_OutputPageSelection(&b_flag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrintAndExportPageOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrintAndExportPageOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrintAndExportPageOptions.get_OutputPageSelection() returned %ld", (long)hr);
        goto iprintandexportpageoptions_get_outputpageselection_method_cleanup;
    }

    // Set up return values as needed
    pyvar_flag = ((b_flag == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iprintandexportpageoptions_get_outputpageselection_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_flag);
    goto iprintandexportpageoptions_get_outputpageselection_method_cleanup;

    iprintandexportpageoptions_get_outputpageselection_method_cleanup:
    self->m_HR = hr;
    // No cleanup for flag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrintAndExportPageOptions.get_OutputPageSelection");
    return return_tuple;
}

static PyObject*
IPrintAndExportPageOptionsMethod_put_OutputPageSelection(PyIPrintAndExportPageOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_flag = VARIANT_FALSE;
    PyObject* pyvar_flag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_flag))
      goto iprintandexportpageoptions_put_outputpageselection_method_cleanup;

    // Set up initial variable values as needed
    b_flag = ((PyObject_IsTrue(pyvar_flag) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iprintandexportpageoptions_put_outputpageselection_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPrintAndExportPageOptions->put_OutputPageSelection(b_flag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrintAndExportPageOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrintAndExportPageOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrintAndExportPageOptions.put_OutputPageSelection() returned %ld", (long)hr);
        goto iprintandexportpageoptions_put_outputpageselection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for flag

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprintandexportpageoptions_put_outputpageselection_method_cleanup;

    iprintandexportpageoptions_put_outputpageselection_method_cleanup:
    self->m_HR = hr;
    // No cleanup for flag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrintAndExportPageOptions.put_OutputPageSelection");
    return return_tuple;
}


PyMethodDef PyIPrintAndExportPageOptionsMethods[] = {
    {"supports", (PyCFunction)PyIPrintAndExportPageOptions_SupportsInterface, METH_O, ""},
    {"put_OutputSelection", (PyCFunction)IPrintAndExportPageOptionsMethod_put_OutputSelection, METH_VARARGS, ""},
    {"get_OutputSelection", (PyCFunction)IPrintAndExportPageOptionsMethod_get_OutputSelection, METH_VARARGS, ""},
    {"put_PageRange", (PyCFunction)IPrintAndExportPageOptionsMethod_put_PageRange, METH_VARARGS, ""},
    {"get_PageRange", (PyCFunction)IPrintAndExportPageOptionsMethod_get_PageRange, METH_VARARGS, ""},
    {"get_OutputPageSelection", (PyCFunction)IPrintAndExportPageOptionsMethod_get_OutputPageSelection, METH_VARARGS, ""},
    {"put_OutputPageSelection", (PyCFunction)IPrintAndExportPageOptionsMethod_put_OutputPageSelection, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPrintAndExportPageOptionsGetSet[] = {
  {"_pUnk", (getter)PyIPrintAndExportPageOptions_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPrintAndExportPageOptions", NULL},
  {"_pointer", (getter)PyIPrintAndExportPageOptions_GetPointer, NULL, "Get memory address for IPrintAndExportPageOptions", NULL},
  {"_IID", (getter)PyIPrintAndExportPageOptions_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPrintAndExportPageOptions_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPrintAndExportPageOptions_GetIgnoreFailures, (setter)PyIPrintAndExportPageOptions_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPrintAndExportPageOptionsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPrintAndExportPageOptionsObject",                          
                                              /* tp_name */
  sizeof(PyIPrintAndExportPageOptionsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPrintAndExportPageOptionsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPrintAndExportPageOptionsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPrintAndExportPageOptionsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPrintAndExportPageOptionsObject_new,                      
                                              /* tp_new */
};

// Interface IEmfExporter

typedef struct PyIEmfExporterObject {
    PyObject_HEAD
    IEmfExporter* m_pIEmfExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIEmfExporterObject;

static PyObject*
PyIEmfExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIEmfExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IEmfExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IEmfExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IEmfExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIEmfExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IEmfExporter");
            return NULL;
        }
        self->m_pIEmfExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IEmfExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IEmfExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IEmfExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IEmfExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IEmfExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIEmfExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IEmfExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIEmfExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIEmfExporterObject_dealloc(PyIEmfExporterObject* self)
{
    if (self->m_pIEmfExporter)
        self->m_pIEmfExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIEmfExporter_GetpUnk(PyIEmfExporterObject* self)
{
    if (!self->m_pIEmfExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIEmfExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IEmfExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIEmfExporter_GetPointer(PyIEmfExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIEmfExporter);
}

static PyObject*
PyIEmfExporter_GetIID(PyIEmfExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7d4881e3-57c6-11d1-945e-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIEmfExporter_GetHR(PyIEmfExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIEmfExporter_GetIgnoreFailures(PyIEmfExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIEmfExporter_SetIgnoreFailures(PyIEmfExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIEmfExporter_SupportsInterface(PyIEmfExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIEmfExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IEmfExporterMethod_put_IsInMemory(PyIEmfExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsInMemory = VARIANT_FALSE;
    PyObject* pyvar_pIsInMemory = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pIsInMemory))
      goto iemfexporter_put_isinmemory_method_cleanup;

    // Set up initial variable values as needed
    b_pIsInMemory = ((PyObject_IsTrue(pyvar_pIsInMemory) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iemfexporter_put_isinmemory_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIEmfExporter->put_IsInMemory(b_pIsInMemory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEmfExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEmfExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEmfExporter.put_IsInMemory() returned %ld", (long)hr);
        goto iemfexporter_put_isinmemory_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIsInMemory

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iemfexporter_put_isinmemory_method_cleanup;

    iemfexporter_put_isinmemory_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsInMemory
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEmfExporter.put_IsInMemory");
    return return_tuple;
}

static PyObject*
IEmfExporterMethod_get_IsInMemory(PyIEmfExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsInMemory = VARIANT_FALSE;
    PyObject* pyvar_pIsInMemory = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIsInMemory

    // Call method on actual COM interface
    hr = self->m_pIEmfExporter->get_IsInMemory(&b_pIsInMemory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEmfExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEmfExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEmfExporter.get_IsInMemory() returned %ld", (long)hr);
        goto iemfexporter_get_isinmemory_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pIsInMemory = ((b_pIsInMemory == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iemfexporter_get_isinmemory_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pIsInMemory);
    goto iemfexporter_get_isinmemory_method_cleanup;

    iemfexporter_get_isinmemory_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsInMemory
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEmfExporter.get_IsInMemory");
    return return_tuple;
}

static PyObject*
IEmfExporterMethod_get_HENHMETAFILE(PyIEmfExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HpHandle = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHandle

    // Call method on actual COM interface
    hr = self->m_pIEmfExporter->get_HENHMETAFILE(&HpHandle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEmfExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEmfExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEmfExporter.get_HENHMETAFILE() returned %ld", (long)hr);
        goto iemfexporter_get_henhmetafile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHandle

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HpHandle);
    goto iemfexporter_get_henhmetafile_method_cleanup;

    iemfexporter_get_henhmetafile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHandle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEmfExporter.get_HENHMETAFILE");
    return return_tuple;
}

static PyObject*
IEmfExporterMethod_TakeHENHMETAFILE(PyIEmfExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HpHandle = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHandle

    // Call method on actual COM interface
    hr = self->m_pIEmfExporter->TakeHENHMETAFILE(&HpHandle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEmfExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEmfExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEmfExporter.TakeHENHMETAFILE() returned %ld", (long)hr);
        goto iemfexporter_takehenhmetafile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHandle

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HpHandle);
    goto iemfexporter_takehenhmetafile_method_cleanup;

    iemfexporter_takehenhmetafile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHandle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEmfExporter.TakeHENHMETAFILE");
    return return_tuple;
}

static PyObject*
IEmfExporterMethod_put_Description(PyIEmfExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDescription = 0;
    PyObject* pyvar_pDescription;
    PyObject* unicodepDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pDescription))
      goto iemfexporter_put_description_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pDescription))
        unicodepDescription = PyUnicode_FromObject(pyvar_pDescription);
    else if (PyUnicode_Check(pyvar_pDescription))
    {
        unicodepDescription = pyvar_pDescription;
        Py_INCREF(unicodepDescription);
    }
    else if (pyvar_pDescription != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pDescription at index 0");
    if (unicodepDescription)
        bspDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepDescription));
    
    if (PyErr_Occurred())
      goto iemfexporter_put_description_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIEmfExporter->put_Description(bspDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEmfExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEmfExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEmfExporter.put_Description() returned %ld", (long)hr);
        goto iemfexporter_put_description_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDescription

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iemfexporter_put_description_method_cleanup;

    iemfexporter_put_description_method_cleanup:
    self->m_HR = hr;
    if (bspDescription)
        ::SysFreeString(bspDescription);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEmfExporter.put_Description");
    return return_tuple;
}

static PyObject*
IEmfExporterMethod_get_Description(PyIEmfExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDescription;
    PyObject* pyvar_pDescription = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDescription

    // Call method on actual COM interface
    hr = self->m_pIEmfExporter->get_Description(&bspDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEmfExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEmfExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEmfExporter.get_Description() returned %ld", (long)hr);
        goto iemfexporter_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pDescription = PyUnicode_FromWideChar(bspDescription,::SysStringLen(bspDescription));
    ::SysFreeString(bspDescription);
    
    if (PyErr_Occurred())
      goto iemfexporter_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pDescription);
    goto iemfexporter_get_description_method_cleanup;

    iemfexporter_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pDescription != Py_None)
        Py_XDECREF(pyvar_pDescription);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEmfExporter.get_Description");
    return return_tuple;
}


PyMethodDef PyIEmfExporterMethods[] = {
    {"supports", (PyCFunction)PyIEmfExporter_SupportsInterface, METH_O, ""},
    {"put_IsInMemory", (PyCFunction)IEmfExporterMethod_put_IsInMemory, METH_VARARGS, ""},
    {"get_IsInMemory", (PyCFunction)IEmfExporterMethod_get_IsInMemory, METH_VARARGS, ""},
    {"get_HENHMETAFILE", (PyCFunction)IEmfExporterMethod_get_HENHMETAFILE, METH_VARARGS, ""},
    {"TakeHENHMETAFILE", (PyCFunction)IEmfExporterMethod_TakeHENHMETAFILE, METH_VARARGS, ""},
    {"put_Description", (PyCFunction)IEmfExporterMethod_put_Description, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)IEmfExporterMethod_get_Description, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIEmfExporterGetSet[] = {
  {"_pUnk", (getter)PyIEmfExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IEmfExporter", NULL},
  {"_pointer", (getter)PyIEmfExporter_GetPointer, NULL, "Get memory address for IEmfExporter", NULL},
  {"_IID", (getter)PyIEmfExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIEmfExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIEmfExporter_GetIgnoreFailures, (setter)PyIEmfExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIEmfExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IEmfExporterObject",                          
                                              /* tp_name */
  sizeof(PyIEmfExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIEmfExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIEmfExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIEmfExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIEmfExporterObject_new,                      
                                              /* tp_new */
};

// Interface ISpotPlate

typedef struct PyISpotPlateObject {
    PyObject_HEAD
    ISpotPlate* m_pISpotPlate;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISpotPlateObject;

static PyObject*
PyISpotPlateObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISpotPlateObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISpotPlate* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISpotPlate, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISpotPlate with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISpotPlateObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISpotPlate");
            return NULL;
        }
        self->m_pISpotPlate = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISpotPlate");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISpotPlate");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISpotPlate* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISpotPlate, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISpotPlate");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISpotPlateObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISpotPlate");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISpotPlate = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISpotPlateObject_dealloc(PyISpotPlateObject* self)
{
    if (self->m_pISpotPlate)
        self->m_pISpotPlate->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISpotPlate_GetpUnk(PyISpotPlateObject* self)
{
    if (!self->m_pISpotPlate)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISpotPlate->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISpotPlate to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISpotPlate_GetPointer(PyISpotPlateObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISpotPlate);
}

static PyObject*
PyISpotPlate_GetIID(PyISpotPlateObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "481614e4-9407-11d1-9127-0000f87808ee");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISpotPlate_GetHR(PyISpotPlateObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISpotPlate_GetIgnoreFailures(PyISpotPlateObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISpotPlate_SetIgnoreFailures(PyISpotPlateObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISpotPlate_SupportsInterface(PyISpotPlateObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISpotPlate->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISpotPlateMethod_put_Color(PyISpotPlateObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPostScriptColor* ipColor = NULL;
    PyObject* py_Color;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Color))
      goto ispotplate_put_color_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Color, &IID_IPostScriptColor, (void**)&ipColor))
        PyErr_SetString(PyExc_TypeError, "Argument Color (position 0) is not IPostScriptColor");
    
    if (PyErr_Occurred())
      goto ispotplate_put_color_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISpotPlate->put_Color(ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlate->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlate) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlate.put_Color() returned %ld", (long)hr);
        goto ispotplate_put_color_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Color

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ispotplate_put_color_method_cleanup;

    ispotplate_put_color_method_cleanup:
    self->m_HR = hr;
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlate.put_Color");
    return return_tuple;
}

static PyObject*
ISpotPlateMethod_get_Color(PyISpotPlateObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPostScriptColor* ipColor = NULL;
    PyObject* py_Color = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Color

    // Call method on actual COM interface
    hr = self->m_pISpotPlate->get_Color(&ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlate->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlate) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlate.get_Color() returned %ld", (long)hr);
        goto ispotplate_get_color_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Color);
    if (ipColor)
    {
        IUnknown* pUnk = NULL;
        ipColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Color = IUnknownToPythonIIDObject(pUnk, &IID_IPostScriptColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Color)
    {
        if (py_Color)
           Py_DECREF(py_Color);
        py_Color = Py_None;
        Py_INCREF(py_Color);
    }
    if (PyErr_Occurred())
      goto ispotplate_get_color_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Color);
    goto ispotplate_get_color_method_cleanup;

    ispotplate_get_color_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Color);
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlate.get_Color");
    return return_tuple;
}

static PyObject*
ISpotPlateMethod_put_Separate(PyISpotPlateObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverSeparates eSeparate;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eSeparate))
      goto ispotplate_put_separate_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Separate

    // Call method on actual COM interface
    hr = self->m_pISpotPlate->put_Separate(eSeparate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlate->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlate) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlate.put_Separate() returned %ld", (long)hr);
        goto ispotplate_put_separate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Separate

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ispotplate_put_separate_method_cleanup;

    ispotplate_put_separate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Separate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlate.put_Separate");
    return return_tuple;
}

static PyObject*
ISpotPlateMethod_get_Separate(PyISpotPlateObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverSeparates eSeparate;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Separate

    // Call method on actual COM interface
    hr = self->m_pISpotPlate->get_Separate(&eSeparate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlate->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlate) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlate.get_Separate() returned %ld", (long)hr);
        goto ispotplate_get_separate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Separate

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eSeparate);
    goto ispotplate_get_separate_method_cleanup;

    ispotplate_get_separate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Separate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlate.get_Separate");
    return return_tuple;
}

static PyObject*
ISpotPlateMethod_put_ScreenAngle(PyISpotPlateObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dangle = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dangle))
      goto ispotplate_put_screenangle_method_cleanup;

    // Set up initial variable values as needed
    // No setup for angle

    // Call method on actual COM interface
    hr = self->m_pISpotPlate->put_ScreenAngle(dangle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlate->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlate) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlate.put_ScreenAngle() returned %ld", (long)hr);
        goto ispotplate_put_screenangle_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for angle

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ispotplate_put_screenangle_method_cleanup;

    ispotplate_put_screenangle_method_cleanup:
    self->m_HR = hr;
    // No cleanup for angle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlate.put_ScreenAngle");
    return return_tuple;
}

static PyObject*
ISpotPlateMethod_get_ScreenAngle(PyISpotPlateObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dangle = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for angle

    // Call method on actual COM interface
    hr = self->m_pISpotPlate->get_ScreenAngle(&dangle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlate->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlate) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlate.get_ScreenAngle() returned %ld", (long)hr);
        goto ispotplate_get_screenangle_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for angle

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dangle);
    goto ispotplate_get_screenangle_method_cleanup;

    ispotplate_get_screenangle_method_cleanup:
    self->m_HR = hr;
    // No cleanup for angle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlate.get_ScreenAngle");
    return return_tuple;
}


PyMethodDef PyISpotPlateMethods[] = {
    {"supports", (PyCFunction)PyISpotPlate_SupportsInterface, METH_O, ""},
    {"put_Color", (PyCFunction)ISpotPlateMethod_put_Color, METH_VARARGS, ""},
    {"get_Color", (PyCFunction)ISpotPlateMethod_get_Color, METH_VARARGS, ""},
    {"put_Separate", (PyCFunction)ISpotPlateMethod_put_Separate, METH_VARARGS, ""},
    {"get_Separate", (PyCFunction)ISpotPlateMethod_get_Separate, METH_VARARGS, ""},
    {"put_ScreenAngle", (PyCFunction)ISpotPlateMethod_put_ScreenAngle, METH_VARARGS, ""},
    {"get_ScreenAngle", (PyCFunction)ISpotPlateMethod_get_ScreenAngle, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISpotPlateGetSet[] = {
  {"_pUnk", (getter)PyISpotPlate_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISpotPlate", NULL},
  {"_pointer", (getter)PyISpotPlate_GetPointer, NULL, "Get memory address for ISpotPlate", NULL},
  {"_IID", (getter)PyISpotPlate_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISpotPlate_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISpotPlate_GetIgnoreFailures, (setter)PyISpotPlate_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISpotPlateObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.ISpotPlateObject",                          
                                              /* tp_name */
  sizeof(PyISpotPlateObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISpotPlateObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISpotPlateMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISpotPlateGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISpotPlateObject_new,                      
                                              /* tp_new */
};

// Interface ISpotPlateCollection

typedef struct PyISpotPlateCollectionObject {
    PyObject_HEAD
    ISpotPlateCollection* m_pISpotPlateCollection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISpotPlateCollectionObject;

static PyObject*
PyISpotPlateCollectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISpotPlateCollectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISpotPlateCollection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISpotPlateCollection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISpotPlateCollection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISpotPlateCollectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISpotPlateCollection");
            return NULL;
        }
        self->m_pISpotPlateCollection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISpotPlateCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISpotPlateCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISpotPlateCollection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISpotPlateCollection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISpotPlateCollection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISpotPlateCollectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISpotPlateCollection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISpotPlateCollection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISpotPlateCollectionObject_dealloc(PyISpotPlateCollectionObject* self)
{
    if (self->m_pISpotPlateCollection)
        self->m_pISpotPlateCollection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISpotPlateCollection_GetpUnk(PyISpotPlateCollectionObject* self)
{
    if (!self->m_pISpotPlateCollection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISpotPlateCollection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISpotPlateCollection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISpotPlateCollection_GetPointer(PyISpotPlateCollectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISpotPlateCollection);
}

static PyObject*
PyISpotPlateCollection_GetIID(PyISpotPlateCollectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f480e790-2b0f-11d3-9fc3-00c04f6bc8dd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISpotPlateCollection_GetHR(PyISpotPlateCollectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISpotPlateCollection_GetIgnoreFailures(PyISpotPlateCollectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISpotPlateCollection_SetIgnoreFailures(PyISpotPlateCollectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISpotPlateCollection_SupportsInterface(PyISpotPlateCollectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISpotPlateCollection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISpotPlateCollectionMethod_get_Count(PyISpotPlateCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pISpotPlateCollection->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlateCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlateCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlateCollection.get_Count() returned %ld", (long)hr);
        goto ispotplatecollection_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto ispotplatecollection_get_count_method_cleanup;

    ispotplatecollection_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlateCollection.get_Count");
    return return_tuple;
}

static PyObject*
ISpotPlateCollectionMethod_get_SpotPlate(PyISpotPlateCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ISpotPlate* ipSpotPlate = NULL;
    PyObject* py_SpotPlate = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ispotplatecollection_get_spotplate_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for SpotPlate

    // Call method on actual COM interface
    hr = self->m_pISpotPlateCollection->get_SpotPlate(lindex, &ipSpotPlate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlateCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlateCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlateCollection.get_SpotPlate() returned %ld", (long)hr);
        goto ispotplatecollection_get_spotplate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_SpotPlate);
    if (ipSpotPlate)
    {
        IUnknown* pUnk = NULL;
        ipSpotPlate->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_SpotPlate = IUnknownToPythonIIDObject(pUnk, &IID_ISpotPlate);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_SpotPlate)
    {
        if (py_SpotPlate)
           Py_DECREF(py_SpotPlate);
        py_SpotPlate = Py_None;
        Py_INCREF(py_SpotPlate);
    }
    if (PyErr_Occurred())
      goto ispotplatecollection_get_spotplate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_SpotPlate);
    goto ispotplatecollection_get_spotplate_method_cleanup;

    ispotplatecollection_get_spotplate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_SpotPlate);
    if (ipSpotPlate)
      ipSpotPlate->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlateCollection.get_SpotPlate");
    return return_tuple;
}

static PyObject*
ISpotPlateCollectionMethod_Add(PyISpotPlateCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpotPlate* ipSpotPlate = NULL;
    PyObject* py_SpotPlate;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_SpotPlate))
      goto ispotplatecollection_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_SpotPlate, &IID_ISpotPlate, (void**)&ipSpotPlate))
        PyErr_SetString(PyExc_TypeError, "Argument SpotPlate (position 0) is not ISpotPlate");
    
    if (PyErr_Occurred())
      goto ispotplatecollection_add_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISpotPlateCollection->Add(ipSpotPlate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlateCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlateCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlateCollection.Add() returned %ld", (long)hr);
        goto ispotplatecollection_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SpotPlate

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ispotplatecollection_add_method_cleanup;

    ispotplatecollection_add_method_cleanup:
    self->m_HR = hr;
    if (ipSpotPlate)
      ipSpotPlate->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlateCollection.Add");
    return return_tuple;
}

static PyObject*
ISpotPlateCollectionMethod_Insert(PyISpotPlateCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ISpotPlate* ipSpotPlate = NULL;
    PyObject* py_SpotPlate;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lindex, &py_SpotPlate))
      goto ispotplatecollection_insert_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_SpotPlate, &IID_ISpotPlate, (void**)&ipSpotPlate))
        PyErr_SetString(PyExc_TypeError, "Argument SpotPlate (position 1) is not ISpotPlate");
    
    if (PyErr_Occurred())
      goto ispotplatecollection_insert_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISpotPlateCollection->Insert(lindex, ipSpotPlate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlateCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlateCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlateCollection.Insert() returned %ld", (long)hr);
        goto ispotplatecollection_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for SpotPlate

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ispotplatecollection_insert_method_cleanup;

    ispotplatecollection_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ipSpotPlate)
      ipSpotPlate->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlateCollection.Insert");
    return return_tuple;
}

static PyObject*
ISpotPlateCollectionMethod_Remove(PyISpotPlateCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ispotplatecollection_remove_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pISpotPlateCollection->Remove(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlateCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlateCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlateCollection.Remove() returned %ld", (long)hr);
        goto ispotplatecollection_remove_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ispotplatecollection_remove_method_cleanup;

    ispotplatecollection_remove_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISpotPlateCollection.Remove");
    return return_tuple;
}

static PyObject*
ISpotPlateCollectionMethod_RemoveAll(PyISpotPlateCollectionObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pISpotPlateCollection->RemoveAll();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISpotPlateCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISpotPlateCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISpotPlateCollection.RemoveAll() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyISpotPlateCollectionMethods[] = {
    {"supports", (PyCFunction)PyISpotPlateCollection_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)ISpotPlateCollectionMethod_get_Count, METH_VARARGS, ""},
    {"get_SpotPlate", (PyCFunction)ISpotPlateCollectionMethod_get_SpotPlate, METH_VARARGS, ""},
    {"Add", (PyCFunction)ISpotPlateCollectionMethod_Add, METH_VARARGS, ""},
    {"Insert", (PyCFunction)ISpotPlateCollectionMethod_Insert, METH_VARARGS, ""},
    {"Remove", (PyCFunction)ISpotPlateCollectionMethod_Remove, METH_VARARGS, ""},
    {"RemoveAll", (PyCFunction)ISpotPlateCollectionMethod_RemoveAll, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISpotPlateCollectionGetSet[] = {
  {"_pUnk", (getter)PyISpotPlateCollection_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISpotPlateCollection", NULL},
  {"_pointer", (getter)PyISpotPlateCollection_GetPointer, NULL, "Get memory address for ISpotPlateCollection", NULL},
  {"_IID", (getter)PyISpotPlateCollection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISpotPlateCollection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISpotPlateCollection_GetIgnoreFailures, (setter)PyISpotPlateCollection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISpotPlateCollectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.ISpotPlateCollectionObject",                          
                                              /* tp_name */
  sizeof(PyISpotPlateCollectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISpotPlateCollectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISpotPlateCollectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISpotPlateCollectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISpotPlateCollectionObject_new,                      
                                              /* tp_new */
};

// Interface IColorCorrection

typedef struct PyIColorCorrectionObject {
    PyObject_HEAD
    IColorCorrection* m_pIColorCorrection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIColorCorrectionObject;

static PyObject*
PyIColorCorrectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIColorCorrectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IColorCorrection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IColorCorrection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IColorCorrection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIColorCorrectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IColorCorrection");
            return NULL;
        }
        self->m_pIColorCorrection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IColorCorrection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IColorCorrection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IColorCorrection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IColorCorrection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IColorCorrection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIColorCorrectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IColorCorrection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIColorCorrection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIColorCorrectionObject_dealloc(PyIColorCorrectionObject* self)
{
    if (self->m_pIColorCorrection)
        self->m_pIColorCorrection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIColorCorrection_GetpUnk(PyIColorCorrectionObject* self)
{
    if (!self->m_pIColorCorrection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIColorCorrection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IColorCorrection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIColorCorrection_GetPointer(PyIColorCorrectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIColorCorrection);
}

static PyObject*
PyIColorCorrection_GetIID(PyIColorCorrectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "80b77a31-4db6-11d3-b654-0080c8ea4fd5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIColorCorrection_GetHR(PyIColorCorrectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIColorCorrection_GetIgnoreFailures(PyIColorCorrectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIColorCorrection_SetIgnoreFailures(PyIColorCorrectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIColorCorrection_SupportsInterface(PyIColorCorrectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IColorCorrectionMethod_get_SupportedColorCorrections(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sval = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->get_SupportedColorCorrections(&sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.get_SupportedColorCorrections() returned %ld", (long)hr);
        goto icolorcorrection_get_supportedcolorcorrections_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for val

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sval);
    goto icolorcorrection_get_supportedcolorcorrections_method_cleanup;

    icolorcorrection_get_supportedcolorcorrections_method_cleanup:
    self->m_HR = hr;
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.get_SupportedColorCorrections");
    return return_tuple;
}

static PyObject*
IColorCorrectionMethod_get_Lightness(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriColorCorrectionDataType edataType;
    short sval = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&edataType))
      goto icolorcorrection_get_lightness_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dataType
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->get_Lightness(edataType, &sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.get_Lightness() returned %ld", (long)hr);
        goto icolorcorrection_get_lightness_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dataType
    // No teardown for val

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sval);
    goto icolorcorrection_get_lightness_method_cleanup;

    icolorcorrection_get_lightness_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dataType
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.get_Lightness");
    return return_tuple;
}

static PyObject*
IColorCorrectionMethod_put_Lightness(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriColorCorrectionDataType edataType;
    short sval = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ih", (int *)&edataType, &sval))
      goto icolorcorrection_put_lightness_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dataType
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->put_Lightness(edataType, sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.put_Lightness() returned %ld", (long)hr);
        goto icolorcorrection_put_lightness_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dataType
    // No teardown for val

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icolorcorrection_put_lightness_method_cleanup;

    icolorcorrection_put_lightness_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dataType
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.put_Lightness");
    return return_tuple;
}

static PyObject*
IColorCorrectionMethod_get_Saturation(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriColorCorrectionDataType edataType;
    short sval = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&edataType))
      goto icolorcorrection_get_saturation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dataType
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->get_Saturation(edataType, &sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.get_Saturation() returned %ld", (long)hr);
        goto icolorcorrection_get_saturation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dataType
    // No teardown for val

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sval);
    goto icolorcorrection_get_saturation_method_cleanup;

    icolorcorrection_get_saturation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dataType
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.get_Saturation");
    return return_tuple;
}

static PyObject*
IColorCorrectionMethod_put_Saturation(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriColorCorrectionDataType edataType;
    short sval = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ih", (int *)&edataType, &sval))
      goto icolorcorrection_put_saturation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dataType
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->put_Saturation(edataType, sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.put_Saturation() returned %ld", (long)hr);
        goto icolorcorrection_put_saturation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dataType
    // No teardown for val

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icolorcorrection_put_saturation_method_cleanup;

    icolorcorrection_put_saturation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dataType
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.put_Saturation");
    return return_tuple;
}

static PyObject*
IColorCorrectionMethod_get_UnderColorRemoval(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriColorCorrectionDataType edataType;
    short sval = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&edataType))
      goto icolorcorrection_get_undercolorremoval_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dataType
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->get_UnderColorRemoval(edataType, &sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.get_UnderColorRemoval() returned %ld", (long)hr);
        goto icolorcorrection_get_undercolorremoval_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dataType
    // No teardown for val

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sval);
    goto icolorcorrection_get_undercolorremoval_method_cleanup;

    icolorcorrection_get_undercolorremoval_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dataType
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.get_UnderColorRemoval");
    return return_tuple;
}

static PyObject*
IColorCorrectionMethod_put_UnderColorRemoval(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriColorCorrectionDataType edataType;
    short sval = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ih", (int *)&edataType, &sval))
      goto icolorcorrection_put_undercolorremoval_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dataType
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->put_UnderColorRemoval(edataType, sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.put_UnderColorRemoval() returned %ld", (long)hr);
        goto icolorcorrection_put_undercolorremoval_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dataType
    // No teardown for val

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icolorcorrection_put_undercolorremoval_method_cleanup;

    icolorcorrection_put_undercolorremoval_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dataType
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.put_UnderColorRemoval");
    return return_tuple;
}

static PyObject*
IColorCorrectionMethod_get_CMYKCorrection(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriColorCorrectionDataType edataType;
    esriCMYKIndex eindex;
    short sval = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ii", (int *)&edataType, (int *)&eindex))
      goto icolorcorrection_get_cmykcorrection_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dataType
    // No setup for index
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->get_CMYKCorrection(edataType, eindex, &sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.get_CMYKCorrection() returned %ld", (long)hr);
        goto icolorcorrection_get_cmykcorrection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dataType
    // No teardown for index
    // No teardown for val

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sval);
    goto icolorcorrection_get_cmykcorrection_method_cleanup;

    icolorcorrection_get_cmykcorrection_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dataType
    // No cleanup for index
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.get_CMYKCorrection");
    return return_tuple;
}

static PyObject*
IColorCorrectionMethod_put_CMYKCorrection(PyIColorCorrectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriColorCorrectionDataType edataType;
    esriCMYKIndex eindex;
    short sval = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iih", (int *)&edataType, (int *)&eindex, &sval))
      goto icolorcorrection_put_cmykcorrection_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dataType
    // No setup for index
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIColorCorrection->put_CMYKCorrection(edataType, eindex, sval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorCorrection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorCorrection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorCorrection.put_CMYKCorrection() returned %ld", (long)hr);
        goto icolorcorrection_put_cmykcorrection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dataType
    // No teardown for index
    // No teardown for val

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icolorcorrection_put_cmykcorrection_method_cleanup;

    icolorcorrection_put_cmykcorrection_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dataType
    // No cleanup for index
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorCorrection.put_CMYKCorrection");
    return return_tuple;
}


PyMethodDef PyIColorCorrectionMethods[] = {
    {"supports", (PyCFunction)PyIColorCorrection_SupportsInterface, METH_O, ""},
    {"get_SupportedColorCorrections", (PyCFunction)IColorCorrectionMethod_get_SupportedColorCorrections, METH_VARARGS, ""},
    {"get_Lightness", (PyCFunction)IColorCorrectionMethod_get_Lightness, METH_VARARGS, ""},
    {"put_Lightness", (PyCFunction)IColorCorrectionMethod_put_Lightness, METH_VARARGS, ""},
    {"get_Saturation", (PyCFunction)IColorCorrectionMethod_get_Saturation, METH_VARARGS, ""},
    {"put_Saturation", (PyCFunction)IColorCorrectionMethod_put_Saturation, METH_VARARGS, ""},
    {"get_UnderColorRemoval", (PyCFunction)IColorCorrectionMethod_get_UnderColorRemoval, METH_VARARGS, ""},
    {"put_UnderColorRemoval", (PyCFunction)IColorCorrectionMethod_put_UnderColorRemoval, METH_VARARGS, ""},
    {"get_CMYKCorrection", (PyCFunction)IColorCorrectionMethod_get_CMYKCorrection, METH_VARARGS, ""},
    {"put_CMYKCorrection", (PyCFunction)IColorCorrectionMethod_put_CMYKCorrection, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIColorCorrectionGetSet[] = {
  {"_pUnk", (getter)PyIColorCorrection_GetpUnk, NULL, "Get opaque pointer to an Unknown from IColorCorrection", NULL},
  {"_pointer", (getter)PyIColorCorrection_GetPointer, NULL, "Get memory address for IColorCorrection", NULL},
  {"_IID", (getter)PyIColorCorrection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIColorCorrection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIColorCorrection_GetIgnoreFailures, (setter)PyIColorCorrection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIColorCorrectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IColorCorrectionObject",                          
                                              /* tp_name */
  sizeof(PyIColorCorrectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIColorCorrectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIColorCorrectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIColorCorrectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIColorCorrectionObject_new,                      
                                              /* tp_new */
};

// Interface IPSDriver

typedef struct PyIPSDriverObject {
    PyObject_HEAD
    IPSDriver* m_pIPSDriver;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPSDriverObject;

static PyObject*
PyIPSDriverObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPSDriverObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPSDriver* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPSDriver, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPSDriver with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPSDriverObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPSDriver");
            return NULL;
        }
        self->m_pIPSDriver = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPSDriver");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPSDriver");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPSDriver* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPSDriver, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPSDriver");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPSDriverObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPSDriver");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPSDriver = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPSDriverObject_dealloc(PyIPSDriverObject* self)
{
    if (self->m_pIPSDriver)
        self->m_pIPSDriver->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPSDriver_GetpUnk(PyIPSDriverObject* self)
{
    if (!self->m_pIPSDriver)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPSDriver->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPSDriver to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPSDriver_GetPointer(PyIPSDriverObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPSDriver);
}

static PyObject*
PyIPSDriver_GetIID(PyIPSDriverObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cd754684-a222-11d0-a68f-080009d57b9a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPSDriver_GetHR(PyIPSDriverObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPSDriver_GetIgnoreFailures(PyIPSDriverObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPSDriver_SetIgnoreFailures(PyIPSDriverObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPSDriver_SupportsInterface(PyIPSDriverObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPSDriverMethod_get_ImageCompression(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverImageCompression eImageCompression;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ImageCompression

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_ImageCompression(&eImageCompression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_ImageCompression() returned %ld", (long)hr);
        goto ipsdriver_get_imagecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ImageCompression

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eImageCompression);
    goto ipsdriver_get_imagecompression_method_cleanup;

    ipsdriver_get_imagecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ImageCompression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_ImageCompression");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_ImageCompression(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverImageCompression eImageCompression;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eImageCompression))
      goto ipsdriver_put_imagecompression_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ImageCompression

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_ImageCompression(eImageCompression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_ImageCompression() returned %ld", (long)hr);
        goto ipsdriver_put_imagecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ImageCompression

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_imagecompression_method_cleanup;

    ipsdriver_put_imagecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ImageCompression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_ImageCompression");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_ArcPressSeparateImage(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_sepImage = VARIANT_FALSE;
    PyObject* pyvar_sepImage = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for sepImage

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_ArcPressSeparateImage(&b_sepImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_ArcPressSeparateImage() returned %ld", (long)hr);
        goto ipsdriver_get_arcpressseparateimage_method_cleanup;
    }

    // Set up return values as needed
    pyvar_sepImage = ((b_sepImage == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipsdriver_get_arcpressseparateimage_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_sepImage);
    goto ipsdriver_get_arcpressseparateimage_method_cleanup;

    ipsdriver_get_arcpressseparateimage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sepImage
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_ArcPressSeparateImage");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_ArcPressSeparateImage(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_sepImage = VARIANT_FALSE;
    PyObject* pyvar_sepImage = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_sepImage))
      goto ipsdriver_put_arcpressseparateimage_method_cleanup;

    // Set up initial variable values as needed
    b_sepImage = ((PyObject_IsTrue(pyvar_sepImage) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ipsdriver_put_arcpressseparateimage_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_ArcPressSeparateImage(b_sepImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_ArcPressSeparateImage() returned %ld", (long)hr);
        goto ipsdriver_put_arcpressseparateimage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for sepImage

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_arcpressseparateimage_method_cleanup;

    ipsdriver_put_arcpressseparateimage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sepImage
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_ArcPressSeparateImage");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_ArcPressSeparateImageRotate(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_sepImage = VARIANT_FALSE;
    PyObject* pyvar_sepImage = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for sepImage

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_ArcPressSeparateImageRotate(&b_sepImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_ArcPressSeparateImageRotate() returned %ld", (long)hr);
        goto ipsdriver_get_arcpressseparateimagerotate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_sepImage = ((b_sepImage == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipsdriver_get_arcpressseparateimagerotate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_sepImage);
    goto ipsdriver_get_arcpressseparateimagerotate_method_cleanup;

    ipsdriver_get_arcpressseparateimagerotate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sepImage
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_ArcPressSeparateImageRotate");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_ArcPressSeparateImageRotate(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_sepImage = VARIANT_FALSE;
    PyObject* pyvar_sepImage = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_sepImage))
      goto ipsdriver_put_arcpressseparateimagerotate_method_cleanup;

    // Set up initial variable values as needed
    b_sepImage = ((PyObject_IsTrue(pyvar_sepImage) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ipsdriver_put_arcpressseparateimagerotate_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_ArcPressSeparateImageRotate(b_sepImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_ArcPressSeparateImageRotate() returned %ld", (long)hr);
        goto ipsdriver_put_arcpressseparateimagerotate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for sepImage

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_arcpressseparateimagerotate_method_cleanup;

    ipsdriver_put_arcpressseparateimagerotate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sepImage
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_ArcPressSeparateImageRotate");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_FontMapCollection(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFontMapCollection* ipFontMapCollection = NULL;
    PyObject* py_FontMapCollection = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FontMapCollection

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_FontMapCollection(&ipFontMapCollection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_FontMapCollection() returned %ld", (long)hr);
        goto ipsdriver_get_fontmapcollection_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_FontMapCollection);
    if (ipFontMapCollection)
    {
        IUnknown* pUnk = NULL;
        ipFontMapCollection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FontMapCollection = IUnknownToPythonIIDObject(pUnk, &IID_IFontMapCollection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FontMapCollection)
    {
        if (py_FontMapCollection)
           Py_DECREF(py_FontMapCollection);
        py_FontMapCollection = Py_None;
        Py_INCREF(py_FontMapCollection);
    }
    if (PyErr_Occurred())
      goto ipsdriver_get_fontmapcollection_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FontMapCollection);
    goto ipsdriver_get_fontmapcollection_method_cleanup;

    ipsdriver_get_fontmapcollection_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_FontMapCollection);
    if (ipFontMapCollection)
      ipFontMapCollection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_FontMapCollection");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_putref_FontMapCollection(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFontMapCollection* ipFontMapCollection = NULL;
    PyObject* py_FontMapCollection;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_FontMapCollection))
      goto ipsdriver_putref_fontmapcollection_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_FontMapCollection, &IID_IFontMapCollection, (void**)&ipFontMapCollection))
        PyErr_SetString(PyExc_TypeError, "Argument FontMapCollection (position 0) is not IFontMapCollection");
    
    if (PyErr_Occurred())
      goto ipsdriver_putref_fontmapcollection_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->putref_FontMapCollection(ipFontMapCollection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.putref_FontMapCollection() returned %ld", (long)hr);
        goto ipsdriver_putref_fontmapcollection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FontMapCollection

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_putref_fontmapcollection_method_cleanup;

    ipsdriver_putref_fontmapcollection_method_cleanup:
    self->m_HR = hr;
    if (ipFontMapCollection)
      ipFontMapCollection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.putref_FontMapCollection");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_PPDFile(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPPDFile;
    PyObject* pyvar_PPDFile = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for PPDFile

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_PPDFile(&bsPPDFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_PPDFile() returned %ld", (long)hr);
        goto ipsdriver_get_ppdfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_PPDFile = PyUnicode_FromWideChar(bsPPDFile,::SysStringLen(bsPPDFile));
    ::SysFreeString(bsPPDFile);
    
    if (PyErr_Occurred())
      goto ipsdriver_get_ppdfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_PPDFile);
    goto ipsdriver_get_ppdfile_method_cleanup;

    ipsdriver_get_ppdfile_method_cleanup:
    self->m_HR = hr;
    if (pyvar_PPDFile != Py_None)
        Py_XDECREF(pyvar_PPDFile);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_PPDFile");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_PPDFile(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPPDFile = 0;
    PyObject* pyvar_PPDFile;
    PyObject* unicodePPDFile = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_PPDFile))
      goto ipsdriver_put_ppdfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_PPDFile))
        unicodePPDFile = PyUnicode_FromObject(pyvar_PPDFile);
    else if (PyUnicode_Check(pyvar_PPDFile))
    {
        unicodePPDFile = pyvar_PPDFile;
        Py_INCREF(unicodePPDFile);
    }
    else if (pyvar_PPDFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter PPDFile at index 0");
    if (unicodePPDFile)
        bsPPDFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodePPDFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodePPDFile));
    
    if (PyErr_Occurred())
      goto ipsdriver_put_ppdfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_PPDFile(bsPPDFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_PPDFile() returned %ld", (long)hr);
        goto ipsdriver_put_ppdfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PPDFile

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_ppdfile_method_cleanup;

    ipsdriver_put_ppdfile_method_cleanup:
    self->m_HR = hr;
    if (bsPPDFile)
        ::SysFreeString(bsPPDFile);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_PPDFile");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_Marks(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sMarks = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Marks

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_Marks(&sMarks);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_Marks() returned %ld", (long)hr);
        goto ipsdriver_get_marks_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Marks

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sMarks);
    goto ipsdriver_get_marks_method_cleanup;

    ipsdriver_get_marks_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Marks
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_Marks");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_Marks(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sMarks = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sMarks))
      goto ipsdriver_put_marks_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Marks

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_Marks(sMarks);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_Marks() returned %ld", (long)hr);
        goto ipsdriver_put_marks_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Marks

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_marks_method_cleanup;

    ipsdriver_put_marks_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Marks
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_Marks");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_HalfTone(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverHalfTone eHalfTone;
    long lvalue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eHalfTone))
      goto ipsdriver_get_halftone_method_cleanup;

    // Set up initial variable values as needed
    // No setup for HalfTone
    // No setup for value

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_HalfTone(eHalfTone, &lvalue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_HalfTone() returned %ld", (long)hr);
        goto ipsdriver_get_halftone_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HalfTone
    // No teardown for value

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lvalue);
    goto ipsdriver_get_halftone_method_cleanup;

    ipsdriver_get_halftone_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HalfTone
    // No cleanup for value
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_HalfTone");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_HalfTone(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverHalfTone eHalfTone;
    long lvalue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "il", (int *)&eHalfTone, &lvalue))
      goto ipsdriver_put_halftone_method_cleanup;

    // Set up initial variable values as needed
    // No setup for HalfTone
    // No setup for value

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_HalfTone(eHalfTone, lvalue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_HalfTone() returned %ld", (long)hr);
        goto ipsdriver_put_halftone_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HalfTone
    // No teardown for value

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_halftone_method_cleanup;

    ipsdriver_put_halftone_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HalfTone
    // No cleanup for value
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_HalfTone");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_FormName(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFormName;
    PyObject* pyvar_FormName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FormName

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_FormName(&bsFormName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_FormName() returned %ld", (long)hr);
        goto ipsdriver_get_formname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_FormName = PyUnicode_FromWideChar(bsFormName,::SysStringLen(bsFormName));
    ::SysFreeString(bsFormName);
    
    if (PyErr_Occurred())
      goto ipsdriver_get_formname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_FormName);
    goto ipsdriver_get_formname_method_cleanup;

    ipsdriver_get_formname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_FormName != Py_None)
        Py_XDECREF(pyvar_FormName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_FormName");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_FormName(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFormName = 0;
    PyObject* pyvar_FormName;
    PyObject* unicodeFormName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FormName))
      goto ipsdriver_put_formname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FormName))
        unicodeFormName = PyUnicode_FromObject(pyvar_FormName);
    else if (PyUnicode_Check(pyvar_FormName))
    {
        unicodeFormName = pyvar_FormName;
        Py_INCREF(unicodeFormName);
    }
    else if (pyvar_FormName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FormName at index 0");
    if (unicodeFormName)
        bsFormName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFormName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFormName));
    
    if (PyErr_Occurred())
      goto ipsdriver_put_formname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_FormName(bsFormName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_FormName() returned %ld", (long)hr);
        goto ipsdriver_put_formname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FormName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_formname_method_cleanup;

    ipsdriver_put_formname_method_cleanup:
    self->m_HR = hr;
    if (bsFormName)
        ::SysFreeString(bsFormName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_FormName");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_PrintableBounds(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppBounds = NULL;
    PyObject* py_ppBounds = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppBounds

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_PrintableBounds(&ipppBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_PrintableBounds() returned %ld", (long)hr);
        goto ipsdriver_get_printablebounds_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppBounds);
    if (ipppBounds)
    {
        IUnknown* pUnk = NULL;
        ipppBounds->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBounds = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBounds)
    {
        if (py_ppBounds)
           Py_DECREF(py_ppBounds);
        py_ppBounds = Py_None;
        Py_INCREF(py_ppBounds);
    }
    if (PyErr_Occurred())
      goto ipsdriver_get_printablebounds_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBounds);
    goto ipsdriver_get_printablebounds_method_cleanup;

    ipsdriver_get_printablebounds_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppBounds);
    if (ipppBounds)
      ipppBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_PrintableBounds");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_PrintableBounds(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppBounds = NULL;
    PyObject* py_ppBounds;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppBounds))
      goto ipsdriver_put_printablebounds_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppBounds, &IID_IEnvelope, (void**)&ipppBounds))
        PyErr_SetString(PyExc_TypeError, "Argument ppBounds (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto ipsdriver_put_printablebounds_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_PrintableBounds(ipppBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_PrintableBounds() returned %ld", (long)hr);
        goto ipsdriver_put_printablebounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppBounds

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_printablebounds_method_cleanup;

    ipsdriver_put_printablebounds_method_cleanup:
    self->m_HR = hr;
    if (ipppBounds)
      ipppBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_PrintableBounds");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_Orientation(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sOrientation = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Orientation

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_Orientation(&sOrientation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_Orientation() returned %ld", (long)hr);
        goto ipsdriver_get_orientation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Orientation

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sOrientation);
    goto ipsdriver_get_orientation_method_cleanup;

    ipsdriver_get_orientation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Orientation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_Orientation");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_Orientation(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sOrientation = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sOrientation))
      goto ipsdriver_put_orientation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Orientation

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_Orientation(sOrientation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_Orientation() returned %ld", (long)hr);
        goto ipsdriver_put_orientation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Orientation

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_orientation_method_cleanup;

    ipsdriver_put_orientation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Orientation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_Orientation");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_Emulsion(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverEmulsion eEmulsion;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Emulsion

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_Emulsion(&eEmulsion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_Emulsion() returned %ld", (long)hr);
        goto ipsdriver_get_emulsion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Emulsion

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eEmulsion);
    goto ipsdriver_get_emulsion_method_cleanup;

    ipsdriver_get_emulsion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Emulsion
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_Emulsion");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_Emulsion(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverEmulsion eEmulsion;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eEmulsion))
      goto ipsdriver_put_emulsion_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Emulsion

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_Emulsion(eEmulsion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_Emulsion() returned %ld", (long)hr);
        goto ipsdriver_put_emulsion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Emulsion

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_emulsion_method_cleanup;

    ipsdriver_put_emulsion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Emulsion
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_Emulsion");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_Image(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverImage eImage;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Image

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_Image(&eImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_Image() returned %ld", (long)hr);
        goto ipsdriver_get_image_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Image

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eImage);
    goto ipsdriver_get_image_method_cleanup;

    ipsdriver_get_image_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Image
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_Image");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_Image(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverImage eImage;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eImage))
      goto ipsdriver_put_image_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Image

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_Image(eImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_Image() returned %ld", (long)hr);
        goto ipsdriver_put_image_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Image

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_image_method_cleanup;

    ipsdriver_put_image_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Image
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_Image");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_OneBitImageTransparency(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_imageTransparency = VARIANT_FALSE;
    PyObject* pyvar_imageTransparency = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for imageTransparency

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_OneBitImageTransparency(&b_imageTransparency);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_OneBitImageTransparency() returned %ld", (long)hr);
        goto ipsdriver_get_onebitimagetransparency_method_cleanup;
    }

    // Set up return values as needed
    pyvar_imageTransparency = ((b_imageTransparency == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipsdriver_get_onebitimagetransparency_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_imageTransparency);
    goto ipsdriver_get_onebitimagetransparency_method_cleanup;

    ipsdriver_get_onebitimagetransparency_method_cleanup:
    self->m_HR = hr;
    // No cleanup for imageTransparency
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_OneBitImageTransparency");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_OneBitImageTransparency(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_imageTransparency = VARIANT_FALSE;
    PyObject* pyvar_imageTransparency = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_imageTransparency))
      goto ipsdriver_put_onebitimagetransparency_method_cleanup;

    // Set up initial variable values as needed
    b_imageTransparency = ((PyObject_IsTrue(pyvar_imageTransparency) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ipsdriver_put_onebitimagetransparency_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_OneBitImageTransparency(b_imageTransparency);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_OneBitImageTransparency() returned %ld", (long)hr);
        goto ipsdriver_put_onebitimagetransparency_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for imageTransparency

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_onebitimagetransparency_method_cleanup;

    ipsdriver_put_onebitimagetransparency_method_cleanup:
    self->m_HR = hr;
    // No cleanup for imageTransparency
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_OneBitImageTransparency");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_UseEMFFrameBoxForPSBoundingBox(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useFrameBox = VARIANT_FALSE;
    PyObject* pyvar_useFrameBox = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for useFrameBox

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_UseEMFFrameBoxForPSBoundingBox(&b_useFrameBox);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_UseEMFFrameBoxForPSBoundingBox() returned %ld", (long)hr);
        goto ipsdriver_get_useemfframeboxforpsboundingbox_method_cleanup;
    }

    // Set up return values as needed
    pyvar_useFrameBox = ((b_useFrameBox == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipsdriver_get_useemfframeboxforpsboundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_useFrameBox);
    goto ipsdriver_get_useemfframeboxforpsboundingbox_method_cleanup;

    ipsdriver_get_useemfframeboxforpsboundingbox_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useFrameBox
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_UseEMFFrameBoxForPSBoundingBox");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_UseEMFFrameBoxForPSBoundingBox(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useFrameBox = VARIANT_FALSE;
    PyObject* pyvar_useFrameBox = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_useFrameBox))
      goto ipsdriver_put_useemfframeboxforpsboundingbox_method_cleanup;

    // Set up initial variable values as needed
    b_useFrameBox = ((PyObject_IsTrue(pyvar_useFrameBox) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ipsdriver_put_useemfframeboxforpsboundingbox_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_UseEMFFrameBoxForPSBoundingBox(b_useFrameBox);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_UseEMFFrameBoxForPSBoundingBox() returned %ld", (long)hr);
        goto ipsdriver_put_useemfframeboxforpsboundingbox_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for useFrameBox

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_useemfframeboxforpsboundingbox_method_cleanup;

    ipsdriver_put_useemfframeboxforpsboundingbox_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useFrameBox
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_UseEMFFrameBoxForPSBoundingBox");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_get_PSLanguageLevel(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverPSLanguageLevel epslevel;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pslevel

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->get_PSLanguageLevel(&epslevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.get_PSLanguageLevel() returned %ld", (long)hr);
        goto ipsdriver_get_pslanguagelevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pslevel

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epslevel);
    goto ipsdriver_get_pslanguagelevel_method_cleanup;

    ipsdriver_get_pslanguagelevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pslevel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.get_PSLanguageLevel");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_PSLanguageLevel(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverPSLanguageLevel epslevel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epslevel))
      goto ipsdriver_put_pslanguagelevel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pslevel

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_PSLanguageLevel(epslevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_PSLanguageLevel() returned %ld", (long)hr);
        goto ipsdriver_put_pslanguagelevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pslevel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_pslanguagelevel_method_cleanup;

    ipsdriver_put_pslanguagelevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pslevel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_PSLanguageLevel");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_put_StepProgressor(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStepProgressor* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto ipsdriver_put_stepprogressor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IStepProgressor, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IStepProgressor");
    
    if (PyErr_Occurred())
      goto ipsdriver_put_stepprogressor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->put_StepProgressor(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.put_StepProgressor() returned %ld", (long)hr);
        goto ipsdriver_put_stepprogressor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_put_stepprogressor_method_cleanup;

    ipsdriver_put_stepprogressor_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.put_StepProgressor");
    return return_tuple;
}

static PyObject*
IPSDriverMethod_CreatePS(PyIPSDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsInputFileName = 0;
    PyObject* pyvar_InputFileName;
    PyObject* unicodeInputFileName = NULL;
    BSTR bsOutputFileName = 0;
    PyObject* pyvar_OutputFileName;
    PyObject* unicodeOutputFileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_InputFileName, &pyvar_OutputFileName))
      goto ipsdriver_createps_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_InputFileName))
        unicodeInputFileName = PyUnicode_FromObject(pyvar_InputFileName);
    else if (PyUnicode_Check(pyvar_InputFileName))
    {
        unicodeInputFileName = pyvar_InputFileName;
        Py_INCREF(unicodeInputFileName);
    }
    else if (pyvar_InputFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter InputFileName at index 0");
    if (unicodeInputFileName)
        bsInputFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeInputFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeInputFileName));
    
    if (PyErr_Occurred())
      goto ipsdriver_createps_method_cleanup;
    
    if (PyString_Check(pyvar_OutputFileName))
        unicodeOutputFileName = PyUnicode_FromObject(pyvar_OutputFileName);
    else if (PyUnicode_Check(pyvar_OutputFileName))
    {
        unicodeOutputFileName = pyvar_OutputFileName;
        Py_INCREF(unicodeOutputFileName);
    }
    else if (pyvar_OutputFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter OutputFileName at index 1");
    if (unicodeOutputFileName)
        bsOutputFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeOutputFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeOutputFileName));
    
    if (PyErr_Occurred())
      goto ipsdriver_createps_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver->CreatePS(bsInputFileName, bsOutputFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver.CreatePS() returned %ld", (long)hr);
        goto ipsdriver_createps_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for InputFileName
    // No teardown for OutputFileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver_createps_method_cleanup;

    ipsdriver_createps_method_cleanup:
    self->m_HR = hr;
    if (bsInputFileName)
        ::SysFreeString(bsInputFileName);
    
    if (bsOutputFileName)
        ::SysFreeString(bsOutputFileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver.CreatePS");
    return return_tuple;
}


PyMethodDef PyIPSDriverMethods[] = {
    {"supports", (PyCFunction)PyIPSDriver_SupportsInterface, METH_O, ""},
    {"get_ImageCompression", (PyCFunction)IPSDriverMethod_get_ImageCompression, METH_VARARGS, ""},
    {"put_ImageCompression", (PyCFunction)IPSDriverMethod_put_ImageCompression, METH_VARARGS, ""},
    {"get_ArcPressSeparateImage", (PyCFunction)IPSDriverMethod_get_ArcPressSeparateImage, METH_VARARGS, ""},
    {"put_ArcPressSeparateImage", (PyCFunction)IPSDriverMethod_put_ArcPressSeparateImage, METH_VARARGS, ""},
    {"get_ArcPressSeparateImageRotate", (PyCFunction)IPSDriverMethod_get_ArcPressSeparateImageRotate, METH_VARARGS, ""},
    {"put_ArcPressSeparateImageRotate", (PyCFunction)IPSDriverMethod_put_ArcPressSeparateImageRotate, METH_VARARGS, ""},
    {"get_FontMapCollection", (PyCFunction)IPSDriverMethod_get_FontMapCollection, METH_VARARGS, ""},
    {"putref_FontMapCollection", (PyCFunction)IPSDriverMethod_putref_FontMapCollection, METH_VARARGS, ""},
    {"get_PPDFile", (PyCFunction)IPSDriverMethod_get_PPDFile, METH_VARARGS, ""},
    {"put_PPDFile", (PyCFunction)IPSDriverMethod_put_PPDFile, METH_VARARGS, ""},
    {"get_Marks", (PyCFunction)IPSDriverMethod_get_Marks, METH_VARARGS, ""},
    {"put_Marks", (PyCFunction)IPSDriverMethod_put_Marks, METH_VARARGS, ""},
    {"get_HalfTone", (PyCFunction)IPSDriverMethod_get_HalfTone, METH_VARARGS, ""},
    {"put_HalfTone", (PyCFunction)IPSDriverMethod_put_HalfTone, METH_VARARGS, ""},
    {"get_FormName", (PyCFunction)IPSDriverMethod_get_FormName, METH_VARARGS, ""},
    {"put_FormName", (PyCFunction)IPSDriverMethod_put_FormName, METH_VARARGS, ""},
    {"get_PrintableBounds", (PyCFunction)IPSDriverMethod_get_PrintableBounds, METH_VARARGS, ""},
    {"put_PrintableBounds", (PyCFunction)IPSDriverMethod_put_PrintableBounds, METH_VARARGS, ""},
    {"get_Orientation", (PyCFunction)IPSDriverMethod_get_Orientation, METH_VARARGS, ""},
    {"put_Orientation", (PyCFunction)IPSDriverMethod_put_Orientation, METH_VARARGS, ""},
    {"get_Emulsion", (PyCFunction)IPSDriverMethod_get_Emulsion, METH_VARARGS, ""},
    {"put_Emulsion", (PyCFunction)IPSDriverMethod_put_Emulsion, METH_VARARGS, ""},
    {"get_Image", (PyCFunction)IPSDriverMethod_get_Image, METH_VARARGS, ""},
    {"put_Image", (PyCFunction)IPSDriverMethod_put_Image, METH_VARARGS, ""},
    {"get_OneBitImageTransparency", (PyCFunction)IPSDriverMethod_get_OneBitImageTransparency, METH_VARARGS, ""},
    {"put_OneBitImageTransparency", (PyCFunction)IPSDriverMethod_put_OneBitImageTransparency, METH_VARARGS, ""},
    {"get_UseEMFFrameBoxForPSBoundingBox", (PyCFunction)IPSDriverMethod_get_UseEMFFrameBoxForPSBoundingBox, METH_VARARGS, ""},
    {"put_UseEMFFrameBoxForPSBoundingBox", (PyCFunction)IPSDriverMethod_put_UseEMFFrameBoxForPSBoundingBox, METH_VARARGS, ""},
    {"get_PSLanguageLevel", (PyCFunction)IPSDriverMethod_get_PSLanguageLevel, METH_VARARGS, ""},
    {"put_PSLanguageLevel", (PyCFunction)IPSDriverMethod_put_PSLanguageLevel, METH_VARARGS, ""},
    {"put_StepProgressor", (PyCFunction)IPSDriverMethod_put_StepProgressor, METH_VARARGS, ""},
    {"CreatePS", (PyCFunction)IPSDriverMethod_CreatePS, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPSDriverGetSet[] = {
  {"_pUnk", (getter)PyIPSDriver_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPSDriver", NULL},
  {"_pointer", (getter)PyIPSDriver_GetPointer, NULL, "Get memory address for IPSDriver", NULL},
  {"_IID", (getter)PyIPSDriver_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPSDriver_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPSDriver_GetIgnoreFailures, (setter)PyIPSDriver_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPSDriverObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPSDriverObject",                          
                                              /* tp_name */
  sizeof(PyIPSDriverObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPSDriverObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPSDriverMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPSDriverGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPSDriverObject_new,                      
                                              /* tp_new */
};

// Interface IPSDriver2

typedef struct PyIPSDriver2Object {
    PyObject_HEAD
    IPSDriver2* m_pIPSDriver2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPSDriver2Object;

static PyObject*
PyIPSDriver2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPSDriver2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPSDriver2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPSDriver2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPSDriver2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPSDriver2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPSDriver2");
            return NULL;
        }
        self->m_pIPSDriver2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPSDriver2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPSDriver2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPSDriver2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPSDriver2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPSDriver2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPSDriver2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPSDriver2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPSDriver2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPSDriver2Object_dealloc(PyIPSDriver2Object* self)
{
    if (self->m_pIPSDriver2)
        self->m_pIPSDriver2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPSDriver2_GetpUnk(PyIPSDriver2Object* self)
{
    if (!self->m_pIPSDriver2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPSDriver2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPSDriver2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPSDriver2_GetPointer(PyIPSDriver2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPSDriver2);
}

static PyObject*
PyIPSDriver2_GetIID(PyIPSDriver2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "25164bc3-56da-4af1-a195-1506ecfec53c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPSDriver2_GetHR(PyIPSDriver2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPSDriver2_GetIgnoreFailures(PyIPSDriver2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPSDriver2_SetIgnoreFailures(PyIPSDriver2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPSDriver2_SupportsInterface(PyIPSDriver2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPSDriver2Method_get_Copies(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sCopies = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Copies

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_Copies(&sCopies);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_Copies() returned %ld", (long)hr);
        goto ipsdriver2_get_copies_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Copies

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sCopies);
    goto ipsdriver2_get_copies_method_cleanup;

    ipsdriver2_get_copies_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Copies
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_Copies");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_Copies(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sCopies = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sCopies))
      goto ipsdriver2_put_copies_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Copies

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_Copies(sCopies);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_Copies() returned %ld", (long)hr);
        goto ipsdriver2_put_copies_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Copies

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_copies_method_cleanup;

    ipsdriver2_put_copies_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Copies
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_Copies");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_ImageCompression(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverImageCompression eImageCompression;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ImageCompression

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_ImageCompression(&eImageCompression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_ImageCompression() returned %ld", (long)hr);
        goto ipsdriver2_get_imagecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ImageCompression

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eImageCompression);
    goto ipsdriver2_get_imagecompression_method_cleanup;

    ipsdriver2_get_imagecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ImageCompression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_ImageCompression");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_ImageCompression(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverImageCompression eImageCompression;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eImageCompression))
      goto ipsdriver2_put_imagecompression_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ImageCompression

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_ImageCompression(eImageCompression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_ImageCompression() returned %ld", (long)hr);
        goto ipsdriver2_put_imagecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ImageCompression

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_imagecompression_method_cleanup;

    ipsdriver2_put_imagecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ImageCompression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_ImageCompression");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_ArcPressSeparateImage(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_sepImage = VARIANT_FALSE;
    PyObject* pyvar_sepImage = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for sepImage

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_ArcPressSeparateImage(&b_sepImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_ArcPressSeparateImage() returned %ld", (long)hr);
        goto ipsdriver2_get_arcpressseparateimage_method_cleanup;
    }

    // Set up return values as needed
    pyvar_sepImage = ((b_sepImage == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipsdriver2_get_arcpressseparateimage_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_sepImage);
    goto ipsdriver2_get_arcpressseparateimage_method_cleanup;

    ipsdriver2_get_arcpressseparateimage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sepImage
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_ArcPressSeparateImage");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_ArcPressSeparateImage(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_sepImage = VARIANT_FALSE;
    PyObject* pyvar_sepImage = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_sepImage))
      goto ipsdriver2_put_arcpressseparateimage_method_cleanup;

    // Set up initial variable values as needed
    b_sepImage = ((PyObject_IsTrue(pyvar_sepImage) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ipsdriver2_put_arcpressseparateimage_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_ArcPressSeparateImage(b_sepImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_ArcPressSeparateImage() returned %ld", (long)hr);
        goto ipsdriver2_put_arcpressseparateimage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for sepImage

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_arcpressseparateimage_method_cleanup;

    ipsdriver2_put_arcpressseparateimage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sepImage
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_ArcPressSeparateImage");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_ArcPressSeparateImageRotate(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_sepImage = VARIANT_FALSE;
    PyObject* pyvar_sepImage = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for sepImage

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_ArcPressSeparateImageRotate(&b_sepImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_ArcPressSeparateImageRotate() returned %ld", (long)hr);
        goto ipsdriver2_get_arcpressseparateimagerotate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_sepImage = ((b_sepImage == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipsdriver2_get_arcpressseparateimagerotate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_sepImage);
    goto ipsdriver2_get_arcpressseparateimagerotate_method_cleanup;

    ipsdriver2_get_arcpressseparateimagerotate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sepImage
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_ArcPressSeparateImageRotate");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_ArcPressSeparateImageRotate(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_sepImage = VARIANT_FALSE;
    PyObject* pyvar_sepImage = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_sepImage))
      goto ipsdriver2_put_arcpressseparateimagerotate_method_cleanup;

    // Set up initial variable values as needed
    b_sepImage = ((PyObject_IsTrue(pyvar_sepImage) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ipsdriver2_put_arcpressseparateimagerotate_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_ArcPressSeparateImageRotate(b_sepImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_ArcPressSeparateImageRotate() returned %ld", (long)hr);
        goto ipsdriver2_put_arcpressseparateimagerotate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for sepImage

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_arcpressseparateimagerotate_method_cleanup;

    ipsdriver2_put_arcpressseparateimagerotate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sepImage
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_ArcPressSeparateImageRotate");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_FontMapCollection(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFontMapCollection* ipFontMapCollection = NULL;
    PyObject* py_FontMapCollection = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FontMapCollection

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_FontMapCollection(&ipFontMapCollection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_FontMapCollection() returned %ld", (long)hr);
        goto ipsdriver2_get_fontmapcollection_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_FontMapCollection);
    if (ipFontMapCollection)
    {
        IUnknown* pUnk = NULL;
        ipFontMapCollection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FontMapCollection = IUnknownToPythonIIDObject(pUnk, &IID_IFontMapCollection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FontMapCollection)
    {
        if (py_FontMapCollection)
           Py_DECREF(py_FontMapCollection);
        py_FontMapCollection = Py_None;
        Py_INCREF(py_FontMapCollection);
    }
    if (PyErr_Occurred())
      goto ipsdriver2_get_fontmapcollection_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FontMapCollection);
    goto ipsdriver2_get_fontmapcollection_method_cleanup;

    ipsdriver2_get_fontmapcollection_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_FontMapCollection);
    if (ipFontMapCollection)
      ipFontMapCollection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_FontMapCollection");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_putref_FontMapCollection(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFontMapCollection* ipFontMapCollection = NULL;
    PyObject* py_FontMapCollection;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_FontMapCollection))
      goto ipsdriver2_putref_fontmapcollection_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_FontMapCollection, &IID_IFontMapCollection, (void**)&ipFontMapCollection))
        PyErr_SetString(PyExc_TypeError, "Argument FontMapCollection (position 0) is not IFontMapCollection");
    
    if (PyErr_Occurred())
      goto ipsdriver2_putref_fontmapcollection_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->putref_FontMapCollection(ipFontMapCollection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.putref_FontMapCollection() returned %ld", (long)hr);
        goto ipsdriver2_putref_fontmapcollection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FontMapCollection

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_putref_fontmapcollection_method_cleanup;

    ipsdriver2_putref_fontmapcollection_method_cleanup:
    self->m_HR = hr;
    if (ipFontMapCollection)
      ipFontMapCollection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.putref_FontMapCollection");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_PPDFile(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPPDFile;
    PyObject* pyvar_PPDFile = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for PPDFile

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_PPDFile(&bsPPDFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_PPDFile() returned %ld", (long)hr);
        goto ipsdriver2_get_ppdfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_PPDFile = PyUnicode_FromWideChar(bsPPDFile,::SysStringLen(bsPPDFile));
    ::SysFreeString(bsPPDFile);
    
    if (PyErr_Occurred())
      goto ipsdriver2_get_ppdfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_PPDFile);
    goto ipsdriver2_get_ppdfile_method_cleanup;

    ipsdriver2_get_ppdfile_method_cleanup:
    self->m_HR = hr;
    if (pyvar_PPDFile != Py_None)
        Py_XDECREF(pyvar_PPDFile);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_PPDFile");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_PPDFile(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPPDFile = 0;
    PyObject* pyvar_PPDFile;
    PyObject* unicodePPDFile = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_PPDFile))
      goto ipsdriver2_put_ppdfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_PPDFile))
        unicodePPDFile = PyUnicode_FromObject(pyvar_PPDFile);
    else if (PyUnicode_Check(pyvar_PPDFile))
    {
        unicodePPDFile = pyvar_PPDFile;
        Py_INCREF(unicodePPDFile);
    }
    else if (pyvar_PPDFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter PPDFile at index 0");
    if (unicodePPDFile)
        bsPPDFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodePPDFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodePPDFile));
    
    if (PyErr_Occurred())
      goto ipsdriver2_put_ppdfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_PPDFile(bsPPDFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_PPDFile() returned %ld", (long)hr);
        goto ipsdriver2_put_ppdfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PPDFile

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_ppdfile_method_cleanup;

    ipsdriver2_put_ppdfile_method_cleanup:
    self->m_HR = hr;
    if (bsPPDFile)
        ::SysFreeString(bsPPDFile);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_PPDFile");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_Marks(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sMarks = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Marks

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_Marks(&sMarks);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_Marks() returned %ld", (long)hr);
        goto ipsdriver2_get_marks_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Marks

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sMarks);
    goto ipsdriver2_get_marks_method_cleanup;

    ipsdriver2_get_marks_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Marks
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_Marks");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_Marks(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sMarks = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sMarks))
      goto ipsdriver2_put_marks_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Marks

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_Marks(sMarks);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_Marks() returned %ld", (long)hr);
        goto ipsdriver2_put_marks_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Marks

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_marks_method_cleanup;

    ipsdriver2_put_marks_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Marks
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_Marks");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_HalfTone(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverHalfTone eHalfTone;
    long lvalue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eHalfTone))
      goto ipsdriver2_get_halftone_method_cleanup;

    // Set up initial variable values as needed
    // No setup for HalfTone
    // No setup for value

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_HalfTone(eHalfTone, &lvalue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_HalfTone() returned %ld", (long)hr);
        goto ipsdriver2_get_halftone_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HalfTone
    // No teardown for value

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lvalue);
    goto ipsdriver2_get_halftone_method_cleanup;

    ipsdriver2_get_halftone_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HalfTone
    // No cleanup for value
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_HalfTone");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_HalfTone(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverHalfTone eHalfTone;
    long lvalue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "il", (int *)&eHalfTone, &lvalue))
      goto ipsdriver2_put_halftone_method_cleanup;

    // Set up initial variable values as needed
    // No setup for HalfTone
    // No setup for value

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_HalfTone(eHalfTone, lvalue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_HalfTone() returned %ld", (long)hr);
        goto ipsdriver2_put_halftone_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HalfTone
    // No teardown for value

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_halftone_method_cleanup;

    ipsdriver2_put_halftone_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HalfTone
    // No cleanup for value
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_HalfTone");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_FormName(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFormName;
    PyObject* pyvar_FormName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FormName

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_FormName(&bsFormName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_FormName() returned %ld", (long)hr);
        goto ipsdriver2_get_formname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_FormName = PyUnicode_FromWideChar(bsFormName,::SysStringLen(bsFormName));
    ::SysFreeString(bsFormName);
    
    if (PyErr_Occurred())
      goto ipsdriver2_get_formname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_FormName);
    goto ipsdriver2_get_formname_method_cleanup;

    ipsdriver2_get_formname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_FormName != Py_None)
        Py_XDECREF(pyvar_FormName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_FormName");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_FormName(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFormName = 0;
    PyObject* pyvar_FormName;
    PyObject* unicodeFormName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FormName))
      goto ipsdriver2_put_formname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FormName))
        unicodeFormName = PyUnicode_FromObject(pyvar_FormName);
    else if (PyUnicode_Check(pyvar_FormName))
    {
        unicodeFormName = pyvar_FormName;
        Py_INCREF(unicodeFormName);
    }
    else if (pyvar_FormName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FormName at index 0");
    if (unicodeFormName)
        bsFormName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFormName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFormName));
    
    if (PyErr_Occurred())
      goto ipsdriver2_put_formname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_FormName(bsFormName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_FormName() returned %ld", (long)hr);
        goto ipsdriver2_put_formname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FormName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_formname_method_cleanup;

    ipsdriver2_put_formname_method_cleanup:
    self->m_HR = hr;
    if (bsFormName)
        ::SysFreeString(bsFormName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_FormName");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_PrintableBounds(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppBounds = NULL;
    PyObject* py_ppBounds = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppBounds

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_PrintableBounds(&ipppBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_PrintableBounds() returned %ld", (long)hr);
        goto ipsdriver2_get_printablebounds_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppBounds);
    if (ipppBounds)
    {
        IUnknown* pUnk = NULL;
        ipppBounds->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBounds = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBounds)
    {
        if (py_ppBounds)
           Py_DECREF(py_ppBounds);
        py_ppBounds = Py_None;
        Py_INCREF(py_ppBounds);
    }
    if (PyErr_Occurred())
      goto ipsdriver2_get_printablebounds_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBounds);
    goto ipsdriver2_get_printablebounds_method_cleanup;

    ipsdriver2_get_printablebounds_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppBounds);
    if (ipppBounds)
      ipppBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_PrintableBounds");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_PrintableBounds(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppBounds = NULL;
    PyObject* py_ppBounds;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppBounds))
      goto ipsdriver2_put_printablebounds_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppBounds, &IID_IEnvelope, (void**)&ipppBounds))
        PyErr_SetString(PyExc_TypeError, "Argument ppBounds (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto ipsdriver2_put_printablebounds_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_PrintableBounds(ipppBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_PrintableBounds() returned %ld", (long)hr);
        goto ipsdriver2_put_printablebounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppBounds

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_printablebounds_method_cleanup;

    ipsdriver2_put_printablebounds_method_cleanup:
    self->m_HR = hr;
    if (ipppBounds)
      ipppBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_PrintableBounds");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_Orientation(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sOrientation = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Orientation

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_Orientation(&sOrientation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_Orientation() returned %ld", (long)hr);
        goto ipsdriver2_get_orientation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Orientation

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sOrientation);
    goto ipsdriver2_get_orientation_method_cleanup;

    ipsdriver2_get_orientation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Orientation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_Orientation");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_Orientation(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sOrientation = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sOrientation))
      goto ipsdriver2_put_orientation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Orientation

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_Orientation(sOrientation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_Orientation() returned %ld", (long)hr);
        goto ipsdriver2_put_orientation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Orientation

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_orientation_method_cleanup;

    ipsdriver2_put_orientation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Orientation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_Orientation");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_Emulsion(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverEmulsion eEmulsion;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Emulsion

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_Emulsion(&eEmulsion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_Emulsion() returned %ld", (long)hr);
        goto ipsdriver2_get_emulsion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Emulsion

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eEmulsion);
    goto ipsdriver2_get_emulsion_method_cleanup;

    ipsdriver2_get_emulsion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Emulsion
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_Emulsion");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_Emulsion(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverEmulsion eEmulsion;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eEmulsion))
      goto ipsdriver2_put_emulsion_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Emulsion

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_Emulsion(eEmulsion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_Emulsion() returned %ld", (long)hr);
        goto ipsdriver2_put_emulsion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Emulsion

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_emulsion_method_cleanup;

    ipsdriver2_put_emulsion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Emulsion
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_Emulsion");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_Image(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverImage eImage;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Image

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_Image(&eImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_Image() returned %ld", (long)hr);
        goto ipsdriver2_get_image_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Image

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eImage);
    goto ipsdriver2_get_image_method_cleanup;

    ipsdriver2_get_image_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Image
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_Image");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_Image(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverImage eImage;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eImage))
      goto ipsdriver2_put_image_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Image

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_Image(eImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_Image() returned %ld", (long)hr);
        goto ipsdriver2_put_image_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Image

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_image_method_cleanup;

    ipsdriver2_put_image_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Image
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_Image");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_OneBitImageTransparency(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_imageTransparency = VARIANT_FALSE;
    PyObject* pyvar_imageTransparency = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for imageTransparency

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_OneBitImageTransparency(&b_imageTransparency);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_OneBitImageTransparency() returned %ld", (long)hr);
        goto ipsdriver2_get_onebitimagetransparency_method_cleanup;
    }

    // Set up return values as needed
    pyvar_imageTransparency = ((b_imageTransparency == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipsdriver2_get_onebitimagetransparency_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_imageTransparency);
    goto ipsdriver2_get_onebitimagetransparency_method_cleanup;

    ipsdriver2_get_onebitimagetransparency_method_cleanup:
    self->m_HR = hr;
    // No cleanup for imageTransparency
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_OneBitImageTransparency");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_OneBitImageTransparency(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_imageTransparency = VARIANT_FALSE;
    PyObject* pyvar_imageTransparency = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_imageTransparency))
      goto ipsdriver2_put_onebitimagetransparency_method_cleanup;

    // Set up initial variable values as needed
    b_imageTransparency = ((PyObject_IsTrue(pyvar_imageTransparency) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ipsdriver2_put_onebitimagetransparency_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_OneBitImageTransparency(b_imageTransparency);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_OneBitImageTransparency() returned %ld", (long)hr);
        goto ipsdriver2_put_onebitimagetransparency_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for imageTransparency

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_onebitimagetransparency_method_cleanup;

    ipsdriver2_put_onebitimagetransparency_method_cleanup:
    self->m_HR = hr;
    // No cleanup for imageTransparency
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_OneBitImageTransparency");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_UseEMFFrameBoxForPSBoundingBox(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useFrameBox = VARIANT_FALSE;
    PyObject* pyvar_useFrameBox = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for useFrameBox

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_UseEMFFrameBoxForPSBoundingBox(&b_useFrameBox);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_UseEMFFrameBoxForPSBoundingBox() returned %ld", (long)hr);
        goto ipsdriver2_get_useemfframeboxforpsboundingbox_method_cleanup;
    }

    // Set up return values as needed
    pyvar_useFrameBox = ((b_useFrameBox == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipsdriver2_get_useemfframeboxforpsboundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_useFrameBox);
    goto ipsdriver2_get_useemfframeboxforpsboundingbox_method_cleanup;

    ipsdriver2_get_useemfframeboxforpsboundingbox_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useFrameBox
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_UseEMFFrameBoxForPSBoundingBox");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_UseEMFFrameBoxForPSBoundingBox(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useFrameBox = VARIANT_FALSE;
    PyObject* pyvar_useFrameBox = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_useFrameBox))
      goto ipsdriver2_put_useemfframeboxforpsboundingbox_method_cleanup;

    // Set up initial variable values as needed
    b_useFrameBox = ((PyObject_IsTrue(pyvar_useFrameBox) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ipsdriver2_put_useemfframeboxforpsboundingbox_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_UseEMFFrameBoxForPSBoundingBox(b_useFrameBox);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_UseEMFFrameBoxForPSBoundingBox() returned %ld", (long)hr);
        goto ipsdriver2_put_useemfframeboxforpsboundingbox_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for useFrameBox

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_useemfframeboxforpsboundingbox_method_cleanup;

    ipsdriver2_put_useemfframeboxforpsboundingbox_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useFrameBox
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_UseEMFFrameBoxForPSBoundingBox");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_get_PSLanguageLevel(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverPSLanguageLevel epslevel;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pslevel

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->get_PSLanguageLevel(&epslevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.get_PSLanguageLevel() returned %ld", (long)hr);
        goto ipsdriver2_get_pslanguagelevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pslevel

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epslevel);
    goto ipsdriver2_get_pslanguagelevel_method_cleanup;

    ipsdriver2_get_pslanguagelevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pslevel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.get_PSLanguageLevel");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_PSLanguageLevel(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPSDriverPSLanguageLevel epslevel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epslevel))
      goto ipsdriver2_put_pslanguagelevel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pslevel

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_PSLanguageLevel(epslevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_PSLanguageLevel() returned %ld", (long)hr);
        goto ipsdriver2_put_pslanguagelevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pslevel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_pslanguagelevel_method_cleanup;

    ipsdriver2_put_pslanguagelevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pslevel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_PSLanguageLevel");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_put_StepProgressor(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStepProgressor* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto ipsdriver2_put_stepprogressor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IStepProgressor, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IStepProgressor");
    
    if (PyErr_Occurred())
      goto ipsdriver2_put_stepprogressor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->put_StepProgressor(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.put_StepProgressor() returned %ld", (long)hr);
        goto ipsdriver2_put_stepprogressor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_put_stepprogressor_method_cleanup;

    ipsdriver2_put_stepprogressor_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.put_StepProgressor");
    return return_tuple;
}

static PyObject*
IPSDriver2Method_CreatePS(PyIPSDriver2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsInputFileName = 0;
    PyObject* pyvar_InputFileName;
    PyObject* unicodeInputFileName = NULL;
    BSTR bsOutputFileName = 0;
    PyObject* pyvar_OutputFileName;
    PyObject* unicodeOutputFileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_InputFileName, &pyvar_OutputFileName))
      goto ipsdriver2_createps_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_InputFileName))
        unicodeInputFileName = PyUnicode_FromObject(pyvar_InputFileName);
    else if (PyUnicode_Check(pyvar_InputFileName))
    {
        unicodeInputFileName = pyvar_InputFileName;
        Py_INCREF(unicodeInputFileName);
    }
    else if (pyvar_InputFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter InputFileName at index 0");
    if (unicodeInputFileName)
        bsInputFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeInputFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeInputFileName));
    
    if (PyErr_Occurred())
      goto ipsdriver2_createps_method_cleanup;
    
    if (PyString_Check(pyvar_OutputFileName))
        unicodeOutputFileName = PyUnicode_FromObject(pyvar_OutputFileName);
    else if (PyUnicode_Check(pyvar_OutputFileName))
    {
        unicodeOutputFileName = pyvar_OutputFileName;
        Py_INCREF(unicodeOutputFileName);
    }
    else if (pyvar_OutputFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter OutputFileName at index 1");
    if (unicodeOutputFileName)
        bsOutputFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeOutputFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeOutputFileName));
    
    if (PyErr_Occurred())
      goto ipsdriver2_createps_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPSDriver2->CreatePS(bsInputFileName, bsOutputFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPSDriver2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPSDriver2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPSDriver2.CreatePS() returned %ld", (long)hr);
        goto ipsdriver2_createps_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for InputFileName
    // No teardown for OutputFileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsdriver2_createps_method_cleanup;

    ipsdriver2_createps_method_cleanup:
    self->m_HR = hr;
    if (bsInputFileName)
        ::SysFreeString(bsInputFileName);
    
    if (bsOutputFileName)
        ::SysFreeString(bsOutputFileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPSDriver2.CreatePS");
    return return_tuple;
}


PyMethodDef PyIPSDriver2Methods[] = {
    {"supports", (PyCFunction)PyIPSDriver2_SupportsInterface, METH_O, ""},
    {"get_Copies", (PyCFunction)IPSDriver2Method_get_Copies, METH_VARARGS, ""},
    {"put_Copies", (PyCFunction)IPSDriver2Method_put_Copies, METH_VARARGS, ""},
    {"get_ImageCompression", (PyCFunction)IPSDriver2Method_get_ImageCompression, METH_VARARGS, ""},
    {"put_ImageCompression", (PyCFunction)IPSDriver2Method_put_ImageCompression, METH_VARARGS, ""},
    {"get_ArcPressSeparateImage", (PyCFunction)IPSDriver2Method_get_ArcPressSeparateImage, METH_VARARGS, ""},
    {"put_ArcPressSeparateImage", (PyCFunction)IPSDriver2Method_put_ArcPressSeparateImage, METH_VARARGS, ""},
    {"get_ArcPressSeparateImageRotate", (PyCFunction)IPSDriver2Method_get_ArcPressSeparateImageRotate, METH_VARARGS, ""},
    {"put_ArcPressSeparateImageRotate", (PyCFunction)IPSDriver2Method_put_ArcPressSeparateImageRotate, METH_VARARGS, ""},
    {"get_FontMapCollection", (PyCFunction)IPSDriver2Method_get_FontMapCollection, METH_VARARGS, ""},
    {"putref_FontMapCollection", (PyCFunction)IPSDriver2Method_putref_FontMapCollection, METH_VARARGS, ""},
    {"get_PPDFile", (PyCFunction)IPSDriver2Method_get_PPDFile, METH_VARARGS, ""},
    {"put_PPDFile", (PyCFunction)IPSDriver2Method_put_PPDFile, METH_VARARGS, ""},
    {"get_Marks", (PyCFunction)IPSDriver2Method_get_Marks, METH_VARARGS, ""},
    {"put_Marks", (PyCFunction)IPSDriver2Method_put_Marks, METH_VARARGS, ""},
    {"get_HalfTone", (PyCFunction)IPSDriver2Method_get_HalfTone, METH_VARARGS, ""},
    {"put_HalfTone", (PyCFunction)IPSDriver2Method_put_HalfTone, METH_VARARGS, ""},
    {"get_FormName", (PyCFunction)IPSDriver2Method_get_FormName, METH_VARARGS, ""},
    {"put_FormName", (PyCFunction)IPSDriver2Method_put_FormName, METH_VARARGS, ""},
    {"get_PrintableBounds", (PyCFunction)IPSDriver2Method_get_PrintableBounds, METH_VARARGS, ""},
    {"put_PrintableBounds", (PyCFunction)IPSDriver2Method_put_PrintableBounds, METH_VARARGS, ""},
    {"get_Orientation", (PyCFunction)IPSDriver2Method_get_Orientation, METH_VARARGS, ""},
    {"put_Orientation", (PyCFunction)IPSDriver2Method_put_Orientation, METH_VARARGS, ""},
    {"get_Emulsion", (PyCFunction)IPSDriver2Method_get_Emulsion, METH_VARARGS, ""},
    {"put_Emulsion", (PyCFunction)IPSDriver2Method_put_Emulsion, METH_VARARGS, ""},
    {"get_Image", (PyCFunction)IPSDriver2Method_get_Image, METH_VARARGS, ""},
    {"put_Image", (PyCFunction)IPSDriver2Method_put_Image, METH_VARARGS, ""},
    {"get_OneBitImageTransparency", (PyCFunction)IPSDriver2Method_get_OneBitImageTransparency, METH_VARARGS, ""},
    {"put_OneBitImageTransparency", (PyCFunction)IPSDriver2Method_put_OneBitImageTransparency, METH_VARARGS, ""},
    {"get_UseEMFFrameBoxForPSBoundingBox", (PyCFunction)IPSDriver2Method_get_UseEMFFrameBoxForPSBoundingBox, METH_VARARGS, ""},
    {"put_UseEMFFrameBoxForPSBoundingBox", (PyCFunction)IPSDriver2Method_put_UseEMFFrameBoxForPSBoundingBox, METH_VARARGS, ""},
    {"get_PSLanguageLevel", (PyCFunction)IPSDriver2Method_get_PSLanguageLevel, METH_VARARGS, ""},
    {"put_PSLanguageLevel", (PyCFunction)IPSDriver2Method_put_PSLanguageLevel, METH_VARARGS, ""},
    {"put_StepProgressor", (PyCFunction)IPSDriver2Method_put_StepProgressor, METH_VARARGS, ""},
    {"CreatePS", (PyCFunction)IPSDriver2Method_CreatePS, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPSDriver2GetSet[] = {
  {"_pUnk", (getter)PyIPSDriver2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPSDriver2", NULL},
  {"_pointer", (getter)PyIPSDriver2_GetPointer, NULL, "Get memory address for IPSDriver2", NULL},
  {"_IID", (getter)PyIPSDriver2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPSDriver2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPSDriver2_GetIgnoreFailures, (setter)PyIPSDriver2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPSDriver2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPSDriver2Object",                          
                                              /* tp_name */
  sizeof(PyIPSDriver2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPSDriver2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPSDriver2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPSDriver2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPSDriver2Object_new,                      
                                              /* tp_new */
};

// Interface IPsExporter

typedef struct PyIPsExporterObject {
    PyObject_HEAD
    IPsExporter* m_pIPsExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPsExporterObject;

static PyObject*
PyIPsExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPsExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPsExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPsExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPsExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPsExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPsExporter");
            return NULL;
        }
        self->m_pIPsExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPsExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPsExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPsExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPsExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPsExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPsExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPsExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPsExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPsExporterObject_dealloc(PyIPsExporterObject* self)
{
    if (self->m_pIPsExporter)
        self->m_pIPsExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPsExporter_GetpUnk(PyIPsExporterObject* self)
{
    if (!self->m_pIPsExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPsExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPsExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPsExporter_GetPointer(PyIPsExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPsExporter);
}

static PyObject*
PyIPsExporter_GetIID(PyIPsExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7d4881e6-57c6-11d1-945e-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPsExporter_GetHR(PyIPsExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPsExporter_GetIgnoreFailures(PyIPsExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPsExporter_SetIgnoreFailures(PyIPsExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPsExporter_SupportsInterface(PyIPsExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPsExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPsExporterMethod_QueryPSDriver(PyIPsExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPSDriver* ipPSDriver = NULL;
    PyObject* py_PSDriver = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for PSDriver

    // Call method on actual COM interface
    hr = self->m_pIPsExporter->QueryPSDriver(&ipPSDriver);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPsExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPsExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPsExporter.QueryPSDriver() returned %ld", (long)hr);
        goto ipsexporter_querypsdriver_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_PSDriver);
    if (ipPSDriver)
    {
        IUnknown* pUnk = NULL;
        ipPSDriver->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_PSDriver = IUnknownToPythonIIDObject(pUnk, &IID_IPSDriver);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_PSDriver)
    {
        if (py_PSDriver)
           Py_DECREF(py_PSDriver);
        py_PSDriver = Py_None;
        Py_INCREF(py_PSDriver);
    }
    if (PyErr_Occurred())
      goto ipsexporter_querypsdriver_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_PSDriver);
    goto ipsexporter_querypsdriver_method_cleanup;

    ipsexporter_querypsdriver_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_PSDriver);
    if (ipPSDriver)
      ipPSDriver->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPsExporter.QueryPSDriver");
    return return_tuple;
}


PyMethodDef PyIPsExporterMethods[] = {
    {"supports", (PyCFunction)PyIPsExporter_SupportsInterface, METH_O, ""},
    {"QueryPSDriver", (PyCFunction)IPsExporterMethod_QueryPSDriver, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPsExporterGetSet[] = {
  {"_pUnk", (getter)PyIPsExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPsExporter", NULL},
  {"_pointer", (getter)PyIPsExporter_GetPointer, NULL, "Get memory address for IPsExporter", NULL},
  {"_IID", (getter)PyIPsExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPsExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPsExporter_GetIgnoreFailures, (setter)PyIPsExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPsExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPsExporterObject",                          
                                              /* tp_name */
  sizeof(PyIPsExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPsExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPsExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPsExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPsExporterObject_new,                      
                                              /* tp_new */
};

// Interface IOutputPageOptionsAdmin

typedef struct PyIOutputPageOptionsAdminObject {
    PyObject_HEAD
    IOutputPageOptionsAdmin* m_pIOutputPageOptionsAdmin;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIOutputPageOptionsAdminObject;

static PyObject*
PyIOutputPageOptionsAdminObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIOutputPageOptionsAdminObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IOutputPageOptionsAdmin* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IOutputPageOptionsAdmin, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IOutputPageOptionsAdmin with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIOutputPageOptionsAdminObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IOutputPageOptionsAdmin");
            return NULL;
        }
        self->m_pIOutputPageOptionsAdmin = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IOutputPageOptionsAdmin");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IOutputPageOptionsAdmin");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IOutputPageOptionsAdmin* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IOutputPageOptionsAdmin, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IOutputPageOptionsAdmin");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIOutputPageOptionsAdminObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IOutputPageOptionsAdmin");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIOutputPageOptionsAdmin = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIOutputPageOptionsAdminObject_dealloc(PyIOutputPageOptionsAdminObject* self)
{
    if (self->m_pIOutputPageOptionsAdmin)
        self->m_pIOutputPageOptionsAdmin->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIOutputPageOptionsAdmin_GetpUnk(PyIOutputPageOptionsAdminObject* self)
{
    if (!self->m_pIOutputPageOptionsAdmin)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IOutputPageOptionsAdmin to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIOutputPageOptionsAdmin_GetPointer(PyIOutputPageOptionsAdminObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIOutputPageOptionsAdmin);
}

static PyObject*
PyIOutputPageOptionsAdmin_GetIID(PyIOutputPageOptionsAdminObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1f685f18-704a-4755-834f-4c0d67303a2f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIOutputPageOptionsAdmin_GetHR(PyIOutputPageOptionsAdminObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIOutputPageOptionsAdmin_GetIgnoreFailures(PyIOutputPageOptionsAdminObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIOutputPageOptionsAdmin_SetIgnoreFailures(PyIOutputPageOptionsAdminObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIOutputPageOptionsAdmin_SupportsInterface(PyIOutputPageOptionsAdminObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IOutputPageOptionsAdminMethod_get_OutputtingPageLayout(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_flag = VARIANT_FALSE;
    PyObject* pyvar_flag = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for flag

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->get_OutputtingPageLayout(&b_flag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.get_OutputtingPageLayout() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_get_outputtingpagelayout_method_cleanup;
    }

    // Set up return values as needed
    pyvar_flag = ((b_flag == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ioutputpageoptionsadmin_get_outputtingpagelayout_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_flag);
    goto ioutputpageoptionsadmin_get_outputtingpagelayout_method_cleanup;

    ioutputpageoptionsadmin_get_outputtingpagelayout_method_cleanup:
    self->m_HR = hr;
    // No cleanup for flag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.get_OutputtingPageLayout");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_put_OutputtingPageLayout(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_flag = VARIANT_FALSE;
    PyObject* pyvar_flag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_flag))
      goto ioutputpageoptionsadmin_put_outputtingpagelayout_method_cleanup;

    // Set up initial variable values as needed
    b_flag = ((PyObject_IsTrue(pyvar_flag) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ioutputpageoptionsadmin_put_outputtingpagelayout_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->put_OutputtingPageLayout(b_flag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.put_OutputtingPageLayout() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_put_outputtingpagelayout_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for flag

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioutputpageoptionsadmin_put_outputtingpagelayout_method_cleanup;

    ioutputpageoptionsadmin_put_outputtingpagelayout_method_cleanup:
    self->m_HR = hr;
    // No cleanup for flag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.put_OutputtingPageLayout");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_get_PageSelectionExists(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_flag = VARIANT_FALSE;
    PyObject* pyvar_flag = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for flag

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->get_PageSelectionExists(&b_flag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.get_PageSelectionExists() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_get_pageselectionexists_method_cleanup;
    }

    // Set up return values as needed
    pyvar_flag = ((b_flag == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ioutputpageoptionsadmin_get_pageselectionexists_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_flag);
    goto ioutputpageoptionsadmin_get_pageselectionexists_method_cleanup;

    ioutputpageoptionsadmin_get_pageselectionexists_method_cleanup:
    self->m_HR = hr;
    // No cleanup for flag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.get_PageSelectionExists");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_put_PageSelectionExists(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_flag = VARIANT_FALSE;
    PyObject* pyvar_flag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_flag))
      goto ioutputpageoptionsadmin_put_pageselectionexists_method_cleanup;

    // Set up initial variable values as needed
    b_flag = ((PyObject_IsTrue(pyvar_flag) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ioutputpageoptionsadmin_put_pageselectionexists_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->put_PageSelectionExists(b_flag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.put_PageSelectionExists() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_put_pageselectionexists_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for flag

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioutputpageoptionsadmin_put_pageselectionexists_method_cleanup;

    ioutputpageoptionsadmin_put_pageselectionexists_method_cleanup:
    self->m_HR = hr;
    // No cleanup for flag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.put_PageSelectionExists");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_get_PageCount(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->get_PageCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.get_PageCount() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_get_pagecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto ioutputpageoptionsadmin_get_pagecount_method_cleanup;

    ioutputpageoptionsadmin_get_pagecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.get_PageCount");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_put_PageCount(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lCount))
      goto ioutputpageoptionsadmin_put_pagecount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->put_PageCount(lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.put_PageCount() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_put_pagecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioutputpageoptionsadmin_put_pagecount_method_cleanup;

    ioutputpageoptionsadmin_put_pagecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.put_PageCount");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_get_SelectedPageCount(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->get_SelectedPageCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.get_SelectedPageCount() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_get_selectedpagecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto ioutputpageoptionsadmin_get_selectedpagecount_method_cleanup;

    ioutputpageoptionsadmin_get_selectedpagecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.get_SelectedPageCount");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_put_SelectedPageCount(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lCount))
      goto ioutputpageoptionsadmin_put_selectedpagecount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->put_SelectedPageCount(lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.put_SelectedPageCount() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_put_selectedpagecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioutputpageoptionsadmin_put_selectedpagecount_method_cleanup;

    ioutputpageoptionsadmin_put_selectedpagecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.put_SelectedPageCount");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_get_CurrentIndex(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->get_CurrentIndex(&lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.get_CurrentIndex() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_get_currentindex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lindex);
    goto ioutputpageoptionsadmin_get_currentindex_method_cleanup;

    ioutputpageoptionsadmin_get_currentindex_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.get_CurrentIndex");
    return return_tuple;
}

static PyObject*
IOutputPageOptionsAdminMethod_put_CurrentIndex(PyIOutputPageOptionsAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ioutputpageoptionsadmin_put_currentindex_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pIOutputPageOptionsAdmin->put_CurrentIndex(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOutputPageOptionsAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOutputPageOptionsAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOutputPageOptionsAdmin.put_CurrentIndex() returned %ld", (long)hr);
        goto ioutputpageoptionsadmin_put_currentindex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioutputpageoptionsadmin_put_currentindex_method_cleanup;

    ioutputpageoptionsadmin_put_currentindex_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOutputPageOptionsAdmin.put_CurrentIndex");
    return return_tuple;
}


PyMethodDef PyIOutputPageOptionsAdminMethods[] = {
    {"supports", (PyCFunction)PyIOutputPageOptionsAdmin_SupportsInterface, METH_O, ""},
    {"get_OutputtingPageLayout", (PyCFunction)IOutputPageOptionsAdminMethod_get_OutputtingPageLayout, METH_VARARGS, ""},
    {"put_OutputtingPageLayout", (PyCFunction)IOutputPageOptionsAdminMethod_put_OutputtingPageLayout, METH_VARARGS, ""},
    {"get_PageSelectionExists", (PyCFunction)IOutputPageOptionsAdminMethod_get_PageSelectionExists, METH_VARARGS, ""},
    {"put_PageSelectionExists", (PyCFunction)IOutputPageOptionsAdminMethod_put_PageSelectionExists, METH_VARARGS, ""},
    {"get_PageCount", (PyCFunction)IOutputPageOptionsAdminMethod_get_PageCount, METH_VARARGS, ""},
    {"put_PageCount", (PyCFunction)IOutputPageOptionsAdminMethod_put_PageCount, METH_VARARGS, ""},
    {"get_SelectedPageCount", (PyCFunction)IOutputPageOptionsAdminMethod_get_SelectedPageCount, METH_VARARGS, ""},
    {"put_SelectedPageCount", (PyCFunction)IOutputPageOptionsAdminMethod_put_SelectedPageCount, METH_VARARGS, ""},
    {"get_CurrentIndex", (PyCFunction)IOutputPageOptionsAdminMethod_get_CurrentIndex, METH_VARARGS, ""},
    {"put_CurrentIndex", (PyCFunction)IOutputPageOptionsAdminMethod_put_CurrentIndex, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIOutputPageOptionsAdminGetSet[] = {
  {"_pUnk", (getter)PyIOutputPageOptionsAdmin_GetpUnk, NULL, "Get opaque pointer to an Unknown from IOutputPageOptionsAdmin", NULL},
  {"_pointer", (getter)PyIOutputPageOptionsAdmin_GetPointer, NULL, "Get memory address for IOutputPageOptionsAdmin", NULL},
  {"_IID", (getter)PyIOutputPageOptionsAdmin_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIOutputPageOptionsAdmin_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIOutputPageOptionsAdmin_GetIgnoreFailures, (setter)PyIOutputPageOptionsAdmin_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIOutputPageOptionsAdminObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IOutputPageOptionsAdminObject",                          
                                              /* tp_name */
  sizeof(PyIOutputPageOptionsAdminObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIOutputPageOptionsAdminObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIOutputPageOptionsAdminMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIOutputPageOptionsAdminGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIOutputPageOptionsAdminObject_new,                      
                                              /* tp_new */
};

// Interface IPDFDriver

typedef struct PyIPDFDriverObject {
    PyObject_HEAD
    IPDFDriver* m_pIPDFDriver;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPDFDriverObject;

static PyObject*
PyIPDFDriverObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPDFDriverObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPDFDriver* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPDFDriver, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPDFDriver with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPDFDriverObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPDFDriver");
            return NULL;
        }
        self->m_pIPDFDriver = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPDFDriver");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPDFDriver");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPDFDriver* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPDFDriver, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPDFDriver");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPDFDriverObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPDFDriver");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPDFDriver = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPDFDriverObject_dealloc(PyIPDFDriverObject* self)
{
    if (self->m_pIPDFDriver)
        self->m_pIPDFDriver->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPDFDriver_GetpUnk(PyIPDFDriverObject* self)
{
    if (!self->m_pIPDFDriver)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPDFDriver->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPDFDriver to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPDFDriver_GetPointer(PyIPDFDriverObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPDFDriver);
}

static PyObject*
PyIPDFDriver_GetIID(PyIPDFDriverObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0201602d-1521-11d3-9f97-00c04f6bc8dd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPDFDriver_GetHR(PyIPDFDriverObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPDFDriver_GetIgnoreFailures(PyIPDFDriverObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPDFDriver_SetIgnoreFailures(PyIPDFDriverObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPDFDriver_SupportsInterface(PyIPDFDriverObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPDFDriver->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPDFDriverMethod_get_FontMapCollection(PyIPDFDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFontMapCollection* ipFontMapCollection = NULL;
    PyObject* py_FontMapCollection = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FontMapCollection

    // Call method on actual COM interface
    hr = self->m_pIPDFDriver->get_FontMapCollection(&ipFontMapCollection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPDFDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPDFDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPDFDriver.get_FontMapCollection() returned %ld", (long)hr);
        goto ipdfdriver_get_fontmapcollection_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_FontMapCollection);
    if (ipFontMapCollection)
    {
        IUnknown* pUnk = NULL;
        ipFontMapCollection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FontMapCollection = IUnknownToPythonIIDObject(pUnk, &IID_IFontMapCollection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FontMapCollection)
    {
        if (py_FontMapCollection)
           Py_DECREF(py_FontMapCollection);
        py_FontMapCollection = Py_None;
        Py_INCREF(py_FontMapCollection);
    }
    if (PyErr_Occurred())
      goto ipdfdriver_get_fontmapcollection_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FontMapCollection);
    goto ipdfdriver_get_fontmapcollection_method_cleanup;

    ipdfdriver_get_fontmapcollection_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_FontMapCollection);
    if (ipFontMapCollection)
      ipFontMapCollection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPDFDriver.get_FontMapCollection");
    return return_tuple;
}

static PyObject*
IPDFDriverMethod_putref_FontMapCollection(PyIPDFDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFontMapCollection* ipFontMapCollection = NULL;
    PyObject* py_FontMapCollection;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_FontMapCollection))
      goto ipdfdriver_putref_fontmapcollection_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_FontMapCollection, &IID_IFontMapCollection, (void**)&ipFontMapCollection))
        PyErr_SetString(PyExc_TypeError, "Argument FontMapCollection (position 0) is not IFontMapCollection");
    
    if (PyErr_Occurred())
      goto ipdfdriver_putref_fontmapcollection_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPDFDriver->putref_FontMapCollection(ipFontMapCollection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPDFDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPDFDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPDFDriver.putref_FontMapCollection() returned %ld", (long)hr);
        goto ipdfdriver_putref_fontmapcollection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FontMapCollection

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipdfdriver_putref_fontmapcollection_method_cleanup;

    ipdfdriver_putref_fontmapcollection_method_cleanup:
    self->m_HR = hr;
    if (ipFontMapCollection)
      ipFontMapCollection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPDFDriver.putref_FontMapCollection");
    return return_tuple;
}

static PyObject*
IPDFDriverMethod_CreatePDF(PyIPDFDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsInputFileName = 0;
    PyObject* pyvar_InputFileName;
    PyObject* unicodeInputFileName = NULL;
    BSTR bsOutputFileName = 0;
    PyObject* pyvar_OutputFileName;
    PyObject* unicodeOutputFileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_InputFileName, &pyvar_OutputFileName))
      goto ipdfdriver_createpdf_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_InputFileName))
        unicodeInputFileName = PyUnicode_FromObject(pyvar_InputFileName);
    else if (PyUnicode_Check(pyvar_InputFileName))
    {
        unicodeInputFileName = pyvar_InputFileName;
        Py_INCREF(unicodeInputFileName);
    }
    else if (pyvar_InputFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter InputFileName at index 0");
    if (unicodeInputFileName)
        bsInputFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeInputFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeInputFileName));
    
    if (PyErr_Occurred())
      goto ipdfdriver_createpdf_method_cleanup;
    
    if (PyString_Check(pyvar_OutputFileName))
        unicodeOutputFileName = PyUnicode_FromObject(pyvar_OutputFileName);
    else if (PyUnicode_Check(pyvar_OutputFileName))
    {
        unicodeOutputFileName = pyvar_OutputFileName;
        Py_INCREF(unicodeOutputFileName);
    }
    else if (pyvar_OutputFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter OutputFileName at index 1");
    if (unicodeOutputFileName)
        bsOutputFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeOutputFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeOutputFileName));
    
    if (PyErr_Occurred())
      goto ipdfdriver_createpdf_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPDFDriver->CreatePDF(bsInputFileName, bsOutputFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPDFDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPDFDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPDFDriver.CreatePDF() returned %ld", (long)hr);
        goto ipdfdriver_createpdf_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for InputFileName
    // No teardown for OutputFileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipdfdriver_createpdf_method_cleanup;

    ipdfdriver_createpdf_method_cleanup:
    self->m_HR = hr;
    if (bsInputFileName)
        ::SysFreeString(bsInputFileName);
    
    if (bsOutputFileName)
        ::SysFreeString(bsOutputFileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPDFDriver.CreatePDF");
    return return_tuple;
}


PyMethodDef PyIPDFDriverMethods[] = {
    {"supports", (PyCFunction)PyIPDFDriver_SupportsInterface, METH_O, ""},
    {"get_FontMapCollection", (PyCFunction)IPDFDriverMethod_get_FontMapCollection, METH_VARARGS, ""},
    {"putref_FontMapCollection", (PyCFunction)IPDFDriverMethod_putref_FontMapCollection, METH_VARARGS, ""},
    {"CreatePDF", (PyCFunction)IPDFDriverMethod_CreatePDF, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPDFDriverGetSet[] = {
  {"_pUnk", (getter)PyIPDFDriver_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPDFDriver", NULL},
  {"_pointer", (getter)PyIPDFDriver_GetPointer, NULL, "Get memory address for IPDFDriver", NULL},
  {"_IID", (getter)PyIPDFDriver_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPDFDriver_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPDFDriver_GetIgnoreFailures, (setter)PyIPDFDriver_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPDFDriverObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPDFDriverObject",                          
                                              /* tp_name */
  sizeof(PyIPDFDriverObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPDFDriverObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPDFDriverMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPDFDriverGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPDFDriverObject_new,                      
                                              /* tp_new */
};

// Interface IAIDriver

typedef struct PyIAIDriverObject {
    PyObject_HEAD
    IAIDriver* m_pIAIDriver;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAIDriverObject;

static PyObject*
PyIAIDriverObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAIDriverObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAIDriver* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAIDriver, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAIDriver with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAIDriverObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAIDriver");
            return NULL;
        }
        self->m_pIAIDriver = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAIDriver");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAIDriver");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAIDriver* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAIDriver, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAIDriver");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAIDriverObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAIDriver");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAIDriver = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAIDriverObject_dealloc(PyIAIDriverObject* self)
{
    if (self->m_pIAIDriver)
        self->m_pIAIDriver->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAIDriver_GetpUnk(PyIAIDriverObject* self)
{
    if (!self->m_pIAIDriver)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAIDriver->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAIDriver to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAIDriver_GetPointer(PyIAIDriverObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAIDriver);
}

static PyObject*
PyIAIDriver_GetIID(PyIAIDriverObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "9e790106-4047-4fb3-be12-8f29106a1f86");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAIDriver_GetHR(PyIAIDriverObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAIDriver_GetIgnoreFailures(PyIAIDriverObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAIDriver_SetIgnoreFailures(PyIAIDriverObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAIDriver_SupportsInterface(PyIAIDriverObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAIDriver->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAIDriverMethod_CreateAI(PyIAIDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsInputFileName = 0;
    PyObject* pyvar_InputFileName;
    PyObject* unicodeInputFileName = NULL;
    BSTR bsOutputFileName = 0;
    PyObject* pyvar_OutputFileName;
    PyObject* unicodeOutputFileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_InputFileName, &pyvar_OutputFileName))
      goto iaidriver_createai_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_InputFileName))
        unicodeInputFileName = PyUnicode_FromObject(pyvar_InputFileName);
    else if (PyUnicode_Check(pyvar_InputFileName))
    {
        unicodeInputFileName = pyvar_InputFileName;
        Py_INCREF(unicodeInputFileName);
    }
    else if (pyvar_InputFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter InputFileName at index 0");
    if (unicodeInputFileName)
        bsInputFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeInputFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeInputFileName));
    
    if (PyErr_Occurred())
      goto iaidriver_createai_method_cleanup;
    
    if (PyString_Check(pyvar_OutputFileName))
        unicodeOutputFileName = PyUnicode_FromObject(pyvar_OutputFileName);
    else if (PyUnicode_Check(pyvar_OutputFileName))
    {
        unicodeOutputFileName = pyvar_OutputFileName;
        Py_INCREF(unicodeOutputFileName);
    }
    else if (pyvar_OutputFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter OutputFileName at index 1");
    if (unicodeOutputFileName)
        bsOutputFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeOutputFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeOutputFileName));
    
    if (PyErr_Occurred())
      goto iaidriver_createai_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAIDriver->CreateAI(bsInputFileName, bsOutputFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAIDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAIDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAIDriver.CreateAI() returned %ld", (long)hr);
        goto iaidriver_createai_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for InputFileName
    // No teardown for OutputFileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iaidriver_createai_method_cleanup;

    iaidriver_createai_method_cleanup:
    self->m_HR = hr;
    if (bsInputFileName)
        ::SysFreeString(bsInputFileName);
    
    if (bsOutputFileName)
        ::SysFreeString(bsOutputFileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAIDriver.CreateAI");
    return return_tuple;
}

static PyObject*
IAIDriverMethod_get_AIDriverOptions(PyIAIDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAIDriverOptions eaiOptions;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for aiOptions

    // Call method on actual COM interface
    hr = self->m_pIAIDriver->get_AIDriverOptions(&eaiOptions);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAIDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAIDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAIDriver.get_AIDriverOptions() returned %ld", (long)hr);
        goto iaidriver_get_aidriveroptions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for aiOptions

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eaiOptions);
    goto iaidriver_get_aidriveroptions_method_cleanup;

    iaidriver_get_aidriveroptions_method_cleanup:
    self->m_HR = hr;
    // No cleanup for aiOptions
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAIDriver.get_AIDriverOptions");
    return return_tuple;
}

static PyObject*
IAIDriverMethod_put_AIDriverOptions(PyIAIDriverObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAIDriverOptions eaiOptions;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eaiOptions))
      goto iaidriver_put_aidriveroptions_method_cleanup;

    // Set up initial variable values as needed
    // No setup for aiOptions

    // Call method on actual COM interface
    hr = self->m_pIAIDriver->put_AIDriverOptions(eaiOptions);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAIDriver->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAIDriver) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAIDriver.put_AIDriverOptions() returned %ld", (long)hr);
        goto iaidriver_put_aidriveroptions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for aiOptions

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iaidriver_put_aidriveroptions_method_cleanup;

    iaidriver_put_aidriveroptions_method_cleanup:
    self->m_HR = hr;
    // No cleanup for aiOptions
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAIDriver.put_AIDriverOptions");
    return return_tuple;
}


PyMethodDef PyIAIDriverMethods[] = {
    {"supports", (PyCFunction)PyIAIDriver_SupportsInterface, METH_O, ""},
    {"CreateAI", (PyCFunction)IAIDriverMethod_CreateAI, METH_VARARGS, ""},
    {"get_AIDriverOptions", (PyCFunction)IAIDriverMethod_get_AIDriverOptions, METH_VARARGS, ""},
    {"put_AIDriverOptions", (PyCFunction)IAIDriverMethod_put_AIDriverOptions, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAIDriverGetSet[] = {
  {"_pUnk", (getter)PyIAIDriver_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAIDriver", NULL},
  {"_pointer", (getter)PyIAIDriver_GetPointer, NULL, "Get memory address for IAIDriver", NULL},
  {"_IID", (getter)PyIAIDriver_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAIDriver_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAIDriver_GetIgnoreFailures, (setter)PyIAIDriver_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAIDriverObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IAIDriverObject",                          
                                              /* tp_name */
  sizeof(PyIAIDriverObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAIDriverObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAIDriverMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAIDriverGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAIDriverObject_new,                      
                                              /* tp_new */
};

// Interface IAIExporter

typedef struct PyIAIExporterObject {
    PyObject_HEAD
    IAIExporter* m_pIAIExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAIExporterObject;

static PyObject*
PyIAIExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAIExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAIExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAIExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAIExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAIExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAIExporter");
            return NULL;
        }
        self->m_pIAIExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAIExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAIExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAIExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAIExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAIExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAIExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAIExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAIExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAIExporterObject_dealloc(PyIAIExporterObject* self)
{
    if (self->m_pIAIExporter)
        self->m_pIAIExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAIExporter_GetpUnk(PyIAIExporterObject* self)
{
    if (!self->m_pIAIExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAIExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAIExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAIExporter_GetPointer(PyIAIExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAIExporter);
}

static PyObject*
PyIAIExporter_GetIID(PyIAIExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "722a2714-cd07-4c68-b07a-86a8d7b925e3");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAIExporter_GetHR(PyIAIExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAIExporter_GetIgnoreFailures(PyIAIExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAIExporter_SetIgnoreFailures(PyIAIExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAIExporter_SupportsInterface(PyIAIExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAIExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAIExporterMethod_QueryAIDriver(PyIAIExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAIDriver* ipAIDriver = NULL;
    PyObject* py_AIDriver = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for AIDriver

    // Call method on actual COM interface
    hr = self->m_pIAIExporter->QueryAIDriver(&ipAIDriver);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAIExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAIExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAIExporter.QueryAIDriver() returned %ld", (long)hr);
        goto iaiexporter_queryaidriver_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_AIDriver);
    if (ipAIDriver)
    {
        IUnknown* pUnk = NULL;
        ipAIDriver->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_AIDriver = IUnknownToPythonIIDObject(pUnk, &IID_IAIDriver);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_AIDriver)
    {
        if (py_AIDriver)
           Py_DECREF(py_AIDriver);
        py_AIDriver = Py_None;
        Py_INCREF(py_AIDriver);
    }
    if (PyErr_Occurred())
      goto iaiexporter_queryaidriver_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_AIDriver);
    goto iaiexporter_queryaidriver_method_cleanup;

    iaiexporter_queryaidriver_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_AIDriver);
    if (ipAIDriver)
      ipAIDriver->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAIExporter.QueryAIDriver");
    return return_tuple;
}


PyMethodDef PyIAIExporterMethods[] = {
    {"supports", (PyCFunction)PyIAIExporter_SupportsInterface, METH_O, ""},
    {"QueryAIDriver", (PyCFunction)IAIExporterMethod_QueryAIDriver, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAIExporterGetSet[] = {
  {"_pUnk", (getter)PyIAIExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAIExporter", NULL},
  {"_pointer", (getter)PyIAIExporter_GetPointer, NULL, "Get memory address for IAIExporter", NULL},
  {"_IID", (getter)PyIAIExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAIExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAIExporter_GetIgnoreFailures, (setter)PyIAIExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAIExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IAIExporterObject",                          
                                              /* tp_name */
  sizeof(PyIAIExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAIExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAIExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAIExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAIExporterObject_new,                      
                                              /* tp_new */
};

// Interface IPaper

typedef struct PyIPaperObject {
    PyObject_HEAD
    IPaper* m_pIPaper;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPaperObject;

static PyObject*
PyIPaperObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPaperObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPaper* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPaper, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPaper with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPaperObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPaper");
            return NULL;
        }
        self->m_pIPaper = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPaper");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPaper");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPaper* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPaper, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPaper");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPaperObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPaper");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPaper = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPaperObject_dealloc(PyIPaperObject* self)
{
    if (self->m_pIPaper)
        self->m_pIPaper->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPaper_GetpUnk(PyIPaperObject* self)
{
    if (!self->m_pIPaper)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPaper->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPaper to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPaper_GetPointer(PyIPaperObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPaper);
}

static PyObject*
PyIPaper_GetIID(PyIPaperObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "387bc1d1-3f54-11d1-885e-0000f87808ee");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPaper_GetHR(PyIPaperObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPaper_GetIgnoreFailures(PyIPaperObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPaper_SetIgnoreFailures(PyIPaperObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPaper_SupportsInterface(PyIPaperObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPaperMethod_get_Units(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriUnits eUnits;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Units

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_Units(&eUnits);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_Units() returned %ld", (long)hr);
        goto ipaper_get_units_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Units

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eUnits);
    goto ipaper_get_units_method_cleanup;

    ipaper_get_units_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Units
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_Units");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_PrintableBounds(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipbounds = NULL;
    PyObject* py_bounds = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bounds

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_PrintableBounds(&ipbounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_PrintableBounds() returned %ld", (long)hr);
        goto ipaper_get_printablebounds_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_bounds);
    if (ipbounds)
    {
        IUnknown* pUnk = NULL;
        ipbounds->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_bounds = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_bounds)
    {
        if (py_bounds)
           Py_DECREF(py_bounds);
        py_bounds = Py_None;
        Py_INCREF(py_bounds);
    }
    if (PyErr_Occurred())
      goto ipaper_get_printablebounds_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_bounds);
    goto ipaper_get_printablebounds_method_cleanup;

    ipaper_get_printablebounds_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_bounds);
    if (ipbounds)
      ipbounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_PrintableBounds");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_Orientation(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sOrientation = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Orientation

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_Orientation(&sOrientation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_Orientation() returned %ld", (long)hr);
        goto ipaper_get_orientation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Orientation

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sOrientation);
    goto ipaper_get_orientation_method_cleanup;

    ipaper_get_orientation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Orientation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_Orientation");
    return return_tuple;
}

static PyObject*
IPaperMethod_put_Orientation(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sOrientation = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sOrientation))
      goto ipaper_put_orientation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Orientation

    // Call method on actual COM interface
    hr = self->m_pIPaper->put_Orientation(sOrientation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.put_Orientation() returned %ld", (long)hr);
        goto ipaper_put_orientation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Orientation

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipaper_put_orientation_method_cleanup;

    ipaper_put_orientation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Orientation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.put_Orientation");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_Forms(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumNamedID* ipForms = NULL;
    PyObject* py_Forms = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Forms

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_Forms(&ipForms);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_Forms() returned %ld", (long)hr);
        goto ipaper_get_forms_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Forms);
    if (ipForms)
    {
        IUnknown* pUnk = NULL;
        ipForms->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Forms = IUnknownToPythonIIDObject(pUnk, &IID_IEnumNamedID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Forms)
    {
        if (py_Forms)
           Py_DECREF(py_Forms);
        py_Forms = Py_None;
        Py_INCREF(py_Forms);
    }
    if (PyErr_Occurred())
      goto ipaper_get_forms_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Forms);
    goto ipaper_get_forms_method_cleanup;

    ipaper_get_forms_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Forms);
    if (ipForms)
      ipForms->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_Forms");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_FormName(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFormName;
    PyObject* pyvar_FormName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FormName

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_FormName(&bsFormName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_FormName() returned %ld", (long)hr);
        goto ipaper_get_formname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_FormName = PyUnicode_FromWideChar(bsFormName,::SysStringLen(bsFormName));
    ::SysFreeString(bsFormName);
    
    if (PyErr_Occurred())
      goto ipaper_get_formname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_FormName);
    goto ipaper_get_formname_method_cleanup;

    ipaper_get_formname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_FormName != Py_None)
        Py_XDECREF(pyvar_FormName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_FormName");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_FormID(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sFormID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FormID

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_FormID(&sFormID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_FormID() returned %ld", (long)hr);
        goto ipaper_get_formid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FormID

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sFormID);
    goto ipaper_get_formid_method_cleanup;

    ipaper_get_formid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FormID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_FormID");
    return return_tuple;
}

static PyObject*
IPaperMethod_put_FormID(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sFormID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sFormID))
      goto ipaper_put_formid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FormID

    // Call method on actual COM interface
    hr = self->m_pIPaper->put_FormID(sFormID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.put_FormID() returned %ld", (long)hr);
        goto ipaper_put_formid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FormID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipaper_put_formid_method_cleanup;

    ipaper_put_formid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FormID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.put_FormID");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_Trays(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumNamedID* ipTrays = NULL;
    PyObject* py_Trays = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Trays

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_Trays(&ipTrays);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_Trays() returned %ld", (long)hr);
        goto ipaper_get_trays_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Trays);
    if (ipTrays)
    {
        IUnknown* pUnk = NULL;
        ipTrays->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Trays = IUnknownToPythonIIDObject(pUnk, &IID_IEnumNamedID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Trays)
    {
        if (py_Trays)
           Py_DECREF(py_Trays);
        py_Trays = Py_None;
        Py_INCREF(py_Trays);
    }
    if (PyErr_Occurred())
      goto ipaper_get_trays_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Trays);
    goto ipaper_get_trays_method_cleanup;

    ipaper_get_trays_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Trays);
    if (ipTrays)
      ipTrays->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_Trays");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_TrayID(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sTrayID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for TrayID

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_TrayID(&sTrayID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_TrayID() returned %ld", (long)hr);
        goto ipaper_get_trayid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TrayID

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sTrayID);
    goto ipaper_get_trayid_method_cleanup;

    ipaper_get_trayid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for TrayID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_TrayID");
    return return_tuple;
}

static PyObject*
IPaperMethod_put_TrayID(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sTrayID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sTrayID))
      goto ipaper_put_trayid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for TrayID

    // Call method on actual COM interface
    hr = self->m_pIPaper->put_TrayID(sTrayID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.put_TrayID() returned %ld", (long)hr);
        goto ipaper_put_trayid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TrayID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipaper_put_trayid_method_cleanup;

    ipaper_put_trayid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for TrayID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.put_TrayID");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_PrinterName(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPrinterName;
    PyObject* pyvar_PrinterName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for PrinterName

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_PrinterName(&bsPrinterName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_PrinterName() returned %ld", (long)hr);
        goto ipaper_get_printername_method_cleanup;
    }

    // Set up return values as needed
    pyvar_PrinterName = PyUnicode_FromWideChar(bsPrinterName,::SysStringLen(bsPrinterName));
    ::SysFreeString(bsPrinterName);
    
    if (PyErr_Occurred())
      goto ipaper_get_printername_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_PrinterName);
    goto ipaper_get_printername_method_cleanup;

    ipaper_get_printername_method_cleanup:
    self->m_HR = hr;
    if (pyvar_PrinterName != Py_None)
        Py_XDECREF(pyvar_PrinterName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_PrinterName");
    return return_tuple;
}

static PyObject*
IPaperMethod_put_PrinterName(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPrinterName = 0;
    PyObject* pyvar_PrinterName;
    PyObject* unicodePrinterName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_PrinterName))
      goto ipaper_put_printername_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_PrinterName))
        unicodePrinterName = PyUnicode_FromObject(pyvar_PrinterName);
    else if (PyUnicode_Check(pyvar_PrinterName))
    {
        unicodePrinterName = pyvar_PrinterName;
        Py_INCREF(unicodePrinterName);
    }
    else if (pyvar_PrinterName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter PrinterName at index 0");
    if (unicodePrinterName)
        bsPrinterName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodePrinterName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodePrinterName));
    
    if (PyErr_Occurred())
      goto ipaper_put_printername_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPaper->put_PrinterName(bsPrinterName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.put_PrinterName() returned %ld", (long)hr);
        goto ipaper_put_printername_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PrinterName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipaper_put_printername_method_cleanup;

    ipaper_put_printername_method_cleanup:
    self->m_HR = hr;
    if (bsPrinterName)
        ::SysFreeString(bsPrinterName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.put_PrinterName");
    return return_tuple;
}

static PyObject*
IPaperMethod_Attach(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhDevMode = 0;
    OLE_HANDLE HhDevNames = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "II", &HhDevMode, &HhDevNames))
      goto ipaper_attach_method_cleanup;

    // Set up initial variable values as needed
    // No setup for hDevMode
    // No setup for hDevNames

    // Call method on actual COM interface
    hr = self->m_pIPaper->Attach(HhDevMode, HhDevNames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.Attach() returned %ld", (long)hr);
        goto ipaper_attach_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hDevMode
    // No teardown for hDevNames

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipaper_attach_method_cleanup;

    ipaper_attach_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hDevMode
    // No cleanup for hDevNames
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.Attach");
    return return_tuple;
}

static PyObject*
IPaperMethod_QueryPaperSize(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dWidth = 0;
    double dHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIPaper->QueryPaperSize(&dWidth, &dHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.QueryPaperSize() returned %ld", (long)hr);
        goto ipaper_querypapersize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("dd",
                                            dWidth, dHeight);
    goto ipaper_querypapersize_method_cleanup;

    ipaper_querypapersize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.QueryPaperSize");
    return return_tuple;
}

static PyObject*
IPaperMethod_get_PrinterInfo(PyIPaperObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhDevMode = 0;
    OLE_HANDLE HhDevNames = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hDevMode
    // No setup for hDevNames

    // Call method on actual COM interface
    hr = self->m_pIPaper->get_PrinterInfo(&HhDevMode, &HhDevNames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper.get_PrinterInfo() returned %ld", (long)hr);
        goto ipaper_get_printerinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hDevMode
    // No teardown for hDevNames

    // Initialize output tuple
    return_tuple = Py_BuildValue("II",
                                            HhDevMode, HhDevNames);
    goto ipaper_get_printerinfo_method_cleanup;

    ipaper_get_printerinfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hDevMode
    // No cleanup for hDevNames
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper.get_PrinterInfo");
    return return_tuple;
}


PyMethodDef PyIPaperMethods[] = {
    {"supports", (PyCFunction)PyIPaper_SupportsInterface, METH_O, ""},
    {"get_Units", (PyCFunction)IPaperMethod_get_Units, METH_VARARGS, ""},
    {"get_PrintableBounds", (PyCFunction)IPaperMethod_get_PrintableBounds, METH_VARARGS, ""},
    {"get_Orientation", (PyCFunction)IPaperMethod_get_Orientation, METH_VARARGS, ""},
    {"put_Orientation", (PyCFunction)IPaperMethod_put_Orientation, METH_VARARGS, ""},
    {"get_Forms", (PyCFunction)IPaperMethod_get_Forms, METH_VARARGS, ""},
    {"get_FormName", (PyCFunction)IPaperMethod_get_FormName, METH_VARARGS, ""},
    {"get_FormID", (PyCFunction)IPaperMethod_get_FormID, METH_VARARGS, ""},
    {"put_FormID", (PyCFunction)IPaperMethod_put_FormID, METH_VARARGS, ""},
    {"get_Trays", (PyCFunction)IPaperMethod_get_Trays, METH_VARARGS, ""},
    {"get_TrayID", (PyCFunction)IPaperMethod_get_TrayID, METH_VARARGS, ""},
    {"put_TrayID", (PyCFunction)IPaperMethod_put_TrayID, METH_VARARGS, ""},
    {"get_PrinterName", (PyCFunction)IPaperMethod_get_PrinterName, METH_VARARGS, ""},
    {"put_PrinterName", (PyCFunction)IPaperMethod_put_PrinterName, METH_VARARGS, ""},
    {"Attach", (PyCFunction)IPaperMethod_Attach, METH_VARARGS, ""},
    {"QueryPaperSize", (PyCFunction)IPaperMethod_QueryPaperSize, METH_VARARGS, ""},
    {"get_PrinterInfo", (PyCFunction)IPaperMethod_get_PrinterInfo, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPaperGetSet[] = {
  {"_pUnk", (getter)PyIPaper_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPaper", NULL},
  {"_pointer", (getter)PyIPaper_GetPointer, NULL, "Get memory address for IPaper", NULL},
  {"_IID", (getter)PyIPaper_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPaper_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPaper_GetIgnoreFailures, (setter)PyIPaper_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPaperObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPaperObject",                          
                                              /* tp_name */
  sizeof(PyIPaperObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPaperObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPaperMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPaperGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPaperObject_new,                      
                                              /* tp_new */
};

// Interface IPaper2

typedef struct PyIPaper2Object {
    PyObject_HEAD
    IPaper2* m_pIPaper2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPaper2Object;

static PyObject*
PyIPaper2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPaper2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPaper2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPaper2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPaper2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPaper2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPaper2");
            return NULL;
        }
        self->m_pIPaper2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPaper2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPaper2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPaper2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPaper2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPaper2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPaper2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPaper2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPaper2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPaper2Object_dealloc(PyIPaper2Object* self)
{
    if (self->m_pIPaper2)
        self->m_pIPaper2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPaper2_GetpUnk(PyIPaper2Object* self)
{
    if (!self->m_pIPaper2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPaper2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPaper2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPaper2_GetPointer(PyIPaper2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPaper2);
}

static PyObject*
PyIPaper2_GetIID(PyIPaper2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6a319332-d3e2-413a-97f4-f25ce438feda");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPaper2_GetHR(PyIPaper2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPaper2_GetIgnoreFailures(PyIPaper2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPaper2_SetIgnoreFailures(PyIPaper2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPaper2_SupportsInterface(PyIPaper2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPaper2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPaper2Method_get_Resolution(PyIPaper2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sResolution = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Resolution

    // Call method on actual COM interface
    hr = self->m_pIPaper2->get_Resolution(&sResolution);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaper2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaper2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaper2.get_Resolution() returned %ld", (long)hr);
        goto ipaper2_get_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Resolution

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sResolution);
    goto ipaper2_get_resolution_method_cleanup;

    ipaper2_get_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Resolution
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPaper2.get_Resolution");
    return return_tuple;
}


PyMethodDef PyIPaper2Methods[] = {
    {"supports", (PyCFunction)PyIPaper2_SupportsInterface, METH_O, ""},
    {"get_Resolution", (PyCFunction)IPaper2Method_get_Resolution, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPaper2GetSet[] = {
  {"_pUnk", (getter)PyIPaper2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPaper2", NULL},
  {"_pointer", (getter)PyIPaper2_GetPointer, NULL, "Get memory address for IPaper2", NULL},
  {"_IID", (getter)PyIPaper2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPaper2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPaper2_GetIgnoreFailures, (setter)PyIPaper2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPaper2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPaper2Object",                          
                                              /* tp_name */
  sizeof(PyIPaper2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPaper2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPaper2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPaper2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPaper2Object_new,                      
                                              /* tp_new */
};

// Interface IPrinter

typedef struct PyIPrinterObject {
    PyObject_HEAD
    IPrinter* m_pIPrinter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPrinterObject;

static PyObject*
PyIPrinterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPrinterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPrinter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPrinter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPrinter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPrinterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPrinter");
            return NULL;
        }
        self->m_pIPrinter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPrinter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPrinter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPrinter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPrinter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPrinter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPrinterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPrinter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPrinter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPrinterObject_dealloc(PyIPrinterObject* self)
{
    if (self->m_pIPrinter)
        self->m_pIPrinter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPrinter_GetpUnk(PyIPrinterObject* self)
{
    if (!self->m_pIPrinter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPrinter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPrinter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPrinter_GetPointer(PyIPrinterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPrinter);
}

static PyObject*
PyIPrinter_GetIID(PyIPrinterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2ab49820-9406-11d0-87ef-080009ec732a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPrinter_GetHR(PyIPrinterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPrinter_GetIgnoreFailures(PyIPrinterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPrinter_SetIgnoreFailures(PyIPrinterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPrinter_SupportsInterface(PyIPrinterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPrinterMethod_get_Name(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_Name() returned %ld", (long)hr);
        goto iprinter_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iprinter_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iprinter_get_name_method_cleanup;

    iprinter_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_Name");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_Filter(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFilter;
    PyObject* pyvar_Filter = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Filter

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_Filter(&bsFilter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_Filter() returned %ld", (long)hr);
        goto iprinter_get_filter_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Filter = PyUnicode_FromWideChar(bsFilter,::SysStringLen(bsFilter));
    ::SysFreeString(bsFilter);
    
    if (PyErr_Occurred())
      goto iprinter_get_filter_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Filter);
    goto iprinter_get_filter_method_cleanup;

    iprinter_get_filter_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Filter != Py_None)
        Py_XDECREF(pyvar_Filter);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_Filter");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_FileExtension(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_FileExtension(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_FileExtension() returned %ld", (long)hr);
        goto iprinter_get_fileextension_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iprinter_get_fileextension_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iprinter_get_fileextension_method_cleanup;

    iprinter_get_fileextension_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_FileExtension");
    return return_tuple;
}

static PyObject*
IPrinterMethod_put_PrintToFile(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iprinter_put_printtofile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iprinter_put_printtofile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPrinter->put_PrintToFile(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.put_PrintToFile() returned %ld", (long)hr);
        goto iprinter_put_printtofile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprinter_put_printtofile_method_cleanup;

    iprinter_put_printtofile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.put_PrintToFile");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_PrintToFile(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName;
    PyObject* pyvar_fileName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for fileName

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_PrintToFile(&bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_PrintToFile() returned %ld", (long)hr);
        goto iprinter_get_printtofile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_fileName = PyUnicode_FromWideChar(bsfileName,::SysStringLen(bsfileName));
    ::SysFreeString(bsfileName);
    
    if (PyErr_Occurred())
      goto iprinter_get_printtofile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_fileName);
    goto iprinter_get_printtofile_method_cleanup;

    iprinter_get_printtofile_method_cleanup:
    self->m_HR = hr;
    if (pyvar_fileName != Py_None)
        Py_XDECREF(pyvar_fileName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_PrintToFile");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_DriverName(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDriverName;
    PyObject* pyvar_DriverName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for DriverName

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_DriverName(&bsDriverName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_DriverName() returned %ld", (long)hr);
        goto iprinter_get_drivername_method_cleanup;
    }

    // Set up return values as needed
    pyvar_DriverName = PyUnicode_FromWideChar(bsDriverName,::SysStringLen(bsDriverName));
    ::SysFreeString(bsDriverName);
    
    if (PyErr_Occurred())
      goto iprinter_get_drivername_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_DriverName);
    goto iprinter_get_drivername_method_cleanup;

    iprinter_get_drivername_method_cleanup:
    self->m_HR = hr;
    if (pyvar_DriverName != Py_None)
        Py_XDECREF(pyvar_DriverName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_DriverName");
    return return_tuple;
}

static PyObject*
IPrinterMethod_put_SpoolFileName(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsSpoolFileName = 0;
    PyObject* pyvar_SpoolFileName;
    PyObject* unicodeSpoolFileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_SpoolFileName))
      goto iprinter_put_spoolfilename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_SpoolFileName))
        unicodeSpoolFileName = PyUnicode_FromObject(pyvar_SpoolFileName);
    else if (PyUnicode_Check(pyvar_SpoolFileName))
    {
        unicodeSpoolFileName = pyvar_SpoolFileName;
        Py_INCREF(unicodeSpoolFileName);
    }
    else if (pyvar_SpoolFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter SpoolFileName at index 0");
    if (unicodeSpoolFileName)
        bsSpoolFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeSpoolFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeSpoolFileName));
    
    if (PyErr_Occurred())
      goto iprinter_put_spoolfilename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPrinter->put_SpoolFileName(bsSpoolFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.put_SpoolFileName() returned %ld", (long)hr);
        goto iprinter_put_spoolfilename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SpoolFileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprinter_put_spoolfilename_method_cleanup;

    iprinter_put_spoolfilename_method_cleanup:
    self->m_HR = hr;
    if (bsSpoolFileName)
        ::SysFreeString(bsSpoolFileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.put_SpoolFileName");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_SpoolFileName(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsSpoolFileName;
    PyObject* pyvar_SpoolFileName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SpoolFileName

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_SpoolFileName(&bsSpoolFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_SpoolFileName() returned %ld", (long)hr);
        goto iprinter_get_spoolfilename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_SpoolFileName = PyUnicode_FromWideChar(bsSpoolFileName,::SysStringLen(bsSpoolFileName));
    ::SysFreeString(bsSpoolFileName);
    
    if (PyErr_Occurred())
      goto iprinter_get_spoolfilename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_SpoolFileName);
    goto iprinter_get_spoolfilename_method_cleanup;

    iprinter_get_spoolfilename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_SpoolFileName != Py_None)
        Py_XDECREF(pyvar_SpoolFileName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_SpoolFileName");
    return return_tuple;
}

static PyObject*
IPrinterMethod_put_Resolution(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sres = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sres))
      goto iprinter_put_resolution_method_cleanup;

    // Set up initial variable values as needed
    // No setup for res

    // Call method on actual COM interface
    hr = self->m_pIPrinter->put_Resolution(sres);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.put_Resolution() returned %ld", (long)hr);
        goto iprinter_put_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for res

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprinter_put_resolution_method_cleanup;

    iprinter_put_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for res
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.put_Resolution");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_Resolution(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sres = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for res

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_Resolution(&sres);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_Resolution() returned %ld", (long)hr);
        goto iprinter_get_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for res

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sres);
    goto iprinter_get_resolution_method_cleanup;

    iprinter_get_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for res
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_Resolution");
    return return_tuple;
}

static PyObject*
IPrinterMethod_put_StepProgressor(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStepProgressor* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto iprinter_put_stepprogressor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IStepProgressor, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IStepProgressor");
    
    if (PyErr_Occurred())
      goto iprinter_put_stepprogressor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPrinter->put_StepProgressor(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.put_StepProgressor() returned %ld", (long)hr);
        goto iprinter_put_stepprogressor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprinter_put_stepprogressor_method_cleanup;

    iprinter_put_stepprogressor_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.put_StepProgressor");
    return return_tuple;
}

static PyObject*
IPrinterMethod_putref_Paper(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPaper* ipPaper = NULL;
    PyObject* py_Paper;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Paper))
      goto iprinter_putref_paper_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Paper, &IID_IPaper, (void**)&ipPaper))
        PyErr_SetString(PyExc_TypeError, "Argument Paper (position 0) is not IPaper");
    
    if (PyErr_Occurred())
      goto iprinter_putref_paper_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPrinter->putref_Paper(ipPaper);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.putref_Paper() returned %ld", (long)hr);
        goto iprinter_putref_paper_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Paper

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprinter_putref_paper_method_cleanup;

    iprinter_putref_paper_method_cleanup:
    self->m_HR = hr;
    if (ipPaper)
      ipPaper->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.putref_Paper");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_Paper(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPaper* ipPaper = NULL;
    PyObject* py_Paper = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Paper

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_Paper(&ipPaper);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_Paper() returned %ld", (long)hr);
        goto iprinter_get_paper_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Paper);
    if (ipPaper)
    {
        IUnknown* pUnk = NULL;
        ipPaper->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Paper = IUnknownToPythonIIDObject(pUnk, &IID_IPaper);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Paper)
    {
        if (py_Paper)
           Py_DECREF(py_Paper);
        py_Paper = Py_None;
        Py_INCREF(py_Paper);
    }
    if (PyErr_Occurred())
      goto iprinter_get_paper_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Paper);
    goto iprinter_get_paper_method_cleanup;

    iprinter_get_paper_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Paper);
    if (ipPaper)
      ipPaper->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_Paper");
    return return_tuple;
}

static PyObject*
IPrinterMethod_QueryPaperSize(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dWidth = 0;
    double dHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIPrinter->QueryPaperSize(&dWidth, &dHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.QueryPaperSize() returned %ld", (long)hr);
        goto iprinter_querypapersize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("dd",
                                            dWidth, dHeight);
    goto iprinter_querypapersize_method_cleanup;

    iprinter_querypapersize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.QueryPaperSize");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_PrintableBounds(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipbounds = NULL;
    PyObject* py_bounds = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bounds

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_PrintableBounds(&ipbounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_PrintableBounds() returned %ld", (long)hr);
        goto iprinter_get_printablebounds_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_bounds);
    if (ipbounds)
    {
        IUnknown* pUnk = NULL;
        ipbounds->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_bounds = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_bounds)
    {
        if (py_bounds)
           Py_DECREF(py_bounds);
        py_bounds = Py_None;
        Py_INCREF(py_bounds);
    }
    if (PyErr_Occurred())
      goto iprinter_get_printablebounds_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_bounds);
    goto iprinter_get_printablebounds_method_cleanup;

    iprinter_get_printablebounds_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_bounds);
    if (ipbounds)
      ipbounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_PrintableBounds");
    return return_tuple;
}

static PyObject*
IPrinterMethod_get_Units(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriUnits eUnits;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Units

    // Call method on actual COM interface
    hr = self->m_pIPrinter->get_Units(&eUnits);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.get_Units() returned %ld", (long)hr);
        goto iprinter_get_units_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Units

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eUnits);
    goto iprinter_get_units_method_cleanup;

    iprinter_get_units_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Units
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.get_Units");
    return return_tuple;
}

static PyObject*
IPrinterMethod_VerifyDriverSettings(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_ok = VARIANT_FALSE;
    PyObject* pyvar_ok = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ok

    // Call method on actual COM interface
    hr = self->m_pIPrinter->VerifyDriverSettings(&b_ok);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.VerifyDriverSettings() returned %ld", (long)hr);
        goto iprinter_verifydriversettings_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ok = ((b_ok == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iprinter_verifydriversettings_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ok);
    goto iprinter_verifydriversettings_method_cleanup;

    iprinter_verifydriversettings_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ok
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.VerifyDriverSettings");
    return return_tuple;
}

static PyObject*
IPrinterMethod_DoesDriverSupportPrinter(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPrinterName = 0;
    PyObject* pyvar_PrinterName;
    PyObject* unicodePrinterName = NULL;
    VARIANT_BOOL b_supported = VARIANT_FALSE;
    PyObject* pyvar_supported = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_PrinterName))
      goto iprinter_doesdriversupportprinter_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_PrinterName))
        unicodePrinterName = PyUnicode_FromObject(pyvar_PrinterName);
    else if (PyUnicode_Check(pyvar_PrinterName))
    {
        unicodePrinterName = pyvar_PrinterName;
        Py_INCREF(unicodePrinterName);
    }
    else if (pyvar_PrinterName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter PrinterName at index 0");
    if (unicodePrinterName)
        bsPrinterName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodePrinterName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodePrinterName));
    
    if (PyErr_Occurred())
      goto iprinter_doesdriversupportprinter_method_cleanup;
    
    // No setup for supported

    // Call method on actual COM interface
    hr = self->m_pIPrinter->DoesDriverSupportPrinter(bsPrinterName, &b_supported);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.DoesDriverSupportPrinter() returned %ld", (long)hr);
        goto iprinter_doesdriversupportprinter_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PrinterName
    pyvar_supported = ((b_supported == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iprinter_doesdriversupportprinter_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_supported);
    goto iprinter_doesdriversupportprinter_method_cleanup;

    iprinter_doesdriversupportprinter_method_cleanup:
    self->m_HR = hr;
    if (bsPrinterName)
        ::SysFreeString(bsPrinterName);
    
    // No cleanup for supported
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.DoesDriverSupportPrinter");
    return return_tuple;
}

static PyObject*
IPrinterMethod_StartPrinting(PyIPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipPixelBounds = NULL;
    PyObject* py_PixelBounds;
    OLE_HANDLE HhDcPrinter = 0;
    OLE_HANDLE HhDcRet = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &py_PixelBounds, &HhDcPrinter))
      goto iprinter_startprinting_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_PixelBounds, &IID_IEnvelope, (void**)&ipPixelBounds))
        PyErr_SetString(PyExc_TypeError, "Argument PixelBounds (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iprinter_startprinting_method_cleanup;
    
    // No setup for hDcPrinter
    // No setup for hDcRet

    // Call method on actual COM interface
    hr = self->m_pIPrinter->StartPrinting(ipPixelBounds, HhDcPrinter, &HhDcRet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.StartPrinting() returned %ld", (long)hr);
        goto iprinter_startprinting_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PixelBounds
    // No teardown for hDcPrinter
    // No teardown for hDcRet

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhDcRet);
    goto iprinter_startprinting_method_cleanup;

    iprinter_startprinting_method_cleanup:
    self->m_HR = hr;
    if (ipPixelBounds)
      ipPixelBounds->Release();
    // No cleanup for hDcPrinter
    // No cleanup for hDcRet
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinter.StartPrinting");
    return return_tuple;
}

static PyObject*
IPrinterMethod_FinishPrinting(PyIPrinterObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIPrinter->FinishPrinting();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinter.FinishPrinting() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIPrinterMethods[] = {
    {"supports", (PyCFunction)PyIPrinter_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IPrinterMethod_get_Name, METH_VARARGS, ""},
    {"get_Filter", (PyCFunction)IPrinterMethod_get_Filter, METH_VARARGS, ""},
    {"get_FileExtension", (PyCFunction)IPrinterMethod_get_FileExtension, METH_VARARGS, ""},
    {"put_PrintToFile", (PyCFunction)IPrinterMethod_put_PrintToFile, METH_VARARGS, ""},
    {"get_PrintToFile", (PyCFunction)IPrinterMethod_get_PrintToFile, METH_VARARGS, ""},
    {"get_DriverName", (PyCFunction)IPrinterMethod_get_DriverName, METH_VARARGS, ""},
    {"put_SpoolFileName", (PyCFunction)IPrinterMethod_put_SpoolFileName, METH_VARARGS, ""},
    {"get_SpoolFileName", (PyCFunction)IPrinterMethod_get_SpoolFileName, METH_VARARGS, ""},
    {"put_Resolution", (PyCFunction)IPrinterMethod_put_Resolution, METH_VARARGS, ""},
    {"get_Resolution", (PyCFunction)IPrinterMethod_get_Resolution, METH_VARARGS, ""},
    {"put_StepProgressor", (PyCFunction)IPrinterMethod_put_StepProgressor, METH_VARARGS, ""},
    {"putref_Paper", (PyCFunction)IPrinterMethod_putref_Paper, METH_VARARGS, ""},
    {"get_Paper", (PyCFunction)IPrinterMethod_get_Paper, METH_VARARGS, ""},
    {"QueryPaperSize", (PyCFunction)IPrinterMethod_QueryPaperSize, METH_VARARGS, ""},
    {"get_PrintableBounds", (PyCFunction)IPrinterMethod_get_PrintableBounds, METH_VARARGS, ""},
    {"get_Units", (PyCFunction)IPrinterMethod_get_Units, METH_VARARGS, ""},
    {"VerifyDriverSettings", (PyCFunction)IPrinterMethod_VerifyDriverSettings, METH_VARARGS, ""},
    {"DoesDriverSupportPrinter", (PyCFunction)IPrinterMethod_DoesDriverSupportPrinter, METH_VARARGS, ""},
    {"StartPrinting", (PyCFunction)IPrinterMethod_StartPrinting, METH_VARARGS, ""},
    {"FinishPrinting", (PyCFunction)IPrinterMethod_FinishPrinting, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPrinterGetSet[] = {
  {"_pUnk", (getter)PyIPrinter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPrinter", NULL},
  {"_pointer", (getter)PyIPrinter_GetPointer, NULL, "Get memory address for IPrinter", NULL},
  {"_IID", (getter)PyIPrinter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPrinter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPrinter_GetIgnoreFailures, (setter)PyIPrinter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPrinterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPrinterObject",                          
                                              /* tp_name */
  sizeof(PyIPrinterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPrinterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPrinterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPrinterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPrinterObject_new,                      
                                              /* tp_new */
};

// Interface IPrinterMPage

typedef struct PyIPrinterMPageObject {
    PyObject_HEAD
    IPrinterMPage* m_pIPrinterMPage;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPrinterMPageObject;

static PyObject*
PyIPrinterMPageObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPrinterMPageObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPrinterMPage* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPrinterMPage, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPrinterMPage with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPrinterMPageObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPrinterMPage");
            return NULL;
        }
        self->m_pIPrinterMPage = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPrinterMPage");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPrinterMPage");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPrinterMPage* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPrinterMPage, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPrinterMPage");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPrinterMPageObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPrinterMPage");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPrinterMPage = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPrinterMPageObject_dealloc(PyIPrinterMPageObject* self)
{
    if (self->m_pIPrinterMPage)
        self->m_pIPrinterMPage->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPrinterMPage_GetpUnk(PyIPrinterMPageObject* self)
{
    if (!self->m_pIPrinterMPage)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPrinterMPage->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPrinterMPage to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPrinterMPage_GetPointer(PyIPrinterMPageObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPrinterMPage);
}

static PyObject*
PyIPrinterMPage_GetIID(PyIPrinterMPageObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4004040c-a184-4c77-ba78-0475d93a3803");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPrinterMPage_GetHR(PyIPrinterMPageObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPrinterMPage_GetIgnoreFailures(PyIPrinterMPageObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPrinterMPage_SetIgnoreFailures(PyIPrinterMPageObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPrinterMPage_SupportsInterface(PyIPrinterMPageObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPrinterMPage->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPrinterMPageMethod_StartMapDocument(PyIPrinterMPageObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIPrinterMPage->StartMapDocument();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinterMPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinterMPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinterMPage.StartMapDocument() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IPrinterMPageMethod_StartPage(PyIPrinterMPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipPixelBounds = NULL;
    PyObject* py_PixelBounds;
    OLE_HANDLE HhDcPrinter = 0;
    OLE_HANDLE HhDcRet = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &py_PixelBounds, &HhDcPrinter))
      goto iprintermpage_startpage_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_PixelBounds, &IID_IEnvelope, (void**)&ipPixelBounds))
        PyErr_SetString(PyExc_TypeError, "Argument PixelBounds (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iprintermpage_startpage_method_cleanup;
    
    // No setup for hDcPrinter
    // No setup for hDcRet

    // Call method on actual COM interface
    hr = self->m_pIPrinterMPage->StartPage(ipPixelBounds, HhDcPrinter, &HhDcRet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinterMPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinterMPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinterMPage.StartPage() returned %ld", (long)hr);
        goto iprintermpage_startpage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PixelBounds
    // No teardown for hDcPrinter
    // No teardown for hDcRet

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhDcRet);
    goto iprintermpage_startpage_method_cleanup;

    iprintermpage_startpage_method_cleanup:
    self->m_HR = hr;
    if (ipPixelBounds)
      ipPixelBounds->Release();
    // No cleanup for hDcPrinter
    // No cleanup for hDcRet
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPrinterMPage.StartPage");
    return return_tuple;
}

static PyObject*
IPrinterMPageMethod_EndPage(PyIPrinterMPageObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIPrinterMPage->EndPage();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinterMPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinterMPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinterMPage.EndPage() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IPrinterMPageMethod_EndMapDocument(PyIPrinterMPageObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIPrinterMPage->EndMapDocument();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPrinterMPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPrinterMPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPrinterMPage.EndMapDocument() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIPrinterMPageMethods[] = {
    {"supports", (PyCFunction)PyIPrinterMPage_SupportsInterface, METH_O, ""},
    {"StartMapDocument", (PyCFunction)IPrinterMPageMethod_StartMapDocument, METH_NOARGS, ""},
    {"StartPage", (PyCFunction)IPrinterMPageMethod_StartPage, METH_VARARGS, ""},
    {"EndPage", (PyCFunction)IPrinterMPageMethod_EndPage, METH_NOARGS, ""},
    {"EndMapDocument", (PyCFunction)IPrinterMPageMethod_EndMapDocument, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPrinterMPageGetSet[] = {
  {"_pUnk", (getter)PyIPrinterMPage_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPrinterMPage", NULL},
  {"_pointer", (getter)PyIPrinterMPage_GetPointer, NULL, "Get memory address for IPrinterMPage", NULL},
  {"_IID", (getter)PyIPrinterMPage_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPrinterMPage_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPrinterMPage_GetIgnoreFailures, (setter)PyIPrinterMPage_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPrinterMPageObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPrinterMPageObject",                          
                                              /* tp_name */
  sizeof(PyIPrinterMPageObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPrinterMPageObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPrinterMPageMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPrinterMPageGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPrinterMPageObject_new,                      
                                              /* tp_new */
};

// Interface IPsPrinter

typedef struct PyIPsPrinterObject {
    PyObject_HEAD
    IPsPrinter* m_pIPsPrinter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPsPrinterObject;

static PyObject*
PyIPsPrinterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPsPrinterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPsPrinter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPsPrinter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPsPrinter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPsPrinterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPsPrinter");
            return NULL;
        }
        self->m_pIPsPrinter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPsPrinter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPsPrinter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPsPrinter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPsPrinter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPsPrinter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPsPrinterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPsPrinter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPsPrinter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPsPrinterObject_dealloc(PyIPsPrinterObject* self)
{
    if (self->m_pIPsPrinter)
        self->m_pIPsPrinter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPsPrinter_GetpUnk(PyIPsPrinterObject* self)
{
    if (!self->m_pIPsPrinter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPsPrinter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPsPrinter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPsPrinter_GetPointer(PyIPsPrinterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPsPrinter);
}

static PyObject*
PyIPsPrinter_GetIID(PyIPsPrinterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "de6dcd82-3f54-11d1-885e-0000f87808ee");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPsPrinter_GetHR(PyIPsPrinterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPsPrinter_GetIgnoreFailures(PyIPsPrinterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPsPrinter_SetIgnoreFailures(PyIPsPrinterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPsPrinter_SupportsInterface(PyIPsPrinterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPsPrinter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPsPrinterMethod_put_PPDFile(PyIPsPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPPDFile = 0;
    PyObject* pyvar_PPDFile;
    PyObject* unicodePPDFile = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_PPDFile))
      goto ipsprinter_put_ppdfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_PPDFile))
        unicodePPDFile = PyUnicode_FromObject(pyvar_PPDFile);
    else if (PyUnicode_Check(pyvar_PPDFile))
    {
        unicodePPDFile = pyvar_PPDFile;
        Py_INCREF(unicodePPDFile);
    }
    else if (pyvar_PPDFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter PPDFile at index 0");
    if (unicodePPDFile)
        bsPPDFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodePPDFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodePPDFile));
    
    if (PyErr_Occurred())
      goto ipsprinter_put_ppdfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPsPrinter->put_PPDFile(bsPPDFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPsPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPsPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPsPrinter.put_PPDFile() returned %ld", (long)hr);
        goto ipsprinter_put_ppdfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PPDFile

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipsprinter_put_ppdfile_method_cleanup;

    ipsprinter_put_ppdfile_method_cleanup:
    self->m_HR = hr;
    if (bsPPDFile)
        ::SysFreeString(bsPPDFile);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPsPrinter.put_PPDFile");
    return return_tuple;
}

static PyObject*
IPsPrinterMethod_get_PPDFile(PyIPsPrinterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPPDFile;
    PyObject* pyvar_PPDFile = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for PPDFile

    // Call method on actual COM interface
    hr = self->m_pIPsPrinter->get_PPDFile(&bsPPDFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPsPrinter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPsPrinter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPsPrinter.get_PPDFile() returned %ld", (long)hr);
        goto ipsprinter_get_ppdfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_PPDFile = PyUnicode_FromWideChar(bsPPDFile,::SysStringLen(bsPPDFile));
    ::SysFreeString(bsPPDFile);
    
    if (PyErr_Occurred())
      goto ipsprinter_get_ppdfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_PPDFile);
    goto ipsprinter_get_ppdfile_method_cleanup;

    ipsprinter_get_ppdfile_method_cleanup:
    self->m_HR = hr;
    if (pyvar_PPDFile != Py_None)
        Py_XDECREF(pyvar_PPDFile);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPsPrinter.get_PPDFile");
    return return_tuple;
}


PyMethodDef PyIPsPrinterMethods[] = {
    {"supports", (PyCFunction)PyIPsPrinter_SupportsInterface, METH_O, ""},
    {"put_PPDFile", (PyCFunction)IPsPrinterMethod_put_PPDFile, METH_VARARGS, ""},
    {"get_PPDFile", (PyCFunction)IPsPrinterMethod_get_PPDFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPsPrinterGetSet[] = {
  {"_pUnk", (getter)PyIPsPrinter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPsPrinter", NULL},
  {"_pointer", (getter)PyIPsPrinter_GetPointer, NULL, "Get memory address for IPsPrinter", NULL},
  {"_IID", (getter)PyIPsPrinter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPsPrinter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPsPrinter_GetIgnoreFailures, (setter)PyIPsPrinter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPsPrinterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IPsPrinterObject",                          
                                              /* tp_name */
  sizeof(PyIPsPrinterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPsPrinterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPsPrinterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPsPrinterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPsPrinterObject_new,                      
                                              /* tp_new */
};

// Interface IExport

typedef struct PyIExportObject {
    PyObject_HEAD
    IExport* m_pIExport;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportObject;

static PyObject*
PyIExportObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExport* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExport, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExport with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExport");
            return NULL;
        }
        self->m_pIExport = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExport");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExport");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExport* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExport, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExport");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExport");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExport = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportObject_dealloc(PyIExportObject* self)
{
    if (self->m_pIExport)
        self->m_pIExport->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExport_GetpUnk(PyIExportObject* self)
{
    if (!self->m_pIExport)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExport->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExport to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExport_GetPointer(PyIExportObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExport);
}

static PyObject*
PyIExport_GetIID(PyIExportObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "55c11165-0c2d-4e2d-afea-10b4186c4364");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExport_GetHR(PyIExportObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExport_GetIgnoreFailures(PyIExportObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExport_SetIgnoreFailures(PyIExportObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExport_SupportsInterface(PyIExportObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportMethod_get_Name(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIExport->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.get_Name() returned %ld", (long)hr);
        goto iexport_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iexport_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iexport_get_name_method_cleanup;

    iexport_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.get_Name");
    return return_tuple;
}

static PyObject*
IExportMethod_get_Filter(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFilter;
    PyObject* pyvar_Filter = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Filter

    // Call method on actual COM interface
    hr = self->m_pIExport->get_Filter(&bsFilter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.get_Filter() returned %ld", (long)hr);
        goto iexport_get_filter_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Filter = PyUnicode_FromWideChar(bsFilter,::SysStringLen(bsFilter));
    ::SysFreeString(bsFilter);
    
    if (PyErr_Occurred())
      goto iexport_get_filter_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Filter);
    goto iexport_get_filter_method_cleanup;

    iexport_get_filter_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Filter != Py_None)
        Py_XDECREF(pyvar_Filter);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.get_Filter");
    return return_tuple;
}

static PyObject*
IExportMethod_get_Priority(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpPriority = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPriority

    // Call method on actual COM interface
    hr = self->m_pIExport->get_Priority(&lpPriority);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.get_Priority() returned %ld", (long)hr);
        goto iexport_get_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPriority

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpPriority);
    goto iexport_get_priority_method_cleanup;

    iexport_get_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPriority
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.get_Priority");
    return return_tuple;
}

static PyObject*
IExportMethod_putref_StepProgressor(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStepProgressor* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto iexport_putref_stepprogressor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IStepProgressor, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IStepProgressor");
    
    if (PyErr_Occurred())
      goto iexport_putref_stepprogressor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExport->putref_StepProgressor(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.putref_StepProgressor() returned %ld", (long)hr);
        goto iexport_putref_stepprogressor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexport_putref_stepprogressor_method_cleanup;

    iexport_putref_stepprogressor_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.putref_StepProgressor");
    return return_tuple;
}

static PyObject*
IExportMethod_putref_TrackCancel(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto iexport_putref_trackcancel_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_ITrackCancel, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iexport_putref_trackcancel_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExport->putref_TrackCancel(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.putref_TrackCancel() returned %ld", (long)hr);
        goto iexport_putref_trackcancel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexport_putref_trackcancel_method_cleanup;

    iexport_putref_trackcancel_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.putref_TrackCancel");
    return return_tuple;
}

static PyObject*
IExportMethod_put_PixelBounds(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipPixelBounds = NULL;
    PyObject* py_PixelBounds;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_PixelBounds))
      goto iexport_put_pixelbounds_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_PixelBounds, &IID_IEnvelope, (void**)&ipPixelBounds))
        PyErr_SetString(PyExc_TypeError, "Argument PixelBounds (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iexport_put_pixelbounds_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExport->put_PixelBounds(ipPixelBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.put_PixelBounds() returned %ld", (long)hr);
        goto iexport_put_pixelbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PixelBounds

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexport_put_pixelbounds_method_cleanup;

    iexport_put_pixelbounds_method_cleanup:
    self->m_HR = hr;
    if (ipPixelBounds)
      ipPixelBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.put_PixelBounds");
    return return_tuple;
}

static PyObject*
IExportMethod_get_PixelBounds(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipPixelBounds = NULL;
    PyObject* py_PixelBounds = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for PixelBounds

    // Call method on actual COM interface
    hr = self->m_pIExport->get_PixelBounds(&ipPixelBounds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.get_PixelBounds() returned %ld", (long)hr);
        goto iexport_get_pixelbounds_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_PixelBounds);
    if (ipPixelBounds)
    {
        IUnknown* pUnk = NULL;
        ipPixelBounds->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_PixelBounds = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_PixelBounds)
    {
        if (py_PixelBounds)
           Py_DECREF(py_PixelBounds);
        py_PixelBounds = Py_None;
        Py_INCREF(py_PixelBounds);
    }
    if (PyErr_Occurred())
      goto iexport_get_pixelbounds_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_PixelBounds);
    goto iexport_get_pixelbounds_method_cleanup;

    iexport_get_pixelbounds_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_PixelBounds);
    if (ipPixelBounds)
      ipPixelBounds->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.get_PixelBounds");
    return return_tuple;
}

static PyObject*
IExportMethod_put_ExportFileName(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iexport_put_exportfilename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iexport_put_exportfilename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExport->put_ExportFileName(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.put_ExportFileName() returned %ld", (long)hr);
        goto iexport_put_exportfilename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexport_put_exportfilename_method_cleanup;

    iexport_put_exportfilename_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.put_ExportFileName");
    return return_tuple;
}

static PyObject*
IExportMethod_get_ExportFileName(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName;
    PyObject* pyvar_fileName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for fileName

    // Call method on actual COM interface
    hr = self->m_pIExport->get_ExportFileName(&bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.get_ExportFileName() returned %ld", (long)hr);
        goto iexport_get_exportfilename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_fileName = PyUnicode_FromWideChar(bsfileName,::SysStringLen(bsfileName));
    ::SysFreeString(bsfileName);
    
    if (PyErr_Occurred())
      goto iexport_get_exportfilename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_fileName);
    goto iexport_get_exportfilename_method_cleanup;

    iexport_get_exportfilename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_fileName != Py_None)
        Py_XDECREF(pyvar_fileName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.get_ExportFileName");
    return return_tuple;
}

static PyObject*
IExportMethod_put_Resolution(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dres = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dres))
      goto iexport_put_resolution_method_cleanup;

    // Set up initial variable values as needed
    // No setup for res

    // Call method on actual COM interface
    hr = self->m_pIExport->put_Resolution(dres);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.put_Resolution() returned %ld", (long)hr);
        goto iexport_put_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for res

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexport_put_resolution_method_cleanup;

    iexport_put_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for res
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.put_Resolution");
    return return_tuple;
}

static PyObject*
IExportMethod_get_Resolution(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dres = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for res

    // Call method on actual COM interface
    hr = self->m_pIExport->get_Resolution(&dres);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.get_Resolution() returned %ld", (long)hr);
        goto iexport_get_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for res

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dres);
    goto iexport_get_resolution_method_cleanup;

    iexport_get_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for res
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.get_Resolution");
    return return_tuple;
}

static PyObject*
IExportMethod_StartExporting(PyIExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhDC = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hDC

    // Call method on actual COM interface
    hr = self->m_pIExport->StartExporting(&HhDC);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.StartExporting() returned %ld", (long)hr);
        goto iexport_startexporting_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hDC

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhDC);
    goto iexport_startexporting_method_cleanup;

    iexport_startexporting_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hDC
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExport.StartExporting");
    return return_tuple;
}

static PyObject*
IExportMethod_FinishExporting(PyIExportObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIExport->FinishExporting();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.FinishExporting() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IExportMethod_Cleanup(PyIExportObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIExport->Cleanup();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExport.Cleanup() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIExportMethods[] = {
    {"supports", (PyCFunction)PyIExport_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IExportMethod_get_Name, METH_VARARGS, ""},
    {"get_Filter", (PyCFunction)IExportMethod_get_Filter, METH_VARARGS, ""},
    {"get_Priority", (PyCFunction)IExportMethod_get_Priority, METH_VARARGS, ""},
    {"putref_StepProgressor", (PyCFunction)IExportMethod_putref_StepProgressor, METH_VARARGS, ""},
    {"putref_TrackCancel", (PyCFunction)IExportMethod_putref_TrackCancel, METH_VARARGS, ""},
    {"put_PixelBounds", (PyCFunction)IExportMethod_put_PixelBounds, METH_VARARGS, ""},
    {"get_PixelBounds", (PyCFunction)IExportMethod_get_PixelBounds, METH_VARARGS, ""},
    {"put_ExportFileName", (PyCFunction)IExportMethod_put_ExportFileName, METH_VARARGS, ""},
    {"get_ExportFileName", (PyCFunction)IExportMethod_get_ExportFileName, METH_VARARGS, ""},
    {"put_Resolution", (PyCFunction)IExportMethod_put_Resolution, METH_VARARGS, ""},
    {"get_Resolution", (PyCFunction)IExportMethod_get_Resolution, METH_VARARGS, ""},
    {"StartExporting", (PyCFunction)IExportMethod_StartExporting, METH_VARARGS, ""},
    {"FinishExporting", (PyCFunction)IExportMethod_FinishExporting, METH_NOARGS, ""},
    {"Cleanup", (PyCFunction)IExportMethod_Cleanup, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportGetSet[] = {
  {"_pUnk", (getter)PyIExport_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExport", NULL},
  {"_pointer", (getter)PyIExport_GetPointer, NULL, "Get memory address for IExport", NULL},
  {"_IID", (getter)PyIExport_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExport_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExport_GetIgnoreFailures, (setter)PyIExport_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportObject",                          
                                              /* tp_name */
  sizeof(PyIExportObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportObject_new,                      
                                              /* tp_new */
};

// Interface IExportImage

typedef struct PyIExportImageObject {
    PyObject_HEAD
    IExportImage* m_pIExportImage;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportImageObject;

static PyObject*
PyIExportImageObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportImageObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportImage* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportImage, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportImage with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportImageObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportImage");
            return NULL;
        }
        self->m_pIExportImage = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportImage");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportImage");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportImage* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportImage, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportImage");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportImageObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportImage");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportImage = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportImageObject_dealloc(PyIExportImageObject* self)
{
    if (self->m_pIExportImage)
        self->m_pIExportImage->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportImage_GetpUnk(PyIExportImageObject* self)
{
    if (!self->m_pIExportImage)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportImage->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportImage to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportImage_GetPointer(PyIExportImageObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportImage);
}

static PyObject*
PyIExportImage_GetIID(PyIExportImageObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4bf7d12a-5c15-4671-a9e2-11fce89f0873");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportImage_GetHR(PyIExportImageObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportImage_GetIgnoreFailures(PyIExportImageObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportImage_SetIgnoreFailures(PyIExportImageObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportImage_SupportsInterface(PyIExportImageObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportImageMethod_put_ImageType(PyIExportImageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportImageType epimageType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epimageType))
      goto iexportimage_put_imagetype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pimageType

    // Call method on actual COM interface
    hr = self->m_pIExportImage->put_ImageType(epimageType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportImage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportImage.put_ImageType() returned %ld", (long)hr);
        goto iexportimage_put_imagetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pimageType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportimage_put_imagetype_method_cleanup;

    iexportimage_put_imagetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pimageType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportImage.put_ImageType");
    return return_tuple;
}

static PyObject*
IExportImageMethod_get_ImageType(PyIExportImageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportImageType epimageType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pimageType

    // Call method on actual COM interface
    hr = self->m_pIExportImage->get_ImageType(&epimageType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportImage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportImage.get_ImageType() returned %ld", (long)hr);
        goto iexportimage_get_imagetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pimageType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epimageType);
    goto iexportimage_get_imagetype_method_cleanup;

    iexportimage_get_imagetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pimageType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportImage.get_ImageType");
    return return_tuple;
}

static PyObject*
IExportImageMethod_put_BackgroundColor(PyIExportImageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipppBackgroundColor = NULL;
    PyObject* py_ppBackgroundColor;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppBackgroundColor))
      goto iexportimage_put_backgroundcolor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppBackgroundColor, &IID_IColor, (void**)&ipppBackgroundColor))
        PyErr_SetString(PyExc_TypeError, "Argument ppBackgroundColor (position 0) is not IColor");
    
    if (PyErr_Occurred())
      goto iexportimage_put_backgroundcolor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportImage->put_BackgroundColor(ipppBackgroundColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportImage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportImage.put_BackgroundColor() returned %ld", (long)hr);
        goto iexportimage_put_backgroundcolor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppBackgroundColor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportimage_put_backgroundcolor_method_cleanup;

    iexportimage_put_backgroundcolor_method_cleanup:
    self->m_HR = hr;
    if (ipppBackgroundColor)
      ipppBackgroundColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportImage.put_BackgroundColor");
    return return_tuple;
}

static PyObject*
IExportImageMethod_get_BackgroundColor(PyIExportImageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipppBackgroundColor = NULL;
    PyObject* py_ppBackgroundColor = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppBackgroundColor

    // Call method on actual COM interface
    hr = self->m_pIExportImage->get_BackgroundColor(&ipppBackgroundColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportImage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportImage.get_BackgroundColor() returned %ld", (long)hr);
        goto iexportimage_get_backgroundcolor_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppBackgroundColor);
    if (ipppBackgroundColor)
    {
        IUnknown* pUnk = NULL;
        ipppBackgroundColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBackgroundColor = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBackgroundColor)
    {
        if (py_ppBackgroundColor)
           Py_DECREF(py_ppBackgroundColor);
        py_ppBackgroundColor = Py_None;
        Py_INCREF(py_ppBackgroundColor);
    }
    if (PyErr_Occurred())
      goto iexportimage_get_backgroundcolor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBackgroundColor);
    goto iexportimage_get_backgroundcolor_method_cleanup;

    iexportimage_get_backgroundcolor_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppBackgroundColor);
    if (ipppBackgroundColor)
      ipppBackgroundColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportImage.get_BackgroundColor");
    return return_tuple;
}

static PyObject*
IExportImageMethod_put_Width(PyIExportImageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpWidth = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpWidth))
      goto iexportimage_put_width_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pWidth

    // Call method on actual COM interface
    hr = self->m_pIExportImage->put_Width(lpWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportImage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportImage.put_Width() returned %ld", (long)hr);
        goto iexportimage_put_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWidth

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportimage_put_width_method_cleanup;

    iexportimage_put_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportImage.put_Width");
    return return_tuple;
}

static PyObject*
IExportImageMethod_get_Width(PyIExportImageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pWidth

    // Call method on actual COM interface
    hr = self->m_pIExportImage->get_Width(&lpWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportImage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportImage.get_Width() returned %ld", (long)hr);
        goto iexportimage_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWidth

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpWidth);
    goto iexportimage_get_width_method_cleanup;

    iexportimage_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportImage.get_Width");
    return return_tuple;
}

static PyObject*
IExportImageMethod_put_Height(PyIExportImageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpHeight = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpHeight))
      goto iexportimage_put_height_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pHeight

    // Call method on actual COM interface
    hr = self->m_pIExportImage->put_Height(lpHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportImage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportImage.put_Height() returned %ld", (long)hr);
        goto iexportimage_put_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHeight

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportimage_put_height_method_cleanup;

    iexportimage_put_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHeight
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportImage.put_Height");
    return return_tuple;
}

static PyObject*
IExportImageMethod_get_Height(PyIExportImageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHeight

    // Call method on actual COM interface
    hr = self->m_pIExportImage->get_Height(&lpHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportImage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportImage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportImage.get_Height() returned %ld", (long)hr);
        goto iexportimage_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHeight

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpHeight);
    goto iexportimage_get_height_method_cleanup;

    iexportimage_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHeight
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportImage.get_Height");
    return return_tuple;
}


PyMethodDef PyIExportImageMethods[] = {
    {"supports", (PyCFunction)PyIExportImage_SupportsInterface, METH_O, ""},
    {"put_ImageType", (PyCFunction)IExportImageMethod_put_ImageType, METH_VARARGS, ""},
    {"get_ImageType", (PyCFunction)IExportImageMethod_get_ImageType, METH_VARARGS, ""},
    {"put_BackgroundColor", (PyCFunction)IExportImageMethod_put_BackgroundColor, METH_VARARGS, ""},
    {"get_BackgroundColor", (PyCFunction)IExportImageMethod_get_BackgroundColor, METH_VARARGS, ""},
    {"put_Width", (PyCFunction)IExportImageMethod_put_Width, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IExportImageMethod_get_Width, METH_VARARGS, ""},
    {"put_Height", (PyCFunction)IExportImageMethod_put_Height, METH_VARARGS, ""},
    {"get_Height", (PyCFunction)IExportImageMethod_get_Height, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportImageGetSet[] = {
  {"_pUnk", (getter)PyIExportImage_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportImage", NULL},
  {"_pointer", (getter)PyIExportImage_GetPointer, NULL, "Get memory address for IExportImage", NULL},
  {"_IID", (getter)PyIExportImage_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportImage_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportImage_GetIgnoreFailures, (setter)PyIExportImage_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportImageObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportImageObject",                          
                                              /* tp_name */
  sizeof(PyIExportImageObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportImageObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportImageMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportImageGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportImageObject_new,                      
                                              /* tp_new */
};

// Interface IExportBMP

typedef struct PyIExportBMPObject {
    PyObject_HEAD
    IExportBMP* m_pIExportBMP;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportBMPObject;

static PyObject*
PyIExportBMPObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportBMPObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportBMP* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportBMP, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportBMP with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportBMPObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportBMP");
            return NULL;
        }
        self->m_pIExportBMP = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportBMP");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportBMP");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportBMP* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportBMP, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportBMP");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportBMPObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportBMP");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportBMP = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportBMPObject_dealloc(PyIExportBMPObject* self)
{
    if (self->m_pIExportBMP)
        self->m_pIExportBMP->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportBMP_GetpUnk(PyIExportBMPObject* self)
{
    if (!self->m_pIExportBMP)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportBMP->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportBMP to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportBMP_GetPointer(PyIExportBMPObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportBMP);
}

static PyObject*
PyIExportBMP_GetIID(PyIExportBMPObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "759be840-8eb9-45a0-b511-2a297096344b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportBMP_GetHR(PyIExportBMPObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportBMP_GetIgnoreFailures(PyIExportBMPObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportBMP_SetIgnoreFailures(PyIExportBMPObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportBMP_SupportsInterface(PyIExportBMPObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportBMP->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportBMPMethod_get_Bitmap(PyIExportBMPObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HphBmp = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for phBmp

    // Call method on actual COM interface
    hr = self->m_pIExportBMP->get_Bitmap(&HphBmp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportBMP->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportBMP) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportBMP.get_Bitmap() returned %ld", (long)hr);
        goto iexportbmp_get_bitmap_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for phBmp

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HphBmp);
    goto iexportbmp_get_bitmap_method_cleanup;

    iexportbmp_get_bitmap_method_cleanup:
    self->m_HR = hr;
    // No cleanup for phBmp
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportBMP.get_Bitmap");
    return return_tuple;
}

static PyObject*
IExportBMPMethod_get_Palette(PyIExportBMPObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HphPal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for phPal

    // Call method on actual COM interface
    hr = self->m_pIExportBMP->get_Palette(&HphPal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportBMP->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportBMP) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportBMP.get_Palette() returned %ld", (long)hr);
        goto iexportbmp_get_palette_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for phPal

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HphPal);
    goto iexportbmp_get_palette_method_cleanup;

    iexportbmp_get_palette_method_cleanup:
    self->m_HR = hr;
    // No cleanup for phPal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportBMP.get_Palette");
    return return_tuple;
}

static PyObject*
IExportBMPMethod_put_RLECompression(PyIExportBMPObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_compression = VARIANT_FALSE;
    PyObject* pyvar_compression = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_compression))
      goto iexportbmp_put_rlecompression_method_cleanup;

    // Set up initial variable values as needed
    b_compression = ((PyObject_IsTrue(pyvar_compression) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportbmp_put_rlecompression_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportBMP->put_RLECompression(b_compression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportBMP->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportBMP) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportBMP.put_RLECompression() returned %ld", (long)hr);
        goto iexportbmp_put_rlecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for compression

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportbmp_put_rlecompression_method_cleanup;

    iexportbmp_put_rlecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for compression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportBMP.put_RLECompression");
    return return_tuple;
}

static PyObject*
IExportBMPMethod_get_RLECompression(PyIExportBMPObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_compression = VARIANT_FALSE;
    PyObject* pyvar_compression = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for compression

    // Call method on actual COM interface
    hr = self->m_pIExportBMP->get_RLECompression(&b_compression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportBMP->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportBMP) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportBMP.get_RLECompression() returned %ld", (long)hr);
        goto iexportbmp_get_rlecompression_method_cleanup;
    }

    // Set up return values as needed
    pyvar_compression = ((b_compression == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportbmp_get_rlecompression_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_compression);
    goto iexportbmp_get_rlecompression_method_cleanup;

    iexportbmp_get_rlecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for compression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportBMP.get_RLECompression");
    return return_tuple;
}

static PyObject*
IExportBMPMethod_put_BiLevelThreshold(PyIExportBMPObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ithreshold = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ithreshold))
      goto iexportbmp_put_bilevelthreshold_method_cleanup;

    // Set up initial variable values as needed
    // No setup for threshold

    // Call method on actual COM interface
    hr = self->m_pIExportBMP->put_BiLevelThreshold(ithreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportBMP->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportBMP) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportBMP.put_BiLevelThreshold() returned %ld", (long)hr);
        goto iexportbmp_put_bilevelthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for threshold

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportbmp_put_bilevelthreshold_method_cleanup;

    iexportbmp_put_bilevelthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportBMP.put_BiLevelThreshold");
    return return_tuple;
}

static PyObject*
IExportBMPMethod_get_BiLevelThreshold(PyIExportBMPObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ithreshold = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for threshold

    // Call method on actual COM interface
    hr = self->m_pIExportBMP->get_BiLevelThreshold(&ithreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportBMP->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportBMP) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportBMP.get_BiLevelThreshold() returned %ld", (long)hr);
        goto iexportbmp_get_bilevelthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for threshold

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ithreshold);
    goto iexportbmp_get_bilevelthreshold_method_cleanup;

    iexportbmp_get_bilevelthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportBMP.get_BiLevelThreshold");
    return return_tuple;
}


PyMethodDef PyIExportBMPMethods[] = {
    {"supports", (PyCFunction)PyIExportBMP_SupportsInterface, METH_O, ""},
    {"get_Bitmap", (PyCFunction)IExportBMPMethod_get_Bitmap, METH_VARARGS, ""},
    {"get_Palette", (PyCFunction)IExportBMPMethod_get_Palette, METH_VARARGS, ""},
    {"put_RLECompression", (PyCFunction)IExportBMPMethod_put_RLECompression, METH_VARARGS, ""},
    {"get_RLECompression", (PyCFunction)IExportBMPMethod_get_RLECompression, METH_VARARGS, ""},
    {"put_BiLevelThreshold", (PyCFunction)IExportBMPMethod_put_BiLevelThreshold, METH_VARARGS, ""},
    {"get_BiLevelThreshold", (PyCFunction)IExportBMPMethod_get_BiLevelThreshold, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportBMPGetSet[] = {
  {"_pUnk", (getter)PyIExportBMP_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportBMP", NULL},
  {"_pointer", (getter)PyIExportBMP_GetPointer, NULL, "Get memory address for IExportBMP", NULL},
  {"_IID", (getter)PyIExportBMP_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportBMP_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportBMP_GetIgnoreFailures, (setter)PyIExportBMP_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportBMPObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportBMPObject",                          
                                              /* tp_name */
  sizeof(PyIExportBMPObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportBMPObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportBMPMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportBMPGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportBMPObject_new,                      
                                              /* tp_new */
};

// Interface IExportJPEG

typedef struct PyIExportJPEGObject {
    PyObject_HEAD
    IExportJPEG* m_pIExportJPEG;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportJPEGObject;

static PyObject*
PyIExportJPEGObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportJPEGObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportJPEG* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportJPEG, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportJPEG with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportJPEGObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportJPEG");
            return NULL;
        }
        self->m_pIExportJPEG = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportJPEG");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportJPEG");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportJPEG* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportJPEG, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportJPEG");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportJPEGObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportJPEG");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportJPEG = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportJPEGObject_dealloc(PyIExportJPEGObject* self)
{
    if (self->m_pIExportJPEG)
        self->m_pIExportJPEG->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportJPEG_GetpUnk(PyIExportJPEGObject* self)
{
    if (!self->m_pIExportJPEG)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportJPEG->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportJPEG to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportJPEG_GetPointer(PyIExportJPEGObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportJPEG);
}

static PyObject*
PyIExportJPEG_GetIID(PyIExportJPEGObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8746bb14-4c79-42f0-b0f1-3327651eb378");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportJPEG_GetHR(PyIExportJPEGObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportJPEG_GetIgnoreFailures(PyIExportJPEGObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportJPEG_SetIgnoreFailures(PyIExportJPEGObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportJPEG_SupportsInterface(PyIExportJPEGObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportJPEG->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportJPEGMethod_put_Quality(PyIExportJPEGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sQuality = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sQuality))
      goto iexportjpeg_put_quality_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Quality

    // Call method on actual COM interface
    hr = self->m_pIExportJPEG->put_Quality(sQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportJPEG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportJPEG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportJPEG.put_Quality() returned %ld", (long)hr);
        goto iexportjpeg_put_quality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Quality

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportjpeg_put_quality_method_cleanup;

    iexportjpeg_put_quality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Quality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportJPEG.put_Quality");
    return return_tuple;
}

static PyObject*
IExportJPEGMethod_get_Quality(PyIExportJPEGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sQuality = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Quality

    // Call method on actual COM interface
    hr = self->m_pIExportJPEG->get_Quality(&sQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportJPEG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportJPEG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportJPEG.get_Quality() returned %ld", (long)hr);
        goto iexportjpeg_get_quality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Quality

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sQuality);
    goto iexportjpeg_get_quality_method_cleanup;

    iexportjpeg_get_quality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Quality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportJPEG.get_Quality");
    return return_tuple;
}

static PyObject*
IExportJPEGMethod_put_ProgressiveMode(PyIExportJPEGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bprogressive = VARIANT_FALSE;
    PyObject* pyvar_bprogressive = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bprogressive))
      goto iexportjpeg_put_progressivemode_method_cleanup;

    // Set up initial variable values as needed
    b_bprogressive = ((PyObject_IsTrue(pyvar_bprogressive) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportjpeg_put_progressivemode_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportJPEG->put_ProgressiveMode(b_bprogressive);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportJPEG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportJPEG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportJPEG.put_ProgressiveMode() returned %ld", (long)hr);
        goto iexportjpeg_put_progressivemode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bprogressive

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportjpeg_put_progressivemode_method_cleanup;

    iexportjpeg_put_progressivemode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bprogressive
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportJPEG.put_ProgressiveMode");
    return return_tuple;
}

static PyObject*
IExportJPEGMethod_get_ProgressiveMode(PyIExportJPEGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bprogressive = VARIANT_FALSE;
    PyObject* pyvar_bprogressive = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bprogressive

    // Call method on actual COM interface
    hr = self->m_pIExportJPEG->get_ProgressiveMode(&b_bprogressive);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportJPEG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportJPEG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportJPEG.get_ProgressiveMode() returned %ld", (long)hr);
        goto iexportjpeg_get_progressivemode_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bprogressive = ((b_bprogressive == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportjpeg_get_progressivemode_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bprogressive);
    goto iexportjpeg_get_progressivemode_method_cleanup;

    iexportjpeg_get_progressivemode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bprogressive
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportJPEG.get_ProgressiveMode");
    return return_tuple;
}


PyMethodDef PyIExportJPEGMethods[] = {
    {"supports", (PyCFunction)PyIExportJPEG_SupportsInterface, METH_O, ""},
    {"put_Quality", (PyCFunction)IExportJPEGMethod_put_Quality, METH_VARARGS, ""},
    {"get_Quality", (PyCFunction)IExportJPEGMethod_get_Quality, METH_VARARGS, ""},
    {"put_ProgressiveMode", (PyCFunction)IExportJPEGMethod_put_ProgressiveMode, METH_VARARGS, ""},
    {"get_ProgressiveMode", (PyCFunction)IExportJPEGMethod_get_ProgressiveMode, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportJPEGGetSet[] = {
  {"_pUnk", (getter)PyIExportJPEG_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportJPEG", NULL},
  {"_pointer", (getter)PyIExportJPEG_GetPointer, NULL, "Get memory address for IExportJPEG", NULL},
  {"_IID", (getter)PyIExportJPEG_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportJPEG_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportJPEG_GetIgnoreFailures, (setter)PyIExportJPEG_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportJPEGObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportJPEGObject",                          
                                              /* tp_name */
  sizeof(PyIExportJPEGObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportJPEGObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportJPEGMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportJPEGGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportJPEGObject_new,                      
                                              /* tp_new */
};

// Interface IExportPNG

typedef struct PyIExportPNGObject {
    PyObject_HEAD
    IExportPNG* m_pIExportPNG;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportPNGObject;

static PyObject*
PyIExportPNGObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportPNGObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportPNG* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportPNG, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportPNG with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportPNGObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPNG");
            return NULL;
        }
        self->m_pIExportPNG = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportPNG");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportPNG");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportPNG* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportPNG, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportPNG");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportPNGObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPNG");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportPNG = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportPNGObject_dealloc(PyIExportPNGObject* self)
{
    if (self->m_pIExportPNG)
        self->m_pIExportPNG->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportPNG_GetpUnk(PyIExportPNGObject* self)
{
    if (!self->m_pIExportPNG)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportPNG->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportPNG to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportPNG_GetPointer(PyIExportPNGObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportPNG);
}

static PyObject*
PyIExportPNG_GetIID(PyIExportPNGObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3b12ac60-9d1a-45c8-bde5-a2b4cdced76f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportPNG_GetHR(PyIExportPNGObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportPNG_GetIgnoreFailures(PyIExportPNGObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportPNG_SetIgnoreFailures(PyIExportPNGObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportPNG_SupportsInterface(PyIExportPNGObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportPNG->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportPNGMethod_put_InterlaceMode(PyIExportPNGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_interlace = VARIANT_FALSE;
    PyObject* pyvar_interlace = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_interlace))
      goto iexportpng_put_interlacemode_method_cleanup;

    // Set up initial variable values as needed
    b_interlace = ((PyObject_IsTrue(pyvar_interlace) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportpng_put_interlacemode_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportPNG->put_InterlaceMode(b_interlace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPNG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPNG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPNG.put_InterlaceMode() returned %ld", (long)hr);
        goto iexportpng_put_interlacemode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for interlace

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpng_put_interlacemode_method_cleanup;

    iexportpng_put_interlacemode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for interlace
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPNG.put_InterlaceMode");
    return return_tuple;
}

static PyObject*
IExportPNGMethod_get_InterlaceMode(PyIExportPNGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_interlace = VARIANT_FALSE;
    PyObject* pyvar_interlace = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for interlace

    // Call method on actual COM interface
    hr = self->m_pIExportPNG->get_InterlaceMode(&b_interlace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPNG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPNG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPNG.get_InterlaceMode() returned %ld", (long)hr);
        goto iexportpng_get_interlacemode_method_cleanup;
    }

    // Set up return values as needed
    pyvar_interlace = ((b_interlace == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportpng_get_interlacemode_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_interlace);
    goto iexportpng_get_interlacemode_method_cleanup;

    iexportpng_get_interlacemode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for interlace
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPNG.get_InterlaceMode");
    return return_tuple;
}

static PyObject*
IExportPNGMethod_put_TransparentColor(PyIExportPNGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipColor = NULL;
    PyObject* py_Color;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Color))
      goto iexportpng_put_transparentcolor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Color, &IID_IColor, (void**)&ipColor))
        PyErr_SetString(PyExc_TypeError, "Argument Color (position 0) is not IColor");
    
    if (PyErr_Occurred())
      goto iexportpng_put_transparentcolor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportPNG->put_TransparentColor(ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPNG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPNG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPNG.put_TransparentColor() returned %ld", (long)hr);
        goto iexportpng_put_transparentcolor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Color

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpng_put_transparentcolor_method_cleanup;

    iexportpng_put_transparentcolor_method_cleanup:
    self->m_HR = hr;
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPNG.put_TransparentColor");
    return return_tuple;
}

static PyObject*
IExportPNGMethod_get_TransparentColor(PyIExportPNGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipColor = NULL;
    PyObject* py_Color = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Color

    // Call method on actual COM interface
    hr = self->m_pIExportPNG->get_TransparentColor(&ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPNG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPNG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPNG.get_TransparentColor() returned %ld", (long)hr);
        goto iexportpng_get_transparentcolor_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Color);
    if (ipColor)
    {
        IUnknown* pUnk = NULL;
        ipColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Color = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Color)
    {
        if (py_Color)
           Py_DECREF(py_Color);
        py_Color = Py_None;
        Py_INCREF(py_Color);
    }
    if (PyErr_Occurred())
      goto iexportpng_get_transparentcolor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Color);
    goto iexportpng_get_transparentcolor_method_cleanup;

    iexportpng_get_transparentcolor_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Color);
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPNG.get_TransparentColor");
    return return_tuple;
}

static PyObject*
IExportPNGMethod_put_BiLevelThreshold(PyIExportPNGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ithreshold = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ithreshold))
      goto iexportpng_put_bilevelthreshold_method_cleanup;

    // Set up initial variable values as needed
    // No setup for threshold

    // Call method on actual COM interface
    hr = self->m_pIExportPNG->put_BiLevelThreshold(ithreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPNG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPNG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPNG.put_BiLevelThreshold() returned %ld", (long)hr);
        goto iexportpng_put_bilevelthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for threshold

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpng_put_bilevelthreshold_method_cleanup;

    iexportpng_put_bilevelthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPNG.put_BiLevelThreshold");
    return return_tuple;
}

static PyObject*
IExportPNGMethod_get_BiLevelThreshold(PyIExportPNGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ithreshold = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for threshold

    // Call method on actual COM interface
    hr = self->m_pIExportPNG->get_BiLevelThreshold(&ithreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPNG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPNG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPNG.get_BiLevelThreshold() returned %ld", (long)hr);
        goto iexportpng_get_bilevelthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for threshold

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ithreshold);
    goto iexportpng_get_bilevelthreshold_method_cleanup;

    iexportpng_get_bilevelthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPNG.get_BiLevelThreshold");
    return return_tuple;
}


PyMethodDef PyIExportPNGMethods[] = {
    {"supports", (PyCFunction)PyIExportPNG_SupportsInterface, METH_O, ""},
    {"put_InterlaceMode", (PyCFunction)IExportPNGMethod_put_InterlaceMode, METH_VARARGS, ""},
    {"get_InterlaceMode", (PyCFunction)IExportPNGMethod_get_InterlaceMode, METH_VARARGS, ""},
    {"put_TransparentColor", (PyCFunction)IExportPNGMethod_put_TransparentColor, METH_VARARGS, ""},
    {"get_TransparentColor", (PyCFunction)IExportPNGMethod_get_TransparentColor, METH_VARARGS, ""},
    {"put_BiLevelThreshold", (PyCFunction)IExportPNGMethod_put_BiLevelThreshold, METH_VARARGS, ""},
    {"get_BiLevelThreshold", (PyCFunction)IExportPNGMethod_get_BiLevelThreshold, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportPNGGetSet[] = {
  {"_pUnk", (getter)PyIExportPNG_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportPNG", NULL},
  {"_pointer", (getter)PyIExportPNG_GetPointer, NULL, "Get memory address for IExportPNG", NULL},
  {"_IID", (getter)PyIExportPNG_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportPNG_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportPNG_GetIgnoreFailures, (setter)PyIExportPNG_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportPNGObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportPNGObject",                          
                                              /* tp_name */
  sizeof(PyIExportPNGObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportPNGObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportPNGMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportPNGGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportPNGObject_new,                      
                                              /* tp_new */
};

// Interface IExportTIFF

typedef struct PyIExportTIFFObject {
    PyObject_HEAD
    IExportTIFF* m_pIExportTIFF;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportTIFFObject;

static PyObject*
PyIExportTIFFObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportTIFFObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportTIFF* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportTIFF, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportTIFF with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportTIFFObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportTIFF");
            return NULL;
        }
        self->m_pIExportTIFF = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportTIFF");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportTIFF");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportTIFF* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportTIFF, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportTIFF");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportTIFFObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportTIFF");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportTIFF = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportTIFFObject_dealloc(PyIExportTIFFObject* self)
{
    if (self->m_pIExportTIFF)
        self->m_pIExportTIFF->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportTIFF_GetpUnk(PyIExportTIFFObject* self)
{
    if (!self->m_pIExportTIFF)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportTIFF->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportTIFF to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportTIFF_GetPointer(PyIExportTIFFObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportTIFF);
}

static PyObject*
PyIExportTIFF_GetIID(PyIExportTIFFObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b13d58c7-603f-4610-8538-5b501908ee26");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportTIFF_GetHR(PyIExportTIFFObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportTIFF_GetIgnoreFailures(PyIExportTIFFObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportTIFF_SetIgnoreFailures(PyIExportTIFFObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportTIFF_SupportsInterface(PyIExportTIFFObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportTIFFMethod_put_CompressionType(PyIExportTIFFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTIFFCompression etype;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&etype))
      goto iexporttiff_put_compressiontype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for type

    // Call method on actual COM interface
    hr = self->m_pIExportTIFF->put_CompressionType(etype);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportTIFF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportTIFF.put_CompressionType() returned %ld", (long)hr);
        goto iexporttiff_put_compressiontype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporttiff_put_compressiontype_method_cleanup;

    iexporttiff_put_compressiontype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportTIFF.put_CompressionType");
    return return_tuple;
}

static PyObject*
IExportTIFFMethod_get_CompressionType(PyIExportTIFFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTIFFCompression etype;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for type

    // Call method on actual COM interface
    hr = self->m_pIExportTIFF->get_CompressionType(&etype);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportTIFF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportTIFF.get_CompressionType() returned %ld", (long)hr);
        goto iexporttiff_get_compressiontype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)etype);
    goto iexporttiff_get_compressiontype_method_cleanup;

    iexporttiff_get_compressiontype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportTIFF.get_CompressionType");
    return return_tuple;
}

static PyObject*
IExportTIFFMethod_put_GeoTiff(PyIExportTIFFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bGeoTiff = VARIANT_FALSE;
    PyObject* pyvar_bGeoTiff = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bGeoTiff))
      goto iexporttiff_put_geotiff_method_cleanup;

    // Set up initial variable values as needed
    b_bGeoTiff = ((PyObject_IsTrue(pyvar_bGeoTiff) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexporttiff_put_geotiff_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportTIFF->put_GeoTiff(b_bGeoTiff);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportTIFF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportTIFF.put_GeoTiff() returned %ld", (long)hr);
        goto iexporttiff_put_geotiff_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bGeoTiff

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporttiff_put_geotiff_method_cleanup;

    iexporttiff_put_geotiff_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bGeoTiff
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportTIFF.put_GeoTiff");
    return return_tuple;
}

static PyObject*
IExportTIFFMethod_get_GeoTiff(PyIExportTIFFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bGeoTiff = VARIANT_FALSE;
    PyObject* pyvar_bGeoTiff = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bGeoTiff

    // Call method on actual COM interface
    hr = self->m_pIExportTIFF->get_GeoTiff(&b_bGeoTiff);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportTIFF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportTIFF.get_GeoTiff() returned %ld", (long)hr);
        goto iexporttiff_get_geotiff_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bGeoTiff = ((b_bGeoTiff == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexporttiff_get_geotiff_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bGeoTiff);
    goto iexporttiff_get_geotiff_method_cleanup;

    iexporttiff_get_geotiff_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bGeoTiff
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportTIFF.get_GeoTiff");
    return return_tuple;
}

static PyObject*
IExportTIFFMethod_put_JPEGOrDeflateQuality(PyIExportTIFFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sQuality = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sQuality))
      goto iexporttiff_put_jpegordeflatequality_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Quality

    // Call method on actual COM interface
    hr = self->m_pIExportTIFF->put_JPEGOrDeflateQuality(sQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportTIFF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportTIFF.put_JPEGOrDeflateQuality() returned %ld", (long)hr);
        goto iexporttiff_put_jpegordeflatequality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Quality

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporttiff_put_jpegordeflatequality_method_cleanup;

    iexporttiff_put_jpegordeflatequality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Quality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportTIFF.put_JPEGOrDeflateQuality");
    return return_tuple;
}

static PyObject*
IExportTIFFMethod_get_JPEGOrDeflateQuality(PyIExportTIFFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sQuality = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Quality

    // Call method on actual COM interface
    hr = self->m_pIExportTIFF->get_JPEGOrDeflateQuality(&sQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportTIFF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportTIFF.get_JPEGOrDeflateQuality() returned %ld", (long)hr);
        goto iexporttiff_get_jpegordeflatequality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Quality

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sQuality);
    goto iexporttiff_get_jpegordeflatequality_method_cleanup;

    iexporttiff_get_jpegordeflatequality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Quality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportTIFF.get_JPEGOrDeflateQuality");
    return return_tuple;
}

static PyObject*
IExportTIFFMethod_put_BiLevelThreshold(PyIExportTIFFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ithreshold = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ithreshold))
      goto iexporttiff_put_bilevelthreshold_method_cleanup;

    // Set up initial variable values as needed
    // No setup for threshold

    // Call method on actual COM interface
    hr = self->m_pIExportTIFF->put_BiLevelThreshold(ithreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportTIFF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportTIFF.put_BiLevelThreshold() returned %ld", (long)hr);
        goto iexporttiff_put_bilevelthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for threshold

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexporttiff_put_bilevelthreshold_method_cleanup;

    iexporttiff_put_bilevelthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportTIFF.put_BiLevelThreshold");
    return return_tuple;
}

static PyObject*
IExportTIFFMethod_get_BiLevelThreshold(PyIExportTIFFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ithreshold = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for threshold

    // Call method on actual COM interface
    hr = self->m_pIExportTIFF->get_BiLevelThreshold(&ithreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportTIFF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportTIFF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportTIFF.get_BiLevelThreshold() returned %ld", (long)hr);
        goto iexporttiff_get_bilevelthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for threshold

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ithreshold);
    goto iexporttiff_get_bilevelthreshold_method_cleanup;

    iexporttiff_get_bilevelthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportTIFF.get_BiLevelThreshold");
    return return_tuple;
}


PyMethodDef PyIExportTIFFMethods[] = {
    {"supports", (PyCFunction)PyIExportTIFF_SupportsInterface, METH_O, ""},
    {"put_CompressionType", (PyCFunction)IExportTIFFMethod_put_CompressionType, METH_VARARGS, ""},
    {"get_CompressionType", (PyCFunction)IExportTIFFMethod_get_CompressionType, METH_VARARGS, ""},
    {"put_GeoTiff", (PyCFunction)IExportTIFFMethod_put_GeoTiff, METH_VARARGS, ""},
    {"get_GeoTiff", (PyCFunction)IExportTIFFMethod_get_GeoTiff, METH_VARARGS, ""},
    {"put_JPEGOrDeflateQuality", (PyCFunction)IExportTIFFMethod_put_JPEGOrDeflateQuality, METH_VARARGS, ""},
    {"get_JPEGOrDeflateQuality", (PyCFunction)IExportTIFFMethod_get_JPEGOrDeflateQuality, METH_VARARGS, ""},
    {"put_BiLevelThreshold", (PyCFunction)IExportTIFFMethod_put_BiLevelThreshold, METH_VARARGS, ""},
    {"get_BiLevelThreshold", (PyCFunction)IExportTIFFMethod_get_BiLevelThreshold, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportTIFFGetSet[] = {
  {"_pUnk", (getter)PyIExportTIFF_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportTIFF", NULL},
  {"_pointer", (getter)PyIExportTIFF_GetPointer, NULL, "Get memory address for IExportTIFF", NULL},
  {"_IID", (getter)PyIExportTIFF_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportTIFF_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportTIFF_GetIgnoreFailures, (setter)PyIExportTIFF_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportTIFFObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportTIFFObject",                          
                                              /* tp_name */
  sizeof(PyIExportTIFFObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportTIFFObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportTIFFMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportTIFFGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportTIFFObject_new,                      
                                              /* tp_new */
};

// Interface IExportGIF

typedef struct PyIExportGIFObject {
    PyObject_HEAD
    IExportGIF* m_pIExportGIF;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportGIFObject;

static PyObject*
PyIExportGIFObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportGIFObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportGIF* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportGIF, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportGIF with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportGIFObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportGIF");
            return NULL;
        }
        self->m_pIExportGIF = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportGIF");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportGIF");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportGIF* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportGIF, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportGIF");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportGIFObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportGIF");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportGIF = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportGIFObject_dealloc(PyIExportGIFObject* self)
{
    if (self->m_pIExportGIF)
        self->m_pIExportGIF->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportGIF_GetpUnk(PyIExportGIFObject* self)
{
    if (!self->m_pIExportGIF)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportGIF->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportGIF to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportGIF_GetPointer(PyIExportGIFObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportGIF);
}

static PyObject*
PyIExportGIF_GetIID(PyIExportGIFObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6c43ec0f-352c-42ef-9bd6-83d37529e3e5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportGIF_GetHR(PyIExportGIFObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportGIF_GetIgnoreFailures(PyIExportGIFObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportGIF_SetIgnoreFailures(PyIExportGIFObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportGIF_SupportsInterface(PyIExportGIFObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportGIFMethod_put_InterlaceMode(PyIExportGIFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_interlace = VARIANT_FALSE;
    PyObject* pyvar_interlace = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_interlace))
      goto iexportgif_put_interlacemode_method_cleanup;

    // Set up initial variable values as needed
    b_interlace = ((PyObject_IsTrue(pyvar_interlace) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportgif_put_interlacemode_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportGIF->put_InterlaceMode(b_interlace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportGIF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportGIF.put_InterlaceMode() returned %ld", (long)hr);
        goto iexportgif_put_interlacemode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for interlace

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportgif_put_interlacemode_method_cleanup;

    iexportgif_put_interlacemode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for interlace
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportGIF.put_InterlaceMode");
    return return_tuple;
}

static PyObject*
IExportGIFMethod_get_InterlaceMode(PyIExportGIFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_interlace = VARIANT_FALSE;
    PyObject* pyvar_interlace = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for interlace

    // Call method on actual COM interface
    hr = self->m_pIExportGIF->get_InterlaceMode(&b_interlace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportGIF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportGIF.get_InterlaceMode() returned %ld", (long)hr);
        goto iexportgif_get_interlacemode_method_cleanup;
    }

    // Set up return values as needed
    pyvar_interlace = ((b_interlace == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportgif_get_interlacemode_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_interlace);
    goto iexportgif_get_interlacemode_method_cleanup;

    iexportgif_get_interlacemode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for interlace
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportGIF.get_InterlaceMode");
    return return_tuple;
}

static PyObject*
IExportGIFMethod_put_CompressionType(PyIExportGIFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGIFCompression etype;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&etype))
      goto iexportgif_put_compressiontype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for type

    // Call method on actual COM interface
    hr = self->m_pIExportGIF->put_CompressionType(etype);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportGIF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportGIF.put_CompressionType() returned %ld", (long)hr);
        goto iexportgif_put_compressiontype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportgif_put_compressiontype_method_cleanup;

    iexportgif_put_compressiontype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportGIF.put_CompressionType");
    return return_tuple;
}

static PyObject*
IExportGIFMethod_get_CompressionType(PyIExportGIFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGIFCompression etype;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for type

    // Call method on actual COM interface
    hr = self->m_pIExportGIF->get_CompressionType(&etype);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportGIF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportGIF.get_CompressionType() returned %ld", (long)hr);
        goto iexportgif_get_compressiontype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)etype);
    goto iexportgif_get_compressiontype_method_cleanup;

    iexportgif_get_compressiontype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportGIF.get_CompressionType");
    return return_tuple;
}

static PyObject*
IExportGIFMethod_put_TransparentColor(PyIExportGIFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipColor = NULL;
    PyObject* py_Color;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Color))
      goto iexportgif_put_transparentcolor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Color, &IID_IColor, (void**)&ipColor))
        PyErr_SetString(PyExc_TypeError, "Argument Color (position 0) is not IColor");
    
    if (PyErr_Occurred())
      goto iexportgif_put_transparentcolor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportGIF->put_TransparentColor(ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportGIF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportGIF.put_TransparentColor() returned %ld", (long)hr);
        goto iexportgif_put_transparentcolor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Color

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportgif_put_transparentcolor_method_cleanup;

    iexportgif_put_transparentcolor_method_cleanup:
    self->m_HR = hr;
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportGIF.put_TransparentColor");
    return return_tuple;
}

static PyObject*
IExportGIFMethod_get_TransparentColor(PyIExportGIFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipColor = NULL;
    PyObject* py_Color = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Color

    // Call method on actual COM interface
    hr = self->m_pIExportGIF->get_TransparentColor(&ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportGIF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportGIF.get_TransparentColor() returned %ld", (long)hr);
        goto iexportgif_get_transparentcolor_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Color);
    if (ipColor)
    {
        IUnknown* pUnk = NULL;
        ipColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Color = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Color)
    {
        if (py_Color)
           Py_DECREF(py_Color);
        py_Color = Py_None;
        Py_INCREF(py_Color);
    }
    if (PyErr_Occurred())
      goto iexportgif_get_transparentcolor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Color);
    goto iexportgif_get_transparentcolor_method_cleanup;

    iexportgif_get_transparentcolor_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Color);
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportGIF.get_TransparentColor");
    return return_tuple;
}

static PyObject*
IExportGIFMethod_put_BiLevelThreshold(PyIExportGIFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ithreshold = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ithreshold))
      goto iexportgif_put_bilevelthreshold_method_cleanup;

    // Set up initial variable values as needed
    // No setup for threshold

    // Call method on actual COM interface
    hr = self->m_pIExportGIF->put_BiLevelThreshold(ithreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportGIF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportGIF.put_BiLevelThreshold() returned %ld", (long)hr);
        goto iexportgif_put_bilevelthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for threshold

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportgif_put_bilevelthreshold_method_cleanup;

    iexportgif_put_bilevelthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportGIF.put_BiLevelThreshold");
    return return_tuple;
}

static PyObject*
IExportGIFMethod_get_BiLevelThreshold(PyIExportGIFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ithreshold = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for threshold

    // Call method on actual COM interface
    hr = self->m_pIExportGIF->get_BiLevelThreshold(&ithreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportGIF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportGIF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportGIF.get_BiLevelThreshold() returned %ld", (long)hr);
        goto iexportgif_get_bilevelthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for threshold

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ithreshold);
    goto iexportgif_get_bilevelthreshold_method_cleanup;

    iexportgif_get_bilevelthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportGIF.get_BiLevelThreshold");
    return return_tuple;
}


PyMethodDef PyIExportGIFMethods[] = {
    {"supports", (PyCFunction)PyIExportGIF_SupportsInterface, METH_O, ""},
    {"put_InterlaceMode", (PyCFunction)IExportGIFMethod_put_InterlaceMode, METH_VARARGS, ""},
    {"get_InterlaceMode", (PyCFunction)IExportGIFMethod_get_InterlaceMode, METH_VARARGS, ""},
    {"put_CompressionType", (PyCFunction)IExportGIFMethod_put_CompressionType, METH_VARARGS, ""},
    {"get_CompressionType", (PyCFunction)IExportGIFMethod_get_CompressionType, METH_VARARGS, ""},
    {"put_TransparentColor", (PyCFunction)IExportGIFMethod_put_TransparentColor, METH_VARARGS, ""},
    {"get_TransparentColor", (PyCFunction)IExportGIFMethod_get_TransparentColor, METH_VARARGS, ""},
    {"put_BiLevelThreshold", (PyCFunction)IExportGIFMethod_put_BiLevelThreshold, METH_VARARGS, ""},
    {"get_BiLevelThreshold", (PyCFunction)IExportGIFMethod_get_BiLevelThreshold, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportGIFGetSet[] = {
  {"_pUnk", (getter)PyIExportGIF_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportGIF", NULL},
  {"_pointer", (getter)PyIExportGIF_GetPointer, NULL, "Get memory address for IExportGIF", NULL},
  {"_IID", (getter)PyIExportGIF_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportGIF_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportGIF_GetIgnoreFailures, (setter)PyIExportGIF_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportGIFObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportGIFObject",                          
                                              /* tp_name */
  sizeof(PyIExportGIFObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportGIFObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportGIFMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportGIFGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportGIFObject_new,                      
                                              /* tp_new */
};

// Interface IExportVectorOptions

typedef struct PyIExportVectorOptionsObject {
    PyObject_HEAD
    IExportVectorOptions* m_pIExportVectorOptions;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportVectorOptionsObject;

static PyObject*
PyIExportVectorOptionsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportVectorOptionsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportVectorOptions* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportVectorOptions, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportVectorOptions with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportVectorOptionsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportVectorOptions");
            return NULL;
        }
        self->m_pIExportVectorOptions = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportVectorOptions");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportVectorOptions");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportVectorOptions* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportVectorOptions, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportVectorOptions");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportVectorOptionsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportVectorOptions");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportVectorOptions = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportVectorOptionsObject_dealloc(PyIExportVectorOptionsObject* self)
{
    if (self->m_pIExportVectorOptions)
        self->m_pIExportVectorOptions->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportVectorOptions_GetpUnk(PyIExportVectorOptionsObject* self)
{
    if (!self->m_pIExportVectorOptions)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportVectorOptions->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportVectorOptions to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportVectorOptions_GetPointer(PyIExportVectorOptionsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportVectorOptions);
}

static PyObject*
PyIExportVectorOptions_GetIID(PyIExportVectorOptionsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1c16bcac-81dd-4662-a6ab-810a205fc645");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportVectorOptions_GetHR(PyIExportVectorOptionsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportVectorOptions_GetIgnoreFailures(PyIExportVectorOptionsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportVectorOptions_SetIgnoreFailures(PyIExportVectorOptionsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportVectorOptions_SupportsInterface(PyIExportVectorOptionsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportVectorOptions->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportVectorOptionsMethod_put_PolygonizeMarkers(PyIExportVectorOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bPolygonizeMarkers = VARIANT_FALSE;
    PyObject* pyvar_bPolygonizeMarkers = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bPolygonizeMarkers))
      goto iexportvectoroptions_put_polygonizemarkers_method_cleanup;

    // Set up initial variable values as needed
    b_bPolygonizeMarkers = ((PyObject_IsTrue(pyvar_bPolygonizeMarkers) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportvectoroptions_put_polygonizemarkers_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportVectorOptions->put_PolygonizeMarkers(b_bPolygonizeMarkers);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportVectorOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportVectorOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportVectorOptions.put_PolygonizeMarkers() returned %ld", (long)hr);
        goto iexportvectoroptions_put_polygonizemarkers_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bPolygonizeMarkers

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportvectoroptions_put_polygonizemarkers_method_cleanup;

    iexportvectoroptions_put_polygonizemarkers_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bPolygonizeMarkers
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportVectorOptions.put_PolygonizeMarkers");
    return return_tuple;
}

static PyObject*
IExportVectorOptionsMethod_get_PolygonizeMarkers(PyIExportVectorOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bPolygonizeMarkers = VARIANT_FALSE;
    PyObject* pyvar_bPolygonizeMarkers = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bPolygonizeMarkers

    // Call method on actual COM interface
    hr = self->m_pIExportVectorOptions->get_PolygonizeMarkers(&b_bPolygonizeMarkers);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportVectorOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportVectorOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportVectorOptions.get_PolygonizeMarkers() returned %ld", (long)hr);
        goto iexportvectoroptions_get_polygonizemarkers_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bPolygonizeMarkers = ((b_bPolygonizeMarkers == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportvectoroptions_get_polygonizemarkers_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bPolygonizeMarkers);
    goto iexportvectoroptions_get_polygonizemarkers_method_cleanup;

    iexportvectoroptions_get_polygonizemarkers_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bPolygonizeMarkers
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportVectorOptions.get_PolygonizeMarkers");
    return return_tuple;
}

static PyObject*
IExportVectorOptionsMethod_put_MaxVertexNumber(PyIExportVectorOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long llMaxVertices = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &llMaxVertices))
      goto iexportvectoroptions_put_maxvertexnumber_method_cleanup;

    // Set up initial variable values as needed
    // No setup for lMaxVertices

    // Call method on actual COM interface
    hr = self->m_pIExportVectorOptions->put_MaxVertexNumber(llMaxVertices);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportVectorOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportVectorOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportVectorOptions.put_MaxVertexNumber() returned %ld", (long)hr);
        goto iexportvectoroptions_put_maxvertexnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lMaxVertices

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportvectoroptions_put_maxvertexnumber_method_cleanup;

    iexportvectoroptions_put_maxvertexnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for lMaxVertices
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportVectorOptions.put_MaxVertexNumber");
    return return_tuple;
}

static PyObject*
IExportVectorOptionsMethod_get_MaxVertexNumber(PyIExportVectorOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long llMaxVertices = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for lMaxVertices

    // Call method on actual COM interface
    hr = self->m_pIExportVectorOptions->get_MaxVertexNumber(&llMaxVertices);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportVectorOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportVectorOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportVectorOptions.get_MaxVertexNumber() returned %ld", (long)hr);
        goto iexportvectoroptions_get_maxvertexnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lMaxVertices

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            llMaxVertices);
    goto iexportvectoroptions_get_maxvertexnumber_method_cleanup;

    iexportvectoroptions_get_maxvertexnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for lMaxVertices
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportVectorOptions.get_MaxVertexNumber");
    return return_tuple;
}


PyMethodDef PyIExportVectorOptionsMethods[] = {
    {"supports", (PyCFunction)PyIExportVectorOptions_SupportsInterface, METH_O, ""},
    {"put_PolygonizeMarkers", (PyCFunction)IExportVectorOptionsMethod_put_PolygonizeMarkers, METH_VARARGS, ""},
    {"get_PolygonizeMarkers", (PyCFunction)IExportVectorOptionsMethod_get_PolygonizeMarkers, METH_VARARGS, ""},
    {"put_MaxVertexNumber", (PyCFunction)IExportVectorOptionsMethod_put_MaxVertexNumber, METH_VARARGS, ""},
    {"get_MaxVertexNumber", (PyCFunction)IExportVectorOptionsMethod_get_MaxVertexNumber, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportVectorOptionsGetSet[] = {
  {"_pUnk", (getter)PyIExportVectorOptions_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportVectorOptions", NULL},
  {"_pointer", (getter)PyIExportVectorOptions_GetPointer, NULL, "Get memory address for IExportVectorOptions", NULL},
  {"_IID", (getter)PyIExportVectorOptions_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportVectorOptions_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportVectorOptions_GetIgnoreFailures, (setter)PyIExportVectorOptions_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportVectorOptionsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportVectorOptionsObject",                          
                                              /* tp_name */
  sizeof(PyIExportVectorOptionsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportVectorOptionsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportVectorOptionsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportVectorOptionsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportVectorOptionsObject_new,                      
                                              /* tp_new */
};

// Interface IExportVectorOptionsEx

typedef struct PyIExportVectorOptionsExObject {
    PyObject_HEAD
    IExportVectorOptionsEx* m_pIExportVectorOptionsEx;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportVectorOptionsExObject;

static PyObject*
PyIExportVectorOptionsExObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportVectorOptionsExObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportVectorOptionsEx* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportVectorOptionsEx, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportVectorOptionsEx with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportVectorOptionsExObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportVectorOptionsEx");
            return NULL;
        }
        self->m_pIExportVectorOptionsEx = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportVectorOptionsEx");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportVectorOptionsEx");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportVectorOptionsEx* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportVectorOptionsEx, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportVectorOptionsEx");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportVectorOptionsExObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportVectorOptionsEx");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportVectorOptionsEx = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportVectorOptionsExObject_dealloc(PyIExportVectorOptionsExObject* self)
{
    if (self->m_pIExportVectorOptionsEx)
        self->m_pIExportVectorOptionsEx->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportVectorOptionsEx_GetpUnk(PyIExportVectorOptionsExObject* self)
{
    if (!self->m_pIExportVectorOptionsEx)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportVectorOptionsEx->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportVectorOptionsEx to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportVectorOptionsEx_GetPointer(PyIExportVectorOptionsExObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportVectorOptionsEx);
}

static PyObject*
PyIExportVectorOptionsEx_GetIID(PyIExportVectorOptionsExObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ccf50555-74e3-4f29-9ffe-1fc489d1552c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportVectorOptionsEx_GetHR(PyIExportVectorOptionsExObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportVectorOptionsEx_GetIgnoreFailures(PyIExportVectorOptionsExObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportVectorOptionsEx_SetIgnoreFailures(PyIExportVectorOptionsExObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportVectorOptionsEx_SupportsInterface(PyIExportVectorOptionsExObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportVectorOptionsEx->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportVectorOptionsExMethod_put_ExportPictureSymbolOptions(PyIExportVectorOptionsExObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPictureSymbolOptions eopt;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eopt))
      goto iexportvectoroptionsex_put_exportpicturesymboloptions_method_cleanup;

    // Set up initial variable values as needed
    // No setup for opt

    // Call method on actual COM interface
    hr = self->m_pIExportVectorOptionsEx->put_ExportPictureSymbolOptions(eopt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportVectorOptionsEx->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportVectorOptionsEx) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportVectorOptionsEx.put_ExportPictureSymbolOptions() returned %ld", (long)hr);
        goto iexportvectoroptionsex_put_exportpicturesymboloptions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for opt

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportvectoroptionsex_put_exportpicturesymboloptions_method_cleanup;

    iexportvectoroptionsex_put_exportpicturesymboloptions_method_cleanup:
    self->m_HR = hr;
    // No cleanup for opt
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportVectorOptionsEx.put_ExportPictureSymbolOptions");
    return return_tuple;
}

static PyObject*
IExportVectorOptionsExMethod_get_ExportPictureSymbolOptions(PyIExportVectorOptionsExObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPictureSymbolOptions eopt;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for opt

    // Call method on actual COM interface
    hr = self->m_pIExportVectorOptionsEx->get_ExportPictureSymbolOptions(&eopt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportVectorOptionsEx->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportVectorOptionsEx) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportVectorOptionsEx.get_ExportPictureSymbolOptions() returned %ld", (long)hr);
        goto iexportvectoroptionsex_get_exportpicturesymboloptions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for opt

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eopt);
    goto iexportvectoroptionsex_get_exportpicturesymboloptions_method_cleanup;

    iexportvectoroptionsex_get_exportpicturesymboloptions_method_cleanup:
    self->m_HR = hr;
    // No cleanup for opt
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportVectorOptionsEx.get_ExportPictureSymbolOptions");
    return return_tuple;
}


PyMethodDef PyIExportVectorOptionsExMethods[] = {
    {"supports", (PyCFunction)PyIExportVectorOptionsEx_SupportsInterface, METH_O, ""},
    {"put_ExportPictureSymbolOptions", (PyCFunction)IExportVectorOptionsExMethod_put_ExportPictureSymbolOptions, METH_VARARGS, ""},
    {"get_ExportPictureSymbolOptions", (PyCFunction)IExportVectorOptionsExMethod_get_ExportPictureSymbolOptions, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportVectorOptionsExGetSet[] = {
  {"_pUnk", (getter)PyIExportVectorOptionsEx_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportVectorOptionsEx", NULL},
  {"_pointer", (getter)PyIExportVectorOptionsEx_GetPointer, NULL, "Get memory address for IExportVectorOptionsEx", NULL},
  {"_IID", (getter)PyIExportVectorOptionsEx_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportVectorOptionsEx_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportVectorOptionsEx_GetIgnoreFailures, (setter)PyIExportVectorOptionsEx_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportVectorOptionsExObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportVectorOptionsExObject",                          
                                              /* tp_name */
  sizeof(PyIExportVectorOptionsExObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportVectorOptionsExObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportVectorOptionsExMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportVectorOptionsExGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportVectorOptionsExObject_new,                      
                                              /* tp_new */
};

// Interface IExportEMF

typedef struct PyIExportEMFObject {
    PyObject_HEAD
    IExportEMF* m_pIExportEMF;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportEMFObject;

static PyObject*
PyIExportEMFObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportEMFObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportEMF* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportEMF, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportEMF with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportEMFObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportEMF");
            return NULL;
        }
        self->m_pIExportEMF = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportEMF");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportEMF");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportEMF* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportEMF, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportEMF");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportEMFObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportEMF");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportEMF = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportEMFObject_dealloc(PyIExportEMFObject* self)
{
    if (self->m_pIExportEMF)
        self->m_pIExportEMF->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportEMF_GetpUnk(PyIExportEMFObject* self)
{
    if (!self->m_pIExportEMF)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportEMF->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportEMF to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportEMF_GetPointer(PyIExportEMFObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportEMF);
}

static PyObject*
PyIExportEMF_GetIID(PyIExportEMFObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "94123bcd-eae7-42a9-9fef-d09a57b87a0f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportEMF_GetHR(PyIExportEMFObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportEMF_GetIgnoreFailures(PyIExportEMFObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportEMF_SetIgnoreFailures(PyIExportEMFObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportEMF_SupportsInterface(PyIExportEMFObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportEMF->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportEMFMethod_get_Handle(PyIExportEMFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HpHandle = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHandle

    // Call method on actual COM interface
    hr = self->m_pIExportEMF->get_Handle(&HpHandle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportEMF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportEMF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportEMF.get_Handle() returned %ld", (long)hr);
        goto iexportemf_get_handle_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHandle

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HpHandle);
    goto iexportemf_get_handle_method_cleanup;

    iexportemf_get_handle_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHandle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportEMF.get_Handle");
    return return_tuple;
}

static PyObject*
IExportEMFMethod_put_Description(PyIExportEMFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDescription = 0;
    PyObject* pyvar_pDescription;
    PyObject* unicodepDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pDescription))
      goto iexportemf_put_description_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pDescription))
        unicodepDescription = PyUnicode_FromObject(pyvar_pDescription);
    else if (PyUnicode_Check(pyvar_pDescription))
    {
        unicodepDescription = pyvar_pDescription;
        Py_INCREF(unicodepDescription);
    }
    else if (pyvar_pDescription != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pDescription at index 0");
    if (unicodepDescription)
        bspDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepDescription));
    
    if (PyErr_Occurred())
      goto iexportemf_put_description_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportEMF->put_Description(bspDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportEMF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportEMF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportEMF.put_Description() returned %ld", (long)hr);
        goto iexportemf_put_description_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDescription

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportemf_put_description_method_cleanup;

    iexportemf_put_description_method_cleanup:
    self->m_HR = hr;
    if (bspDescription)
        ::SysFreeString(bspDescription);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportEMF.put_Description");
    return return_tuple;
}

static PyObject*
IExportEMFMethod_get_Description(PyIExportEMFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDescription;
    PyObject* pyvar_pDescription = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDescription

    // Call method on actual COM interface
    hr = self->m_pIExportEMF->get_Description(&bspDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportEMF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportEMF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportEMF.get_Description() returned %ld", (long)hr);
        goto iexportemf_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pDescription = PyUnicode_FromWideChar(bspDescription,::SysStringLen(bspDescription));
    ::SysFreeString(bspDescription);
    
    if (PyErr_Occurred())
      goto iexportemf_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pDescription);
    goto iexportemf_get_description_method_cleanup;

    iexportemf_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pDescription != Py_None)
        Py_XDECREF(pyvar_pDescription);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportEMF.get_Description");
    return return_tuple;
}


PyMethodDef PyIExportEMFMethods[] = {
    {"supports", (PyCFunction)PyIExportEMF_SupportsInterface, METH_O, ""},
    {"get_Handle", (PyCFunction)IExportEMFMethod_get_Handle, METH_VARARGS, ""},
    {"put_Description", (PyCFunction)IExportEMFMethod_put_Description, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)IExportEMFMethod_get_Description, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportEMFGetSet[] = {
  {"_pUnk", (getter)PyIExportEMF_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportEMF", NULL},
  {"_pointer", (getter)PyIExportEMF_GetPointer, NULL, "Get memory address for IExportEMF", NULL},
  {"_IID", (getter)PyIExportEMF_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportEMF_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportEMF_GetIgnoreFailures, (setter)PyIExportEMF_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportEMFObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportEMFObject",                          
                                              /* tp_name */
  sizeof(PyIExportEMFObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportEMFObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportEMFMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportEMFGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportEMFObject_new,                      
                                              /* tp_new */
};

// Interface IExportPS

typedef struct PyIExportPSObject {
    PyObject_HEAD
    IExportPS* m_pIExportPS;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportPSObject;

static PyObject*
PyIExportPSObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportPSObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportPS* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportPS, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportPS with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportPSObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPS");
            return NULL;
        }
        self->m_pIExportPS = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportPS");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportPS");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportPS* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportPS, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportPS");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportPSObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPS");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportPS = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportPSObject_dealloc(PyIExportPSObject* self)
{
    if (self->m_pIExportPS)
        self->m_pIExportPS->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportPS_GetpUnk(PyIExportPSObject* self)
{
    if (!self->m_pIExportPS)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportPS->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportPS to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportPS_GetPointer(PyIExportPSObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportPS);
}

static PyObject*
PyIExportPS_GetIID(PyIExportPSObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "efcd8d47-8d2a-47a4-b35b-15ca74bce73c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportPS_GetHR(PyIExportPSObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportPS_GetIgnoreFailures(PyIExportPSObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportPS_SetIgnoreFailures(PyIExportPSObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportPS_SupportsInterface(PyIExportPSObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportPSMethod_put_Emulsion(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportPSEmulsion eEmulsion;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eEmulsion))
      goto iexportps_put_emulsion_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Emulsion

    // Call method on actual COM interface
    hr = self->m_pIExportPS->put_Emulsion(eEmulsion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.put_Emulsion() returned %ld", (long)hr);
        goto iexportps_put_emulsion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Emulsion

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportps_put_emulsion_method_cleanup;

    iexportps_put_emulsion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Emulsion
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.put_Emulsion");
    return return_tuple;
}

static PyObject*
IExportPSMethod_get_Emulsion(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportPSEmulsion eEmulsion;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Emulsion

    // Call method on actual COM interface
    hr = self->m_pIExportPS->get_Emulsion(&eEmulsion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.get_Emulsion() returned %ld", (long)hr);
        goto iexportps_get_emulsion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Emulsion

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eEmulsion);
    goto iexportps_get_emulsion_method_cleanup;

    iexportps_get_emulsion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Emulsion
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.get_Emulsion");
    return return_tuple;
}

static PyObject*
IExportPSMethod_put_Image(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportPSImage eImage;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eImage))
      goto iexportps_put_image_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Image

    // Call method on actual COM interface
    hr = self->m_pIExportPS->put_Image(eImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.put_Image() returned %ld", (long)hr);
        goto iexportps_put_image_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Image

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportps_put_image_method_cleanup;

    iexportps_put_image_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Image
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.put_Image");
    return return_tuple;
}

static PyObject*
IExportPSMethod_get_Image(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportPSImage eImage;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Image

    // Call method on actual COM interface
    hr = self->m_pIExportPS->get_Image(&eImage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.get_Image() returned %ld", (long)hr);
        goto iexportps_get_image_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Image

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eImage);
    goto iexportps_get_image_method_cleanup;

    iexportps_get_image_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Image
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.get_Image");
    return return_tuple;
}

static PyObject*
IExportPSMethod_put_LanguageLevel(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportPSLanguageLevel epslevel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epslevel))
      goto iexportps_put_languagelevel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pslevel

    // Call method on actual COM interface
    hr = self->m_pIExportPS->put_LanguageLevel(epslevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.put_LanguageLevel() returned %ld", (long)hr);
        goto iexportps_put_languagelevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pslevel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportps_put_languagelevel_method_cleanup;

    iexportps_put_languagelevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pslevel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.put_LanguageLevel");
    return return_tuple;
}

static PyObject*
IExportPSMethod_get_LanguageLevel(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportPSLanguageLevel epslevel;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pslevel

    // Call method on actual COM interface
    hr = self->m_pIExportPS->get_LanguageLevel(&epslevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.get_LanguageLevel() returned %ld", (long)hr);
        goto iexportps_get_languagelevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pslevel

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epslevel);
    goto iexportps_get_languagelevel_method_cleanup;

    iexportps_get_languagelevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pslevel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.get_LanguageLevel");
    return return_tuple;
}

static PyObject*
IExportPSMethod_put_ImageCompression(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportImageCompression ecompression;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&ecompression))
      goto iexportps_put_imagecompression_method_cleanup;

    // Set up initial variable values as needed
    // No setup for compression

    // Call method on actual COM interface
    hr = self->m_pIExportPS->put_ImageCompression(ecompression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.put_ImageCompression() returned %ld", (long)hr);
        goto iexportps_put_imagecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for compression

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportps_put_imagecompression_method_cleanup;

    iexportps_put_imagecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for compression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.put_ImageCompression");
    return return_tuple;
}

static PyObject*
IExportPSMethod_get_ImageCompression(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportImageCompression ecompression;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for compression

    // Call method on actual COM interface
    hr = self->m_pIExportPS->get_ImageCompression(&ecompression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.get_ImageCompression() returned %ld", (long)hr);
        goto iexportps_get_imagecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for compression

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)ecompression);
    goto iexportps_get_imagecompression_method_cleanup;

    iexportps_get_imagecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for compression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.get_ImageCompression");
    return return_tuple;
}

static PyObject*
IExportPSMethod_put_EmbedFonts(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_EmbedFonts = VARIANT_FALSE;
    PyObject* pyvar_EmbedFonts = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_EmbedFonts))
      goto iexportps_put_embedfonts_method_cleanup;

    // Set up initial variable values as needed
    b_EmbedFonts = ((PyObject_IsTrue(pyvar_EmbedFonts) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportps_put_embedfonts_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportPS->put_EmbedFonts(b_EmbedFonts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.put_EmbedFonts() returned %ld", (long)hr);
        goto iexportps_put_embedfonts_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for EmbedFonts

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportps_put_embedfonts_method_cleanup;

    iexportps_put_embedfonts_method_cleanup:
    self->m_HR = hr;
    // No cleanup for EmbedFonts
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.put_EmbedFonts");
    return return_tuple;
}

static PyObject*
IExportPSMethod_get_EmbedFonts(PyIExportPSObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_EmbedFonts = VARIANT_FALSE;
    PyObject* pyvar_EmbedFonts = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for EmbedFonts

    // Call method on actual COM interface
    hr = self->m_pIExportPS->get_EmbedFonts(&b_EmbedFonts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS.get_EmbedFonts() returned %ld", (long)hr);
        goto iexportps_get_embedfonts_method_cleanup;
    }

    // Set up return values as needed
    pyvar_EmbedFonts = ((b_EmbedFonts == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportps_get_embedfonts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_EmbedFonts);
    goto iexportps_get_embedfonts_method_cleanup;

    iexportps_get_embedfonts_method_cleanup:
    self->m_HR = hr;
    // No cleanup for EmbedFonts
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS.get_EmbedFonts");
    return return_tuple;
}


PyMethodDef PyIExportPSMethods[] = {
    {"supports", (PyCFunction)PyIExportPS_SupportsInterface, METH_O, ""},
    {"put_Emulsion", (PyCFunction)IExportPSMethod_put_Emulsion, METH_VARARGS, ""},
    {"get_Emulsion", (PyCFunction)IExportPSMethod_get_Emulsion, METH_VARARGS, ""},
    {"put_Image", (PyCFunction)IExportPSMethod_put_Image, METH_VARARGS, ""},
    {"get_Image", (PyCFunction)IExportPSMethod_get_Image, METH_VARARGS, ""},
    {"put_LanguageLevel", (PyCFunction)IExportPSMethod_put_LanguageLevel, METH_VARARGS, ""},
    {"get_LanguageLevel", (PyCFunction)IExportPSMethod_get_LanguageLevel, METH_VARARGS, ""},
    {"put_ImageCompression", (PyCFunction)IExportPSMethod_put_ImageCompression, METH_VARARGS, ""},
    {"get_ImageCompression", (PyCFunction)IExportPSMethod_get_ImageCompression, METH_VARARGS, ""},
    {"put_EmbedFonts", (PyCFunction)IExportPSMethod_put_EmbedFonts, METH_VARARGS, ""},
    {"get_EmbedFonts", (PyCFunction)IExportPSMethod_get_EmbedFonts, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportPSGetSet[] = {
  {"_pUnk", (getter)PyIExportPS_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportPS", NULL},
  {"_pointer", (getter)PyIExportPS_GetPointer, NULL, "Get memory address for IExportPS", NULL},
  {"_IID", (getter)PyIExportPS_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportPS_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportPS_GetIgnoreFailures, (setter)PyIExportPS_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportPSObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportPSObject",                          
                                              /* tp_name */
  sizeof(PyIExportPSObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportPSObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportPSMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportPSGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportPSObject_new,                      
                                              /* tp_new */
};

// Interface IExportPS2

typedef struct PyIExportPS2Object {
    PyObject_HEAD
    IExportPS2* m_pIExportPS2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportPS2Object;

static PyObject*
PyIExportPS2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportPS2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportPS2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportPS2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportPS2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportPS2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPS2");
            return NULL;
        }
        self->m_pIExportPS2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportPS2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportPS2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportPS2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportPS2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportPS2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportPS2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPS2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportPS2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportPS2Object_dealloc(PyIExportPS2Object* self)
{
    if (self->m_pIExportPS2)
        self->m_pIExportPS2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportPS2_GetpUnk(PyIExportPS2Object* self)
{
    if (!self->m_pIExportPS2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportPS2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportPS2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportPS2_GetPointer(PyIExportPS2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportPS2);
}

static PyObject*
PyIExportPS2_GetIID(PyIExportPS2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "36ce3f37-30c9-4544-afa6-89a7315abce7");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportPS2_GetHR(PyIExportPS2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportPS2_GetIgnoreFailures(PyIExportPS2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportPS2_SetIgnoreFailures(PyIExportPS2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportPS2_SupportsInterface(PyIExportPS2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportPS2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportPS2Method_put_JPEGCompressionQuality(PyIExportPS2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spImageQuality = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spImageQuality))
      goto iexportps2_put_jpegcompressionquality_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pImageQuality

    // Call method on actual COM interface
    hr = self->m_pIExportPS2->put_JPEGCompressionQuality(spImageQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS2.put_JPEGCompressionQuality() returned %ld", (long)hr);
        goto iexportps2_put_jpegcompressionquality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pImageQuality

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportps2_put_jpegcompressionquality_method_cleanup;

    iexportps2_put_jpegcompressionquality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pImageQuality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS2.put_JPEGCompressionQuality");
    return return_tuple;
}

static PyObject*
IExportPS2Method_get_JPEGCompressionQuality(PyIExportPS2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spImageQuality = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pImageQuality

    // Call method on actual COM interface
    hr = self->m_pIExportPS2->get_JPEGCompressionQuality(&spImageQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPS2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPS2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPS2.get_JPEGCompressionQuality() returned %ld", (long)hr);
        goto iexportps2_get_jpegcompressionquality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pImageQuality

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spImageQuality);
    goto iexportps2_get_jpegcompressionquality_method_cleanup;

    iexportps2_get_jpegcompressionquality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pImageQuality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPS2.get_JPEGCompressionQuality");
    return return_tuple;
}


PyMethodDef PyIExportPS2Methods[] = {
    {"supports", (PyCFunction)PyIExportPS2_SupportsInterface, METH_O, ""},
    {"put_JPEGCompressionQuality", (PyCFunction)IExportPS2Method_put_JPEGCompressionQuality, METH_VARARGS, ""},
    {"get_JPEGCompressionQuality", (PyCFunction)IExportPS2Method_get_JPEGCompressionQuality, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportPS2GetSet[] = {
  {"_pUnk", (getter)PyIExportPS2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportPS2", NULL},
  {"_pointer", (getter)PyIExportPS2_GetPointer, NULL, "Get memory address for IExportPS2", NULL},
  {"_IID", (getter)PyIExportPS2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportPS2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportPS2_GetIgnoreFailures, (setter)PyIExportPS2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportPS2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportPS2Object",                          
                                              /* tp_name */
  sizeof(PyIExportPS2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportPS2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportPS2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportPS2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportPS2Object_new,                      
                                              /* tp_new */
};

// Interface IExportPDF

typedef struct PyIExportPDFObject {
    PyObject_HEAD
    IExportPDF* m_pIExportPDF;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportPDFObject;

static PyObject*
PyIExportPDFObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportPDFObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportPDF* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportPDF, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportPDF with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportPDFObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPDF");
            return NULL;
        }
        self->m_pIExportPDF = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportPDF");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportPDF");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportPDF* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportPDF, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportPDF");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportPDFObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPDF");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportPDF = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportPDFObject_dealloc(PyIExportPDFObject* self)
{
    if (self->m_pIExportPDF)
        self->m_pIExportPDF->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportPDF_GetpUnk(PyIExportPDFObject* self)
{
    if (!self->m_pIExportPDF)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportPDF->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportPDF to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportPDF_GetPointer(PyIExportPDFObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportPDF);
}

static PyObject*
PyIExportPDF_GetIID(PyIExportPDFObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6a2a0820-e1b6-4eb0-af9b-6449dae7a952");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportPDF_GetHR(PyIExportPDFObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportPDF_GetIgnoreFailures(PyIExportPDFObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportPDF_SetIgnoreFailures(PyIExportPDFObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportPDF_SupportsInterface(PyIExportPDFObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportPDF->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportPDFMethod_get_Compressed(PyIExportPDFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Compressed

    // Call method on actual COM interface
    hr = self->m_pIExportPDF->get_Compressed(&b_Compressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF.get_Compressed() returned %ld", (long)hr);
        goto iexportpdf_get_compressed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Compressed = ((b_Compressed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportpdf_get_compressed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Compressed);
    goto iexportpdf_get_compressed_method_cleanup;

    iexportpdf_get_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Compressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF.get_Compressed");
    return return_tuple;
}

static PyObject*
IExportPDFMethod_put_Compressed(PyIExportPDFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Compressed))
      goto iexportpdf_put_compressed_method_cleanup;

    // Set up initial variable values as needed
    b_Compressed = ((PyObject_IsTrue(pyvar_Compressed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportpdf_put_compressed_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportPDF->put_Compressed(b_Compressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF.put_Compressed() returned %ld", (long)hr);
        goto iexportpdf_put_compressed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Compressed

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdf_put_compressed_method_cleanup;

    iexportpdf_put_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Compressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF.put_Compressed");
    return return_tuple;
}

static PyObject*
IExportPDFMethod_put_ImageCompression(PyIExportPDFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportImageCompression ecompression;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&ecompression))
      goto iexportpdf_put_imagecompression_method_cleanup;

    // Set up initial variable values as needed
    // No setup for compression

    // Call method on actual COM interface
    hr = self->m_pIExportPDF->put_ImageCompression(ecompression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF.put_ImageCompression() returned %ld", (long)hr);
        goto iexportpdf_put_imagecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for compression

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdf_put_imagecompression_method_cleanup;

    iexportpdf_put_imagecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for compression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF.put_ImageCompression");
    return return_tuple;
}

static PyObject*
IExportPDFMethod_get_ImageCompression(PyIExportPDFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportImageCompression ecompression;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for compression

    // Call method on actual COM interface
    hr = self->m_pIExportPDF->get_ImageCompression(&ecompression);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF.get_ImageCompression() returned %ld", (long)hr);
        goto iexportpdf_get_imagecompression_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for compression

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)ecompression);
    goto iexportpdf_get_imagecompression_method_cleanup;

    iexportpdf_get_imagecompression_method_cleanup:
    self->m_HR = hr;
    // No cleanup for compression
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF.get_ImageCompression");
    return return_tuple;
}

static PyObject*
IExportPDFMethod_put_EmbedFonts(PyIExportPDFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_EmbedFonts = VARIANT_FALSE;
    PyObject* pyvar_EmbedFonts = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_EmbedFonts))
      goto iexportpdf_put_embedfonts_method_cleanup;

    // Set up initial variable values as needed
    b_EmbedFonts = ((PyObject_IsTrue(pyvar_EmbedFonts) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportpdf_put_embedfonts_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportPDF->put_EmbedFonts(b_EmbedFonts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF.put_EmbedFonts() returned %ld", (long)hr);
        goto iexportpdf_put_embedfonts_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for EmbedFonts

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdf_put_embedfonts_method_cleanup;

    iexportpdf_put_embedfonts_method_cleanup:
    self->m_HR = hr;
    // No cleanup for EmbedFonts
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF.put_EmbedFonts");
    return return_tuple;
}

static PyObject*
IExportPDFMethod_get_EmbedFonts(PyIExportPDFObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_EmbedFonts = VARIANT_FALSE;
    PyObject* pyvar_EmbedFonts = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for EmbedFonts

    // Call method on actual COM interface
    hr = self->m_pIExportPDF->get_EmbedFonts(&b_EmbedFonts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF.get_EmbedFonts() returned %ld", (long)hr);
        goto iexportpdf_get_embedfonts_method_cleanup;
    }

    // Set up return values as needed
    pyvar_EmbedFonts = ((b_EmbedFonts == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportpdf_get_embedfonts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_EmbedFonts);
    goto iexportpdf_get_embedfonts_method_cleanup;

    iexportpdf_get_embedfonts_method_cleanup:
    self->m_HR = hr;
    // No cleanup for EmbedFonts
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF.get_EmbedFonts");
    return return_tuple;
}


PyMethodDef PyIExportPDFMethods[] = {
    {"supports", (PyCFunction)PyIExportPDF_SupportsInterface, METH_O, ""},
    {"get_Compressed", (PyCFunction)IExportPDFMethod_get_Compressed, METH_VARARGS, ""},
    {"put_Compressed", (PyCFunction)IExportPDFMethod_put_Compressed, METH_VARARGS, ""},
    {"put_ImageCompression", (PyCFunction)IExportPDFMethod_put_ImageCompression, METH_VARARGS, ""},
    {"get_ImageCompression", (PyCFunction)IExportPDFMethod_get_ImageCompression, METH_VARARGS, ""},
    {"put_EmbedFonts", (PyCFunction)IExportPDFMethod_put_EmbedFonts, METH_VARARGS, ""},
    {"get_EmbedFonts", (PyCFunction)IExportPDFMethod_get_EmbedFonts, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportPDFGetSet[] = {
  {"_pUnk", (getter)PyIExportPDF_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportPDF", NULL},
  {"_pointer", (getter)PyIExportPDF_GetPointer, NULL, "Get memory address for IExportPDF", NULL},
  {"_IID", (getter)PyIExportPDF_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportPDF_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportPDF_GetIgnoreFailures, (setter)PyIExportPDF_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportPDFObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportPDFObject",                          
                                              /* tp_name */
  sizeof(PyIExportPDFObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportPDFObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportPDFMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportPDFGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportPDFObject_new,                      
                                              /* tp_new */
};

// Interface IExportPDF2

typedef struct PyIExportPDF2Object {
    PyObject_HEAD
    IExportPDF2* m_pIExportPDF2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportPDF2Object;

static PyObject*
PyIExportPDF2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportPDF2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportPDF2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportPDF2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportPDF2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportPDF2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPDF2");
            return NULL;
        }
        self->m_pIExportPDF2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportPDF2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportPDF2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportPDF2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportPDF2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportPDF2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportPDF2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPDF2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportPDF2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportPDF2Object_dealloc(PyIExportPDF2Object* self)
{
    if (self->m_pIExportPDF2)
        self->m_pIExportPDF2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportPDF2_GetpUnk(PyIExportPDF2Object* self)
{
    if (!self->m_pIExportPDF2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportPDF2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportPDF2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportPDF2_GetPointer(PyIExportPDF2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportPDF2);
}

static PyObject*
PyIExportPDF2_GetIID(PyIExportPDF2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "86d86855-631d-4a75-ad19-725b460208c7");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportPDF2_GetHR(PyIExportPDF2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportPDF2_GetIgnoreFailures(PyIExportPDF2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportPDF2_SetIgnoreFailures(PyIExportPDF2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportPDF2_SupportsInterface(PyIExportPDF2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportPDF2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportPDF2Method_put_ExportPDFLayersAndFeatureAttributes(PyIExportPDF2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportPDFLayerOptions epOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epOption))
      goto iexportpdf2_put_exportpdflayersandfeatureattributes_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pOption

    // Call method on actual COM interface
    hr = self->m_pIExportPDF2->put_ExportPDFLayersAndFeatureAttributes(epOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF2.put_ExportPDFLayersAndFeatureAttributes() returned %ld", (long)hr);
        goto iexportpdf2_put_exportpdflayersandfeatureattributes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdf2_put_exportpdflayersandfeatureattributes_method_cleanup;

    iexportpdf2_put_exportpdflayersandfeatureattributes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF2.put_ExportPDFLayersAndFeatureAttributes");
    return return_tuple;
}

static PyObject*
IExportPDF2Method_get_ExportPDFLayersAndFeatureAttributes(PyIExportPDF2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportPDFLayerOptions epOption;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pOption

    // Call method on actual COM interface
    hr = self->m_pIExportPDF2->get_ExportPDFLayersAndFeatureAttributes(&epOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF2.get_ExportPDFLayersAndFeatureAttributes() returned %ld", (long)hr);
        goto iexportpdf2_get_exportpdflayersandfeatureattributes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOption

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epOption);
    goto iexportpdf2_get_exportpdflayersandfeatureattributes_method_cleanup;

    iexportpdf2_get_exportpdflayersandfeatureattributes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF2.get_ExportPDFLayersAndFeatureAttributes");
    return return_tuple;
}

static PyObject*
IExportPDF2Method_put_ExportMeasureInfo(PyIExportPDF2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbMeasureInformation = VARIANT_FALSE;
    PyObject* pyvar_pbMeasureInformation = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbMeasureInformation))
      goto iexportpdf2_put_exportmeasureinfo_method_cleanup;

    // Set up initial variable values as needed
    b_pbMeasureInformation = ((PyObject_IsTrue(pyvar_pbMeasureInformation) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportpdf2_put_exportmeasureinfo_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportPDF2->put_ExportMeasureInfo(b_pbMeasureInformation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF2.put_ExportMeasureInfo() returned %ld", (long)hr);
        goto iexportpdf2_put_exportmeasureinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbMeasureInformation

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdf2_put_exportmeasureinfo_method_cleanup;

    iexportpdf2_put_exportmeasureinfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbMeasureInformation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF2.put_ExportMeasureInfo");
    return return_tuple;
}

static PyObject*
IExportPDF2Method_get_ExportMeasureInfo(PyIExportPDF2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbMeasureInformation = VARIANT_FALSE;
    PyObject* pyvar_pbMeasureInformation = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbMeasureInformation

    // Call method on actual COM interface
    hr = self->m_pIExportPDF2->get_ExportMeasureInfo(&b_pbMeasureInformation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF2.get_ExportMeasureInfo() returned %ld", (long)hr);
        goto iexportpdf2_get_exportmeasureinfo_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbMeasureInformation = ((b_pbMeasureInformation == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportpdf2_get_exportmeasureinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbMeasureInformation);
    goto iexportpdf2_get_exportmeasureinfo_method_cleanup;

    iexportpdf2_get_exportmeasureinfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbMeasureInformation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF2.get_ExportMeasureInfo");
    return return_tuple;
}


PyMethodDef PyIExportPDF2Methods[] = {
    {"supports", (PyCFunction)PyIExportPDF2_SupportsInterface, METH_O, ""},
    {"put_ExportPDFLayersAndFeatureAttributes", (PyCFunction)IExportPDF2Method_put_ExportPDFLayersAndFeatureAttributes, METH_VARARGS, ""},
    {"get_ExportPDFLayersAndFeatureAttributes", (PyCFunction)IExportPDF2Method_get_ExportPDFLayersAndFeatureAttributes, METH_VARARGS, ""},
    {"put_ExportMeasureInfo", (PyCFunction)IExportPDF2Method_put_ExportMeasureInfo, METH_VARARGS, ""},
    {"get_ExportMeasureInfo", (PyCFunction)IExportPDF2Method_get_ExportMeasureInfo, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportPDF2GetSet[] = {
  {"_pUnk", (getter)PyIExportPDF2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportPDF2", NULL},
  {"_pointer", (getter)PyIExportPDF2_GetPointer, NULL, "Get memory address for IExportPDF2", NULL},
  {"_IID", (getter)PyIExportPDF2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportPDF2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportPDF2_GetIgnoreFailures, (setter)PyIExportPDF2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportPDF2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportPDF2Object",                          
                                              /* tp_name */
  sizeof(PyIExportPDF2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportPDF2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportPDF2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportPDF2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportPDF2Object_new,                      
                                              /* tp_new */
};

// Interface IExportPDF3

typedef struct PyIExportPDF3Object {
    PyObject_HEAD
    IExportPDF3* m_pIExportPDF3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportPDF3Object;

static PyObject*
PyIExportPDF3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportPDF3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportPDF3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportPDF3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportPDF3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportPDF3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPDF3");
            return NULL;
        }
        self->m_pIExportPDF3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportPDF3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportPDF3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportPDF3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportPDF3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportPDF3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportPDF3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPDF3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportPDF3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportPDF3Object_dealloc(PyIExportPDF3Object* self)
{
    if (self->m_pIExportPDF3)
        self->m_pIExportPDF3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportPDF3_GetpUnk(PyIExportPDF3Object* self)
{
    if (!self->m_pIExportPDF3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportPDF3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportPDF3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportPDF3_GetPointer(PyIExportPDF3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportPDF3);
}

static PyObject*
PyIExportPDF3_GetIID(PyIExportPDF3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "083bc81c-e835-4103-aad6-454aa037966b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportPDF3_GetHR(PyIExportPDF3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportPDF3_GetIgnoreFailures(PyIExportPDF3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportPDF3_SetIgnoreFailures(PyIExportPDF3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportPDF3_SupportsInterface(PyIExportPDF3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportPDF3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportPDF3Method_put_JPEGCompressionQuality(PyIExportPDF3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spImageQuality = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spImageQuality))
      goto iexportpdf3_put_jpegcompressionquality_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pImageQuality

    // Call method on actual COM interface
    hr = self->m_pIExportPDF3->put_JPEGCompressionQuality(spImageQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF3.put_JPEGCompressionQuality() returned %ld", (long)hr);
        goto iexportpdf3_put_jpegcompressionquality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pImageQuality

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdf3_put_jpegcompressionquality_method_cleanup;

    iexportpdf3_put_jpegcompressionquality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pImageQuality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF3.put_JPEGCompressionQuality");
    return return_tuple;
}

static PyObject*
IExportPDF3Method_get_JPEGCompressionQuality(PyIExportPDF3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spImageQuality = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pImageQuality

    // Call method on actual COM interface
    hr = self->m_pIExportPDF3->get_JPEGCompressionQuality(&spImageQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDF3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDF3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDF3.get_JPEGCompressionQuality() returned %ld", (long)hr);
        goto iexportpdf3_get_jpegcompressionquality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pImageQuality

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spImageQuality);
    goto iexportpdf3_get_jpegcompressionquality_method_cleanup;

    iexportpdf3_get_jpegcompressionquality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pImageQuality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDF3.get_JPEGCompressionQuality");
    return return_tuple;
}


PyMethodDef PyIExportPDF3Methods[] = {
    {"supports", (PyCFunction)PyIExportPDF3_SupportsInterface, METH_O, ""},
    {"put_JPEGCompressionQuality", (PyCFunction)IExportPDF3Method_put_JPEGCompressionQuality, METH_VARARGS, ""},
    {"get_JPEGCompressionQuality", (PyCFunction)IExportPDF3Method_get_JPEGCompressionQuality, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportPDF3GetSet[] = {
  {"_pUnk", (getter)PyIExportPDF3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportPDF3", NULL},
  {"_pointer", (getter)PyIExportPDF3_GetPointer, NULL, "Get memory address for IExportPDF3", NULL},
  {"_IID", (getter)PyIExportPDF3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportPDF3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportPDF3_GetIgnoreFailures, (setter)PyIExportPDF3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportPDF3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportPDF3Object",                          
                                              /* tp_name */
  sizeof(PyIExportPDF3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportPDF3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportPDF3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportPDF3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportPDF3Object_new,                      
                                              /* tp_new */
};

// Interface IExportPagesMultipleFile

typedef struct PyIExportPagesMultipleFileObject {
    PyObject_HEAD
    IExportPagesMultipleFile* m_pIExportPagesMultipleFile;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportPagesMultipleFileObject;

static PyObject*
PyIExportPagesMultipleFileObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportPagesMultipleFileObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportPagesMultipleFile* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportPagesMultipleFile, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportPagesMultipleFile with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportPagesMultipleFileObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPagesMultipleFile");
            return NULL;
        }
        self->m_pIExportPagesMultipleFile = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportPagesMultipleFile");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportPagesMultipleFile");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportPagesMultipleFile* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportPagesMultipleFile, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportPagesMultipleFile");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportPagesMultipleFileObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPagesMultipleFile");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportPagesMultipleFile = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportPagesMultipleFileObject_dealloc(PyIExportPagesMultipleFileObject* self)
{
    if (self->m_pIExportPagesMultipleFile)
        self->m_pIExportPagesMultipleFile->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportPagesMultipleFile_GetpUnk(PyIExportPagesMultipleFileObject* self)
{
    if (!self->m_pIExportPagesMultipleFile)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportPagesMultipleFile->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportPagesMultipleFile to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportPagesMultipleFile_GetPointer(PyIExportPagesMultipleFileObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportPagesMultipleFile);
}

static PyObject*
PyIExportPagesMultipleFile_GetIID(PyIExportPagesMultipleFileObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1a551946-895a-4809-80d8-d417d654f3ac");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportPagesMultipleFile_GetHR(PyIExportPagesMultipleFileObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportPagesMultipleFile_GetIgnoreFailures(PyIExportPagesMultipleFileObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportPagesMultipleFile_SetIgnoreFailures(PyIExportPagesMultipleFileObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportPagesMultipleFile_SupportsInterface(PyIExportPagesMultipleFileObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportPagesMultipleFile->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportPagesMultipleFileMethod_put_MultipleFileOutput(PyIExportPagesMultipleFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportMultipleFiles epOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epOption))
      goto iexportpagesmultiplefile_put_multiplefileoutput_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pOption

    // Call method on actual COM interface
    hr = self->m_pIExportPagesMultipleFile->put_MultipleFileOutput(epOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPagesMultipleFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPagesMultipleFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPagesMultipleFile.put_MultipleFileOutput() returned %ld", (long)hr);
        goto iexportpagesmultiplefile_put_multiplefileoutput_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpagesmultiplefile_put_multiplefileoutput_method_cleanup;

    iexportpagesmultiplefile_put_multiplefileoutput_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPagesMultipleFile.put_MultipleFileOutput");
    return return_tuple;
}

static PyObject*
IExportPagesMultipleFileMethod_get_MultipleFileOutput(PyIExportPagesMultipleFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriExportMultipleFiles epOption;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pOption

    // Call method on actual COM interface
    hr = self->m_pIExportPagesMultipleFile->get_MultipleFileOutput(&epOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPagesMultipleFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPagesMultipleFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPagesMultipleFile.get_MultipleFileOutput() returned %ld", (long)hr);
        goto iexportpagesmultiplefile_get_multiplefileoutput_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOption

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epOption);
    goto iexportpagesmultiplefile_get_multiplefileoutput_method_cleanup;

    iexportpagesmultiplefile_get_multiplefileoutput_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPagesMultipleFile.get_MultipleFileOutput");
    return return_tuple;
}


PyMethodDef PyIExportPagesMultipleFileMethods[] = {
    {"supports", (PyCFunction)PyIExportPagesMultipleFile_SupportsInterface, METH_O, ""},
    {"put_MultipleFileOutput", (PyCFunction)IExportPagesMultipleFileMethod_put_MultipleFileOutput, METH_VARARGS, ""},
    {"get_MultipleFileOutput", (PyCFunction)IExportPagesMultipleFileMethod_get_MultipleFileOutput, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportPagesMultipleFileGetSet[] = {
  {"_pUnk", (getter)PyIExportPagesMultipleFile_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportPagesMultipleFile", NULL},
  {"_pointer", (getter)PyIExportPagesMultipleFile_GetPointer, NULL, "Get memory address for IExportPagesMultipleFile", NULL},
  {"_IID", (getter)PyIExportPagesMultipleFile_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportPagesMultipleFile_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportPagesMultipleFile_GetIgnoreFailures, (setter)PyIExportPagesMultipleFile_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportPagesMultipleFileObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportPagesMultipleFileObject",                          
                                              /* tp_name */
  sizeof(PyIExportPagesMultipleFileObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportPagesMultipleFileObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportPagesMultipleFileMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportPagesMultipleFileGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportPagesMultipleFileObject_new,                      
                                              /* tp_new */
};

// Interface IExportAI

typedef struct PyIExportAIObject {
    PyObject_HEAD
    IExportAI* m_pIExportAI;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportAIObject;

static PyObject*
PyIExportAIObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportAIObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportAI* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportAI, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportAI with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportAIObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportAI");
            return NULL;
        }
        self->m_pIExportAI = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportAI");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportAI");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportAI* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportAI, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportAI");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportAIObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportAI");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportAI = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportAIObject_dealloc(PyIExportAIObject* self)
{
    if (self->m_pIExportAI)
        self->m_pIExportAI->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportAI_GetpUnk(PyIExportAIObject* self)
{
    if (!self->m_pIExportAI)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportAI->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportAI to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportAI_GetPointer(PyIExportAIObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportAI);
}

static PyObject*
PyIExportAI_GetIID(PyIExportAIObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "69822e67-c74b-4138-ab20-aa4e00cb87dd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportAI_GetHR(PyIExportAIObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportAI_GetIgnoreFailures(PyIExportAIObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportAI_SetIgnoreFailures(PyIExportAIObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportAI_SupportsInterface(PyIExportAIObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportAI->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportAIMethod_put_EmbedFonts(PyIExportAIObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_EmbedFonts = VARIANT_FALSE;
    PyObject* pyvar_EmbedFonts = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_EmbedFonts))
      goto iexportai_put_embedfonts_method_cleanup;

    // Set up initial variable values as needed
    b_EmbedFonts = ((PyObject_IsTrue(pyvar_EmbedFonts) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportai_put_embedfonts_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportAI->put_EmbedFonts(b_EmbedFonts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportAI->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportAI) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportAI.put_EmbedFonts() returned %ld", (long)hr);
        goto iexportai_put_embedfonts_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for EmbedFonts

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportai_put_embedfonts_method_cleanup;

    iexportai_put_embedfonts_method_cleanup:
    self->m_HR = hr;
    // No cleanup for EmbedFonts
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportAI.put_EmbedFonts");
    return return_tuple;
}

static PyObject*
IExportAIMethod_get_EmbedFonts(PyIExportAIObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_EmbedFonts = VARIANT_FALSE;
    PyObject* pyvar_EmbedFonts = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for EmbedFonts

    // Call method on actual COM interface
    hr = self->m_pIExportAI->get_EmbedFonts(&b_EmbedFonts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportAI->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportAI) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportAI.get_EmbedFonts() returned %ld", (long)hr);
        goto iexportai_get_embedfonts_method_cleanup;
    }

    // Set up return values as needed
    pyvar_EmbedFonts = ((b_EmbedFonts == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportai_get_embedfonts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_EmbedFonts);
    goto iexportai_get_embedfonts_method_cleanup;

    iexportai_get_embedfonts_method_cleanup:
    self->m_HR = hr;
    // No cleanup for EmbedFonts
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportAI.get_EmbedFonts");
    return return_tuple;
}


PyMethodDef PyIExportAIMethods[] = {
    {"supports", (PyCFunction)PyIExportAI_SupportsInterface, METH_O, ""},
    {"put_EmbedFonts", (PyCFunction)IExportAIMethod_put_EmbedFonts, METH_VARARGS, ""},
    {"get_EmbedFonts", (PyCFunction)IExportAIMethod_get_EmbedFonts, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportAIGetSet[] = {
  {"_pUnk", (getter)PyIExportAI_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportAI", NULL},
  {"_pointer", (getter)PyIExportAI_GetPointer, NULL, "Get memory address for IExportAI", NULL},
  {"_IID", (getter)PyIExportAI_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportAI_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportAI_GetIgnoreFailures, (setter)PyIExportAI_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportAIObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportAIObject",                          
                                              /* tp_name */
  sizeof(PyIExportAIObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportAIObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportAIMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportAIGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportAIObject_new,                      
                                              /* tp_new */
};

// Interface IExportAI2

typedef struct PyIExportAI2Object {
    PyObject_HEAD
    IExportAI2* m_pIExportAI2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportAI2Object;

static PyObject*
PyIExportAI2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportAI2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportAI2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportAI2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportAI2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportAI2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportAI2");
            return NULL;
        }
        self->m_pIExportAI2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportAI2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportAI2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportAI2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportAI2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportAI2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportAI2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportAI2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportAI2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportAI2Object_dealloc(PyIExportAI2Object* self)
{
    if (self->m_pIExportAI2)
        self->m_pIExportAI2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportAI2_GetpUnk(PyIExportAI2Object* self)
{
    if (!self->m_pIExportAI2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportAI2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportAI2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportAI2_GetPointer(PyIExportAI2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportAI2);
}

static PyObject*
PyIExportAI2_GetIID(PyIExportAI2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0ab19cc6-7c0b-4916-8d8d-8b6b9c4e4a8a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportAI2_GetHR(PyIExportAI2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportAI2_GetIgnoreFailures(PyIExportAI2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportAI2_SetIgnoreFailures(PyIExportAI2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportAI2_SupportsInterface(PyIExportAI2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportAI2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportAI2Method_put_ExportFeatureName(PyIExportAI2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pExportAttrs = VARIANT_FALSE;
    PyObject* pyvar_pExportAttrs = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pExportAttrs))
      goto iexportai2_put_exportfeaturename_method_cleanup;

    // Set up initial variable values as needed
    b_pExportAttrs = ((PyObject_IsTrue(pyvar_pExportAttrs) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportai2_put_exportfeaturename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportAI2->put_ExportFeatureName(b_pExportAttrs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportAI2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportAI2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportAI2.put_ExportFeatureName() returned %ld", (long)hr);
        goto iexportai2_put_exportfeaturename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pExportAttrs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportai2_put_exportfeaturename_method_cleanup;

    iexportai2_put_exportfeaturename_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pExportAttrs
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportAI2.put_ExportFeatureName");
    return return_tuple;
}

static PyObject*
IExportAI2Method_get_ExportFeatureName(PyIExportAI2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pExportAttrs = VARIANT_FALSE;
    PyObject* pyvar_pExportAttrs = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pExportAttrs

    // Call method on actual COM interface
    hr = self->m_pIExportAI2->get_ExportFeatureName(&b_pExportAttrs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportAI2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportAI2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportAI2.get_ExportFeatureName() returned %ld", (long)hr);
        goto iexportai2_get_exportfeaturename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pExportAttrs = ((b_pExportAttrs == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportai2_get_exportfeaturename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pExportAttrs);
    goto iexportai2_get_exportfeaturename_method_cleanup;

    iexportai2_get_exportfeaturename_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pExportAttrs
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportAI2.get_ExportFeatureName");
    return return_tuple;
}


PyMethodDef PyIExportAI2Methods[] = {
    {"supports", (PyCFunction)PyIExportAI2_SupportsInterface, METH_O, ""},
    {"put_ExportFeatureName", (PyCFunction)IExportAI2Method_put_ExportFeatureName, METH_VARARGS, ""},
    {"get_ExportFeatureName", (PyCFunction)IExportAI2Method_get_ExportFeatureName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportAI2GetSet[] = {
  {"_pUnk", (getter)PyIExportAI2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportAI2", NULL},
  {"_pointer", (getter)PyIExportAI2_GetPointer, NULL, "Get memory address for IExportAI2", NULL},
  {"_IID", (getter)PyIExportAI2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportAI2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportAI2_GetIgnoreFailures, (setter)PyIExportAI2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportAI2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportAI2Object",                          
                                              /* tp_name */
  sizeof(PyIExportAI2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportAI2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportAI2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportAI2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportAI2Object_new,                      
                                              /* tp_new */
};

// Interface IExportSVG

typedef struct PyIExportSVGObject {
    PyObject_HEAD
    IExportSVG* m_pIExportSVG;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportSVGObject;

static PyObject*
PyIExportSVGObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportSVGObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportSVG* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportSVG, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportSVG with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportSVGObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportSVG");
            return NULL;
        }
        self->m_pIExportSVG = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportSVG");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportSVG");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportSVG* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportSVG, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportSVG");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportSVGObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportSVG");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportSVG = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportSVGObject_dealloc(PyIExportSVGObject* self)
{
    if (self->m_pIExportSVG)
        self->m_pIExportSVG->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportSVG_GetpUnk(PyIExportSVGObject* self)
{
    if (!self->m_pIExportSVG)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportSVG->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportSVG to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportSVG_GetPointer(PyIExportSVGObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportSVG);
}

static PyObject*
PyIExportSVG_GetIID(PyIExportSVGObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0a149c8e-5d95-4a5c-9f48-5d30b3f12fa2");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportSVG_GetHR(PyIExportSVGObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportSVG_GetIgnoreFailures(PyIExportSVGObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportSVG_SetIgnoreFailures(PyIExportSVGObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportSVG_SupportsInterface(PyIExportSVGObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportSVG->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportSVGMethod_get_Compressed(PyIExportSVGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Compressed

    // Call method on actual COM interface
    hr = self->m_pIExportSVG->get_Compressed(&b_Compressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportSVG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportSVG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportSVG.get_Compressed() returned %ld", (long)hr);
        goto iexportsvg_get_compressed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Compressed = ((b_Compressed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportsvg_get_compressed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Compressed);
    goto iexportsvg_get_compressed_method_cleanup;

    iexportsvg_get_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Compressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportSVG.get_Compressed");
    return return_tuple;
}

static PyObject*
IExportSVGMethod_put_Compressed(PyIExportSVGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Compressed))
      goto iexportsvg_put_compressed_method_cleanup;

    // Set up initial variable values as needed
    b_Compressed = ((PyObject_IsTrue(pyvar_Compressed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportsvg_put_compressed_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportSVG->put_Compressed(b_Compressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportSVG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportSVG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportSVG.put_Compressed() returned %ld", (long)hr);
        goto iexportsvg_put_compressed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Compressed

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportsvg_put_compressed_method_cleanup;

    iexportsvg_put_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Compressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportSVG.put_Compressed");
    return return_tuple;
}

static PyObject*
IExportSVGMethod_put_EmbedFonts(PyIExportSVGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_EmbedFonts = VARIANT_FALSE;
    PyObject* pyvar_EmbedFonts = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_EmbedFonts))
      goto iexportsvg_put_embedfonts_method_cleanup;

    // Set up initial variable values as needed
    b_EmbedFonts = ((PyObject_IsTrue(pyvar_EmbedFonts) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportsvg_put_embedfonts_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportSVG->put_EmbedFonts(b_EmbedFonts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportSVG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportSVG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportSVG.put_EmbedFonts() returned %ld", (long)hr);
        goto iexportsvg_put_embedfonts_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for EmbedFonts

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportsvg_put_embedfonts_method_cleanup;

    iexportsvg_put_embedfonts_method_cleanup:
    self->m_HR = hr;
    // No cleanup for EmbedFonts
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportSVG.put_EmbedFonts");
    return return_tuple;
}

static PyObject*
IExportSVGMethod_get_EmbedFonts(PyIExportSVGObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_EmbedFonts = VARIANT_FALSE;
    PyObject* pyvar_EmbedFonts = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for EmbedFonts

    // Call method on actual COM interface
    hr = self->m_pIExportSVG->get_EmbedFonts(&b_EmbedFonts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportSVG->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportSVG) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportSVG.get_EmbedFonts() returned %ld", (long)hr);
        goto iexportsvg_get_embedfonts_method_cleanup;
    }

    // Set up return values as needed
    pyvar_EmbedFonts = ((b_EmbedFonts == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iexportsvg_get_embedfonts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_EmbedFonts);
    goto iexportsvg_get_embedfonts_method_cleanup;

    iexportsvg_get_embedfonts_method_cleanup:
    self->m_HR = hr;
    // No cleanup for EmbedFonts
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportSVG.get_EmbedFonts");
    return return_tuple;
}


PyMethodDef PyIExportSVGMethods[] = {
    {"supports", (PyCFunction)PyIExportSVG_SupportsInterface, METH_O, ""},
    {"get_Compressed", (PyCFunction)IExportSVGMethod_get_Compressed, METH_VARARGS, ""},
    {"put_Compressed", (PyCFunction)IExportSVGMethod_put_Compressed, METH_VARARGS, ""},
    {"put_EmbedFonts", (PyCFunction)IExportSVGMethod_put_EmbedFonts, METH_VARARGS, ""},
    {"get_EmbedFonts", (PyCFunction)IExportSVGMethod_get_EmbedFonts, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportSVGGetSet[] = {
  {"_pUnk", (getter)PyIExportSVG_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportSVG", NULL},
  {"_pointer", (getter)PyIExportSVG_GetPointer, NULL, "Get memory address for IExportSVG", NULL},
  {"_IID", (getter)PyIExportSVG_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportSVG_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportSVG_GetIgnoreFailures, (setter)PyIExportSVG_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportSVGObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportSVGObject",                          
                                              /* tp_name */
  sizeof(PyIExportSVGObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportSVGObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportSVGMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportSVGGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportSVGObject_new,                      
                                              /* tp_new */
};

// Interface IExportPDFPasswordSecurity

typedef struct PyIExportPDFPasswordSecurityObject {
    PyObject_HEAD
    IExportPDFPasswordSecurity* m_pIExportPDFPasswordSecurity;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportPDFPasswordSecurityObject;

static PyObject*
PyIExportPDFPasswordSecurityObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportPDFPasswordSecurityObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportPDFPasswordSecurity* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportPDFPasswordSecurity, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportPDFPasswordSecurity with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportPDFPasswordSecurityObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPDFPasswordSecurity");
            return NULL;
        }
        self->m_pIExportPDFPasswordSecurity = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportPDFPasswordSecurity");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportPDFPasswordSecurity");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportPDFPasswordSecurity* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportPDFPasswordSecurity, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportPDFPasswordSecurity");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportPDFPasswordSecurityObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportPDFPasswordSecurity");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportPDFPasswordSecurity = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportPDFPasswordSecurityObject_dealloc(PyIExportPDFPasswordSecurityObject* self)
{
    if (self->m_pIExportPDFPasswordSecurity)
        self->m_pIExportPDFPasswordSecurity->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportPDFPasswordSecurity_GetpUnk(PyIExportPDFPasswordSecurityObject* self)
{
    if (!self->m_pIExportPDFPasswordSecurity)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportPDFPasswordSecurity to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportPDFPasswordSecurity_GetPointer(PyIExportPDFPasswordSecurityObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportPDFPasswordSecurity);
}

static PyObject*
PyIExportPDFPasswordSecurity_GetIID(PyIExportPDFPasswordSecurityObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6c9a13e6-f9ec-4ebf-af52-bb1d822622df");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportPDFPasswordSecurity_GetHR(PyIExportPDFPasswordSecurityObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportPDFPasswordSecurity_GetIgnoreFailures(PyIExportPDFPasswordSecurityObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportPDFPasswordSecurity_SetIgnoreFailures(PyIExportPDFPasswordSecurityObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportPDFPasswordSecurity_SupportsInterface(PyIExportPDFPasswordSecurityObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportPDFPasswordSecurityMethod_put_UserPassword(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspPasswd = 0;
    PyObject* pyvar_pPasswd;
    PyObject* unicodepPasswd = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pPasswd))
      goto iexportpdfpasswordsecurity_put_userpassword_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pPasswd))
        unicodepPasswd = PyUnicode_FromObject(pyvar_pPasswd);
    else if (PyUnicode_Check(pyvar_pPasswd))
    {
        unicodepPasswd = pyvar_pPasswd;
        Py_INCREF(unicodepPasswd);
    }
    else if (pyvar_pPasswd != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pPasswd at index 0");
    if (unicodepPasswd)
        bspPasswd = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepPasswd), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepPasswd));
    
    if (PyErr_Occurred())
      goto iexportpdfpasswordsecurity_put_userpassword_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->put_UserPassword(bspPasswd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.put_UserPassword() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_put_userpassword_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPasswd

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdfpasswordsecurity_put_userpassword_method_cleanup;

    iexportpdfpasswordsecurity_put_userpassword_method_cleanup:
    self->m_HR = hr;
    if (bspPasswd)
        ::SysFreeString(bspPasswd);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.put_UserPassword");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_get_UserPassword(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspPasswd;
    PyObject* pyvar_pPasswd = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPasswd

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->get_UserPassword(&bspPasswd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.get_UserPassword() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_get_userpassword_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pPasswd = PyUnicode_FromWideChar(bspPasswd,::SysStringLen(bspPasswd));
    ::SysFreeString(bspPasswd);
    
    if (PyErr_Occurred())
      goto iexportpdfpasswordsecurity_get_userpassword_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pPasswd);
    goto iexportpdfpasswordsecurity_get_userpassword_method_cleanup;

    iexportpdfpasswordsecurity_get_userpassword_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pPasswd != Py_None)
        Py_XDECREF(pyvar_pPasswd);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.get_UserPassword");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_put_MasterPassword(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspPasswd = 0;
    PyObject* pyvar_pPasswd;
    PyObject* unicodepPasswd = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pPasswd))
      goto iexportpdfpasswordsecurity_put_masterpassword_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pPasswd))
        unicodepPasswd = PyUnicode_FromObject(pyvar_pPasswd);
    else if (PyUnicode_Check(pyvar_pPasswd))
    {
        unicodepPasswd = pyvar_pPasswd;
        Py_INCREF(unicodepPasswd);
    }
    else if (pyvar_pPasswd != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pPasswd at index 0");
    if (unicodepPasswd)
        bspPasswd = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepPasswd), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepPasswd));
    
    if (PyErr_Occurred())
      goto iexportpdfpasswordsecurity_put_masterpassword_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->put_MasterPassword(bspPasswd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.put_MasterPassword() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_put_masterpassword_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPasswd

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdfpasswordsecurity_put_masterpassword_method_cleanup;

    iexportpdfpasswordsecurity_put_masterpassword_method_cleanup:
    self->m_HR = hr;
    if (bspPasswd)
        ::SysFreeString(bspPasswd);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.put_MasterPassword");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_get_MasterPassword(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspPasswd;
    PyObject* pyvar_pPasswd = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPasswd

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->get_MasterPassword(&bspPasswd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.get_MasterPassword() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_get_masterpassword_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pPasswd = PyUnicode_FromWideChar(bspPasswd,::SysStringLen(bspPasswd));
    ::SysFreeString(bspPasswd);
    
    if (PyErr_Occurred())
      goto iexportpdfpasswordsecurity_get_masterpassword_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pPasswd);
    goto iexportpdfpasswordsecurity_get_masterpassword_method_cleanup;

    iexportpdfpasswordsecurity_get_masterpassword_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pPasswd != Py_None)
        Py_XDECREF(pyvar_pPasswd);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.get_MasterPassword");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_put_SecurityPermissions(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpPermission = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpPermission))
      goto iexportpdfpasswordsecurity_put_securitypermissions_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pPermission

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->put_SecurityPermissions(lpPermission);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.put_SecurityPermissions() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_put_securitypermissions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPermission

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdfpasswordsecurity_put_securitypermissions_method_cleanup;

    iexportpdfpasswordsecurity_put_securitypermissions_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPermission
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.put_SecurityPermissions");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_get_SecurityPermissions(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpPermission = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPermission

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->get_SecurityPermissions(&lpPermission);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.get_SecurityPermissions() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_get_securitypermissions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPermission

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpPermission);
    goto iexportpdfpasswordsecurity_get_securitypermissions_method_cleanup;

    iexportpdfpasswordsecurity_get_securitypermissions_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPermission
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.get_SecurityPermissions");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_put_SecurityEncryptionOption(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPDFExtensionSecurityEncryptionOption epEncryptionOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epEncryptionOption))
      goto iexportpdfpasswordsecurity_put_securityencryptionoption_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pEncryptionOption

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->put_SecurityEncryptionOption(epEncryptionOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.put_SecurityEncryptionOption() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_put_securityencryptionoption_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pEncryptionOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdfpasswordsecurity_put_securityencryptionoption_method_cleanup;

    iexportpdfpasswordsecurity_put_securityencryptionoption_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pEncryptionOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.put_SecurityEncryptionOption");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_get_SecurityEncryptionOption(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPDFExtensionSecurityEncryptionOption epEncryptionOption;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pEncryptionOption

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->get_SecurityEncryptionOption(&epEncryptionOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.get_SecurityEncryptionOption() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_get_securityencryptionoption_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pEncryptionOption

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epEncryptionOption);
    goto iexportpdfpasswordsecurity_get_securityencryptionoption_method_cleanup;

    iexportpdfpasswordsecurity_get_securityencryptionoption_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pEncryptionOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.get_SecurityEncryptionOption");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_put_SecurityEncryptionMethod(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPDFExtensionSecurityEncryptionMethod epEncryptionMethod;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epEncryptionMethod))
      goto iexportpdfpasswordsecurity_put_securityencryptionmethod_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pEncryptionMethod

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->put_SecurityEncryptionMethod(epEncryptionMethod);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.put_SecurityEncryptionMethod() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_put_securityencryptionmethod_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pEncryptionMethod

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportpdfpasswordsecurity_put_securityencryptionmethod_method_cleanup;

    iexportpdfpasswordsecurity_put_securityencryptionmethod_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pEncryptionMethod
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.put_SecurityEncryptionMethod");
    return return_tuple;
}

static PyObject*
IExportPDFPasswordSecurityMethod_get_SecurityEncryptionMethod(PyIExportPDFPasswordSecurityObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriPDFExtensionSecurityEncryptionMethod epEncryptionMethod;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pEncryptionMethod

    // Call method on actual COM interface
    hr = self->m_pIExportPDFPasswordSecurity->get_SecurityEncryptionMethod(&epEncryptionMethod);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportPDFPasswordSecurity->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportPDFPasswordSecurity) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportPDFPasswordSecurity.get_SecurityEncryptionMethod() returned %ld", (long)hr);
        goto iexportpdfpasswordsecurity_get_securityencryptionmethod_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pEncryptionMethod

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epEncryptionMethod);
    goto iexportpdfpasswordsecurity_get_securityencryptionmethod_method_cleanup;

    iexportpdfpasswordsecurity_get_securityencryptionmethod_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pEncryptionMethod
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportPDFPasswordSecurity.get_SecurityEncryptionMethod");
    return return_tuple;
}


PyMethodDef PyIExportPDFPasswordSecurityMethods[] = {
    {"supports", (PyCFunction)PyIExportPDFPasswordSecurity_SupportsInterface, METH_O, ""},
    {"put_UserPassword", (PyCFunction)IExportPDFPasswordSecurityMethod_put_UserPassword, METH_VARARGS, ""},
    {"get_UserPassword", (PyCFunction)IExportPDFPasswordSecurityMethod_get_UserPassword, METH_VARARGS, ""},
    {"put_MasterPassword", (PyCFunction)IExportPDFPasswordSecurityMethod_put_MasterPassword, METH_VARARGS, ""},
    {"get_MasterPassword", (PyCFunction)IExportPDFPasswordSecurityMethod_get_MasterPassword, METH_VARARGS, ""},
    {"put_SecurityPermissions", (PyCFunction)IExportPDFPasswordSecurityMethod_put_SecurityPermissions, METH_VARARGS, ""},
    {"get_SecurityPermissions", (PyCFunction)IExportPDFPasswordSecurityMethod_get_SecurityPermissions, METH_VARARGS, ""},
    {"put_SecurityEncryptionOption", (PyCFunction)IExportPDFPasswordSecurityMethod_put_SecurityEncryptionOption, METH_VARARGS, ""},
    {"get_SecurityEncryptionOption", (PyCFunction)IExportPDFPasswordSecurityMethod_get_SecurityEncryptionOption, METH_VARARGS, ""},
    {"put_SecurityEncryptionMethod", (PyCFunction)IExportPDFPasswordSecurityMethod_put_SecurityEncryptionMethod, METH_VARARGS, ""},
    {"get_SecurityEncryptionMethod", (PyCFunction)IExportPDFPasswordSecurityMethod_get_SecurityEncryptionMethod, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportPDFPasswordSecurityGetSet[] = {
  {"_pUnk", (getter)PyIExportPDFPasswordSecurity_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportPDFPasswordSecurity", NULL},
  {"_pointer", (getter)PyIExportPDFPasswordSecurity_GetPointer, NULL, "Get memory address for IExportPDFPasswordSecurity", NULL},
  {"_IID", (getter)PyIExportPDFPasswordSecurity_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportPDFPasswordSecurity_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportPDFPasswordSecurity_GetIgnoreFailures, (setter)PyIExportPDFPasswordSecurity_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportPDFPasswordSecurityObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IExportPDFPasswordSecurityObject",                          
                                              /* tp_name */
  sizeof(PyIExportPDFPasswordSecurityObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportPDFPasswordSecurityObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportPDFPasswordSecurityMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportPDFPasswordSecurityGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportPDFPasswordSecurityObject_new,                      
                                              /* tp_new */
};

// Interface IDibExporter

typedef struct PyIDibExporterObject {
    PyObject_HEAD
    IDibExporter* m_pIDibExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDibExporterObject;

static PyObject*
PyIDibExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDibExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDibExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDibExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDibExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDibExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDibExporter");
            return NULL;
        }
        self->m_pIDibExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDibExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDibExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDibExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDibExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDibExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDibExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDibExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDibExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDibExporterObject_dealloc(PyIDibExporterObject* self)
{
    if (self->m_pIDibExporter)
        self->m_pIDibExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDibExporter_GetpUnk(PyIDibExporterObject* self)
{
    if (!self->m_pIDibExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDibExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDibExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDibExporter_GetPointer(PyIDibExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDibExporter);
}

static PyObject*
PyIDibExporter_GetIID(PyIDibExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7d4881e5-57c6-11d1-945e-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDibExporter_GetHR(PyIDibExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDibExporter_GetIgnoreFailures(PyIDibExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDibExporter_SetIgnoreFailures(PyIDibExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDibExporter_SupportsInterface(PyIDibExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDibExporterMethod_put_IsInMemory(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsInMemory = VARIANT_FALSE;
    PyObject* pyvar_pIsInMemory = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pIsInMemory))
      goto idibexporter_put_isinmemory_method_cleanup;

    // Set up initial variable values as needed
    b_pIsInMemory = ((PyObject_IsTrue(pyvar_pIsInMemory) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idibexporter_put_isinmemory_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->put_IsInMemory(b_pIsInMemory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.put_IsInMemory() returned %ld", (long)hr);
        goto idibexporter_put_isinmemory_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIsInMemory

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idibexporter_put_isinmemory_method_cleanup;

    idibexporter_put_isinmemory_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsInMemory
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.put_IsInMemory");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_get_IsInMemory(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsInMemory = VARIANT_FALSE;
    PyObject* pyvar_pIsInMemory = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIsInMemory

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->get_IsInMemory(&b_pIsInMemory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.get_IsInMemory() returned %ld", (long)hr);
        goto idibexporter_get_isinmemory_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pIsInMemory = ((b_pIsInMemory == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idibexporter_get_isinmemory_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pIsInMemory);
    goto idibexporter_get_isinmemory_method_cleanup;

    idibexporter_get_isinmemory_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsInMemory
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.get_IsInMemory");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_get_HDIB(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HpHandle = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHandle

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->get_HDIB(&HpHandle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.get_HDIB() returned %ld", (long)hr);
        goto idibexporter_get_hdib_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHandle

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HpHandle);
    goto idibexporter_get_hdib_method_cleanup;

    idibexporter_get_hdib_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHandle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.get_HDIB");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_put_BitsPerPixel(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spBitsPerPixel = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spBitsPerPixel))
      goto idibexporter_put_bitsperpixel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pBitsPerPixel

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->put_BitsPerPixel(spBitsPerPixel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.put_BitsPerPixel() returned %ld", (long)hr);
        goto idibexporter_put_bitsperpixel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pBitsPerPixel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idibexporter_put_bitsperpixel_method_cleanup;

    idibexporter_put_bitsperpixel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pBitsPerPixel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.put_BitsPerPixel");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_get_BitsPerPixel(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spBitsPerPixel = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pBitsPerPixel

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->get_BitsPerPixel(&spBitsPerPixel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.get_BitsPerPixel() returned %ld", (long)hr);
        goto idibexporter_get_bitsperpixel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pBitsPerPixel

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spBitsPerPixel);
    goto idibexporter_get_bitsperpixel_method_cleanup;

    idibexporter_get_bitsperpixel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pBitsPerPixel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.get_BitsPerPixel");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_put_BackgroundColor(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipppBackgroundColor = NULL;
    PyObject* py_ppBackgroundColor;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppBackgroundColor))
      goto idibexporter_put_backgroundcolor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppBackgroundColor, &IID_IColor, (void**)&ipppBackgroundColor))
        PyErr_SetString(PyExc_TypeError, "Argument ppBackgroundColor (position 0) is not IColor");
    
    if (PyErr_Occurred())
      goto idibexporter_put_backgroundcolor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->put_BackgroundColor(ipppBackgroundColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.put_BackgroundColor() returned %ld", (long)hr);
        goto idibexporter_put_backgroundcolor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppBackgroundColor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idibexporter_put_backgroundcolor_method_cleanup;

    idibexporter_put_backgroundcolor_method_cleanup:
    self->m_HR = hr;
    if (ipppBackgroundColor)
      ipppBackgroundColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.put_BackgroundColor");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_get_BackgroundColor(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipppBackgroundColor = NULL;
    PyObject* py_ppBackgroundColor = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppBackgroundColor

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->get_BackgroundColor(&ipppBackgroundColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.get_BackgroundColor() returned %ld", (long)hr);
        goto idibexporter_get_backgroundcolor_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppBackgroundColor);
    if (ipppBackgroundColor)
    {
        IUnknown* pUnk = NULL;
        ipppBackgroundColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBackgroundColor = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBackgroundColor)
    {
        if (py_ppBackgroundColor)
           Py_DECREF(py_ppBackgroundColor);
        py_ppBackgroundColor = Py_None;
        Py_INCREF(py_ppBackgroundColor);
    }
    if (PyErr_Occurred())
      goto idibexporter_get_backgroundcolor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBackgroundColor);
    goto idibexporter_get_backgroundcolor_method_cleanup;

    idibexporter_get_backgroundcolor_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppBackgroundColor);
    if (ipppBackgroundColor)
      ipppBackgroundColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.get_BackgroundColor");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_put_Width(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spWidth = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spWidth))
      goto idibexporter_put_width_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pWidth

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->put_Width(spWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.put_Width() returned %ld", (long)hr);
        goto idibexporter_put_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWidth

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idibexporter_put_width_method_cleanup;

    idibexporter_put_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.put_Width");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_get_Width(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pWidth

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->get_Width(&spWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.get_Width() returned %ld", (long)hr);
        goto idibexporter_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWidth

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spWidth);
    goto idibexporter_get_width_method_cleanup;

    idibexporter_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.get_Width");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_put_Height(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spHeight = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spHeight))
      goto idibexporter_put_height_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pHeight

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->put_Height(spHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.put_Height() returned %ld", (long)hr);
        goto idibexporter_put_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHeight

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idibexporter_put_height_method_cleanup;

    idibexporter_put_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHeight
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.put_Height");
    return return_tuple;
}

static PyObject*
IDibExporterMethod_get_Height(PyIDibExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHeight

    // Call method on actual COM interface
    hr = self->m_pIDibExporter->get_Height(&spHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDibExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDibExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDibExporter.get_Height() returned %ld", (long)hr);
        goto idibexporter_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHeight

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spHeight);
    goto idibexporter_get_height_method_cleanup;

    idibexporter_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHeight
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDibExporter.get_Height");
    return return_tuple;
}


PyMethodDef PyIDibExporterMethods[] = {
    {"supports", (PyCFunction)PyIDibExporter_SupportsInterface, METH_O, ""},
    {"put_IsInMemory", (PyCFunction)IDibExporterMethod_put_IsInMemory, METH_VARARGS, ""},
    {"get_IsInMemory", (PyCFunction)IDibExporterMethod_get_IsInMemory, METH_VARARGS, ""},
    {"get_HDIB", (PyCFunction)IDibExporterMethod_get_HDIB, METH_VARARGS, ""},
    {"put_BitsPerPixel", (PyCFunction)IDibExporterMethod_put_BitsPerPixel, METH_VARARGS, ""},
    {"get_BitsPerPixel", (PyCFunction)IDibExporterMethod_get_BitsPerPixel, METH_VARARGS, ""},
    {"put_BackgroundColor", (PyCFunction)IDibExporterMethod_put_BackgroundColor, METH_VARARGS, ""},
    {"get_BackgroundColor", (PyCFunction)IDibExporterMethod_get_BackgroundColor, METH_VARARGS, ""},
    {"put_Width", (PyCFunction)IDibExporterMethod_put_Width, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IDibExporterMethod_get_Width, METH_VARARGS, ""},
    {"put_Height", (PyCFunction)IDibExporterMethod_put_Height, METH_VARARGS, ""},
    {"get_Height", (PyCFunction)IDibExporterMethod_get_Height, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDibExporterGetSet[] = {
  {"_pUnk", (getter)PyIDibExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDibExporter", NULL},
  {"_pointer", (getter)PyIDibExporter_GetPointer, NULL, "Get memory address for IDibExporter", NULL},
  {"_IID", (getter)PyIDibExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDibExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDibExporter_GetIgnoreFailures, (setter)PyIDibExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDibExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IDibExporterObject",                          
                                              /* tp_name */
  sizeof(PyIDibExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDibExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDibExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDibExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDibExporterObject_new,                      
                                              /* tp_new */
};

// Interface IJpegExporter

typedef struct PyIJpegExporterObject {
    PyObject_HEAD
    IJpegExporter* m_pIJpegExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIJpegExporterObject;

static PyObject*
PyIJpegExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIJpegExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IJpegExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IJpegExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IJpegExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIJpegExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IJpegExporter");
            return NULL;
        }
        self->m_pIJpegExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IJpegExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IJpegExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IJpegExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IJpegExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IJpegExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIJpegExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IJpegExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIJpegExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIJpegExporterObject_dealloc(PyIJpegExporterObject* self)
{
    if (self->m_pIJpegExporter)
        self->m_pIJpegExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIJpegExporter_GetpUnk(PyIJpegExporterObject* self)
{
    if (!self->m_pIJpegExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIJpegExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IJpegExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIJpegExporter_GetPointer(PyIJpegExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIJpegExporter);
}

static PyObject*
PyIJpegExporter_GetIID(PyIJpegExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "511ff079-55c4-11d3-9ffd-00c04f6bc8dd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIJpegExporter_GetHR(PyIJpegExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIJpegExporter_GetIgnoreFailures(PyIJpegExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIJpegExporter_SetIgnoreFailures(PyIJpegExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIJpegExporter_SupportsInterface(PyIJpegExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IJpegExporterMethod_put_BackgroundColor(PyIJpegExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipppBackgroundColor = NULL;
    PyObject* py_ppBackgroundColor;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppBackgroundColor))
      goto ijpegexporter_put_backgroundcolor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppBackgroundColor, &IID_IColor, (void**)&ipppBackgroundColor))
        PyErr_SetString(PyExc_TypeError, "Argument ppBackgroundColor (position 0) is not IColor");
    
    if (PyErr_Occurred())
      goto ijpegexporter_put_backgroundcolor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIJpegExporter->put_BackgroundColor(ipppBackgroundColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IJpegExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IJpegExporter.put_BackgroundColor() returned %ld", (long)hr);
        goto ijpegexporter_put_backgroundcolor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppBackgroundColor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ijpegexporter_put_backgroundcolor_method_cleanup;

    ijpegexporter_put_backgroundcolor_method_cleanup:
    self->m_HR = hr;
    if (ipppBackgroundColor)
      ipppBackgroundColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IJpegExporter.put_BackgroundColor");
    return return_tuple;
}

static PyObject*
IJpegExporterMethod_get_BackgroundColor(PyIJpegExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipppBackgroundColor = NULL;
    PyObject* py_ppBackgroundColor = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppBackgroundColor

    // Call method on actual COM interface
    hr = self->m_pIJpegExporter->get_BackgroundColor(&ipppBackgroundColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IJpegExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IJpegExporter.get_BackgroundColor() returned %ld", (long)hr);
        goto ijpegexporter_get_backgroundcolor_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppBackgroundColor);
    if (ipppBackgroundColor)
    {
        IUnknown* pUnk = NULL;
        ipppBackgroundColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBackgroundColor = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBackgroundColor)
    {
        if (py_ppBackgroundColor)
           Py_DECREF(py_ppBackgroundColor);
        py_ppBackgroundColor = Py_None;
        Py_INCREF(py_ppBackgroundColor);
    }
    if (PyErr_Occurred())
      goto ijpegexporter_get_backgroundcolor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBackgroundColor);
    goto ijpegexporter_get_backgroundcolor_method_cleanup;

    ijpegexporter_get_backgroundcolor_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppBackgroundColor);
    if (ipppBackgroundColor)
      ipppBackgroundColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IJpegExporter.get_BackgroundColor");
    return return_tuple;
}

static PyObject*
IJpegExporterMethod_put_Width(PyIJpegExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spWidth = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spWidth))
      goto ijpegexporter_put_width_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pWidth

    // Call method on actual COM interface
    hr = self->m_pIJpegExporter->put_Width(spWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IJpegExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IJpegExporter.put_Width() returned %ld", (long)hr);
        goto ijpegexporter_put_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWidth

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ijpegexporter_put_width_method_cleanup;

    ijpegexporter_put_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IJpegExporter.put_Width");
    return return_tuple;
}

static PyObject*
IJpegExporterMethod_get_Width(PyIJpegExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pWidth

    // Call method on actual COM interface
    hr = self->m_pIJpegExporter->get_Width(&spWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IJpegExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IJpegExporter.get_Width() returned %ld", (long)hr);
        goto ijpegexporter_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWidth

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spWidth);
    goto ijpegexporter_get_width_method_cleanup;

    ijpegexporter_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IJpegExporter.get_Width");
    return return_tuple;
}

static PyObject*
IJpegExporterMethod_put_Height(PyIJpegExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spHeight = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spHeight))
      goto ijpegexporter_put_height_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pHeight

    // Call method on actual COM interface
    hr = self->m_pIJpegExporter->put_Height(spHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IJpegExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IJpegExporter.put_Height() returned %ld", (long)hr);
        goto ijpegexporter_put_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHeight

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ijpegexporter_put_height_method_cleanup;

    ijpegexporter_put_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHeight
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IJpegExporter.put_Height");
    return return_tuple;
}

static PyObject*
IJpegExporterMethod_get_Height(PyIJpegExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHeight

    // Call method on actual COM interface
    hr = self->m_pIJpegExporter->get_Height(&spHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IJpegExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IJpegExporter.get_Height() returned %ld", (long)hr);
        goto ijpegexporter_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHeight

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spHeight);
    goto ijpegexporter_get_height_method_cleanup;

    ijpegexporter_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHeight
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IJpegExporter.get_Height");
    return return_tuple;
}

static PyObject*
IJpegExporterMethod_put_Quality(PyIJpegExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sQuality = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sQuality))
      goto ijpegexporter_put_quality_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Quality

    // Call method on actual COM interface
    hr = self->m_pIJpegExporter->put_Quality(sQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IJpegExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IJpegExporter.put_Quality() returned %ld", (long)hr);
        goto ijpegexporter_put_quality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Quality

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ijpegexporter_put_quality_method_cleanup;

    ijpegexporter_put_quality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Quality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IJpegExporter.put_Quality");
    return return_tuple;
}

static PyObject*
IJpegExporterMethod_get_Quality(PyIJpegExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sQuality = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Quality

    // Call method on actual COM interface
    hr = self->m_pIJpegExporter->get_Quality(&sQuality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIJpegExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IJpegExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IJpegExporter.get_Quality() returned %ld", (long)hr);
        goto ijpegexporter_get_quality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Quality

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sQuality);
    goto ijpegexporter_get_quality_method_cleanup;

    ijpegexporter_get_quality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Quality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IJpegExporter.get_Quality");
    return return_tuple;
}


PyMethodDef PyIJpegExporterMethods[] = {
    {"supports", (PyCFunction)PyIJpegExporter_SupportsInterface, METH_O, ""},
    {"put_BackgroundColor", (PyCFunction)IJpegExporterMethod_put_BackgroundColor, METH_VARARGS, ""},
    {"get_BackgroundColor", (PyCFunction)IJpegExporterMethod_get_BackgroundColor, METH_VARARGS, ""},
    {"put_Width", (PyCFunction)IJpegExporterMethod_put_Width, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IJpegExporterMethod_get_Width, METH_VARARGS, ""},
    {"put_Height", (PyCFunction)IJpegExporterMethod_put_Height, METH_VARARGS, ""},
    {"get_Height", (PyCFunction)IJpegExporterMethod_get_Height, METH_VARARGS, ""},
    {"put_Quality", (PyCFunction)IJpegExporterMethod_put_Quality, METH_VARARGS, ""},
    {"get_Quality", (PyCFunction)IJpegExporterMethod_get_Quality, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIJpegExporterGetSet[] = {
  {"_pUnk", (getter)PyIJpegExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IJpegExporter", NULL},
  {"_pointer", (getter)PyIJpegExporter_GetPointer, NULL, "Get memory address for IJpegExporter", NULL},
  {"_IID", (getter)PyIJpegExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIJpegExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIJpegExporter_GetIgnoreFailures, (setter)PyIJpegExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIJpegExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IJpegExporterObject",                          
                                              /* tp_name */
  sizeof(PyIJpegExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIJpegExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIJpegExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIJpegExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIJpegExporterObject_new,                      
                                              /* tp_new */
};

// Interface IBmpExporter

typedef struct PyIBmpExporterObject {
    PyObject_HEAD
    IBmpExporter* m_pIBmpExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIBmpExporterObject;

static PyObject*
PyIBmpExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIBmpExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IBmpExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IBmpExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IBmpExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIBmpExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IBmpExporter");
            return NULL;
        }
        self->m_pIBmpExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IBmpExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IBmpExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IBmpExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IBmpExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IBmpExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIBmpExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IBmpExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIBmpExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIBmpExporterObject_dealloc(PyIBmpExporterObject* self)
{
    if (self->m_pIBmpExporter)
        self->m_pIBmpExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIBmpExporter_GetpUnk(PyIBmpExporterObject* self)
{
    if (!self->m_pIBmpExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIBmpExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IBmpExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIBmpExporter_GetPointer(PyIBmpExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIBmpExporter);
}

static PyObject*
PyIBmpExporter_GetIID(PyIBmpExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4c59f34d-db32-11d3-9ff6-00c04f6bc8dd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIBmpExporter_GetHR(PyIBmpExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIBmpExporter_GetIgnoreFailures(PyIBmpExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIBmpExporter_SetIgnoreFailures(PyIBmpExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIBmpExporter_SupportsInterface(PyIBmpExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIBmpExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IBmpExporterMethod_get_Bitmap(PyIBmpExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhBmp = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hBmp

    // Call method on actual COM interface
    hr = self->m_pIBmpExporter->get_Bitmap(&HhBmp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIBmpExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IBmpExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IBmpExporter.get_Bitmap() returned %ld", (long)hr);
        goto ibmpexporter_get_bitmap_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hBmp

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhBmp);
    goto ibmpexporter_get_bitmap_method_cleanup;

    ibmpexporter_get_bitmap_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hBmp
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IBmpExporter.get_Bitmap");
    return return_tuple;
}

static PyObject*
IBmpExporterMethod_get_Palette(PyIBmpExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhPal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hPal

    // Call method on actual COM interface
    hr = self->m_pIBmpExporter->get_Palette(&HhPal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIBmpExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IBmpExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IBmpExporter.get_Palette() returned %ld", (long)hr);
        goto ibmpexporter_get_palette_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hPal

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhPal);
    goto ibmpexporter_get_palette_method_cleanup;

    ibmpexporter_get_palette_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hPal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IBmpExporter.get_Palette");
    return return_tuple;
}


PyMethodDef PyIBmpExporterMethods[] = {
    {"supports", (PyCFunction)PyIBmpExporter_SupportsInterface, METH_O, ""},
    {"get_Bitmap", (PyCFunction)IBmpExporterMethod_get_Bitmap, METH_VARARGS, ""},
    {"get_Palette", (PyCFunction)IBmpExporterMethod_get_Palette, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIBmpExporterGetSet[] = {
  {"_pUnk", (getter)PyIBmpExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IBmpExporter", NULL},
  {"_pointer", (getter)PyIBmpExporter_GetPointer, NULL, "Get memory address for IBmpExporter", NULL},
  {"_IID", (getter)PyIBmpExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIBmpExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIBmpExporter_GetIgnoreFailures, (setter)PyIBmpExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIBmpExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.IBmpExporterObject",                          
                                              /* tp_name */
  sizeof(PyIBmpExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIBmpExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIBmpExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIBmpExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIBmpExporterObject_new,                      
                                              /* tp_new */
};

// Interface ITiffExporter

typedef struct PyITiffExporterObject {
    PyObject_HEAD
    ITiffExporter* m_pITiffExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITiffExporterObject;

static PyObject*
PyITiffExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITiffExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITiffExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITiffExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITiffExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITiffExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITiffExporter");
            return NULL;
        }
        self->m_pITiffExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITiffExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITiffExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITiffExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITiffExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITiffExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITiffExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITiffExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITiffExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITiffExporterObject_dealloc(PyITiffExporterObject* self)
{
    if (self->m_pITiffExporter)
        self->m_pITiffExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITiffExporter_GetpUnk(PyITiffExporterObject* self)
{
    if (!self->m_pITiffExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITiffExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITiffExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITiffExporter_GetPointer(PyITiffExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITiffExporter);
}

static PyObject*
PyITiffExporter_GetIID(PyITiffExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "71001418-565a-4588-90b7-3ffb04b74be7");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITiffExporter_GetHR(PyITiffExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITiffExporter_GetIgnoreFailures(PyITiffExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITiffExporter_SetIgnoreFailures(PyITiffExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITiffExporter_SupportsInterface(PyITiffExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITiffExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITiffExporterMethod_put_BackgroundColor(PyITiffExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipppBackgroundColor = NULL;
    PyObject* py_ppBackgroundColor;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppBackgroundColor))
      goto itiffexporter_put_backgroundcolor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppBackgroundColor, &IID_IColor, (void**)&ipppBackgroundColor))
        PyErr_SetString(PyExc_TypeError, "Argument ppBackgroundColor (position 0) is not IColor");
    
    if (PyErr_Occurred())
      goto itiffexporter_put_backgroundcolor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITiffExporter->put_BackgroundColor(ipppBackgroundColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITiffExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITiffExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITiffExporter.put_BackgroundColor() returned %ld", (long)hr);
        goto itiffexporter_put_backgroundcolor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppBackgroundColor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itiffexporter_put_backgroundcolor_method_cleanup;

    itiffexporter_put_backgroundcolor_method_cleanup:
    self->m_HR = hr;
    if (ipppBackgroundColor)
      ipppBackgroundColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITiffExporter.put_BackgroundColor");
    return return_tuple;
}

static PyObject*
ITiffExporterMethod_get_BackgroundColor(PyITiffExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipppBackgroundColor = NULL;
    PyObject* py_ppBackgroundColor = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppBackgroundColor

    // Call method on actual COM interface
    hr = self->m_pITiffExporter->get_BackgroundColor(&ipppBackgroundColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITiffExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITiffExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITiffExporter.get_BackgroundColor() returned %ld", (long)hr);
        goto itiffexporter_get_backgroundcolor_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppBackgroundColor);
    if (ipppBackgroundColor)
    {
        IUnknown* pUnk = NULL;
        ipppBackgroundColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBackgroundColor = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBackgroundColor)
    {
        if (py_ppBackgroundColor)
           Py_DECREF(py_ppBackgroundColor);
        py_ppBackgroundColor = Py_None;
        Py_INCREF(py_ppBackgroundColor);
    }
    if (PyErr_Occurred())
      goto itiffexporter_get_backgroundcolor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBackgroundColor);
    goto itiffexporter_get_backgroundcolor_method_cleanup;

    itiffexporter_get_backgroundcolor_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppBackgroundColor);
    if (ipppBackgroundColor)
      ipppBackgroundColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITiffExporter.get_BackgroundColor");
    return return_tuple;
}

static PyObject*
ITiffExporterMethod_put_Width(PyITiffExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spWidth = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spWidth))
      goto itiffexporter_put_width_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pWidth

    // Call method on actual COM interface
    hr = self->m_pITiffExporter->put_Width(spWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITiffExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITiffExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITiffExporter.put_Width() returned %ld", (long)hr);
        goto itiffexporter_put_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWidth

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itiffexporter_put_width_method_cleanup;

    itiffexporter_put_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITiffExporter.put_Width");
    return return_tuple;
}

static PyObject*
ITiffExporterMethod_get_Width(PyITiffExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pWidth

    // Call method on actual COM interface
    hr = self->m_pITiffExporter->get_Width(&spWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITiffExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITiffExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITiffExporter.get_Width() returned %ld", (long)hr);
        goto itiffexporter_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWidth

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spWidth);
    goto itiffexporter_get_width_method_cleanup;

    itiffexporter_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITiffExporter.get_Width");
    return return_tuple;
}

static PyObject*
ITiffExporterMethod_put_Height(PyITiffExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spHeight = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spHeight))
      goto itiffexporter_put_height_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pHeight

    // Call method on actual COM interface
    hr = self->m_pITiffExporter->put_Height(spHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITiffExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITiffExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITiffExporter.put_Height() returned %ld", (long)hr);
        goto itiffexporter_put_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHeight

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itiffexporter_put_height_method_cleanup;

    itiffexporter_put_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHeight
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITiffExporter.put_Height");
    return return_tuple;
}

static PyObject*
ITiffExporterMethod_get_Height(PyITiffExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHeight

    // Call method on actual COM interface
    hr = self->m_pITiffExporter->get_Height(&spHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITiffExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITiffExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITiffExporter.get_Height() returned %ld", (long)hr);
        goto itiffexporter_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pHeight

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spHeight);
    goto itiffexporter_get_height_method_cleanup;

    itiffexporter_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHeight
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITiffExporter.get_Height");
    return return_tuple;
}


PyMethodDef PyITiffExporterMethods[] = {
    {"supports", (PyCFunction)PyITiffExporter_SupportsInterface, METH_O, ""},
    {"put_BackgroundColor", (PyCFunction)ITiffExporterMethod_put_BackgroundColor, METH_VARARGS, ""},
    {"get_BackgroundColor", (PyCFunction)ITiffExporterMethod_get_BackgroundColor, METH_VARARGS, ""},
    {"put_Width", (PyCFunction)ITiffExporterMethod_put_Width, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)ITiffExporterMethod_get_Width, METH_VARARGS, ""},
    {"put_Height", (PyCFunction)ITiffExporterMethod_put_Height, METH_VARARGS, ""},
    {"get_Height", (PyCFunction)ITiffExporterMethod_get_Height, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITiffExporterGetSet[] = {
  {"_pUnk", (getter)PyITiffExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITiffExporter", NULL},
  {"_pointer", (getter)PyITiffExporter_GetPointer, NULL, "Get memory address for ITiffExporter", NULL},
  {"_IID", (getter)PyITiffExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITiffExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITiffExporter_GetIgnoreFailures, (setter)PyITiffExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITiffExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriOutput.ITiffExporterObject",                          
                                              /* tp_name */
  sizeof(PyITiffExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITiffExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITiffExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITiffExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITiffExporterObject_new,                      
                                              /* tp_new */
};





static PyObject*
CoCreateFontMap(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_FontMap, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of FontMap");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("0710508f-2d9e-11d3-9fc6-00c04f6bc8dd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "0710508f-2d9e-11d3-9fc6-00c04f6bc8dd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateFontMapCollection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_FontMapCollection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of FontMapCollection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("eb0e7543-2d97-11d3-9fc6-00c04f6bc8dd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "eb0e7543-2d97-11d3-9fc6-00c04f6bc8dd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateFontMapEnvironment(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_FontMapEnvironment, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of FontMapEnvironment");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9ecb85b1-6caa-11d3-b685-0080c8ea4fd5")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9ecb85b1-6caa-11d3-b685-0080c8ea4fd5");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePrintAndExportPageOptions(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_PrintAndExportPageOptions, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of PrintAndExportPageOptions");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("36673b39-2ecf-4bb9-8304-98f58d829054")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "36673b39-2ecf-4bb9-8304-98f58d829054");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateEmfExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_EmfExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of EmfExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4011-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4011-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePSDriver(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_PSDriver, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of PSDriver");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("cd754683-a222-11d0-a68f-080009d57b9a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "cd754683-a222-11d0-a68f-080009d57b9a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePsExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_PsExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of PsExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4014-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4014-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSpotPlate(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SpotPlate, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SpotPlate");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("481614e5-9407-11d1-9127-0000f87808ee")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "481614e5-9407-11d1-9127-0000f87808ee");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePDFDriver(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_PDFDriver, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of PDFDriver");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("02016031-1521-11d3-9f97-00c04f6bc8dd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "02016031-1521-11d3-9f97-00c04f6bc8dd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePDFExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_PDFExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of PDFExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("4aa8cc0e-151d-11d3-9f97-00c04f6bc8dd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "4aa8cc0e-151d-11d3-9f97-00c04f6bc8dd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAIDriver(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AIDriver, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AIDriver");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2bd83bf2-eca7-4b7f-9b41-3ad52eae1b1d")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2bd83bf2-eca7-4b7f-9b41-3ad52eae1b1d");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAIExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AIExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AIExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("94512290-b913-4a0b-a509-03f803f19922")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "94512290-b913-4a0b-a509-03f803f19922");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePaper(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_Paper, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of Paper");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("e28c4e63-3f55-11d1-885e-0000f87808ee")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "e28c4e63-3f55-11d1-885e-0000f87808ee");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateEmfPrinter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_EmfPrinter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of EmfPrinter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ae064d01-d6ce-11d0-867a-0000f8751720")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ae064d01-d6ce-11d0-867a-0000f8751720");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePsPrinter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_PsPrinter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of PsPrinter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("e28c4e61-3f55-11d1-885e-0000f87808ee")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "e28c4e61-3f55-11d1-885e-0000f87808ee");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportBMP(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportBMP, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportBMP");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("058d2242-918d-4941-a048-8b259aaa1aa7")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "058d2242-918d-4941-a048-8b259aaa1aa7");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportJPEG(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportJPEG, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportJPEG");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8e29f55c-f8d2-48b3-8227-34b279de8358")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8e29f55c-f8d2-48b3-8227-34b279de8358");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportPNG(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportPNG, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportPNG");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("69fa668c-58d9-4fd4-805c-964b5c383c8b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "69fa668c-58d9-4fd4-805c-964b5c383c8b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportTIFF(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportTIFF, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportTIFF");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("77c648d5-c2e1-4ec5-8764-9034181f9858")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "77c648d5-c2e1-4ec5-8764-9034181f9858");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportGIF(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportGIF, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportGIF");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("167d909e-2528-4e5d-b5ee-c2e4b553b224")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "167d909e-2528-4e5d-b5ee-c2e4b553b224");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportEMF(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportEMF, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportEMF");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("b4d7ae22-1d09-4b5b-8d37-4ff7d5f9233a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "b4d7ae22-1d09-4b5b-8d37-4ff7d5f9233a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportPS(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportPS, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportPS");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("1918f0e0-69ff-4d19-b06d-4c2f8c6067a3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "1918f0e0-69ff-4d19-b06d-4c2f8c6067a3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportPDF(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportPDF, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportPDF");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a0d673ef-bcb9-4c6d-9226-214e4142fbc7")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a0d673ef-bcb9-4c6d-9226-214e4142fbc7");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportAI(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportAI, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportAI");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("c5f4e89d-20fc-4c43-922c-b165d09c12aa")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "c5f4e89d-20fc-4c43-922c-b165d09c12aa");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateExportSVG(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ExportSVG, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ExportSVG");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("637180af-72cf-4e99-afce-887b9a1091c3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "637180af-72cf-4e99-afce-887b9a1091c3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDibExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DibExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DibExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4013-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4013-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateJpegExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_JpegExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of JpegExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("511ff07a-55c4-11d3-9ffd-00c04f6bc8dd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "511ff07a-55c4-11d3-9ffd-00c04f6bc8dd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTiffExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TiffExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TiffExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("39c10487-b0fa-4f2b-ac7b-c76e0bce9a95")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "39c10487-b0fa-4f2b-ac7b-c76e0bce9a95");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyMethodDef _esriOutputMethods[] = {
    {"FontMap", (PyCFunction)CoCreateFontMap, METH_NOARGS,
     "Create instance of FontMap\n"},
    {"FontMapCollection", (PyCFunction)CoCreateFontMapCollection, METH_NOARGS,
     "Create instance of FontMapCollection\n"},
    {"FontMapEnvironment", (PyCFunction)CoCreateFontMapEnvironment, METH_NOARGS,
     "Create instance of FontMapEnvironment\n"},
    {"PrintAndExportPageOptions", (PyCFunction)CoCreatePrintAndExportPageOptions, METH_NOARGS,
     "Create instance of PrintAndExportPageOptions\n"},
    {"EmfExporter", (PyCFunction)CoCreateEmfExporter, METH_NOARGS,
     "Create instance of EmfExporter\n"},
    {"PSDriver", (PyCFunction)CoCreatePSDriver, METH_NOARGS,
     "Create instance of PSDriver\n"},
    {"PsExporter", (PyCFunction)CoCreatePsExporter, METH_NOARGS,
     "Create instance of PsExporter\n"},
    {"SpotPlate", (PyCFunction)CoCreateSpotPlate, METH_NOARGS,
     "Create instance of SpotPlate\n"},
    {"PDFDriver", (PyCFunction)CoCreatePDFDriver, METH_NOARGS,
     "Create instance of PDFDriver\n"},
    {"PDFExporter", (PyCFunction)CoCreatePDFExporter, METH_NOARGS,
     "Create instance of PDFExporter\n"},
    {"AIDriver", (PyCFunction)CoCreateAIDriver, METH_NOARGS,
     "Create instance of AIDriver\n"},
    {"AIExporter", (PyCFunction)CoCreateAIExporter, METH_NOARGS,
     "Create instance of AIExporter\n"},
    {"Paper", (PyCFunction)CoCreatePaper, METH_NOARGS,
     "Create instance of Paper\n"},
    {"EmfPrinter", (PyCFunction)CoCreateEmfPrinter, METH_NOARGS,
     "Create instance of EmfPrinter\n"},
    {"PsPrinter", (PyCFunction)CoCreatePsPrinter, METH_NOARGS,
     "Create instance of PsPrinter\n"},
    {"ExportBMP", (PyCFunction)CoCreateExportBMP, METH_NOARGS,
     "Create instance of ExportBMP\n"},
    {"ExportJPEG", (PyCFunction)CoCreateExportJPEG, METH_NOARGS,
     "Create instance of ExportJPEG\n"},
    {"ExportPNG", (PyCFunction)CoCreateExportPNG, METH_NOARGS,
     "Create instance of ExportPNG\n"},
    {"ExportTIFF", (PyCFunction)CoCreateExportTIFF, METH_NOARGS,
     "Create instance of ExportTIFF\n"},
    {"ExportGIF", (PyCFunction)CoCreateExportGIF, METH_NOARGS,
     "Create instance of ExportGIF\n"},
    {"ExportEMF", (PyCFunction)CoCreateExportEMF, METH_NOARGS,
     "Create instance of ExportEMF\n"},
    {"ExportPS", (PyCFunction)CoCreateExportPS, METH_NOARGS,
     "Create instance of ExportPS\n"},
    {"ExportPDF", (PyCFunction)CoCreateExportPDF, METH_NOARGS,
     "Create instance of ExportPDF\n"},
    {"ExportAI", (PyCFunction)CoCreateExportAI, METH_NOARGS,
     "Create instance of ExportAI\n"},
    {"ExportSVG", (PyCFunction)CoCreateExportSVG, METH_NOARGS,
     "Create instance of ExportSVG\n"},
    {"DibExporter", (PyCFunction)CoCreateDibExporter, METH_NOARGS,
     "Create instance of DibExporter\n"},
    {"JpegExporter", (PyCFunction)CoCreateJpegExporter, METH_NOARGS,
     "Create instance of JpegExporter\n"},
    {"TiffExporter", (PyCFunction)CoCreateTiffExporter, METH_NOARGS,
     "Create instance of TiffExporter\n"},
    {NULL, NULL, 0, NULL}
};

extern "C" {

    PyMODINIT_FUNC
    init_esriOutput(void)
    {
        // Import UUID module and keep a global pointer to the UUID object
        PyObject* uuid_module = PyImport_ImportModuleNoBlock("uuid");
        if (!uuid_module)
        {
            PyErr_SetString(PyExc_ImportError, "Could not import UUID module");
            return;
        }
        if (g_pUUID_type)
            Py_DECREF(g_pUUID_type);
        g_pUUID_type = PyObject_GetAttrString(uuid_module, "UUID");

        // Initialize module, make it show up in the right place
        PyObject* module;
        module = Py_InitModule3("cartocomutils._esriOutput",
                                 _esriOutputMethods,
                                "Type library");
        Py_INCREF(module);

        // Add IUnknown base type to parent module so every typelib is using the same
        // Py_Type pointer when typechecking.
        PyObject* parent = PyImport_ImportModuleNoBlock("cartocomutils");
        if (parent)
        {
            if (!PyObject_HasAttrString(parent, "IUnknown"))
            {
                // Bootstrapping
                PyType_Ready(&IUnknownObject_Type);
                PyModule_AddObject(parent, "IUnknown", (PyObject*)(&IUnknownObject_Type));
                // Also probably means we need to coinitialize
                ::CoInitialize(NULL);
            }
            g_pUnk_type = PyObject_GetAttrString(parent, "IUnknown");
            if (!PyObject_HasAttrString(parent, "_IIDMap"))
                PyModule_AddObject(parent, "_IIDMap", PyDict_New());
            if (!PyObject_HasAttrString(parent, "_CLSIDMap"))
                PyModule_AddObject(parent, "_CLSIDMap", PyDict_New());
            g_pIIDMap = PyObject_GetAttrString(parent, "_IIDMap");
            Py_XINCREF(g_pIIDMap);
            // Set global unknown object
            if (g_pUnk_type && g_pIIDMap)
                PyDict_SetItem(g_pIIDMap, PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}"), g_pUnk_type);
            g_pCLSIDMap = PyObject_GetAttrString(parent, "_CLSIDMap");
            Py_XINCREF(g_pCLSIDMap);
            g_pRecordMap = PyObject_GetAttrString(parent, "_RecordMap");
            Py_XINCREF(g_pRecordMap);
            PyErr_Clear();
        }

        // Bulk add all interfaces as objects
        // IFontMap
        PyType_Ready(&PyIFontMapObject_Type);
        Py_INCREF((PyObject* )&PyIFontMapObject_Type);
        PyModule_AddObject(module, "IFontMap", 
                           (PyObject *)&PyIFontMapObject_Type);

        // IFontMap2
        PyType_Ready(&PyIFontMap2Object_Type);
        Py_INCREF((PyObject* )&PyIFontMap2Object_Type);
        PyModule_AddObject(module, "IFontMap2", 
                           (PyObject *)&PyIFontMap2Object_Type);

        // IFontMapCollection
        PyType_Ready(&PyIFontMapCollectionObject_Type);
        Py_INCREF((PyObject* )&PyIFontMapCollectionObject_Type);
        PyModule_AddObject(module, "IFontMapCollection", 
                           (PyObject *)&PyIFontMapCollectionObject_Type);

        // IFontMapEnvironment
        PyType_Ready(&PyIFontMapEnvironmentObject_Type);
        Py_INCREF((PyObject* )&PyIFontMapEnvironmentObject_Type);
        PyModule_AddObject(module, "IFontMapEnvironment", 
                           (PyObject *)&PyIFontMapEnvironmentObject_Type);

        // IExporter
        PyType_Ready(&PyIExporterObject_Type);
        Py_INCREF((PyObject* )&PyIExporterObject_Type);
        PyModule_AddObject(module, "IExporter", 
                           (PyObject *)&PyIExporterObject_Type);

        // IExporter2
        PyType_Ready(&PyIExporter2Object_Type);
        Py_INCREF((PyObject* )&PyIExporter2Object_Type);
        PyModule_AddObject(module, "IExporter2", 
                           (PyObject *)&PyIExporter2Object_Type);

        // IExporterPriority
        PyType_Ready(&PyIExporterPriorityObject_Type);
        Py_INCREF((PyObject* )&PyIExporterPriorityObject_Type);
        PyModule_AddObject(module, "IExporterPriority", 
                           (PyObject *)&PyIExporterPriorityObject_Type);

        // IOutputCleanup
        PyType_Ready(&PyIOutputCleanupObject_Type);
        Py_INCREF((PyObject* )&PyIOutputCleanupObject_Type);
        PyModule_AddObject(module, "IOutputCleanup", 
                           (PyObject *)&PyIOutputCleanupObject_Type);

        // IWorldFileSettings
        PyType_Ready(&PyIWorldFileSettingsObject_Type);
        Py_INCREF((PyObject* )&PyIWorldFileSettingsObject_Type);
        PyModule_AddObject(module, "IWorldFileSettings", 
                           (PyObject *)&PyIWorldFileSettingsObject_Type);

        // IWorldFileSettings2
        PyType_Ready(&PyIWorldFileSettings2Object_Type);
        Py_INCREF((PyObject* )&PyIWorldFileSettings2Object_Type);
        PyModule_AddObject(module, "IWorldFileSettings2", 
                           (PyObject *)&PyIWorldFileSettings2Object_Type);

        // IStepProgressorSetup
        PyType_Ready(&PyIStepProgressorSetupObject_Type);
        Py_INCREF((PyObject* )&PyIStepProgressorSetupObject_Type);
        PyModule_AddObject(module, "IStepProgressorSetup", 
                           (PyObject *)&PyIStepProgressorSetupObject_Type);

        // ITrackCancelSetup
        PyType_Ready(&PyITrackCancelSetupObject_Type);
        Py_INCREF((PyObject* )&PyITrackCancelSetupObject_Type);
        PyModule_AddObject(module, "ITrackCancelSetup", 
                           (PyObject *)&PyITrackCancelSetupObject_Type);

        // ISettingsInRegistry
        PyType_Ready(&PyISettingsInRegistryObject_Type);
        Py_INCREF((PyObject* )&PyISettingsInRegistryObject_Type);
        PyModule_AddObject(module, "ISettingsInRegistry", 
                           (PyObject *)&PyISettingsInRegistryObject_Type);

        // IExportColorspaceSettings
        PyType_Ready(&PyIExportColorspaceSettingsObject_Type);
        Py_INCREF((PyObject* )&PyIExportColorspaceSettingsObject_Type);
        PyModule_AddObject(module, "IExportColorspaceSettings", 
                           (PyObject *)&PyIExportColorspaceSettingsObject_Type);

        // IPrintAndExportPageOptions
        PyType_Ready(&PyIPrintAndExportPageOptionsObject_Type);
        Py_INCREF((PyObject* )&PyIPrintAndExportPageOptionsObject_Type);
        PyModule_AddObject(module, "IPrintAndExportPageOptions", 
                           (PyObject *)&PyIPrintAndExportPageOptionsObject_Type);

        // IEmfExporter
        PyType_Ready(&PyIEmfExporterObject_Type);
        Py_INCREF((PyObject* )&PyIEmfExporterObject_Type);
        PyModule_AddObject(module, "IEmfExporter", 
                           (PyObject *)&PyIEmfExporterObject_Type);

        // ISpotPlate
        PyType_Ready(&PyISpotPlateObject_Type);
        Py_INCREF((PyObject* )&PyISpotPlateObject_Type);
        PyModule_AddObject(module, "ISpotPlate", 
                           (PyObject *)&PyISpotPlateObject_Type);

        // ISpotPlateCollection
        PyType_Ready(&PyISpotPlateCollectionObject_Type);
        Py_INCREF((PyObject* )&PyISpotPlateCollectionObject_Type);
        PyModule_AddObject(module, "ISpotPlateCollection", 
                           (PyObject *)&PyISpotPlateCollectionObject_Type);

        // IColorCorrection
        PyType_Ready(&PyIColorCorrectionObject_Type);
        Py_INCREF((PyObject* )&PyIColorCorrectionObject_Type);
        PyModule_AddObject(module, "IColorCorrection", 
                           (PyObject *)&PyIColorCorrectionObject_Type);

        // IPSDriver
        PyType_Ready(&PyIPSDriverObject_Type);
        Py_INCREF((PyObject* )&PyIPSDriverObject_Type);
        PyModule_AddObject(module, "IPSDriver", 
                           (PyObject *)&PyIPSDriverObject_Type);

        // IPSDriver2
        PyType_Ready(&PyIPSDriver2Object_Type);
        Py_INCREF((PyObject* )&PyIPSDriver2Object_Type);
        PyModule_AddObject(module, "IPSDriver2", 
                           (PyObject *)&PyIPSDriver2Object_Type);

        // IPsExporter
        PyType_Ready(&PyIPsExporterObject_Type);
        Py_INCREF((PyObject* )&PyIPsExporterObject_Type);
        PyModule_AddObject(module, "IPsExporter", 
                           (PyObject *)&PyIPsExporterObject_Type);

        // IOutputPageOptionsAdmin
        PyType_Ready(&PyIOutputPageOptionsAdminObject_Type);
        Py_INCREF((PyObject* )&PyIOutputPageOptionsAdminObject_Type);
        PyModule_AddObject(module, "IOutputPageOptionsAdmin", 
                           (PyObject *)&PyIOutputPageOptionsAdminObject_Type);

        // IPDFDriver
        PyType_Ready(&PyIPDFDriverObject_Type);
        Py_INCREF((PyObject* )&PyIPDFDriverObject_Type);
        PyModule_AddObject(module, "IPDFDriver", 
                           (PyObject *)&PyIPDFDriverObject_Type);

        // IAIDriver
        PyType_Ready(&PyIAIDriverObject_Type);
        Py_INCREF((PyObject* )&PyIAIDriverObject_Type);
        PyModule_AddObject(module, "IAIDriver", 
                           (PyObject *)&PyIAIDriverObject_Type);

        // IAIExporter
        PyType_Ready(&PyIAIExporterObject_Type);
        Py_INCREF((PyObject* )&PyIAIExporterObject_Type);
        PyModule_AddObject(module, "IAIExporter", 
                           (PyObject *)&PyIAIExporterObject_Type);

        // IPaper
        PyType_Ready(&PyIPaperObject_Type);
        Py_INCREF((PyObject* )&PyIPaperObject_Type);
        PyModule_AddObject(module, "IPaper", 
                           (PyObject *)&PyIPaperObject_Type);

        // IPaper2
        PyType_Ready(&PyIPaper2Object_Type);
        Py_INCREF((PyObject* )&PyIPaper2Object_Type);
        PyModule_AddObject(module, "IPaper2", 
                           (PyObject *)&PyIPaper2Object_Type);

        // IPrinter
        PyType_Ready(&PyIPrinterObject_Type);
        Py_INCREF((PyObject* )&PyIPrinterObject_Type);
        PyModule_AddObject(module, "IPrinter", 
                           (PyObject *)&PyIPrinterObject_Type);

        // IPrinterMPage
        PyType_Ready(&PyIPrinterMPageObject_Type);
        Py_INCREF((PyObject* )&PyIPrinterMPageObject_Type);
        PyModule_AddObject(module, "IPrinterMPage", 
                           (PyObject *)&PyIPrinterMPageObject_Type);

        // IPsPrinter
        PyType_Ready(&PyIPsPrinterObject_Type);
        Py_INCREF((PyObject* )&PyIPsPrinterObject_Type);
        PyModule_AddObject(module, "IPsPrinter", 
                           (PyObject *)&PyIPsPrinterObject_Type);

        // IExport
        PyType_Ready(&PyIExportObject_Type);
        Py_INCREF((PyObject* )&PyIExportObject_Type);
        PyModule_AddObject(module, "IExport", 
                           (PyObject *)&PyIExportObject_Type);

        // IExportImage
        PyType_Ready(&PyIExportImageObject_Type);
        Py_INCREF((PyObject* )&PyIExportImageObject_Type);
        PyModule_AddObject(module, "IExportImage", 
                           (PyObject *)&PyIExportImageObject_Type);

        // IExportBMP
        PyType_Ready(&PyIExportBMPObject_Type);
        Py_INCREF((PyObject* )&PyIExportBMPObject_Type);
        PyModule_AddObject(module, "IExportBMP", 
                           (PyObject *)&PyIExportBMPObject_Type);

        // IExportJPEG
        PyType_Ready(&PyIExportJPEGObject_Type);
        Py_INCREF((PyObject* )&PyIExportJPEGObject_Type);
        PyModule_AddObject(module, "IExportJPEG", 
                           (PyObject *)&PyIExportJPEGObject_Type);

        // IExportPNG
        PyType_Ready(&PyIExportPNGObject_Type);
        Py_INCREF((PyObject* )&PyIExportPNGObject_Type);
        PyModule_AddObject(module, "IExportPNG", 
                           (PyObject *)&PyIExportPNGObject_Type);

        // IExportTIFF
        PyType_Ready(&PyIExportTIFFObject_Type);
        Py_INCREF((PyObject* )&PyIExportTIFFObject_Type);
        PyModule_AddObject(module, "IExportTIFF", 
                           (PyObject *)&PyIExportTIFFObject_Type);

        // IExportGIF
        PyType_Ready(&PyIExportGIFObject_Type);
        Py_INCREF((PyObject* )&PyIExportGIFObject_Type);
        PyModule_AddObject(module, "IExportGIF", 
                           (PyObject *)&PyIExportGIFObject_Type);

        // IExportVectorOptions
        PyType_Ready(&PyIExportVectorOptionsObject_Type);
        Py_INCREF((PyObject* )&PyIExportVectorOptionsObject_Type);
        PyModule_AddObject(module, "IExportVectorOptions", 
                           (PyObject *)&PyIExportVectorOptionsObject_Type);

        // IExportVectorOptionsEx
        PyType_Ready(&PyIExportVectorOptionsExObject_Type);
        Py_INCREF((PyObject* )&PyIExportVectorOptionsExObject_Type);
        PyModule_AddObject(module, "IExportVectorOptionsEx", 
                           (PyObject *)&PyIExportVectorOptionsExObject_Type);

        // IExportEMF
        PyType_Ready(&PyIExportEMFObject_Type);
        Py_INCREF((PyObject* )&PyIExportEMFObject_Type);
        PyModule_AddObject(module, "IExportEMF", 
                           (PyObject *)&PyIExportEMFObject_Type);

        // IExportPS
        PyType_Ready(&PyIExportPSObject_Type);
        Py_INCREF((PyObject* )&PyIExportPSObject_Type);
        PyModule_AddObject(module, "IExportPS", 
                           (PyObject *)&PyIExportPSObject_Type);

        // IExportPS2
        PyType_Ready(&PyIExportPS2Object_Type);
        Py_INCREF((PyObject* )&PyIExportPS2Object_Type);
        PyModule_AddObject(module, "IExportPS2", 
                           (PyObject *)&PyIExportPS2Object_Type);

        // IExportPDF
        PyType_Ready(&PyIExportPDFObject_Type);
        Py_INCREF((PyObject* )&PyIExportPDFObject_Type);
        PyModule_AddObject(module, "IExportPDF", 
                           (PyObject *)&PyIExportPDFObject_Type);

        // IExportPDF2
        PyType_Ready(&PyIExportPDF2Object_Type);
        Py_INCREF((PyObject* )&PyIExportPDF2Object_Type);
        PyModule_AddObject(module, "IExportPDF2", 
                           (PyObject *)&PyIExportPDF2Object_Type);

        // IExportPDF3
        PyType_Ready(&PyIExportPDF3Object_Type);
        Py_INCREF((PyObject* )&PyIExportPDF3Object_Type);
        PyModule_AddObject(module, "IExportPDF3", 
                           (PyObject *)&PyIExportPDF3Object_Type);

        // IExportPagesMultipleFile
        PyType_Ready(&PyIExportPagesMultipleFileObject_Type);
        Py_INCREF((PyObject* )&PyIExportPagesMultipleFileObject_Type);
        PyModule_AddObject(module, "IExportPagesMultipleFile", 
                           (PyObject *)&PyIExportPagesMultipleFileObject_Type);

        // IExportAI
        PyType_Ready(&PyIExportAIObject_Type);
        Py_INCREF((PyObject* )&PyIExportAIObject_Type);
        PyModule_AddObject(module, "IExportAI", 
                           (PyObject *)&PyIExportAIObject_Type);

        // IExportAI2
        PyType_Ready(&PyIExportAI2Object_Type);
        Py_INCREF((PyObject* )&PyIExportAI2Object_Type);
        PyModule_AddObject(module, "IExportAI2", 
                           (PyObject *)&PyIExportAI2Object_Type);

        // IExportSVG
        PyType_Ready(&PyIExportSVGObject_Type);
        Py_INCREF((PyObject* )&PyIExportSVGObject_Type);
        PyModule_AddObject(module, "IExportSVG", 
                           (PyObject *)&PyIExportSVGObject_Type);

        // IExportPDFPasswordSecurity
        PyType_Ready(&PyIExportPDFPasswordSecurityObject_Type);
        Py_INCREF((PyObject* )&PyIExportPDFPasswordSecurityObject_Type);
        PyModule_AddObject(module, "IExportPDFPasswordSecurity", 
                           (PyObject *)&PyIExportPDFPasswordSecurityObject_Type);

        // IDibExporter
        PyType_Ready(&PyIDibExporterObject_Type);
        Py_INCREF((PyObject* )&PyIDibExporterObject_Type);
        PyModule_AddObject(module, "IDibExporter", 
                           (PyObject *)&PyIDibExporterObject_Type);

        // IJpegExporter
        PyType_Ready(&PyIJpegExporterObject_Type);
        Py_INCREF((PyObject* )&PyIJpegExporterObject_Type);
        PyModule_AddObject(module, "IJpegExporter", 
                           (PyObject *)&PyIJpegExporterObject_Type);

        // IBmpExporter
        PyType_Ready(&PyIBmpExporterObject_Type);
        Py_INCREF((PyObject* )&PyIBmpExporterObject_Type);
        PyModule_AddObject(module, "IBmpExporter", 
                           (PyObject *)&PyIBmpExporterObject_Type);

        // ITiffExporter
        PyType_Ready(&PyITiffExporterObject_Type);
        Py_INCREF((PyObject* )&PyITiffExporterObject_Type);
        PyModule_AddObject(module, "ITiffExporter", 
                           (PyObject *)&PyITiffExporterObject_Type);


        // Bulk add all the IID_* CLSID_* from this type lib
        if (g_pUUID_type)
        {
            // guids registration for interfaces
            if (g_pIIDMap)
            {
// Disabled for now, done in the .py file
            }

            // clsids registration for known coclasses
            if (g_pCLSIDMap)
            {
// Disabled for now, done in the .py file
            }
        }
        Py_XDECREF(g_pIIDMap);
        Py_XDECREF(g_pCLSIDMap);
    }

}
