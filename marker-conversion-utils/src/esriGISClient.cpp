// This source is all automatically generated. Editing it may very
// well be an exercise in futility and frustration.
#include "Python.h"
#include "datetime.h"

// imports
#import "ArcGISVersion.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids, rename("esriProductCode", "esriVersionProductCode"), rename("VersionManager", "ArcGISVersionManager")
#import "esriSystem.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("OLE_COLOR", "OLE_HANDLE", "VARTYPE")
#import "esriSystemUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeometry.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsCore.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsSymbols.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDisplay.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriServer.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriOutput.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabase.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseDistributed.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseExtensions.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabasePS.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGISClient.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesFile.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesGDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesOleDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRaster.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesNetCDF.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRasterUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriCarto.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("UINT_PTR")


// Globals we need to keep around -- a reference to the UUID class for mapping
// GUIDs to Python-usable UUIDs and the IUnknown type we'll be using across the
// board.
static PyObject* g_pUUID_type = NULL;
static PyObject* g_pUnk_type = NULL;
static PyObject* g_pIIDMap = NULL;
static PyObject* g_pCLSIDMap = NULL;
static PyObject* g_pRecordMap = NULL;

// PyObject destructor for PyCObjects that hold IUnknown* in them
static void
destr_unknown(void* pvUnk)
{
    IUnknown* pUnk = (IUnknown*)pvUnk;
    if (pUnk)
        pUnk->Release();
}

// Checker/caster to see if we can get a GUID from a Python object, either
// by  checking if the object is an instance of the uuid.UUID type, or if
// it is a string, coercing it with the constructor and seeing if it accepts
// it.
//
// def GuidFromPyObject(potentialIID, GUID*):
//     if isinstance(potentialIID, basestring):
//         try:
//             potentialIID = uuid.UUID(potentialIID)
//         except:
//             return False
//     if isinstance(potentialIID, uuid.UUID):
//         if (<copy raw bytes of UUID data in object to out GUID*>):
//             return True
//     return False
//
static bool
GuidFromPyObject(PyObject* potentialIID, GUID* pOutGUID)
{
    if (!g_pUUID_type)
        return false;

    // See if we can cast a string into a UUID instance, if that's what we've got.
    if (PyString_Check(potentialIID) || PyUnicode_Check(potentialIID))
    {
        PyObject* piid_object = PyObject_CallFunction(g_pUUID_type, "O", potentialIID);
        bool retval = (piid_object)?GuidFromPyObject(piid_object, pOutGUID): false;
        Py_XDECREF(piid_object);
        if (!piid_object || PyErr_Occurred())
        {
            PyErr_Clear();
            PyObject* unicodearg = NULL;
            if (PyString_Check(potentialIID))
                unicodearg = PyUnicode_FromObject(potentialIID);
            else if (PyUnicode_Check(potentialIID))
            {
                unicodearg = potentialIID;
                Py_INCREF(unicodearg);
            }
            if (unicodearg)
            {
                BSTR classname = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodearg),
                                                     (UINT)PyUnicode_GET_SIZE(unicodearg));
                CLSID clsid;
                if (CLSIDFromProgID(classname, &clsid) == S_OK)
                {
                    retval = true;
                    if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)&clsid, 16))
                        retval = false;
                }
                ::SysFreeString(classname);
            }
            Py_XDECREF(unicodearg);
        }
        return retval;
    }
    else if (PyObject_IsInstance(potentialIID, g_pUUID_type))
    {
        // Fetch raw bytes string -- need to fetch "bytes" on big-endian, 
        // "bytes_le" on little-endian architectures
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )        
            pBytes = PyObject_GetAttrString(potentialIID, "bytes");
        else
            pBytes = PyObject_GetAttrString(potentialIID, "bytes_le");
        if (pBytes)
        {
            bool retval = true;
            // Pointer to raw data
            char* pRawBytes = PyString_AsString(pBytes);
            if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)pRawBytes, 16))
                retval = false;
            Py_XDECREF(pBytes);
            return retval;
        }
        PyErr_Clear();
    }
    return false;
}

static PyObject*
GUIDToPythonUUID(const GUID* UUID)
{
    if (UUID)
    {
        // Lie to Python and tell it that our GUID is a 16-byte string
        PyObject* PyUUIDString = PyString_FromStringAndSize((char *)UUID, sizeof(GUID));
        if (!PyUUIDString)
            return NULL;
        // Args, varargs
        PyObject* PyArgs = PyTuple_New(0);
        PyObject* PyKWArgs = PyDict_New();
        PyObject* RetVal = NULL;
        // Dict with single value: the keyword argument bytes_le.
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )
            PyDict_SetItemString(PyKWArgs, "bytes", PyUUIDString);
        else
            PyDict_SetItemString(PyKWArgs, "bytes_le", PyUUIDString);
        // New UUID with KW
        if (g_pUUID_type)
            RetVal = PyObject_Call(g_pUUID_type, PyArgs, PyKWArgs);
        else
            PyErr_SetString(PyExc_ImportError, "UUID module import failed");

        Py_DECREF(PyUUIDString);
        Py_DECREF(PyArgs);
        Py_DECREF(PyKWArgs);
        return RetVal;
    }
    else
    {
        PyErr_SetString(PyExc_ValueError, "Bad GUID");
        return NULL;
    }
}

static PyObject*
IUnknownToPythonIIDObject(IUnknown* pUnk, const GUID* IID)
{
    PyObject* RetVal = NULL;
    pUnk->AddRef();
    PyObject* PyUnk = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    //return PyUnk;

    PyObject* pCall = NULL;

    PyObject* pGuidObject = GUIDToPythonUUID(IID);
    if (!pGuidObject || !g_pIIDMap)
        return PyUnk;

    if (PyDict_Contains(g_pIIDMap, pGuidObject) == 1)
        pCall = PyDict_GetItem(g_pIIDMap, pGuidObject);
    if (!pCall)
        pCall = g_pUnk_type;
    if (pCall)
        RetVal = PyObject_CallFunction(pCall, "O", PyUnk);

    if (!RetVal)
        RetVal = PyUnk;
    else
        Py_DECREF(PyUnk);

    Py_XDECREF(pGuidObject);
    return RetVal;
}

static PyObject*
DATE_AsPyObject(DATE in_date)
{
  PyDateTime_IMPORT;
  // Round to even number of days
  int days = (int)in_date;
  // Convert what's left (after the decimal) to seconds; 86400 seconds per day.
  int seconds = (int)((in_date - (double)days) * 86400.0);
  if (in_date < 0)
    seconds *= -1;
  // TimeDelta to add to the date representing the start of all Variant VT_DATEs
  PyObject* pDelta = PyDelta_FromDSU(days, seconds, 0);
  // Midnight 30 December 1899
  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  // Do addition of computed delta to 1899-12-30 00:00:00
  PyObject* pRetVal = PyObject_CallMethod(pStartOfVariantTime, "__add__", "O", pDelta);

  Py_XDECREF(pDelta);
  Py_XDECREF(pStartOfVariantTime);

  return pRetVal;
}

static DATE
PyObject_AsDATE(PyObject* in_date)
{
  PyDateTime_IMPORT;
  if (!PyDateTime_Check(in_date))
  {
    PyErr_SetString(PyExc_ValueError, "Cannot convert this Python object to a datetime");
    return (DATE)0.0;
  }

  double out_date;

  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  PyDateTime_Delta* pDelta = (PyDateTime_Delta *)PyObject_CallMethod(in_date, "__sub__", "O", pStartOfVariantTime);
  Py_XDECREF(pStartOfVariantTime);
  
  if (pDelta && PyDelta_Check((PyObject *)pDelta))
  {
    out_date = (double)pDelta->days;
    out_date += (double)(pDelta->seconds) / 86400.0;
  }
  
  Py_XDECREF(pDelta);
  return (DATE)out_date;
}

static bool
PyObject_AsVariant(PyObject* in_object, VARIANT* out_variant)
{
  ::VariantClear(out_variant);
  PyDateTime_IMPORT;

  if (in_object == Py_None)
    return true;
  else if (PyUnicode_Check(in_object))
  {
    out_variant->vt = VT_BSTR;
    BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(in_object), 
                                          (UINT)PyUnicode_GET_SIZE(in_object));
    out_variant->bstrVal = out_string;
    return true;
  }
  else if (PyString_Check(in_object))
  {
    PyObject* pUnicode = PyUnicode_FromObject(in_object);
    if (pUnicode)
    {
      out_variant->vt = VT_BSTR;
      BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(pUnicode), 
                                            (UINT)PyUnicode_GET_SIZE(pUnicode));
      out_variant->bstrVal = out_string;
      Py_DECREF(pUnicode);
      return true;
    }
    return false;
  }
  else if (PyFloat_Check(in_object))
  {
    out_variant->vt = VT_R8;
    out_variant->dblVal = PyFloat_AsDouble(in_object);
    return true;
  }
  else if (PyInt_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyInt_AsLong(in_object);
    return true;
  }
  else if (PyLong_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyLong_AsLongLong(in_object);
    if (PyErr_Occurred())
    {
      PyErr_Clear();
      PyObject* strval = PyObject_Str(in_object);
      if (strval)
      {
        PyObject* unival = PyUnicode_FromObject(strval);
        out_variant->vt = VT_BSTR;
        BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unival), 
                                              (UINT)PyUnicode_GET_SIZE(unival));
        out_variant->bstrVal = out_string;
        Py_DecRef(unival);
        Py_DecRef(strval);
        return true;
      }
      return false;
    }
    else
      return true;
  }
  else if (PyDateTime_Check(in_object))
  {
    out_variant->vt = VT_DATE;
    out_variant->date = PyObject_AsDATE(in_object);

    return true;
  }
  else if (PyObject_HasAttrString(in_object, "_pUnk"))
  {
    PyObject* pUnk = PyObject_GetAttrString(in_object, "_pUnk");
    if (pUnk && PyCObject_Check(pUnk))
    {
      IUnknown* pIUnknown = (IUnknown*)PyCObject_AsVoidPtr(pUnk);
      pIUnknown->AddRef();
      out_variant->vt = VT_UNKNOWN;
      out_variant->punkVal = pIUnknown;
      Py_DecRef(pUnk);
      return true;
    }
    Py_XDECREF(pUnk);
  }
  PyObject* repr = PyObject_Repr(in_object);
  PyErr_Format(PyExc_ValueError, "Can't convert %s to Variant.", repr?PyString_AsString(repr):"<Undef>", NULL);
  Py_XDECREF(repr);
  return false;
}

// Forward decl!
static PyObject* SAFEARRAYToPyObject(SAFEARRAY*, VARTYPE);

static PyObject*
Variant_AsPyObject(VARIANT* in_variant)
{
  if (in_variant->vt == VT_EMPTY)
    Py_RETURN_NONE;
  else if (in_variant->vt  == (VT_BYREF|VT_I1))
    return PyInt_FromLong(*(in_variant->pcVal)); //CHAR                *
  else if (in_variant->vt == (VT_BYREF|VT_UI2))
    return PyInt_FromLong(*(in_variant->puiVal)); //USHORT              *
  else if (in_variant->vt == (VT_BYREF|VT_UI4))
    return PyInt_FromLong(*(in_variant->pulVal)); //ULONG               *
  else if (in_variant->vt == (VT_BYREF|VT_UI8))
    return PyLong_FromUnsignedLongLong(*(in_variant->pullVal)); //ULONGLONG           *
  else if (in_variant->vt == (VT_BYREF|VT_INT))
    return PyInt_FromLong(*(in_variant->pintVal)); //INT                 *
  else if (in_variant->vt == (VT_BYREF|VT_UINT))
    return PyInt_FromLong(*(in_variant->puintVal)); //UINT                *
  else if (in_variant->vt == (VT_BYREF|VT_UI1))
    return PyInt_FromLong(*(in_variant->pbVal)); //BYTE                *
  else if (in_variant->vt == (VT_BYREF|VT_I2))
    return PyInt_FromLong(*(in_variant->piVal)); //SHORT               *
  else if (in_variant->vt == (VT_BYREF|VT_I4))
    return PyInt_FromLong(*(in_variant->plVal)); //LONG                *
  else if (in_variant->vt == (VT_BYREF|VT_I8))
    return PyLong_FromLongLong(*(in_variant->pllVal)); //LONGLONG            *
  else if (in_variant->vt == (VT_BYREF|VT_R4))
    return PyFloat_FromDouble((double)*(in_variant->pfltVal)); //FLOAT               *
  else if (in_variant->vt == (VT_BYREF|VT_R8))
    return PyFloat_FromDouble((double)*(in_variant->pdblVal)); //DOUBLE              *
  else if (in_variant->vt == (VT_BYREF|VT_BOOL))
    if ((*(in_variant->pboolVal)) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;
  else if (in_variant->vt == (VT_BYREF|VT_BSTR))
    return PyUnicode_FromWideChar(*(in_variant->pbstrVal),::SysStringLen(*(in_variant->pbstrVal)));  //BSTR                *
  else if (in_variant->vt == (VT_BYREF|VT_UNKNOWN))
  {
    IUnknown* pUnk = *(in_variant->ppunkVal);
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_DISPATCH))
  {
    IDispatch* pDisp = *(in_variant->ppdispVal);
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_VARIANT))
    return Variant_AsPyObject(in_variant->pvarVal); //VARIANT             *
  else if (in_variant->vt  == VT_I8)
    return PyLong_FromLongLong(in_variant->llVal); //LONGLONG           
  else if (in_variant->vt == VT_I4)
    return PyInt_FromLong(in_variant->lVal); //LONG               
  else if (in_variant->vt == VT_UI1)
    return PyInt_FromLong((unsigned)in_variant->bVal); //BYTE               
  else if (in_variant->vt == VT_I2)
    return PyInt_FromLong(in_variant->iVal); //SHORT              
  else if (in_variant->vt == VT_R4)
    return PyFloat_FromDouble((double)(in_variant->fltVal)); //FLOAT              
  else if (in_variant->vt == VT_R8)
    return PyFloat_FromDouble((double)(in_variant->dblVal)); //DOUBLE             
  else if (in_variant->vt == VT_BOOL)
    if ((in_variant->boolVal) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;              
  else if (in_variant->vt == VT_BSTR)
    return PyUnicode_FromWideChar(in_variant->bstrVal, ::SysStringLen(in_variant->bstrVal)); //BSTR               
  else if (in_variant->vt == VT_UNKNOWN)
  {
    IUnknown* pUnk = in_variant->punkVal;
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_DISPATCH)
  {
    IDispatch* pDisp = in_variant->pdispVal;
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_I1)
    return PyInt_FromLong(in_variant->cVal); //CHAR               
  else if (in_variant->vt == VT_UI2)
    return PyInt_FromLong(in_variant->uiVal); //USHORT             
  else if (in_variant->vt == VT_UI4)
    return PyInt_FromLong(in_variant->ulVal); //ULONG              
  else if (in_variant->vt == VT_UI8)
    return PyLong_FromUnsignedLongLong(in_variant->ullVal); //ULONGLONG          
  else if (in_variant->vt == VT_INT)
    return PyInt_FromLong(in_variant->intVal); //INT                
  else if (in_variant->vt == VT_UINT)
    return PyInt_FromLong(in_variant->uintVal); //UINT               
  else if ((in_variant->vt & VT_DATE) == VT_DATE)
  {
    DATE in_date = (in_variant->vt & VT_BYREF)?(*(in_variant->pdate)):in_variant->date;
    return DATE_AsPyObject(in_date);
  }
  else if (in_variant->vt & VT_ARRAY)
  {
    return SAFEARRAYToPyObject((in_variant->vt & VT_BYREF) ? 
                                        *(in_variant->pparray) : 
                                        in_variant->parray,
                                (in_variant->vt));
  }

  PyErr_SetString(PyExc_ValueError, "Cannot convert this variant to a Python object");
  return NULL;
}

static PyObject*
SAFEARRAYToPyObject(SAFEARRAY* pArray, VARTYPE vt)
{
  if (!pArray)
    Py_RETURN_NONE;
  PyObject* return_array(NULL);
  long entry_count(1);
  for (ssize_t dimension(0); dimension < pArray->cDims; ++dimension)
    entry_count *= (pArray->rgsabound[dimension]).cElements;
  if (pArray->fFeatures & FADF_BSTR)
  {
    return_array = PyList_New(0);
    BSTR* barray = (BSTR*)pArray->pvData;
    for (long string_index = 0; string_index < entry_count; ++string_index)
    {
      PyObject* new_string = PyUnicode_FromWideChar(barray[string_index], ::SysStringLen(barray[string_index]));
      PyList_Append(return_array, new_string);
      Py_DECREF(new_string);
    }
  }
  else if (pArray->fFeatures & FADF_VARIANT)
  {
    return_array = PyList_New(0);
    VARIANT* varray = (VARIANT*)pArray->pvData;
    for (long variant_index(0); variant_index < entry_count; ++variant_index)
    {
      PyObject* new_variant = Variant_AsPyObject(&varray[variant_index]);
      if (new_variant)
      {
        PyList_Append(return_array, new_variant);
        Py_DECREF(new_variant);
      }
      else
      {
        PyErr_Clear();
        PyList_Append(return_array, Py_None);
      }
    }
  }
  else if (pArray->fFeatures & FADF_UNKNOWN)
  {
    return_array = PyList_New(0);
    IUnknown** oarray = (IUnknown**)pArray->pvData;
    for (long object_index(0); object_index < entry_count; ++object_index)
    {
      PyObject* new_object = IUnknownToPythonIIDObject(oarray[object_index], &IID_IUnknown);
      PyList_Append(return_array, new_object);
      Py_DECREF(new_object);
    }
  }
  else if (vt == (VT_UI1 | VT_ARRAY))
  {
    return_array = PyByteArray_FromStringAndSize((char*)(pArray->pvData), entry_count);
  }

  if (!return_array)
  {
    if (PyErr_WarnEx(PyExc_Warning, "conversion for this error type not implemented", -1) != 0)
      return 0;

    return_array = Py_BuildValue("(HHNK)", (unsigned short)vt,
                                           (unsigned short)pArray->fFeatures,
                                           PyByteArray_FromStringAndSize((char*)(pArray->pvData), 
                                                                         sizeof(pArray->pvData)),
                                           (unsigned long long)pArray->pvData);
  }
  return return_array;
}

// Attempt to get an interface pointer from a Python object
static bool
IFaceFromPyObject(PyObject* pIn, const GUID* pOutGuid, void** pOutIFace)
{
    IUnknown* pUnk = NULL;

    if (pIn == Py_None)
    {
        *pOutIFace = NULL;
        return true;
    }
    else if (PyCObject_Check(pIn))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(pIn);
    }
    else
    {
        bool need_decref(false);
        if (PyObject_HasAttrString(pIn, "_arc_object"))
        {
          pIn = PyObject_GetAttrString(pIn, "_arc_object");
          if (pIn)
            need_decref = true;
        }
        PyObject* pObject = PyObject_GetAttrString(pIn, "_pUnk");
        if (!pObject)
            return false;
        if (!PyCObject_Check(pObject))
            return false;
        else
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(pObject);
        if (need_decref)
            Py_DECREF(pIn);
        Py_XDECREF(pObject);
    }
    if (pUnk && SUCCEEDED(pUnk->QueryInterface(*pOutGuid, pOutIFace)))
        return true;

    return false;
}



// Every module implements this IUnknown thing but only one reference to the 
// _Type struct will be used between them, so type checking will still work.
// This has the happy side effect of letting us pick and choose which of the
// OLBs that are offered as wrappers (and just plain remove them) without 
// needing to worry about it. Whichever of the C modules in the suite that gets
// imported first is fully capable and will do its best to bootstrap the system.

typedef struct IUnknownObject {
    PyObject_HEAD
    IUnknown* m_pUnk;
} IUnknownObject;

static PyObject*
IUnknownObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    IUnknownObject* self;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {        
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUnknown with provided CLSID");
            return NULL;
        }
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        pUnk->AddRef();
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUnknown");
            return NULL;
        }
        if (!PyCObject_Check(argument))
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUnknown");
            return NULL;
        }
        else
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
            pUnk->AddRef();
        }
        if (argument)
            Py_DECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    if (!(self = ((IUnknownObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUnknown");
        return NULL;
    }

    self->m_pUnk = pUnk;
    return (PyObject *)self;
}

static void
IUnknownObject_dealloc(IUnknownObject* self)
{
    if (self->m_pUnk)
        self->m_pUnk->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
IUnknown_GetpUnk(IUnknownObject* self)
{
    if (!self->m_pUnk)
        Py_RETURN_NONE;
    self->m_pUnk->AddRef();
    return PyCObject_FromVoidPtr((void*)self->m_pUnk, destr_unknown);
}

static PyObject*
IUnknown_GetPointer(IUnknownObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pUnk);
}

static PyObject*
IUnknown_GetIID(IUnknownObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
IUnknown_SupportsInterface(IUnknownObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pUnk->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}

PyMethodDef IUnknownMethods[] = {
    {"supports", (PyCFunction)IUnknown_SupportsInterface, METH_O, ""},
};

PyGetSetDef IUnknownGetSet[] = {
  {"_IID", (getter)IUnknown_GetIID, NULL, "Get IID for Unknown", NULL},
  {"_pUnk", (getter)IUnknown_GetpUnk, NULL, "Get opaque pointer to Unknown", NULL},
  {"_pointer", (getter)IUnknown_GetPointer, NULL, "Get long pointer to Unknown", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject IUnknownObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "cartocomutils.IUnknown",
                                              /* tp_name */
  sizeof(IUnknownObject),                     /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)IUnknownObject_dealloc,         /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "IUnknown",                                 /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  IUnknownMethods,                            /* tp_methods */
  0,                                          /* tp_members */
  IUnknownGetSet,                             /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  IUnknownObject_new,                         /* tp_new */
};




// Interface IAGSServerConnectionName

typedef struct PyIAGSServerConnectionNameObject {
    PyObject_HEAD
    IAGSServerConnectionName* m_pIAGSServerConnectionName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnectionNameObject;

static PyObject*
PyIAGSServerConnectionNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnectionNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnectionName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnectionName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnectionName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnectionNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionName");
            return NULL;
        }
        self->m_pIAGSServerConnectionName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnectionName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnectionName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnectionName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnectionNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnectionName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnectionNameObject_dealloc(PyIAGSServerConnectionNameObject* self)
{
    if (self->m_pIAGSServerConnectionName)
        self->m_pIAGSServerConnectionName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnectionName_GetpUnk(PyIAGSServerConnectionNameObject* self)
{
    if (!self->m_pIAGSServerConnectionName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnectionName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnectionName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnectionName_GetPointer(PyIAGSServerConnectionNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnectionName);
}

static PyObject*
PyIAGSServerConnectionName_GetIID(PyIAGSServerConnectionNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "298cce6a-4d86-40ee-8f4a-bebc419b9a4d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnectionName_GetHR(PyIAGSServerConnectionNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnectionName_GetIgnoreFailures(PyIAGSServerConnectionNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnectionName_SetIgnoreFailures(PyIAGSServerConnectionNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnectionName_SupportsInterface(PyIAGSServerConnectionNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnectionNameMethod_put_ConnectionProperties(PyIAGSServerConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnProps = NULL;
    PyObject* py_ppConnProps;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppConnProps))
      goto iagsserverconnectionname_put_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppConnProps, &IID_IPropertySet, (void**)&ipppConnProps))
        PyErr_SetString(PyExc_TypeError, "Argument ppConnProps (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname_put_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName->put_ConnectionProperties(ipppConnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName.put_ConnectionProperties() returned %ld", (long)hr);
        goto iagsserverconnectionname_put_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppConnProps

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname_put_connectionproperties_method_cleanup;

    iagsserverconnectionname_put_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipppConnProps)
      ipppConnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName.put_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionNameMethod_get_ConnectionProperties(PyIAGSServerConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnProps = NULL;
    PyObject* py_ppConnProps = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppConnProps

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName->get_ConnectionProperties(&ipppConnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName.get_ConnectionProperties() returned %ld", (long)hr);
        goto iagsserverconnectionname_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppConnProps);
    if (ipppConnProps)
    {
        IUnknown* pUnk = NULL;
        ipppConnProps->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnProps = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnProps)
    {
        if (py_ppConnProps)
           Py_DECREF(py_ppConnProps);
        py_ppConnProps = Py_None;
        Py_INCREF(py_ppConnProps);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionname_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnProps);
    goto iagsserverconnectionname_get_connectionproperties_method_cleanup;

    iagsserverconnectionname_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppConnProps);
    if (ipppConnProps)
      ipppConnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName.get_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionNameMethod_get_ConnectionType(PyIAGSServerConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSConnectionType epConnType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pConnType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName->get_ConnectionType(&epConnType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName.get_ConnectionType() returned %ld", (long)hr);
        goto iagsserverconnectionname_get_connectiontype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epConnType);
    goto iagsserverconnectionname_get_connectiontype_method_cleanup;

    iagsserverconnectionname_get_connectiontype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pConnType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName.get_ConnectionType");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnectionNameMethods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnectionName_SupportsInterface, METH_O, ""},
    {"put_ConnectionProperties", (PyCFunction)IAGSServerConnectionNameMethod_put_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IAGSServerConnectionNameMethod_get_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionType", (PyCFunction)IAGSServerConnectionNameMethod_get_ConnectionType, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnectionNameGetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnectionName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnectionName", NULL},
  {"_pointer", (getter)PyIAGSServerConnectionName_GetPointer, NULL, "Get memory address for IAGSServerConnectionName", NULL},
  {"_IID", (getter)PyIAGSServerConnectionName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnectionName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnectionName_GetIgnoreFailures, (setter)PyIAGSServerConnectionName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnectionNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnectionNameObject",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnectionNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnectionNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnectionNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnectionNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnectionNameObject_new,                      
                                              /* tp_new */
};

// Interface IAGSServerObjectName

typedef struct PyIAGSServerObjectNameObject {
    PyObject_HEAD
    IAGSServerObjectName* m_pIAGSServerObjectName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerObjectNameObject;

static PyObject*
PyIAGSServerObjectNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerObjectNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerObjectName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerObjectName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerObjectName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerObjectNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerObjectName");
            return NULL;
        }
        self->m_pIAGSServerObjectName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerObjectName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerObjectName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerObjectName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerObjectName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerObjectName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerObjectNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerObjectName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerObjectName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerObjectNameObject_dealloc(PyIAGSServerObjectNameObject* self)
{
    if (self->m_pIAGSServerObjectName)
        self->m_pIAGSServerObjectName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerObjectName_GetpUnk(PyIAGSServerObjectNameObject* self)
{
    if (!self->m_pIAGSServerObjectName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerObjectName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerObjectName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerObjectName_GetPointer(PyIAGSServerObjectNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerObjectName);
}

static PyObject*
PyIAGSServerObjectName_GetIID(PyIAGSServerObjectNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "436bd37c-fe61-4a2e-9d74-1ae6fc8d654d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerObjectName_GetHR(PyIAGSServerObjectNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerObjectName_GetIgnoreFailures(PyIAGSServerObjectNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerObjectName_SetIgnoreFailures(PyIAGSServerObjectNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerObjectName_SupportsInterface(PyIAGSServerObjectNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerObjectNameMethod_put_Name(PyIAGSServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectName = 0;
    PyObject* pyvar_objectName;
    PyObject* unicodeobjectName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_objectName))
      goto iagsserverobjectname_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_objectName))
        unicodeobjectName = PyUnicode_FromObject(pyvar_objectName);
    else if (PyUnicode_Check(pyvar_objectName))
    {
        unicodeobjectName = pyvar_objectName;
        Py_INCREF(unicodeobjectName);
    }
    else if (pyvar_objectName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter objectName at index 0");
    if (unicodeobjectName)
        bsobjectName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeobjectName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeobjectName));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName->put_Name(bsobjectName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName.put_Name() returned %ld", (long)hr);
        goto iagsserverobjectname_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objectName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname_put_name_method_cleanup;

    iagsserverobjectname_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsobjectName)
        ::SysFreeString(bsobjectName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName.put_Name");
    return return_tuple;
}

static PyObject*
IAGSServerObjectNameMethod_get_Name(PyIAGSServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectName;
    PyObject* pyvar_objectName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for objectName

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName->get_Name(&bsobjectName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName.get_Name() returned %ld", (long)hr);
        goto iagsserverobjectname_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_objectName = PyUnicode_FromWideChar(bsobjectName,::SysStringLen(bsobjectName));
    ::SysFreeString(bsobjectName);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_objectName);
    goto iagsserverobjectname_get_name_method_cleanup;

    iagsserverobjectname_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_objectName != Py_None)
        Py_XDECREF(pyvar_objectName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName.get_Name");
    return return_tuple;
}

static PyObject*
IAGSServerObjectNameMethod_put_Type(PyIAGSServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsObjectType = 0;
    PyObject* pyvar_ObjectType;
    PyObject* unicodeObjectType = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ObjectType))
      goto iagsserverobjectname_put_type_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ObjectType))
        unicodeObjectType = PyUnicode_FromObject(pyvar_ObjectType);
    else if (PyUnicode_Check(pyvar_ObjectType))
    {
        unicodeObjectType = pyvar_ObjectType;
        Py_INCREF(unicodeObjectType);
    }
    else if (pyvar_ObjectType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ObjectType at index 0");
    if (unicodeObjectType)
        bsObjectType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeObjectType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeObjectType));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname_put_type_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName->put_Type(bsObjectType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName.put_Type() returned %ld", (long)hr);
        goto iagsserverobjectname_put_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ObjectType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname_put_type_method_cleanup;

    iagsserverobjectname_put_type_method_cleanup:
    self->m_HR = hr;
    if (bsObjectType)
        ::SysFreeString(bsObjectType);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName.put_Type");
    return return_tuple;
}

static PyObject*
IAGSServerObjectNameMethod_get_Type(PyIAGSServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsObjectType;
    PyObject* pyvar_ObjectType = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ObjectType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName->get_Type(&bsObjectType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName.get_Type() returned %ld", (long)hr);
        goto iagsserverobjectname_get_type_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ObjectType = PyUnicode_FromWideChar(bsObjectType,::SysStringLen(bsObjectType));
    ::SysFreeString(bsObjectType);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname_get_type_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ObjectType);
    goto iagsserverobjectname_get_type_method_cleanup;

    iagsserverobjectname_get_type_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ObjectType != Py_None)
        Py_XDECREF(pyvar_ObjectType);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName.get_Type");
    return return_tuple;
}

static PyObject*
IAGSServerObjectNameMethod_put_URL(PyIAGSServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectURL = 0;
    PyObject* pyvar_objectURL;
    PyObject* unicodeobjectURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_objectURL))
      goto iagsserverobjectname_put_url_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_objectURL))
        unicodeobjectURL = PyUnicode_FromObject(pyvar_objectURL);
    else if (PyUnicode_Check(pyvar_objectURL))
    {
        unicodeobjectURL = pyvar_objectURL;
        Py_INCREF(unicodeobjectURL);
    }
    else if (pyvar_objectURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter objectURL at index 0");
    if (unicodeobjectURL)
        bsobjectURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeobjectURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeobjectURL));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname_put_url_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName->put_URL(bsobjectURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName.put_URL() returned %ld", (long)hr);
        goto iagsserverobjectname_put_url_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objectURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname_put_url_method_cleanup;

    iagsserverobjectname_put_url_method_cleanup:
    self->m_HR = hr;
    if (bsobjectURL)
        ::SysFreeString(bsobjectURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName.put_URL");
    return return_tuple;
}

static PyObject*
IAGSServerObjectNameMethod_get_URL(PyIAGSServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectURL;
    PyObject* pyvar_objectURL = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for objectURL

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName->get_URL(&bsobjectURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName.get_URL() returned %ld", (long)hr);
        goto iagsserverobjectname_get_url_method_cleanup;
    }

    // Set up return values as needed
    pyvar_objectURL = PyUnicode_FromWideChar(bsobjectURL,::SysStringLen(bsobjectURL));
    ::SysFreeString(bsobjectURL);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname_get_url_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_objectURL);
    goto iagsserverobjectname_get_url_method_cleanup;

    iagsserverobjectname_get_url_method_cleanup:
    self->m_HR = hr;
    if (pyvar_objectURL != Py_None)
        Py_XDECREF(pyvar_objectURL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName.get_URL");
    return return_tuple;
}

static PyObject*
IAGSServerObjectNameMethod_get_AGSServerConnectionName(PyIAGSServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnectionName* ipppServerConnName = NULL;
    PyObject* py_ppServerConnName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppServerConnName

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName->get_AGSServerConnectionName(&ipppServerConnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName.get_AGSServerConnectionName() returned %ld", (long)hr);
        goto iagsserverobjectname_get_agsserverconnectionname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppServerConnName);
    if (ipppServerConnName)
    {
        IUnknown* pUnk = NULL;
        ipppServerConnName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppServerConnName = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnectionName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppServerConnName)
    {
        if (py_ppServerConnName)
           Py_DECREF(py_ppServerConnName);
        py_ppServerConnName = Py_None;
        Py_INCREF(py_ppServerConnName);
    }
    if (PyErr_Occurred())
      goto iagsserverobjectname_get_agsserverconnectionname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppServerConnName);
    goto iagsserverobjectname_get_agsserverconnectionname_method_cleanup;

    iagsserverobjectname_get_agsserverconnectionname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppServerConnName);
    if (ipppServerConnName)
      ipppServerConnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName.get_AGSServerConnectionName");
    return return_tuple;
}

static PyObject*
IAGSServerObjectNameMethod_putref_AGSServerConnectionName(PyIAGSServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnectionName* ipppServerConnName = NULL;
    PyObject* py_ppServerConnName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppServerConnName))
      goto iagsserverobjectname_putref_agsserverconnectionname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppServerConnName, &IID_IAGSServerConnectionName, (void**)&ipppServerConnName))
        PyErr_SetString(PyExc_TypeError, "Argument ppServerConnName (position 0) is not IAGSServerConnectionName");
    
    if (PyErr_Occurred())
      goto iagsserverobjectname_putref_agsserverconnectionname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName->putref_AGSServerConnectionName(ipppServerConnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName.putref_AGSServerConnectionName() returned %ld", (long)hr);
        goto iagsserverobjectname_putref_agsserverconnectionname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppServerConnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname_putref_agsserverconnectionname_method_cleanup;

    iagsserverobjectname_putref_agsserverconnectionname_method_cleanup:
    self->m_HR = hr;
    if (ipppServerConnName)
      ipppServerConnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName.putref_AGSServerConnectionName");
    return return_tuple;
}


PyMethodDef PyIAGSServerObjectNameMethods[] = {
    {"supports", (PyCFunction)PyIAGSServerObjectName_SupportsInterface, METH_O, ""},
    {"put_Name", (PyCFunction)IAGSServerObjectNameMethod_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IAGSServerObjectNameMethod_get_Name, METH_VARARGS, ""},
    {"put_Type", (PyCFunction)IAGSServerObjectNameMethod_put_Type, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IAGSServerObjectNameMethod_get_Type, METH_VARARGS, ""},
    {"put_URL", (PyCFunction)IAGSServerObjectNameMethod_put_URL, METH_VARARGS, ""},
    {"get_URL", (PyCFunction)IAGSServerObjectNameMethod_get_URL, METH_VARARGS, ""},
    {"get_AGSServerConnectionName", (PyCFunction)IAGSServerObjectNameMethod_get_AGSServerConnectionName, METH_VARARGS, ""},
    {"putref_AGSServerConnectionName", (PyCFunction)IAGSServerObjectNameMethod_putref_AGSServerConnectionName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerObjectNameGetSet[] = {
  {"_pUnk", (getter)PyIAGSServerObjectName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerObjectName", NULL},
  {"_pointer", (getter)PyIAGSServerObjectName_GetPointer, NULL, "Get memory address for IAGSServerObjectName", NULL},
  {"_IID", (getter)PyIAGSServerObjectName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerObjectName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerObjectName_GetIgnoreFailures, (setter)PyIAGSServerObjectName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerObjectNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerObjectNameObject",                          
                                              /* tp_name */
  sizeof(PyIAGSServerObjectNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerObjectNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerObjectNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerObjectNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerObjectNameObject_new,                      
                                              /* tp_new */
};

// Interface IAGSEnumServerObjectName

typedef struct PyIAGSEnumServerObjectNameObject {
    PyObject_HEAD
    IAGSEnumServerObjectName* m_pIAGSEnumServerObjectName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSEnumServerObjectNameObject;

static PyObject*
PyIAGSEnumServerObjectNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSEnumServerObjectNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSEnumServerObjectName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSEnumServerObjectName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSEnumServerObjectName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSEnumServerObjectNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSEnumServerObjectName");
            return NULL;
        }
        self->m_pIAGSEnumServerObjectName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSEnumServerObjectName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSEnumServerObjectName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSEnumServerObjectName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSEnumServerObjectName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSEnumServerObjectName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSEnumServerObjectNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSEnumServerObjectName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSEnumServerObjectName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSEnumServerObjectNameObject_dealloc(PyIAGSEnumServerObjectNameObject* self)
{
    if (self->m_pIAGSEnumServerObjectName)
        self->m_pIAGSEnumServerObjectName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSEnumServerObjectName_GetpUnk(PyIAGSEnumServerObjectNameObject* self)
{
    if (!self->m_pIAGSEnumServerObjectName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSEnumServerObjectName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSEnumServerObjectName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSEnumServerObjectName_GetPointer(PyIAGSEnumServerObjectNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSEnumServerObjectName);
}

static PyObject*
PyIAGSEnumServerObjectName_GetIID(PyIAGSEnumServerObjectNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e584b406-753e-4e29-b20b-fed66fa3ef3c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSEnumServerObjectName_GetHR(PyIAGSEnumServerObjectNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSEnumServerObjectName_GetIgnoreFailures(PyIAGSEnumServerObjectNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSEnumServerObjectName_SetIgnoreFailures(PyIAGSEnumServerObjectNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSEnumServerObjectName_SupportsInterface(PyIAGSEnumServerObjectNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSEnumServerObjectName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSEnumServerObjectNameMethod_Next(PyIAGSEnumServerObjectNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerObjectName* ipppSOName = NULL;
    PyObject* py_ppSOName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSOName

    // Call method on actual COM interface
    hr = self->m_pIAGSEnumServerObjectName->Next(&ipppSOName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSEnumServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSEnumServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSEnumServerObjectName.Next() returned %ld", (long)hr);
        goto iagsenumserverobjectname_next_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSOName);
    if (ipppSOName)
    {
        IUnknown* pUnk = NULL;
        ipppSOName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSOName = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerObjectName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSOName)
    {
        if (py_ppSOName)
           Py_DECREF(py_ppSOName);
        py_ppSOName = Py_None;
        Py_INCREF(py_ppSOName);
    }
    if (PyErr_Occurred())
      goto iagsenumserverobjectname_next_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSOName);
    goto iagsenumserverobjectname_next_method_cleanup;

    iagsenumserverobjectname_next_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSOName);
    if (ipppSOName)
      ipppSOName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSEnumServerObjectName.Next");
    return return_tuple;
}

static PyObject*
IAGSEnumServerObjectNameMethod_Reset(PyIAGSEnumServerObjectNameObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIAGSEnumServerObjectName->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSEnumServerObjectName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSEnumServerObjectName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSEnumServerObjectName.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIAGSEnumServerObjectNameMethods[] = {
    {"supports", (PyCFunction)PyIAGSEnumServerObjectName_SupportsInterface, METH_O, ""},
    {"Next", (PyCFunction)IAGSEnumServerObjectNameMethod_Next, METH_VARARGS, ""},
    {"Reset", (PyCFunction)IAGSEnumServerObjectNameMethod_Reset, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSEnumServerObjectNameGetSet[] = {
  {"_pUnk", (getter)PyIAGSEnumServerObjectName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSEnumServerObjectName", NULL},
  {"_pointer", (getter)PyIAGSEnumServerObjectName_GetPointer, NULL, "Get memory address for IAGSEnumServerObjectName", NULL},
  {"_IID", (getter)PyIAGSEnumServerObjectName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSEnumServerObjectName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSEnumServerObjectName_GetIgnoreFailures, (setter)PyIAGSEnumServerObjectName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSEnumServerObjectNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSEnumServerObjectNameObject",                          
                                              /* tp_name */
  sizeof(PyIAGSEnumServerObjectNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSEnumServerObjectNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSEnumServerObjectNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSEnumServerObjectNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSEnumServerObjectNameObject_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnection

typedef struct PyIAGSServerConnectionObject {
    PyObject_HEAD
    IAGSServerConnection* m_pIAGSServerConnection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnectionObject;

static PyObject*
PyIAGSServerConnectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnection");
            return NULL;
        }
        self->m_pIAGSServerConnection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnectionObject_dealloc(PyIAGSServerConnectionObject* self)
{
    if (self->m_pIAGSServerConnection)
        self->m_pIAGSServerConnection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnection_GetpUnk(PyIAGSServerConnectionObject* self)
{
    if (!self->m_pIAGSServerConnection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnection_GetPointer(PyIAGSServerConnectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnection);
}

static PyObject*
PyIAGSServerConnection_GetIID(PyIAGSServerConnectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "657f65fd-9795-40b4-b1ce-e235ef08614c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnection_GetHR(PyIAGSServerConnectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnection_GetIgnoreFailures(PyIAGSServerConnectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnection_SetIgnoreFailures(PyIAGSServerConnectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnection_SupportsInterface(PyIAGSServerConnectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnectionMethod_put_Name(PyIAGSServerConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iagsserverconnection_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection.put_Name() returned %ld", (long)hr);
        goto iagsserverconnection_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnection_put_name_method_cleanup;

    iagsserverconnection_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection.put_Name");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionMethod_get_Name(PyIAGSServerConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection.get_Name() returned %ld", (long)hr);
        goto iagsserverconnection_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iagsserverconnection_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iagsserverconnection_get_name_method_cleanup;

    iagsserverconnection_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection.get_Name");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionMethod_get_ServerObjectNames(PyIAGSServerConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSEnumServerObjectName* ipppSONames = NULL;
    PyObject* py_ppSONames = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSONames

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection->get_ServerObjectNames(&ipppSONames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection.get_ServerObjectNames() returned %ld", (long)hr);
        goto iagsserverconnection_get_serverobjectnames_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
    {
        IUnknown* pUnk = NULL;
        ipppSONames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSONames = IUnknownToPythonIIDObject(pUnk, &IID_IAGSEnumServerObjectName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSONames)
    {
        if (py_ppSONames)
           Py_DECREF(py_ppSONames);
        py_ppSONames = Py_None;
        Py_INCREF(py_ppSONames);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection_get_serverobjectnames_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSONames);
    goto iagsserverconnection_get_serverobjectnames_method_cleanup;

    iagsserverconnection_get_serverobjectnames_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
      ipppSONames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection.get_ServerObjectNames");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionMethod_get_FullName(PyIAGSServerConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppNameObject = NULL;
    PyObject* py_ppNameObject = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppNameObject

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection->get_FullName(&ipppNameObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection.get_FullName() returned %ld", (long)hr);
        goto iagsserverconnection_get_fullname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppNameObject);
    if (ipppNameObject)
    {
        IUnknown* pUnk = NULL;
        ipppNameObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppNameObject = IUnknownToPythonIIDObject(pUnk, &IID_IName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppNameObject)
    {
        if (py_ppNameObject)
           Py_DECREF(py_ppNameObject);
        py_ppNameObject = Py_None;
        Py_INCREF(py_ppNameObject);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection_get_fullname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppNameObject);
    goto iagsserverconnection_get_fullname_method_cleanup;

    iagsserverconnection_get_fullname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppNameObject);
    if (ipppNameObject)
      ipppNameObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection.get_FullName");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionMethod_putref_FullName(PyIAGSServerConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppNameObject = NULL;
    PyObject* py_ppNameObject;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppNameObject))
      goto iagsserverconnection_putref_fullname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppNameObject, &IID_IName, (void**)&ipppNameObject))
        PyErr_SetString(PyExc_TypeError, "Argument ppNameObject (position 0) is not IName");
    
    if (PyErr_Occurred())
      goto iagsserverconnection_putref_fullname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection->putref_FullName(ipppNameObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection.putref_FullName() returned %ld", (long)hr);
        goto iagsserverconnection_putref_fullname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppNameObject

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnection_putref_fullname_method_cleanup;

    iagsserverconnection_putref_fullname_method_cleanup:
    self->m_HR = hr;
    if (ipppNameObject)
      ipppNameObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection.putref_FullName");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnectionMethods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnection_SupportsInterface, METH_O, ""},
    {"put_Name", (PyCFunction)IAGSServerConnectionMethod_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IAGSServerConnectionMethod_get_Name, METH_VARARGS, ""},
    {"get_ServerObjectNames", (PyCFunction)IAGSServerConnectionMethod_get_ServerObjectNames, METH_VARARGS, ""},
    {"get_FullName", (PyCFunction)IAGSServerConnectionMethod_get_FullName, METH_VARARGS, ""},
    {"putref_FullName", (PyCFunction)IAGSServerConnectionMethod_putref_FullName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnectionGetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnection_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnection", NULL},
  {"_pointer", (getter)PyIAGSServerConnection_GetPointer, NULL, "Get memory address for IAGSServerConnection", NULL},
  {"_IID", (getter)PyIAGSServerConnection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnection_GetIgnoreFailures, (setter)PyIAGSServerConnection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnectionObject",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnectionObject_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnection2

typedef struct PyIAGSServerConnection2Object {
    PyObject_HEAD
    IAGSServerConnection2* m_pIAGSServerConnection2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnection2Object;

static PyObject*
PyIAGSServerConnection2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnection2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnection2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnection2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnection2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnection2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnection2");
            return NULL;
        }
        self->m_pIAGSServerConnection2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnection2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnection2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnection2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnection2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnection2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnection2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnection2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnection2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnection2Object_dealloc(PyIAGSServerConnection2Object* self)
{
    if (self->m_pIAGSServerConnection2)
        self->m_pIAGSServerConnection2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnection2_GetpUnk(PyIAGSServerConnection2Object* self)
{
    if (!self->m_pIAGSServerConnection2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnection2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnection2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnection2_GetPointer(PyIAGSServerConnection2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnection2);
}

static PyObject*
PyIAGSServerConnection2_GetIID(PyIAGSServerConnection2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6921c52d-0d14-4d2c-8a80-a7873c1306ea");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnection2_GetHR(PyIAGSServerConnection2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnection2_GetIgnoreFailures(PyIAGSServerConnection2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnection2_SetIgnoreFailures(PyIAGSServerConnection2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnection2_SupportsInterface(PyIAGSServerConnection2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnection2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnection2Method_get_ServerObjectNamesEx(PyIAGSServerConnection2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFolderName = 0;
    PyObject* pyvar_FolderName;
    PyObject* unicodeFolderName = NULL;
    IAGSEnumServerObjectName* ipppSONames = NULL;
    PyObject* py_ppSONames = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FolderName))
      goto iagsserverconnection2_get_serverobjectnamesex_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FolderName))
        unicodeFolderName = PyUnicode_FromObject(pyvar_FolderName);
    else if (PyUnicode_Check(pyvar_FolderName))
    {
        unicodeFolderName = pyvar_FolderName;
        Py_INCREF(unicodeFolderName);
    }
    else if (pyvar_FolderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FolderName at index 0");
    if (unicodeFolderName)
        bsFolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFolderName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection2_get_serverobjectnamesex_method_cleanup;
    
    // No setup for ppSONames

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection2->get_ServerObjectNamesEx(bsFolderName, &ipppSONames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection2.get_ServerObjectNamesEx() returned %ld", (long)hr);
        goto iagsserverconnection2_get_serverobjectnamesex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FolderName
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
    {
        IUnknown* pUnk = NULL;
        ipppSONames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSONames = IUnknownToPythonIIDObject(pUnk, &IID_IAGSEnumServerObjectName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSONames)
    {
        if (py_ppSONames)
           Py_DECREF(py_ppSONames);
        py_ppSONames = Py_None;
        Py_INCREF(py_ppSONames);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection2_get_serverobjectnamesex_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSONames);
    goto iagsserverconnection2_get_serverobjectnamesex_method_cleanup;

    iagsserverconnection2_get_serverobjectnamesex_method_cleanup:
    self->m_HR = hr;
    if (bsFolderName)
        ::SysFreeString(bsFolderName);
    
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
      ipppSONames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection2.get_ServerObjectNamesEx");
    return return_tuple;
}

static PyObject*
IAGSServerConnection2Method_GetFolders(PyIAGSServerConnection2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsreserved = 0;
    PyObject* pyvar_reserved;
    PyObject* unicodereserved = NULL;
    IEnumBSTR* ipppEnum = NULL;
    PyObject* py_ppEnum = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_reserved))
      goto iagsserverconnection2_getfolders_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_reserved))
        unicodereserved = PyUnicode_FromObject(pyvar_reserved);
    else if (PyUnicode_Check(pyvar_reserved))
    {
        unicodereserved = pyvar_reserved;
        Py_INCREF(unicodereserved);
    }
    else if (pyvar_reserved != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter reserved at index 0");
    if (unicodereserved)
        bsreserved = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodereserved), 
                                            (UINT)PyUnicode_GET_SIZE(unicodereserved));
    
    if (PyErr_Occurred())
      goto iagsserverconnection2_getfolders_method_cleanup;
    
    // No setup for ppEnum

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection2->GetFolders(bsreserved, &ipppEnum);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection2.GetFolders() returned %ld", (long)hr);
        goto iagsserverconnection2_getfolders_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for reserved
    Py_XDECREF(py_ppEnum);
    if (ipppEnum)
    {
        IUnknown* pUnk = NULL;
        ipppEnum->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppEnum = IUnknownToPythonIIDObject(pUnk, &IID_IEnumBSTR);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppEnum)
    {
        if (py_ppEnum)
           Py_DECREF(py_ppEnum);
        py_ppEnum = Py_None;
        Py_INCREF(py_ppEnum);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection2_getfolders_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppEnum);
    goto iagsserverconnection2_getfolders_method_cleanup;

    iagsserverconnection2_getfolders_method_cleanup:
    self->m_HR = hr;
    if (bsreserved)
        ::SysFreeString(bsreserved);
    
    Py_XDECREF(py_ppEnum);
    if (ipppEnum)
      ipppEnum->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection2.GetFolders");
    return return_tuple;
}

static PyObject*
IAGSServerConnection2Method_put_Name(PyIAGSServerConnection2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iagsserverconnection2_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection2_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection2->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection2.put_Name() returned %ld", (long)hr);
        goto iagsserverconnection2_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnection2_put_name_method_cleanup;

    iagsserverconnection2_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection2.put_Name");
    return return_tuple;
}

static PyObject*
IAGSServerConnection2Method_get_Name(PyIAGSServerConnection2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection2->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection2.get_Name() returned %ld", (long)hr);
        goto iagsserverconnection2_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iagsserverconnection2_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iagsserverconnection2_get_name_method_cleanup;

    iagsserverconnection2_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection2.get_Name");
    return return_tuple;
}

static PyObject*
IAGSServerConnection2Method_get_ServerObjectNames(PyIAGSServerConnection2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSEnumServerObjectName* ipppSONames = NULL;
    PyObject* py_ppSONames = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSONames

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection2->get_ServerObjectNames(&ipppSONames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection2.get_ServerObjectNames() returned %ld", (long)hr);
        goto iagsserverconnection2_get_serverobjectnames_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
    {
        IUnknown* pUnk = NULL;
        ipppSONames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSONames = IUnknownToPythonIIDObject(pUnk, &IID_IAGSEnumServerObjectName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSONames)
    {
        if (py_ppSONames)
           Py_DECREF(py_ppSONames);
        py_ppSONames = Py_None;
        Py_INCREF(py_ppSONames);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection2_get_serverobjectnames_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSONames);
    goto iagsserverconnection2_get_serverobjectnames_method_cleanup;

    iagsserverconnection2_get_serverobjectnames_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
      ipppSONames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection2.get_ServerObjectNames");
    return return_tuple;
}

static PyObject*
IAGSServerConnection2Method_get_FullName(PyIAGSServerConnection2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppNameObject = NULL;
    PyObject* py_ppNameObject = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppNameObject

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection2->get_FullName(&ipppNameObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection2.get_FullName() returned %ld", (long)hr);
        goto iagsserverconnection2_get_fullname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppNameObject);
    if (ipppNameObject)
    {
        IUnknown* pUnk = NULL;
        ipppNameObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppNameObject = IUnknownToPythonIIDObject(pUnk, &IID_IName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppNameObject)
    {
        if (py_ppNameObject)
           Py_DECREF(py_ppNameObject);
        py_ppNameObject = Py_None;
        Py_INCREF(py_ppNameObject);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection2_get_fullname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppNameObject);
    goto iagsserverconnection2_get_fullname_method_cleanup;

    iagsserverconnection2_get_fullname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppNameObject);
    if (ipppNameObject)
      ipppNameObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection2.get_FullName");
    return return_tuple;
}

static PyObject*
IAGSServerConnection2Method_putref_FullName(PyIAGSServerConnection2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppNameObject = NULL;
    PyObject* py_ppNameObject;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppNameObject))
      goto iagsserverconnection2_putref_fullname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppNameObject, &IID_IName, (void**)&ipppNameObject))
        PyErr_SetString(PyExc_TypeError, "Argument ppNameObject (position 0) is not IName");
    
    if (PyErr_Occurred())
      goto iagsserverconnection2_putref_fullname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection2->putref_FullName(ipppNameObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection2.putref_FullName() returned %ld", (long)hr);
        goto iagsserverconnection2_putref_fullname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppNameObject

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnection2_putref_fullname_method_cleanup;

    iagsserverconnection2_putref_fullname_method_cleanup:
    self->m_HR = hr;
    if (ipppNameObject)
      ipppNameObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection2.putref_FullName");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnection2Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnection2_SupportsInterface, METH_O, ""},
    {"get_ServerObjectNamesEx", (PyCFunction)IAGSServerConnection2Method_get_ServerObjectNamesEx, METH_VARARGS, ""},
    {"GetFolders", (PyCFunction)IAGSServerConnection2Method_GetFolders, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IAGSServerConnection2Method_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IAGSServerConnection2Method_get_Name, METH_VARARGS, ""},
    {"get_ServerObjectNames", (PyCFunction)IAGSServerConnection2Method_get_ServerObjectNames, METH_VARARGS, ""},
    {"get_FullName", (PyCFunction)IAGSServerConnection2Method_get_FullName, METH_VARARGS, ""},
    {"putref_FullName", (PyCFunction)IAGSServerConnection2Method_putref_FullName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnection2GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnection2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnection2", NULL},
  {"_pointer", (getter)PyIAGSServerConnection2_GetPointer, NULL, "Get memory address for IAGSServerConnection2", NULL},
  {"_IID", (getter)PyIAGSServerConnection2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnection2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnection2_GetIgnoreFailures, (setter)PyIAGSServerConnection2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnection2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnection2Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnection2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnection2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnection2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnection2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnection2Object_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnection3

typedef struct PyIAGSServerConnection3Object {
    PyObject_HEAD
    IAGSServerConnection3* m_pIAGSServerConnection3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnection3Object;

static PyObject*
PyIAGSServerConnection3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnection3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnection3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnection3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnection3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnection3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnection3");
            return NULL;
        }
        self->m_pIAGSServerConnection3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnection3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnection3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnection3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnection3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnection3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnection3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnection3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnection3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnection3Object_dealloc(PyIAGSServerConnection3Object* self)
{
    if (self->m_pIAGSServerConnection3)
        self->m_pIAGSServerConnection3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnection3_GetpUnk(PyIAGSServerConnection3Object* self)
{
    if (!self->m_pIAGSServerConnection3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnection3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnection3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnection3_GetPointer(PyIAGSServerConnection3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnection3);
}

static PyObject*
PyIAGSServerConnection3_GetIID(PyIAGSServerConnection3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "20e6a647-de9e-4e4c-a301-640b9ab0d143");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnection3_GetHR(PyIAGSServerConnection3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnection3_GetIgnoreFailures(PyIAGSServerConnection3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnection3_SetIgnoreFailures(PyIAGSServerConnection3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnection3_SupportsInterface(PyIAGSServerConnection3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnection3Method_GetFile(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;
    IStream* ipstream = NULL;
    PyObject* py_stream = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_URL))
      goto iagsserverconnection3_getfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 0");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto iagsserverconnection3_getfile_method_cleanup;
    
    // No setup for stream

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->GetFile(bsURL, &ipstream);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.GetFile() returned %ld", (long)hr);
        goto iagsserverconnection3_getfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for URL
    Py_XDECREF(py_stream);
    if (ipstream)
    {
        IUnknown* pUnk = NULL;
        ipstream->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_stream = IUnknownToPythonIIDObject(pUnk, &IID_IStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_stream)
    {
        if (py_stream)
           Py_DECREF(py_stream);
        py_stream = Py_None;
        Py_INCREF(py_stream);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection3_getfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_stream);
    goto iagsserverconnection3_getfile_method_cleanup;

    iagsserverconnection3_getfile_method_cleanup:
    self->m_HR = hr;
    if (bsURL)
        ::SysFreeString(bsURL);
    
    Py_XDECREF(py_stream);
    if (ipstream)
      ipstream->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.GetFile");
    return return_tuple;
}

static PyObject*
IAGSServerConnection3Method_GetFileAsVariant(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_URL))
      goto iagsserverconnection3_getfileasvariant_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 0");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto iagsserverconnection3_getfileasvariant_method_cleanup;
    
    // No setup for pValue

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->GetFileAsVariant(bsURL, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.GetFileAsVariant() returned %ld", (long)hr);
        goto iagsserverconnection3_getfileasvariant_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for URL
    pyvar_pValue = Variant_AsPyObject(&vpValue);
    if (PyErr_Occurred())
      goto iagsserverconnection3_getfileasvariant_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pValue);
    goto iagsserverconnection3_getfileasvariant_method_cleanup;

    iagsserverconnection3_getfileasvariant_method_cleanup:
    self->m_HR = hr;
    if (bsURL)
        ::SysFreeString(bsURL);
    
    ::VariantClear(&vpValue);
    Py_XDECREF(pyvar_pValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.GetFileAsVariant");
    return return_tuple;
}

static PyObject*
IAGSServerConnection3Method_get_ServerObjectNamesEx(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFolderName = 0;
    PyObject* pyvar_FolderName;
    PyObject* unicodeFolderName = NULL;
    IAGSEnumServerObjectName* ipppSONames = NULL;
    PyObject* py_ppSONames = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FolderName))
      goto iagsserverconnection3_get_serverobjectnamesex_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FolderName))
        unicodeFolderName = PyUnicode_FromObject(pyvar_FolderName);
    else if (PyUnicode_Check(pyvar_FolderName))
    {
        unicodeFolderName = pyvar_FolderName;
        Py_INCREF(unicodeFolderName);
    }
    else if (pyvar_FolderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FolderName at index 0");
    if (unicodeFolderName)
        bsFolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFolderName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection3_get_serverobjectnamesex_method_cleanup;
    
    // No setup for ppSONames

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->get_ServerObjectNamesEx(bsFolderName, &ipppSONames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.get_ServerObjectNamesEx() returned %ld", (long)hr);
        goto iagsserverconnection3_get_serverobjectnamesex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FolderName
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
    {
        IUnknown* pUnk = NULL;
        ipppSONames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSONames = IUnknownToPythonIIDObject(pUnk, &IID_IAGSEnumServerObjectName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSONames)
    {
        if (py_ppSONames)
           Py_DECREF(py_ppSONames);
        py_ppSONames = Py_None;
        Py_INCREF(py_ppSONames);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection3_get_serverobjectnamesex_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSONames);
    goto iagsserverconnection3_get_serverobjectnamesex_method_cleanup;

    iagsserverconnection3_get_serverobjectnamesex_method_cleanup:
    self->m_HR = hr;
    if (bsFolderName)
        ::SysFreeString(bsFolderName);
    
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
      ipppSONames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.get_ServerObjectNamesEx");
    return return_tuple;
}

static PyObject*
IAGSServerConnection3Method_GetFolders(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsreserved = 0;
    PyObject* pyvar_reserved;
    PyObject* unicodereserved = NULL;
    IEnumBSTR* ipppEnum = NULL;
    PyObject* py_ppEnum = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_reserved))
      goto iagsserverconnection3_getfolders_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_reserved))
        unicodereserved = PyUnicode_FromObject(pyvar_reserved);
    else if (PyUnicode_Check(pyvar_reserved))
    {
        unicodereserved = pyvar_reserved;
        Py_INCREF(unicodereserved);
    }
    else if (pyvar_reserved != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter reserved at index 0");
    if (unicodereserved)
        bsreserved = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodereserved), 
                                            (UINT)PyUnicode_GET_SIZE(unicodereserved));
    
    if (PyErr_Occurred())
      goto iagsserverconnection3_getfolders_method_cleanup;
    
    // No setup for ppEnum

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->GetFolders(bsreserved, &ipppEnum);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.GetFolders() returned %ld", (long)hr);
        goto iagsserverconnection3_getfolders_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for reserved
    Py_XDECREF(py_ppEnum);
    if (ipppEnum)
    {
        IUnknown* pUnk = NULL;
        ipppEnum->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppEnum = IUnknownToPythonIIDObject(pUnk, &IID_IEnumBSTR);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppEnum)
    {
        if (py_ppEnum)
           Py_DECREF(py_ppEnum);
        py_ppEnum = Py_None;
        Py_INCREF(py_ppEnum);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection3_getfolders_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppEnum);
    goto iagsserverconnection3_getfolders_method_cleanup;

    iagsserverconnection3_getfolders_method_cleanup:
    self->m_HR = hr;
    if (bsreserved)
        ::SysFreeString(bsreserved);
    
    Py_XDECREF(py_ppEnum);
    if (ipppEnum)
      ipppEnum->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.GetFolders");
    return return_tuple;
}

static PyObject*
IAGSServerConnection3Method_put_Name(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iagsserverconnection3_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection3_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.put_Name() returned %ld", (long)hr);
        goto iagsserverconnection3_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnection3_put_name_method_cleanup;

    iagsserverconnection3_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.put_Name");
    return return_tuple;
}

static PyObject*
IAGSServerConnection3Method_get_Name(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.get_Name() returned %ld", (long)hr);
        goto iagsserverconnection3_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iagsserverconnection3_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iagsserverconnection3_get_name_method_cleanup;

    iagsserverconnection3_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.get_Name");
    return return_tuple;
}

static PyObject*
IAGSServerConnection3Method_get_ServerObjectNames(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSEnumServerObjectName* ipppSONames = NULL;
    PyObject* py_ppSONames = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSONames

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->get_ServerObjectNames(&ipppSONames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.get_ServerObjectNames() returned %ld", (long)hr);
        goto iagsserverconnection3_get_serverobjectnames_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
    {
        IUnknown* pUnk = NULL;
        ipppSONames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSONames = IUnknownToPythonIIDObject(pUnk, &IID_IAGSEnumServerObjectName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSONames)
    {
        if (py_ppSONames)
           Py_DECREF(py_ppSONames);
        py_ppSONames = Py_None;
        Py_INCREF(py_ppSONames);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection3_get_serverobjectnames_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSONames);
    goto iagsserverconnection3_get_serverobjectnames_method_cleanup;

    iagsserverconnection3_get_serverobjectnames_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
      ipppSONames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.get_ServerObjectNames");
    return return_tuple;
}

static PyObject*
IAGSServerConnection3Method_get_FullName(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppNameObject = NULL;
    PyObject* py_ppNameObject = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppNameObject

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->get_FullName(&ipppNameObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.get_FullName() returned %ld", (long)hr);
        goto iagsserverconnection3_get_fullname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppNameObject);
    if (ipppNameObject)
    {
        IUnknown* pUnk = NULL;
        ipppNameObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppNameObject = IUnknownToPythonIIDObject(pUnk, &IID_IName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppNameObject)
    {
        if (py_ppNameObject)
           Py_DECREF(py_ppNameObject);
        py_ppNameObject = Py_None;
        Py_INCREF(py_ppNameObject);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection3_get_fullname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppNameObject);
    goto iagsserverconnection3_get_fullname_method_cleanup;

    iagsserverconnection3_get_fullname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppNameObject);
    if (ipppNameObject)
      ipppNameObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.get_FullName");
    return return_tuple;
}

static PyObject*
IAGSServerConnection3Method_putref_FullName(PyIAGSServerConnection3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppNameObject = NULL;
    PyObject* py_ppNameObject;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppNameObject))
      goto iagsserverconnection3_putref_fullname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppNameObject, &IID_IName, (void**)&ipppNameObject))
        PyErr_SetString(PyExc_TypeError, "Argument ppNameObject (position 0) is not IName");
    
    if (PyErr_Occurred())
      goto iagsserverconnection3_putref_fullname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection3->putref_FullName(ipppNameObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection3.putref_FullName() returned %ld", (long)hr);
        goto iagsserverconnection3_putref_fullname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppNameObject

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnection3_putref_fullname_method_cleanup;

    iagsserverconnection3_putref_fullname_method_cleanup:
    self->m_HR = hr;
    if (ipppNameObject)
      ipppNameObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection3.putref_FullName");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnection3Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnection3_SupportsInterface, METH_O, ""},
    {"GetFile", (PyCFunction)IAGSServerConnection3Method_GetFile, METH_VARARGS, ""},
    {"GetFileAsVariant", (PyCFunction)IAGSServerConnection3Method_GetFileAsVariant, METH_VARARGS, ""},
    {"get_ServerObjectNamesEx", (PyCFunction)IAGSServerConnection3Method_get_ServerObjectNamesEx, METH_VARARGS, ""},
    {"GetFolders", (PyCFunction)IAGSServerConnection3Method_GetFolders, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IAGSServerConnection3Method_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IAGSServerConnection3Method_get_Name, METH_VARARGS, ""},
    {"get_ServerObjectNames", (PyCFunction)IAGSServerConnection3Method_get_ServerObjectNames, METH_VARARGS, ""},
    {"get_FullName", (PyCFunction)IAGSServerConnection3Method_get_FullName, METH_VARARGS, ""},
    {"putref_FullName", (PyCFunction)IAGSServerConnection3Method_putref_FullName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnection3GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnection3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnection3", NULL},
  {"_pointer", (getter)PyIAGSServerConnection3_GetPointer, NULL, "Get memory address for IAGSServerConnection3", NULL},
  {"_IID", (getter)PyIAGSServerConnection3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnection3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnection3_GetIgnoreFailures, (setter)PyIAGSServerConnection3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnection3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnection3Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnection3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnection3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnection3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnection3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnection3Object_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnection4

typedef struct PyIAGSServerConnection4Object {
    PyObject_HEAD
    IAGSServerConnection4* m_pIAGSServerConnection4;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnection4Object;

static PyObject*
PyIAGSServerConnection4Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnection4Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnection4* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnection4, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnection4 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnection4Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnection4");
            return NULL;
        }
        self->m_pIAGSServerConnection4 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnection4");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnection4");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnection4* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnection4, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnection4");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnection4Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnection4");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnection4 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnection4Object_dealloc(PyIAGSServerConnection4Object* self)
{
    if (self->m_pIAGSServerConnection4)
        self->m_pIAGSServerConnection4->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnection4_GetpUnk(PyIAGSServerConnection4Object* self)
{
    if (!self->m_pIAGSServerConnection4)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnection4->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnection4 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnection4_GetPointer(PyIAGSServerConnection4Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnection4);
}

static PyObject*
PyIAGSServerConnection4_GetIID(PyIAGSServerConnection4Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b291fd85-b247-4ab0-85d0-2244688936fd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnection4_GetHR(PyIAGSServerConnection4Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnection4_GetIgnoreFailures(PyIAGSServerConnection4Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnection4_SetIgnoreFailures(PyIAGSServerConnection4Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnection4_SupportsInterface(PyIAGSServerConnection4Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnection4Method_GetServerVersion(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSServerVersionType eversionType;
    VARIANT vServerVersion;
    ::VariantInit(&vServerVersion);
    PyObject* pyvar_ServerVersion = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eversionType))
      goto iagsserverconnection4_getserverversion_method_cleanup;

    // Set up initial variable values as needed
    // No setup for versionType
    // No setup for ServerVersion

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->GetServerVersion(eversionType, &vServerVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.GetServerVersion() returned %ld", (long)hr);
        goto iagsserverconnection4_getserverversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionType
    pyvar_ServerVersion = Variant_AsPyObject(&vServerVersion);
    if (PyErr_Occurred())
      goto iagsserverconnection4_getserverversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ServerVersion);
    goto iagsserverconnection4_getserverversion_method_cleanup;

    iagsserverconnection4_getserverversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for versionType
    ::VariantClear(&vServerVersion);
    Py_XDECREF(pyvar_ServerVersion);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.GetServerVersion");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_GetServiceURL(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriServiceURLType eurlType;
    IAGSServerObjectName* ipService = NULL;
    PyObject* py_Service;
    BSTR bsURL;
    PyObject* pyvar_URL = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eurlType, &py_Service))
      goto iagsserverconnection4_getserviceurl_method_cleanup;

    // Set up initial variable values as needed
    // No setup for urlType
    if (!IFaceFromPyObject(py_Service, &IID_IAGSServerObjectName, (void**)&ipService))
        PyErr_SetString(PyExc_TypeError, "Argument Service (position 1) is not IAGSServerObjectName");
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getserviceurl_method_cleanup;
    
    // No setup for URL

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->GetServiceURL(eurlType, ipService, &bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.GetServiceURL() returned %ld", (long)hr);
        goto iagsserverconnection4_getserviceurl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for urlType
    // No teardown for Service
    pyvar_URL = PyUnicode_FromWideChar(bsURL,::SysStringLen(bsURL));
    ::SysFreeString(bsURL);
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getserviceurl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_URL);
    goto iagsserverconnection4_getserviceurl_method_cleanup;

    iagsserverconnection4_getserviceurl_method_cleanup:
    self->m_HR = hr;
    // No cleanup for urlType
    if (ipService)
      ipService->Release();
    if (pyvar_URL != Py_None)
        Py_XDECREF(pyvar_URL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.GetServiceURL");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_GetItemInfo(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bsType = 0;
    PyObject* pyvar_Type;
    PyObject* unicodeType = NULL;
    BSTR bssoeType = 0;
    PyObject* pyvar_soeType;
    PyObject* unicodesoeType = NULL;
    IItemInfo* ipppItemInfo = NULL;
    PyObject* py_ppItemInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_Name, &pyvar_Type, &pyvar_soeType))
      goto iagsserverconnection4_getiteminfo_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getiteminfo_method_cleanup;
    
    if (PyString_Check(pyvar_Type))
        unicodeType = PyUnicode_FromObject(pyvar_Type);
    else if (PyUnicode_Check(pyvar_Type))
    {
        unicodeType = pyvar_Type;
        Py_INCREF(unicodeType);
    }
    else if (pyvar_Type != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Type at index 1");
    if (unicodeType)
        bsType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeType));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getiteminfo_method_cleanup;
    
    if (PyString_Check(pyvar_soeType))
        unicodesoeType = PyUnicode_FromObject(pyvar_soeType);
    else if (PyUnicode_Check(pyvar_soeType))
    {
        unicodesoeType = pyvar_soeType;
        Py_INCREF(unicodesoeType);
    }
    else if (pyvar_soeType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter soeType at index 2");
    if (unicodesoeType)
        bssoeType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesoeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesoeType));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getiteminfo_method_cleanup;
    
    // No setup for ppItemInfo

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->GetItemInfo(bsName, bsType, bssoeType, &ipppItemInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.GetItemInfo() returned %ld", (long)hr);
        goto iagsserverconnection4_getiteminfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for Type
    // No teardown for soeType
    Py_XDECREF(py_ppItemInfo);
    if (ipppItemInfo)
    {
        IUnknown* pUnk = NULL;
        ipppItemInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppItemInfo = IUnknownToPythonIIDObject(pUnk, &IID_IItemInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppItemInfo)
    {
        if (py_ppItemInfo)
           Py_DECREF(py_ppItemInfo);
        py_ppItemInfo = Py_None;
        Py_INCREF(py_ppItemInfo);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection4_getiteminfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppItemInfo);
    goto iagsserverconnection4_getiteminfo_method_cleanup;

    iagsserverconnection4_getiteminfo_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bsType)
        ::SysFreeString(bsType);
    
    if (bssoeType)
        ::SysFreeString(bssoeType);
    
    Py_XDECREF(py_ppItemInfo);
    if (ipppItemInfo)
      ipppItemInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.GetItemInfo");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_GetMetadata(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bsType = 0;
    PyObject* pyvar_Type;
    PyObject* unicodeType = NULL;
    BSTR bssoeType = 0;
    PyObject* pyvar_soeType;
    PyObject* unicodesoeType = NULL;
    IPropertySet* ipppMetadata = NULL;
    PyObject* py_ppMetadata = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_Name, &pyvar_Type, &pyvar_soeType))
      goto iagsserverconnection4_getmetadata_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getmetadata_method_cleanup;
    
    if (PyString_Check(pyvar_Type))
        unicodeType = PyUnicode_FromObject(pyvar_Type);
    else if (PyUnicode_Check(pyvar_Type))
    {
        unicodeType = pyvar_Type;
        Py_INCREF(unicodeType);
    }
    else if (pyvar_Type != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Type at index 1");
    if (unicodeType)
        bsType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeType));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getmetadata_method_cleanup;
    
    if (PyString_Check(pyvar_soeType))
        unicodesoeType = PyUnicode_FromObject(pyvar_soeType);
    else if (PyUnicode_Check(pyvar_soeType))
    {
        unicodesoeType = pyvar_soeType;
        Py_INCREF(unicodesoeType);
    }
    else if (pyvar_soeType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter soeType at index 2");
    if (unicodesoeType)
        bssoeType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesoeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesoeType));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getmetadata_method_cleanup;
    
    // No setup for ppMetadata

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->GetMetadata(bsName, bsType, bssoeType, &ipppMetadata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.GetMetadata() returned %ld", (long)hr);
        goto iagsserverconnection4_getmetadata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for Type
    // No teardown for soeType
    Py_XDECREF(py_ppMetadata);
    if (ipppMetadata)
    {
        IUnknown* pUnk = NULL;
        ipppMetadata->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppMetadata = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppMetadata)
    {
        if (py_ppMetadata)
           Py_DECREF(py_ppMetadata);
        py_ppMetadata = Py_None;
        Py_INCREF(py_ppMetadata);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection4_getmetadata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppMetadata);
    goto iagsserverconnection4_getmetadata_method_cleanup;

    iagsserverconnection4_getmetadata_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bsType)
        ::SysFreeString(bsType);
    
    if (bssoeType)
        ::SysFreeString(bssoeType);
    
    Py_XDECREF(py_ppMetadata);
    if (ipppMetadata)
      ipppMetadata->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.GetMetadata");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_GetFile(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;
    IStream* ipstream = NULL;
    PyObject* py_stream = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_URL))
      goto iagsserverconnection4_getfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 0");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getfile_method_cleanup;
    
    // No setup for stream

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->GetFile(bsURL, &ipstream);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.GetFile() returned %ld", (long)hr);
        goto iagsserverconnection4_getfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for URL
    Py_XDECREF(py_stream);
    if (ipstream)
    {
        IUnknown* pUnk = NULL;
        ipstream->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_stream = IUnknownToPythonIIDObject(pUnk, &IID_IStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_stream)
    {
        if (py_stream)
           Py_DECREF(py_stream);
        py_stream = Py_None;
        Py_INCREF(py_stream);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection4_getfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_stream);
    goto iagsserverconnection4_getfile_method_cleanup;

    iagsserverconnection4_getfile_method_cleanup:
    self->m_HR = hr;
    if (bsURL)
        ::SysFreeString(bsURL);
    
    Py_XDECREF(py_stream);
    if (ipstream)
      ipstream->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.GetFile");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_GetFileAsVariant(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_URL))
      goto iagsserverconnection4_getfileasvariant_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 0");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getfileasvariant_method_cleanup;
    
    // No setup for pValue

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->GetFileAsVariant(bsURL, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.GetFileAsVariant() returned %ld", (long)hr);
        goto iagsserverconnection4_getfileasvariant_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for URL
    pyvar_pValue = Variant_AsPyObject(&vpValue);
    if (PyErr_Occurred())
      goto iagsserverconnection4_getfileasvariant_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pValue);
    goto iagsserverconnection4_getfileasvariant_method_cleanup;

    iagsserverconnection4_getfileasvariant_method_cleanup:
    self->m_HR = hr;
    if (bsURL)
        ::SysFreeString(bsURL);
    
    ::VariantClear(&vpValue);
    Py_XDECREF(pyvar_pValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.GetFileAsVariant");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_get_ServerObjectNamesEx(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFolderName = 0;
    PyObject* pyvar_FolderName;
    PyObject* unicodeFolderName = NULL;
    IAGSEnumServerObjectName* ipppSONames = NULL;
    PyObject* py_ppSONames = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FolderName))
      goto iagsserverconnection4_get_serverobjectnamesex_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FolderName))
        unicodeFolderName = PyUnicode_FromObject(pyvar_FolderName);
    else if (PyUnicode_Check(pyvar_FolderName))
    {
        unicodeFolderName = pyvar_FolderName;
        Py_INCREF(unicodeFolderName);
    }
    else if (pyvar_FolderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FolderName at index 0");
    if (unicodeFolderName)
        bsFolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFolderName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_get_serverobjectnamesex_method_cleanup;
    
    // No setup for ppSONames

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->get_ServerObjectNamesEx(bsFolderName, &ipppSONames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.get_ServerObjectNamesEx() returned %ld", (long)hr);
        goto iagsserverconnection4_get_serverobjectnamesex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FolderName
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
    {
        IUnknown* pUnk = NULL;
        ipppSONames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSONames = IUnknownToPythonIIDObject(pUnk, &IID_IAGSEnumServerObjectName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSONames)
    {
        if (py_ppSONames)
           Py_DECREF(py_ppSONames);
        py_ppSONames = Py_None;
        Py_INCREF(py_ppSONames);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection4_get_serverobjectnamesex_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSONames);
    goto iagsserverconnection4_get_serverobjectnamesex_method_cleanup;

    iagsserverconnection4_get_serverobjectnamesex_method_cleanup:
    self->m_HR = hr;
    if (bsFolderName)
        ::SysFreeString(bsFolderName);
    
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
      ipppSONames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.get_ServerObjectNamesEx");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_GetFolders(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsreserved = 0;
    PyObject* pyvar_reserved;
    PyObject* unicodereserved = NULL;
    IEnumBSTR* ipppEnum = NULL;
    PyObject* py_ppEnum = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_reserved))
      goto iagsserverconnection4_getfolders_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_reserved))
        unicodereserved = PyUnicode_FromObject(pyvar_reserved);
    else if (PyUnicode_Check(pyvar_reserved))
    {
        unicodereserved = pyvar_reserved;
        Py_INCREF(unicodereserved);
    }
    else if (pyvar_reserved != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter reserved at index 0");
    if (unicodereserved)
        bsreserved = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodereserved), 
                                            (UINT)PyUnicode_GET_SIZE(unicodereserved));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_getfolders_method_cleanup;
    
    // No setup for ppEnum

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->GetFolders(bsreserved, &ipppEnum);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.GetFolders() returned %ld", (long)hr);
        goto iagsserverconnection4_getfolders_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for reserved
    Py_XDECREF(py_ppEnum);
    if (ipppEnum)
    {
        IUnknown* pUnk = NULL;
        ipppEnum->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppEnum = IUnknownToPythonIIDObject(pUnk, &IID_IEnumBSTR);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppEnum)
    {
        if (py_ppEnum)
           Py_DECREF(py_ppEnum);
        py_ppEnum = Py_None;
        Py_INCREF(py_ppEnum);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection4_getfolders_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppEnum);
    goto iagsserverconnection4_getfolders_method_cleanup;

    iagsserverconnection4_getfolders_method_cleanup:
    self->m_HR = hr;
    if (bsreserved)
        ::SysFreeString(bsreserved);
    
    Py_XDECREF(py_ppEnum);
    if (ipppEnum)
      ipppEnum->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.GetFolders");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_put_Name(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iagsserverconnection4_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.put_Name() returned %ld", (long)hr);
        goto iagsserverconnection4_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnection4_put_name_method_cleanup;

    iagsserverconnection4_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.put_Name");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_get_Name(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.get_Name() returned %ld", (long)hr);
        goto iagsserverconnection4_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iagsserverconnection4_get_name_method_cleanup;

    iagsserverconnection4_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.get_Name");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_get_ServerObjectNames(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSEnumServerObjectName* ipppSONames = NULL;
    PyObject* py_ppSONames = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSONames

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->get_ServerObjectNames(&ipppSONames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.get_ServerObjectNames() returned %ld", (long)hr);
        goto iagsserverconnection4_get_serverobjectnames_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
    {
        IUnknown* pUnk = NULL;
        ipppSONames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSONames = IUnknownToPythonIIDObject(pUnk, &IID_IAGSEnumServerObjectName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSONames)
    {
        if (py_ppSONames)
           Py_DECREF(py_ppSONames);
        py_ppSONames = Py_None;
        Py_INCREF(py_ppSONames);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection4_get_serverobjectnames_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSONames);
    goto iagsserverconnection4_get_serverobjectnames_method_cleanup;

    iagsserverconnection4_get_serverobjectnames_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSONames);
    if (ipppSONames)
      ipppSONames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.get_ServerObjectNames");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_get_FullName(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppNameObject = NULL;
    PyObject* py_ppNameObject = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppNameObject

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->get_FullName(&ipppNameObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.get_FullName() returned %ld", (long)hr);
        goto iagsserverconnection4_get_fullname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppNameObject);
    if (ipppNameObject)
    {
        IUnknown* pUnk = NULL;
        ipppNameObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppNameObject = IUnknownToPythonIIDObject(pUnk, &IID_IName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppNameObject)
    {
        if (py_ppNameObject)
           Py_DECREF(py_ppNameObject);
        py_ppNameObject = Py_None;
        Py_INCREF(py_ppNameObject);
    }
    if (PyErr_Occurred())
      goto iagsserverconnection4_get_fullname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppNameObject);
    goto iagsserverconnection4_get_fullname_method_cleanup;

    iagsserverconnection4_get_fullname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppNameObject);
    if (ipppNameObject)
      ipppNameObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.get_FullName");
    return return_tuple;
}

static PyObject*
IAGSServerConnection4Method_putref_FullName(PyIAGSServerConnection4Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppNameObject = NULL;
    PyObject* py_ppNameObject;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppNameObject))
      goto iagsserverconnection4_putref_fullname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppNameObject, &IID_IName, (void**)&ipppNameObject))
        PyErr_SetString(PyExc_TypeError, "Argument ppNameObject (position 0) is not IName");
    
    if (PyErr_Occurred())
      goto iagsserverconnection4_putref_fullname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnection4->putref_FullName(ipppNameObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnection4->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnection4) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnection4.putref_FullName() returned %ld", (long)hr);
        goto iagsserverconnection4_putref_fullname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppNameObject

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnection4_putref_fullname_method_cleanup;

    iagsserverconnection4_putref_fullname_method_cleanup:
    self->m_HR = hr;
    if (ipppNameObject)
      ipppNameObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnection4.putref_FullName");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnection4Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnection4_SupportsInterface, METH_O, ""},
    {"GetServerVersion", (PyCFunction)IAGSServerConnection4Method_GetServerVersion, METH_VARARGS, ""},
    {"GetServiceURL", (PyCFunction)IAGSServerConnection4Method_GetServiceURL, METH_VARARGS, ""},
    {"GetItemInfo", (PyCFunction)IAGSServerConnection4Method_GetItemInfo, METH_VARARGS, ""},
    {"GetMetadata", (PyCFunction)IAGSServerConnection4Method_GetMetadata, METH_VARARGS, ""},
    {"GetFile", (PyCFunction)IAGSServerConnection4Method_GetFile, METH_VARARGS, ""},
    {"GetFileAsVariant", (PyCFunction)IAGSServerConnection4Method_GetFileAsVariant, METH_VARARGS, ""},
    {"get_ServerObjectNamesEx", (PyCFunction)IAGSServerConnection4Method_get_ServerObjectNamesEx, METH_VARARGS, ""},
    {"GetFolders", (PyCFunction)IAGSServerConnection4Method_GetFolders, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IAGSServerConnection4Method_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IAGSServerConnection4Method_get_Name, METH_VARARGS, ""},
    {"get_ServerObjectNames", (PyCFunction)IAGSServerConnection4Method_get_ServerObjectNames, METH_VARARGS, ""},
    {"get_FullName", (PyCFunction)IAGSServerConnection4Method_get_FullName, METH_VARARGS, ""},
    {"putref_FullName", (PyCFunction)IAGSServerConnection4Method_putref_FullName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnection4GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnection4_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnection4", NULL},
  {"_pointer", (getter)PyIAGSServerConnection4_GetPointer, NULL, "Get memory address for IAGSServerConnection4", NULL},
  {"_IID", (getter)PyIAGSServerConnection4_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnection4_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnection4_GetIgnoreFailures, (setter)PyIAGSServerConnection4_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnection4Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnection4Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnection4Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnection4Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnection4Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnection4GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnection4Object_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnectionAdmin

typedef struct PyIAGSServerConnectionAdminObject {
    PyObject_HEAD
    IAGSServerConnectionAdmin* m_pIAGSServerConnectionAdmin;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnectionAdminObject;

static PyObject*
PyIAGSServerConnectionAdminObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnectionAdminObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnectionAdmin* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnectionAdmin, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnectionAdmin with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnectionAdminObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionAdmin");
            return NULL;
        }
        self->m_pIAGSServerConnectionAdmin = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnectionAdmin");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnectionAdmin");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnectionAdmin* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnectionAdmin, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnectionAdmin");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnectionAdminObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionAdmin");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnectionAdmin = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnectionAdminObject_dealloc(PyIAGSServerConnectionAdminObject* self)
{
    if (self->m_pIAGSServerConnectionAdmin)
        self->m_pIAGSServerConnectionAdmin->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnectionAdmin_GetpUnk(PyIAGSServerConnectionAdminObject* self)
{
    if (!self->m_pIAGSServerConnectionAdmin)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnectionAdmin->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnectionAdmin to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnectionAdmin_GetPointer(PyIAGSServerConnectionAdminObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnectionAdmin);
}

static PyObject*
PyIAGSServerConnectionAdmin_GetIID(PyIAGSServerConnectionAdminObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2609d396-4c06-4c35-9ae3-df690ed88506");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnectionAdmin_GetHR(PyIAGSServerConnectionAdminObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnectionAdmin_GetIgnoreFailures(PyIAGSServerConnectionAdminObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnectionAdmin_SetIgnoreFailures(PyIAGSServerConnectionAdminObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnectionAdmin_SupportsInterface(PyIAGSServerConnectionAdminObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnectionAdmin->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnectionAdminMethod_get_ServerObjectManager(PyIAGSServerConnectionAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IServerObjectManager* ipppObjectManager = NULL;
    PyObject* py_ppObjectManager = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppObjectManager

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionAdmin->get_ServerObjectManager(&ipppObjectManager);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionAdmin.get_ServerObjectManager() returned %ld", (long)hr);
        goto iagsserverconnectionadmin_get_serverobjectmanager_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppObjectManager);
    if (ipppObjectManager)
    {
        IUnknown* pUnk = NULL;
        ipppObjectManager->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppObjectManager = IUnknownToPythonIIDObject(pUnk, &IID_IServerObjectManager);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppObjectManager)
    {
        if (py_ppObjectManager)
           Py_DECREF(py_ppObjectManager);
        py_ppObjectManager = Py_None;
        Py_INCREF(py_ppObjectManager);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionadmin_get_serverobjectmanager_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppObjectManager);
    goto iagsserverconnectionadmin_get_serverobjectmanager_method_cleanup;

    iagsserverconnectionadmin_get_serverobjectmanager_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppObjectManager);
    if (ipppObjectManager)
      ipppObjectManager->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionAdmin.get_ServerObjectManager");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionAdminMethod_get_ServerObjectAdmin(PyIAGSServerConnectionAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IServerObjectAdmin* ipppObjectAdmin = NULL;
    PyObject* py_ppObjectAdmin = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppObjectAdmin

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionAdmin->get_ServerObjectAdmin(&ipppObjectAdmin);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionAdmin.get_ServerObjectAdmin() returned %ld", (long)hr);
        goto iagsserverconnectionadmin_get_serverobjectadmin_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppObjectAdmin);
    if (ipppObjectAdmin)
    {
        IUnknown* pUnk = NULL;
        ipppObjectAdmin->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppObjectAdmin = IUnknownToPythonIIDObject(pUnk, &IID_IServerObjectAdmin);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppObjectAdmin)
    {
        if (py_ppObjectAdmin)
           Py_DECREF(py_ppObjectAdmin);
        py_ppObjectAdmin = Py_None;
        Py_INCREF(py_ppObjectAdmin);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionadmin_get_serverobjectadmin_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppObjectAdmin);
    goto iagsserverconnectionadmin_get_serverobjectadmin_method_cleanup;

    iagsserverconnectionadmin_get_serverobjectadmin_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppObjectAdmin);
    if (ipppObjectAdmin)
      ipppObjectAdmin->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionAdmin.get_ServerObjectAdmin");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionAdminMethod_get_ServerObjectConfiguration(PyIAGSServerConnectionAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bsType = 0;
    PyObject* pyvar_Type;
    PyObject* unicodeType = NULL;
    IServerObjectConfiguration* ipppObject = NULL;
    PyObject* py_ppObject = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_Name, &pyvar_Type))
      goto iagsserverconnectionadmin_get_serverobjectconfiguration_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionadmin_get_serverobjectconfiguration_method_cleanup;
    
    if (PyString_Check(pyvar_Type))
        unicodeType = PyUnicode_FromObject(pyvar_Type);
    else if (PyUnicode_Check(pyvar_Type))
    {
        unicodeType = pyvar_Type;
        Py_INCREF(unicodeType);
    }
    else if (pyvar_Type != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Type at index 1");
    if (unicodeType)
        bsType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeType));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionadmin_get_serverobjectconfiguration_method_cleanup;
    
    // No setup for ppObject

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionAdmin->get_ServerObjectConfiguration(bsName, bsType, &ipppObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionAdmin.get_ServerObjectConfiguration() returned %ld", (long)hr);
        goto iagsserverconnectionadmin_get_serverobjectconfiguration_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for Type
    Py_XDECREF(py_ppObject);
    if (ipppObject)
    {
        IUnknown* pUnk = NULL;
        ipppObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppObject = IUnknownToPythonIIDObject(pUnk, &IID_IServerObjectConfiguration);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppObject)
    {
        if (py_ppObject)
           Py_DECREF(py_ppObject);
        py_ppObject = Py_None;
        Py_INCREF(py_ppObject);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionadmin_get_serverobjectconfiguration_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppObject);
    goto iagsserverconnectionadmin_get_serverobjectconfiguration_method_cleanup;

    iagsserverconnectionadmin_get_serverobjectconfiguration_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bsType)
        ::SysFreeString(bsType);
    
    Py_XDECREF(py_ppObject);
    if (ipppObject)
      ipppObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionAdmin.get_ServerObjectConfiguration");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnectionAdminMethods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnectionAdmin_SupportsInterface, METH_O, ""},
    {"get_ServerObjectManager", (PyCFunction)IAGSServerConnectionAdminMethod_get_ServerObjectManager, METH_VARARGS, ""},
    {"get_ServerObjectAdmin", (PyCFunction)IAGSServerConnectionAdminMethod_get_ServerObjectAdmin, METH_VARARGS, ""},
    {"get_ServerObjectConfiguration", (PyCFunction)IAGSServerConnectionAdminMethod_get_ServerObjectConfiguration, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnectionAdminGetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnectionAdmin_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnectionAdmin", NULL},
  {"_pointer", (getter)PyIAGSServerConnectionAdmin_GetPointer, NULL, "Get memory address for IAGSServerConnectionAdmin", NULL},
  {"_IID", (getter)PyIAGSServerConnectionAdmin_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnectionAdmin_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnectionAdmin_GetIgnoreFailures, (setter)PyIAGSServerConnectionAdmin_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnectionAdminObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnectionAdminObject",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnectionAdminObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnectionAdminObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnectionAdminMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnectionAdminGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnectionAdminObject_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnectionName2

typedef struct PyIAGSServerConnectionName2Object {
    PyObject_HEAD
    IAGSServerConnectionName2* m_pIAGSServerConnectionName2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnectionName2Object;

static PyObject*
PyIAGSServerConnectionName2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnectionName2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnectionName2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnectionName2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnectionName2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnectionName2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionName2");
            return NULL;
        }
        self->m_pIAGSServerConnectionName2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnectionName2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnectionName2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnectionName2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnectionName2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnectionName2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnectionName2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionName2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnectionName2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnectionName2Object_dealloc(PyIAGSServerConnectionName2Object* self)
{
    if (self->m_pIAGSServerConnectionName2)
        self->m_pIAGSServerConnectionName2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnectionName2_GetpUnk(PyIAGSServerConnectionName2Object* self)
{
    if (!self->m_pIAGSServerConnectionName2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnectionName2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnectionName2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnectionName2_GetPointer(PyIAGSServerConnectionName2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnectionName2);
}

static PyObject*
PyIAGSServerConnectionName2_GetIID(PyIAGSServerConnectionName2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c65dc76b-b454-4b35-83ec-e9082b57a56f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnectionName2_GetHR(PyIAGSServerConnectionName2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnectionName2_GetIgnoreFailures(PyIAGSServerConnectionName2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnectionName2_SetIgnoreFailures(PyIAGSServerConnectionName2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnectionName2_SupportsInterface(PyIAGSServerConnectionName2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnectionName2Method_get_ConnectionString(PyIAGSServerConnectionName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsconnString;
    PyObject* pyvar_connString = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for connString

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName2->get_ConnectionString(&bsconnString);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName2.get_ConnectionString() returned %ld", (long)hr);
        goto iagsserverconnectionname2_get_connectionstring_method_cleanup;
    }

    // Set up return values as needed
    pyvar_connString = PyUnicode_FromWideChar(bsconnString,::SysStringLen(bsconnString));
    ::SysFreeString(bsconnString);
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname2_get_connectionstring_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_connString);
    goto iagsserverconnectionname2_get_connectionstring_method_cleanup;

    iagsserverconnectionname2_get_connectionstring_method_cleanup:
    self->m_HR = hr;
    if (pyvar_connString != Py_None)
        Py_XDECREF(pyvar_connString);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName2.get_ConnectionString");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName2Method_put_ConnectionString(PyIAGSServerConnectionName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsconnString = 0;
    PyObject* pyvar_connString;
    PyObject* unicodeconnString = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_connString))
      goto iagsserverconnectionname2_put_connectionstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_connString))
        unicodeconnString = PyUnicode_FromObject(pyvar_connString);
    else if (PyUnicode_Check(pyvar_connString))
    {
        unicodeconnString = pyvar_connString;
        Py_INCREF(unicodeconnString);
    }
    else if (pyvar_connString != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter connString at index 0");
    if (unicodeconnString)
        bsconnString = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeconnString), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeconnString));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname2_put_connectionstring_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName2->put_ConnectionString(bsconnString);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName2.put_ConnectionString() returned %ld", (long)hr);
        goto iagsserverconnectionname2_put_connectionstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for connString

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname2_put_connectionstring_method_cleanup;

    iagsserverconnectionname2_put_connectionstring_method_cleanup:
    self->m_HR = hr;
    if (bsconnString)
        ::SysFreeString(bsconnString);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName2.put_ConnectionString");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName2Method_get_ServerConnectionFactoryProgID(PyIAGSServerConnectionName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsprogID;
    PyObject* pyvar_progID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for progID

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName2->get_ServerConnectionFactoryProgID(&bsprogID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName2.get_ServerConnectionFactoryProgID() returned %ld", (long)hr);
        goto iagsserverconnectionname2_get_serverconnectionfactoryprogid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_progID = PyUnicode_FromWideChar(bsprogID,::SysStringLen(bsprogID));
    ::SysFreeString(bsprogID);
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname2_get_serverconnectionfactoryprogid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_progID);
    goto iagsserverconnectionname2_get_serverconnectionfactoryprogid_method_cleanup;

    iagsserverconnectionname2_get_serverconnectionfactoryprogid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_progID != Py_None)
        Py_XDECREF(pyvar_progID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName2.get_ServerConnectionFactoryProgID");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName2Method_put_ServerConnectionFactoryProgID(PyIAGSServerConnectionName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsprogID = 0;
    PyObject* pyvar_progID;
    PyObject* unicodeprogID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_progID))
      goto iagsserverconnectionname2_put_serverconnectionfactoryprogid_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_progID))
        unicodeprogID = PyUnicode_FromObject(pyvar_progID);
    else if (PyUnicode_Check(pyvar_progID))
    {
        unicodeprogID = pyvar_progID;
        Py_INCREF(unicodeprogID);
    }
    else if (pyvar_progID != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter progID at index 0");
    if (unicodeprogID)
        bsprogID = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeprogID), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeprogID));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname2_put_serverconnectionfactoryprogid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName2->put_ServerConnectionFactoryProgID(bsprogID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName2.put_ServerConnectionFactoryProgID() returned %ld", (long)hr);
        goto iagsserverconnectionname2_put_serverconnectionfactoryprogid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for progID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname2_put_serverconnectionfactoryprogid_method_cleanup;

    iagsserverconnectionname2_put_serverconnectionfactoryprogid_method_cleanup:
    self->m_HR = hr;
    if (bsprogID)
        ::SysFreeString(bsprogID);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName2.put_ServerConnectionFactoryProgID");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName2Method_put_ConnectionProperties(PyIAGSServerConnectionName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnProps = NULL;
    PyObject* py_ppConnProps;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppConnProps))
      goto iagsserverconnectionname2_put_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppConnProps, &IID_IPropertySet, (void**)&ipppConnProps))
        PyErr_SetString(PyExc_TypeError, "Argument ppConnProps (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname2_put_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName2->put_ConnectionProperties(ipppConnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName2.put_ConnectionProperties() returned %ld", (long)hr);
        goto iagsserverconnectionname2_put_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppConnProps

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname2_put_connectionproperties_method_cleanup;

    iagsserverconnectionname2_put_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipppConnProps)
      ipppConnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName2.put_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName2Method_get_ConnectionProperties(PyIAGSServerConnectionName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnProps = NULL;
    PyObject* py_ppConnProps = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppConnProps

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName2->get_ConnectionProperties(&ipppConnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName2.get_ConnectionProperties() returned %ld", (long)hr);
        goto iagsserverconnectionname2_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppConnProps);
    if (ipppConnProps)
    {
        IUnknown* pUnk = NULL;
        ipppConnProps->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnProps = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnProps)
    {
        if (py_ppConnProps)
           Py_DECREF(py_ppConnProps);
        py_ppConnProps = Py_None;
        Py_INCREF(py_ppConnProps);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionname2_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnProps);
    goto iagsserverconnectionname2_get_connectionproperties_method_cleanup;

    iagsserverconnectionname2_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppConnProps);
    if (ipppConnProps)
      ipppConnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName2.get_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName2Method_get_ConnectionType(PyIAGSServerConnectionName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSConnectionType epConnType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pConnType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName2->get_ConnectionType(&epConnType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName2.get_ConnectionType() returned %ld", (long)hr);
        goto iagsserverconnectionname2_get_connectiontype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epConnType);
    goto iagsserverconnectionname2_get_connectiontype_method_cleanup;

    iagsserverconnectionname2_get_connectiontype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pConnType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName2.get_ConnectionType");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnectionName2Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnectionName2_SupportsInterface, METH_O, ""},
    {"get_ConnectionString", (PyCFunction)IAGSServerConnectionName2Method_get_ConnectionString, METH_VARARGS, ""},
    {"put_ConnectionString", (PyCFunction)IAGSServerConnectionName2Method_put_ConnectionString, METH_VARARGS, ""},
    {"get_ServerConnectionFactoryProgID", (PyCFunction)IAGSServerConnectionName2Method_get_ServerConnectionFactoryProgID, METH_VARARGS, ""},
    {"put_ServerConnectionFactoryProgID", (PyCFunction)IAGSServerConnectionName2Method_put_ServerConnectionFactoryProgID, METH_VARARGS, ""},
    {"put_ConnectionProperties", (PyCFunction)IAGSServerConnectionName2Method_put_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IAGSServerConnectionName2Method_get_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionType", (PyCFunction)IAGSServerConnectionName2Method_get_ConnectionType, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnectionName2GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnectionName2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnectionName2", NULL},
  {"_pointer", (getter)PyIAGSServerConnectionName2_GetPointer, NULL, "Get memory address for IAGSServerConnectionName2", NULL},
  {"_IID", (getter)PyIAGSServerConnectionName2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnectionName2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnectionName2_GetIgnoreFailures, (setter)PyIAGSServerConnectionName2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnectionName2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnectionName2Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnectionName2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnectionName2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnectionName2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnectionName2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnectionName2Object_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnectionName3

typedef struct PyIAGSServerConnectionName3Object {
    PyObject_HEAD
    IAGSServerConnectionName3* m_pIAGSServerConnectionName3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnectionName3Object;

static PyObject*
PyIAGSServerConnectionName3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnectionName3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnectionName3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnectionName3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnectionName3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnectionName3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionName3");
            return NULL;
        }
        self->m_pIAGSServerConnectionName3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnectionName3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnectionName3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnectionName3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnectionName3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnectionName3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnectionName3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionName3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnectionName3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnectionName3Object_dealloc(PyIAGSServerConnectionName3Object* self)
{
    if (self->m_pIAGSServerConnectionName3)
        self->m_pIAGSServerConnectionName3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnectionName3_GetpUnk(PyIAGSServerConnectionName3Object* self)
{
    if (!self->m_pIAGSServerConnectionName3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnectionName3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnectionName3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnectionName3_GetPointer(PyIAGSServerConnectionName3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnectionName3);
}

static PyObject*
PyIAGSServerConnectionName3_GetIID(PyIAGSServerConnectionName3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "9fe30bfc-aa29-4763-bcc4-d9c1256427ea");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnectionName3_GetHR(PyIAGSServerConnectionName3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnectionName3_GetIgnoreFailures(PyIAGSServerConnectionName3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnectionName3_SetIgnoreFailures(PyIAGSServerConnectionName3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnectionName3_SupportsInterface(PyIAGSServerConnectionName3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnectionName3Method_get_ConnectionMode(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSConnectionMode epConnMode;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pConnMode

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->get_ConnectionMode(&epConnMode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.get_ConnectionMode() returned %ld", (long)hr);
        goto iagsserverconnectionname3_get_connectionmode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnMode

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epConnMode);
    goto iagsserverconnectionname3_get_connectionmode_method_cleanup;

    iagsserverconnectionname3_get_connectionmode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pConnMode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.get_ConnectionMode");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_put_ConnectionMode(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSConnectionMode epConnMode;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epConnMode))
      goto iagsserverconnectionname3_put_connectionmode_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pConnMode

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->put_ConnectionMode(epConnMode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.put_ConnectionMode() returned %ld", (long)hr);
        goto iagsserverconnectionname3_put_connectionmode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnMode

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname3_put_connectionmode_method_cleanup;

    iagsserverconnectionname3_put_connectionmode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pConnMode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.put_ConnectionMode");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_get_ServerType(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSServerType epServerType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pServerType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->get_ServerType(&epServerType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.get_ServerType() returned %ld", (long)hr);
        goto iagsserverconnectionname3_get_servertype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pServerType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epServerType);
    goto iagsserverconnectionname3_get_servertype_method_cleanup;

    iagsserverconnectionname3_get_servertype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pServerType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.get_ServerType");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_put_ServerType(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSServerType epServerType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epServerType))
      goto iagsserverconnectionname3_put_servertype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pServerType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->put_ServerType(epServerType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.put_ServerType() returned %ld", (long)hr);
        goto iagsserverconnectionname3_put_servertype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pServerType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname3_put_servertype_method_cleanup;

    iagsserverconnectionname3_put_servertype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pServerType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.put_ServerType");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_get_ConnectionString(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsconnString;
    PyObject* pyvar_connString = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for connString

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->get_ConnectionString(&bsconnString);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.get_ConnectionString() returned %ld", (long)hr);
        goto iagsserverconnectionname3_get_connectionstring_method_cleanup;
    }

    // Set up return values as needed
    pyvar_connString = PyUnicode_FromWideChar(bsconnString,::SysStringLen(bsconnString));
    ::SysFreeString(bsconnString);
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname3_get_connectionstring_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_connString);
    goto iagsserverconnectionname3_get_connectionstring_method_cleanup;

    iagsserverconnectionname3_get_connectionstring_method_cleanup:
    self->m_HR = hr;
    if (pyvar_connString != Py_None)
        Py_XDECREF(pyvar_connString);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.get_ConnectionString");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_put_ConnectionString(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsconnString = 0;
    PyObject* pyvar_connString;
    PyObject* unicodeconnString = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_connString))
      goto iagsserverconnectionname3_put_connectionstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_connString))
        unicodeconnString = PyUnicode_FromObject(pyvar_connString);
    else if (PyUnicode_Check(pyvar_connString))
    {
        unicodeconnString = pyvar_connString;
        Py_INCREF(unicodeconnString);
    }
    else if (pyvar_connString != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter connString at index 0");
    if (unicodeconnString)
        bsconnString = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeconnString), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeconnString));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname3_put_connectionstring_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->put_ConnectionString(bsconnString);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.put_ConnectionString() returned %ld", (long)hr);
        goto iagsserverconnectionname3_put_connectionstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for connString

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname3_put_connectionstring_method_cleanup;

    iagsserverconnectionname3_put_connectionstring_method_cleanup:
    self->m_HR = hr;
    if (bsconnString)
        ::SysFreeString(bsconnString);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.put_ConnectionString");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_get_ServerConnectionFactoryProgID(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsprogID;
    PyObject* pyvar_progID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for progID

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->get_ServerConnectionFactoryProgID(&bsprogID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.get_ServerConnectionFactoryProgID() returned %ld", (long)hr);
        goto iagsserverconnectionname3_get_serverconnectionfactoryprogid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_progID = PyUnicode_FromWideChar(bsprogID,::SysStringLen(bsprogID));
    ::SysFreeString(bsprogID);
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname3_get_serverconnectionfactoryprogid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_progID);
    goto iagsserverconnectionname3_get_serverconnectionfactoryprogid_method_cleanup;

    iagsserverconnectionname3_get_serverconnectionfactoryprogid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_progID != Py_None)
        Py_XDECREF(pyvar_progID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.get_ServerConnectionFactoryProgID");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_put_ServerConnectionFactoryProgID(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsprogID = 0;
    PyObject* pyvar_progID;
    PyObject* unicodeprogID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_progID))
      goto iagsserverconnectionname3_put_serverconnectionfactoryprogid_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_progID))
        unicodeprogID = PyUnicode_FromObject(pyvar_progID);
    else if (PyUnicode_Check(pyvar_progID))
    {
        unicodeprogID = pyvar_progID;
        Py_INCREF(unicodeprogID);
    }
    else if (pyvar_progID != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter progID at index 0");
    if (unicodeprogID)
        bsprogID = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeprogID), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeprogID));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname3_put_serverconnectionfactoryprogid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->put_ServerConnectionFactoryProgID(bsprogID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.put_ServerConnectionFactoryProgID() returned %ld", (long)hr);
        goto iagsserverconnectionname3_put_serverconnectionfactoryprogid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for progID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname3_put_serverconnectionfactoryprogid_method_cleanup;

    iagsserverconnectionname3_put_serverconnectionfactoryprogid_method_cleanup:
    self->m_HR = hr;
    if (bsprogID)
        ::SysFreeString(bsprogID);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.put_ServerConnectionFactoryProgID");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_put_ConnectionProperties(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnProps = NULL;
    PyObject* py_ppConnProps;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppConnProps))
      goto iagsserverconnectionname3_put_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppConnProps, &IID_IPropertySet, (void**)&ipppConnProps))
        PyErr_SetString(PyExc_TypeError, "Argument ppConnProps (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iagsserverconnectionname3_put_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->put_ConnectionProperties(ipppConnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.put_ConnectionProperties() returned %ld", (long)hr);
        goto iagsserverconnectionname3_put_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppConnProps

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionname3_put_connectionproperties_method_cleanup;

    iagsserverconnectionname3_put_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipppConnProps)
      ipppConnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.put_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_get_ConnectionProperties(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnProps = NULL;
    PyObject* py_ppConnProps = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppConnProps

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->get_ConnectionProperties(&ipppConnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.get_ConnectionProperties() returned %ld", (long)hr);
        goto iagsserverconnectionname3_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppConnProps);
    if (ipppConnProps)
    {
        IUnknown* pUnk = NULL;
        ipppConnProps->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnProps = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnProps)
    {
        if (py_ppConnProps)
           Py_DECREF(py_ppConnProps);
        py_ppConnProps = Py_None;
        Py_INCREF(py_ppConnProps);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionname3_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnProps);
    goto iagsserverconnectionname3_get_connectionproperties_method_cleanup;

    iagsserverconnectionname3_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppConnProps);
    if (ipppConnProps)
      ipppConnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.get_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionName3Method_get_ConnectionType(PyIAGSServerConnectionName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSConnectionType epConnType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pConnType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionName3->get_ConnectionType(&epConnType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionName3.get_ConnectionType() returned %ld", (long)hr);
        goto iagsserverconnectionname3_get_connectiontype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epConnType);
    goto iagsserverconnectionname3_get_connectiontype_method_cleanup;

    iagsserverconnectionname3_get_connectiontype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pConnType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionName3.get_ConnectionType");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnectionName3Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnectionName3_SupportsInterface, METH_O, ""},
    {"get_ConnectionMode", (PyCFunction)IAGSServerConnectionName3Method_get_ConnectionMode, METH_VARARGS, ""},
    {"put_ConnectionMode", (PyCFunction)IAGSServerConnectionName3Method_put_ConnectionMode, METH_VARARGS, ""},
    {"get_ServerType", (PyCFunction)IAGSServerConnectionName3Method_get_ServerType, METH_VARARGS, ""},
    {"put_ServerType", (PyCFunction)IAGSServerConnectionName3Method_put_ServerType, METH_VARARGS, ""},
    {"get_ConnectionString", (PyCFunction)IAGSServerConnectionName3Method_get_ConnectionString, METH_VARARGS, ""},
    {"put_ConnectionString", (PyCFunction)IAGSServerConnectionName3Method_put_ConnectionString, METH_VARARGS, ""},
    {"get_ServerConnectionFactoryProgID", (PyCFunction)IAGSServerConnectionName3Method_get_ServerConnectionFactoryProgID, METH_VARARGS, ""},
    {"put_ServerConnectionFactoryProgID", (PyCFunction)IAGSServerConnectionName3Method_put_ServerConnectionFactoryProgID, METH_VARARGS, ""},
    {"put_ConnectionProperties", (PyCFunction)IAGSServerConnectionName3Method_put_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IAGSServerConnectionName3Method_get_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionType", (PyCFunction)IAGSServerConnectionName3Method_get_ConnectionType, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnectionName3GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnectionName3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnectionName3", NULL},
  {"_pointer", (getter)PyIAGSServerConnectionName3_GetPointer, NULL, "Get memory address for IAGSServerConnectionName3", NULL},
  {"_IID", (getter)PyIAGSServerConnectionName3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnectionName3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnectionName3_GetIgnoreFailures, (setter)PyIAGSServerConnectionName3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnectionName3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnectionName3Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnectionName3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnectionName3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnectionName3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnectionName3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnectionName3Object_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnectionFactory

typedef struct PyIAGSServerConnectionFactoryObject {
    PyObject_HEAD
    IAGSServerConnectionFactory* m_pIAGSServerConnectionFactory;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnectionFactoryObject;

static PyObject*
PyIAGSServerConnectionFactoryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnectionFactoryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnectionFactory* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnectionFactory, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnectionFactory with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnectionFactoryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionFactory");
            return NULL;
        }
        self->m_pIAGSServerConnectionFactory = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnectionFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnectionFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnectionFactory* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnectionFactory, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnectionFactory");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnectionFactoryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionFactory");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnectionFactory = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnectionFactoryObject_dealloc(PyIAGSServerConnectionFactoryObject* self)
{
    if (self->m_pIAGSServerConnectionFactory)
        self->m_pIAGSServerConnectionFactory->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnectionFactory_GetpUnk(PyIAGSServerConnectionFactoryObject* self)
{
    if (!self->m_pIAGSServerConnectionFactory)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnectionFactory->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnectionFactory to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnectionFactory_GetPointer(PyIAGSServerConnectionFactoryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnectionFactory);
}

static PyObject*
PyIAGSServerConnectionFactory_GetIID(PyIAGSServerConnectionFactoryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6047c9fc-2d91-420a-a5a2-eb36b7e2fea2");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnectionFactory_GetHR(PyIAGSServerConnectionFactoryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnectionFactory_GetIgnoreFailures(PyIAGSServerConnectionFactoryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnectionFactory_SetIgnoreFailures(PyIAGSServerConnectionFactoryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnectionFactory_SupportsInterface(PyIAGSServerConnectionFactoryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnectionFactoryMethod_Open(PyIAGSServerConnectionFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippConnectionProperties = NULL;
    PyObject* py_pConnectionProperties;
    OLE_HANDLE HhWnd = 0;
    IAGSServerConnection* ipppConnection = NULL;
    PyObject* py_ppConnection = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &py_pConnectionProperties, &HhWnd))
      goto iagsserverconnectionfactory_open_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConnectionProperties, &IID_IPropertySet, (void**)&ippConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument pConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory_open_method_cleanup;
    
    // No setup for hWnd
    // No setup for ppConnection

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory->Open(ippConnectionProperties, HhWnd, &ipppConnection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory.Open() returned %ld", (long)hr);
        goto iagsserverconnectionfactory_open_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnectionProperties
    // No teardown for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
    {
        IUnknown* pUnk = NULL;
        ipppConnection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnection = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnection)
    {
        if (py_ppConnection)
           Py_DECREF(py_ppConnection);
        py_ppConnection = Py_None;
        Py_INCREF(py_ppConnection);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory_open_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnection);
    goto iagsserverconnectionfactory_open_method_cleanup;

    iagsserverconnectionfactory_open_method_cleanup:
    self->m_HR = hr;
    if (ippConnectionProperties)
      ippConnectionProperties->Release();
    // No cleanup for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
      ipppConnection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory.Open");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnectionFactoryMethods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnectionFactory_SupportsInterface, METH_O, ""},
    {"Open", (PyCFunction)IAGSServerConnectionFactoryMethod_Open, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnectionFactoryGetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnectionFactory_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnectionFactory", NULL},
  {"_pointer", (getter)PyIAGSServerConnectionFactory_GetPointer, NULL, "Get memory address for IAGSServerConnectionFactory", NULL},
  {"_IID", (getter)PyIAGSServerConnectionFactory_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnectionFactory_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnectionFactory_GetIgnoreFailures, (setter)PyIAGSServerConnectionFactory_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnectionFactoryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnectionFactoryObject",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnectionFactoryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnectionFactoryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnectionFactoryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnectionFactoryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnectionFactoryObject_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnectionFactory2

typedef struct PyIAGSServerConnectionFactory2Object {
    PyObject_HEAD
    IAGSServerConnectionFactory2* m_pIAGSServerConnectionFactory2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnectionFactory2Object;

static PyObject*
PyIAGSServerConnectionFactory2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnectionFactory2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnectionFactory2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnectionFactory2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnectionFactory2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnectionFactory2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionFactory2");
            return NULL;
        }
        self->m_pIAGSServerConnectionFactory2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnectionFactory2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnectionFactory2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnectionFactory2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnectionFactory2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnectionFactory2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnectionFactory2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionFactory2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnectionFactory2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnectionFactory2Object_dealloc(PyIAGSServerConnectionFactory2Object* self)
{
    if (self->m_pIAGSServerConnectionFactory2)
        self->m_pIAGSServerConnectionFactory2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnectionFactory2_GetpUnk(PyIAGSServerConnectionFactory2Object* self)
{
    if (!self->m_pIAGSServerConnectionFactory2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnectionFactory2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnectionFactory2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnectionFactory2_GetPointer(PyIAGSServerConnectionFactory2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnectionFactory2);
}

static PyObject*
PyIAGSServerConnectionFactory2_GetIID(PyIAGSServerConnectionFactory2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0264ca94-b0eb-435f-9d3a-5fcc5da0fbae");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnectionFactory2_GetHR(PyIAGSServerConnectionFactory2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnectionFactory2_GetIgnoreFailures(PyIAGSServerConnectionFactory2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnectionFactory2_SetIgnoreFailures(PyIAGSServerConnectionFactory2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnectionFactory2_SupportsInterface(PyIAGSServerConnectionFactory2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnectionFactory2Method_OpenFromFile(PyIAGSServerConnectionFactory2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;
    OLE_HANDLE HhWnd = 0;
    IAGSServerConnection* ipppConnection = NULL;
    PyObject* py_ppConnection = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &pyvar_fileName, &HhWnd))
      goto iagsserverconnectionfactory2_openfromfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory2_openfromfile_method_cleanup;
    
    // No setup for hWnd
    // No setup for ppConnection

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory2->OpenFromFile(bsfileName, HhWnd, &ipppConnection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory2.OpenFromFile() returned %ld", (long)hr);
        goto iagsserverconnectionfactory2_openfromfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName
    // No teardown for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
    {
        IUnknown* pUnk = NULL;
        ipppConnection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnection = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnection)
    {
        if (py_ppConnection)
           Py_DECREF(py_ppConnection);
        py_ppConnection = Py_None;
        Py_INCREF(py_ppConnection);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory2_openfromfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnection);
    goto iagsserverconnectionfactory2_openfromfile_method_cleanup;

    iagsserverconnectionfactory2_openfromfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    // No cleanup for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
      ipppConnection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory2.OpenFromFile");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory2Method_ReadConnectionPropertiesFromFile(PyIAGSServerConnectionFactory2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;
    IPropertySet* ipConnectionProperties = NULL;
    PyObject* py_ConnectionProperties = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iagsserverconnectionfactory2_readconnectionpropertiesfromfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory2_readconnectionpropertiesfromfile_method_cleanup;
    
    // No setup for ConnectionProperties

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory2->ReadConnectionPropertiesFromFile(bsfileName, &ipConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory2.ReadConnectionPropertiesFromFile() returned %ld", (long)hr);
        goto iagsserverconnectionfactory2_readconnectionpropertiesfromfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
    {
        IUnknown* pUnk = NULL;
        ipConnectionProperties->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ConnectionProperties = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ConnectionProperties)
    {
        if (py_ConnectionProperties)
           Py_DECREF(py_ConnectionProperties);
        py_ConnectionProperties = Py_None;
        Py_INCREF(py_ConnectionProperties);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory2_readconnectionpropertiesfromfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ConnectionProperties);
    goto iagsserverconnectionfactory2_readconnectionpropertiesfromfile_method_cleanup;

    iagsserverconnectionfactory2_readconnectionpropertiesfromfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
      ipConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory2.ReadConnectionPropertiesFromFile");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory2Method_put_DefaultHttpTimeout(PyIAGSServerConnectionFactory2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lseconds = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lseconds))
      goto iagsserverconnectionfactory2_put_defaulthttptimeout_method_cleanup;

    // Set up initial variable values as needed
    // No setup for seconds

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory2->put_DefaultHttpTimeout(lseconds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory2.put_DefaultHttpTimeout() returned %ld", (long)hr);
        goto iagsserverconnectionfactory2_put_defaulthttptimeout_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for seconds

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionfactory2_put_defaulthttptimeout_method_cleanup;

    iagsserverconnectionfactory2_put_defaulthttptimeout_method_cleanup:
    self->m_HR = hr;
    // No cleanup for seconds
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory2.put_DefaultHttpTimeout");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory2Method_get_DefaultHttpTimeout(PyIAGSServerConnectionFactory2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lseconds = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for seconds

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory2->get_DefaultHttpTimeout(&lseconds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory2.get_DefaultHttpTimeout() returned %ld", (long)hr);
        goto iagsserverconnectionfactory2_get_defaulthttptimeout_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for seconds

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lseconds);
    goto iagsserverconnectionfactory2_get_defaulthttptimeout_method_cleanup;

    iagsserverconnectionfactory2_get_defaulthttptimeout_method_cleanup:
    self->m_HR = hr;
    // No cleanup for seconds
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory2.get_DefaultHttpTimeout");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory2Method_Open(PyIAGSServerConnectionFactory2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippConnectionProperties = NULL;
    PyObject* py_pConnectionProperties;
    OLE_HANDLE HhWnd = 0;
    IAGSServerConnection* ipppConnection = NULL;
    PyObject* py_ppConnection = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &py_pConnectionProperties, &HhWnd))
      goto iagsserverconnectionfactory2_open_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConnectionProperties, &IID_IPropertySet, (void**)&ippConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument pConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory2_open_method_cleanup;
    
    // No setup for hWnd
    // No setup for ppConnection

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory2->Open(ippConnectionProperties, HhWnd, &ipppConnection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory2.Open() returned %ld", (long)hr);
        goto iagsserverconnectionfactory2_open_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnectionProperties
    // No teardown for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
    {
        IUnknown* pUnk = NULL;
        ipppConnection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnection = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnection)
    {
        if (py_ppConnection)
           Py_DECREF(py_ppConnection);
        py_ppConnection = Py_None;
        Py_INCREF(py_ppConnection);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory2_open_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnection);
    goto iagsserverconnectionfactory2_open_method_cleanup;

    iagsserverconnectionfactory2_open_method_cleanup:
    self->m_HR = hr;
    if (ippConnectionProperties)
      ippConnectionProperties->Release();
    // No cleanup for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
      ipppConnection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory2.Open");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnectionFactory2Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnectionFactory2_SupportsInterface, METH_O, ""},
    {"OpenFromFile", (PyCFunction)IAGSServerConnectionFactory2Method_OpenFromFile, METH_VARARGS, ""},
    {"ReadConnectionPropertiesFromFile", (PyCFunction)IAGSServerConnectionFactory2Method_ReadConnectionPropertiesFromFile, METH_VARARGS, ""},
    {"put_DefaultHttpTimeout", (PyCFunction)IAGSServerConnectionFactory2Method_put_DefaultHttpTimeout, METH_VARARGS, ""},
    {"get_DefaultHttpTimeout", (PyCFunction)IAGSServerConnectionFactory2Method_get_DefaultHttpTimeout, METH_VARARGS, ""},
    {"Open", (PyCFunction)IAGSServerConnectionFactory2Method_Open, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnectionFactory2GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnectionFactory2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnectionFactory2", NULL},
  {"_pointer", (getter)PyIAGSServerConnectionFactory2_GetPointer, NULL, "Get memory address for IAGSServerConnectionFactory2", NULL},
  {"_IID", (getter)PyIAGSServerConnectionFactory2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnectionFactory2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnectionFactory2_GetIgnoreFailures, (setter)PyIAGSServerConnectionFactory2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnectionFactory2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnectionFactory2Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnectionFactory2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnectionFactory2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnectionFactory2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnectionFactory2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnectionFactory2Object_new,                      
                                              /* tp_new */
};

// Interface IEnumAGSServerConnectionName

typedef struct PyIEnumAGSServerConnectionNameObject {
    PyObject_HEAD
    IEnumAGSServerConnectionName* m_pIEnumAGSServerConnectionName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIEnumAGSServerConnectionNameObject;

static PyObject*
PyIEnumAGSServerConnectionNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIEnumAGSServerConnectionNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IEnumAGSServerConnectionName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IEnumAGSServerConnectionName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IEnumAGSServerConnectionName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIEnumAGSServerConnectionNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumAGSServerConnectionName");
            return NULL;
        }
        self->m_pIEnumAGSServerConnectionName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IEnumAGSServerConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IEnumAGSServerConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IEnumAGSServerConnectionName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IEnumAGSServerConnectionName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IEnumAGSServerConnectionName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIEnumAGSServerConnectionNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumAGSServerConnectionName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIEnumAGSServerConnectionName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIEnumAGSServerConnectionNameObject_dealloc(PyIEnumAGSServerConnectionNameObject* self)
{
    if (self->m_pIEnumAGSServerConnectionName)
        self->m_pIEnumAGSServerConnectionName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIEnumAGSServerConnectionName_GetpUnk(PyIEnumAGSServerConnectionNameObject* self)
{
    if (!self->m_pIEnumAGSServerConnectionName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIEnumAGSServerConnectionName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IEnumAGSServerConnectionName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIEnumAGSServerConnectionName_GetPointer(PyIEnumAGSServerConnectionNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIEnumAGSServerConnectionName);
}

static PyObject*
PyIEnumAGSServerConnectionName_GetIID(PyIEnumAGSServerConnectionNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4f11971a-f293-47a4-acf2-fef737fb71f4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIEnumAGSServerConnectionName_GetHR(PyIEnumAGSServerConnectionNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIEnumAGSServerConnectionName_GetIgnoreFailures(PyIEnumAGSServerConnectionNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIEnumAGSServerConnectionName_SetIgnoreFailures(PyIEnumAGSServerConnectionNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIEnumAGSServerConnectionName_SupportsInterface(PyIEnumAGSServerConnectionNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIEnumAGSServerConnectionName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IEnumAGSServerConnectionNameMethod_Reset(PyIEnumAGSServerConnectionNameObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIEnumAGSServerConnectionName->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumAGSServerConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumAGSServerConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumAGSServerConnectionName.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IEnumAGSServerConnectionNameMethod_Next(PyIEnumAGSServerConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnectionName* ipconnName = NULL;
    PyObject* py_connName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for connName

    // Call method on actual COM interface
    hr = self->m_pIEnumAGSServerConnectionName->Next(&ipconnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumAGSServerConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumAGSServerConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumAGSServerConnectionName.Next() returned %ld", (long)hr);
        goto ienumagsserverconnectionname_next_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_connName);
    if (ipconnName)
    {
        IUnknown* pUnk = NULL;
        ipconnName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_connName = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnectionName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_connName)
    {
        if (py_connName)
           Py_DECREF(py_connName);
        py_connName = Py_None;
        Py_INCREF(py_connName);
    }
    if (PyErr_Occurred())
      goto ienumagsserverconnectionname_next_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_connName);
    goto ienumagsserverconnectionname_next_method_cleanup;

    ienumagsserverconnectionname_next_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_connName);
    if (ipconnName)
      ipconnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumAGSServerConnectionName.Next");
    return return_tuple;
}


PyMethodDef PyIEnumAGSServerConnectionNameMethods[] = {
    {"supports", (PyCFunction)PyIEnumAGSServerConnectionName_SupportsInterface, METH_O, ""},
    {"Reset", (PyCFunction)IEnumAGSServerConnectionNameMethod_Reset, METH_NOARGS, ""},
    {"Next", (PyCFunction)IEnumAGSServerConnectionNameMethod_Next, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIEnumAGSServerConnectionNameGetSet[] = {
  {"_pUnk", (getter)PyIEnumAGSServerConnectionName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IEnumAGSServerConnectionName", NULL},
  {"_pointer", (getter)PyIEnumAGSServerConnectionName_GetPointer, NULL, "Get memory address for IEnumAGSServerConnectionName", NULL},
  {"_IID", (getter)PyIEnumAGSServerConnectionName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIEnumAGSServerConnectionName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIEnumAGSServerConnectionName_GetIgnoreFailures, (setter)PyIEnumAGSServerConnectionName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIEnumAGSServerConnectionNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IEnumAGSServerConnectionNameObject",                          
                                              /* tp_name */
  sizeof(PyIEnumAGSServerConnectionNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIEnumAGSServerConnectionNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIEnumAGSServerConnectionNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIEnumAGSServerConnectionNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIEnumAGSServerConnectionNameObject_new,                      
                                              /* tp_new */
};

// Interface IAGSServerConnectionFactory3

typedef struct PyIAGSServerConnectionFactory3Object {
    PyObject_HEAD
    IAGSServerConnectionFactory3* m_pIAGSServerConnectionFactory3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerConnectionFactory3Object;

static PyObject*
PyIAGSServerConnectionFactory3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerConnectionFactory3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerConnectionFactory3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerConnectionFactory3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerConnectionFactory3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerConnectionFactory3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionFactory3");
            return NULL;
        }
        self->m_pIAGSServerConnectionFactory3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerConnectionFactory3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerConnectionFactory3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerConnectionFactory3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerConnectionFactory3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerConnectionFactory3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerConnectionFactory3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerConnectionFactory3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerConnectionFactory3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerConnectionFactory3Object_dealloc(PyIAGSServerConnectionFactory3Object* self)
{
    if (self->m_pIAGSServerConnectionFactory3)
        self->m_pIAGSServerConnectionFactory3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerConnectionFactory3_GetpUnk(PyIAGSServerConnectionFactory3Object* self)
{
    if (!self->m_pIAGSServerConnectionFactory3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerConnectionFactory3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerConnectionFactory3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerConnectionFactory3_GetPointer(PyIAGSServerConnectionFactory3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerConnectionFactory3);
}

static PyObject*
PyIAGSServerConnectionFactory3_GetIID(PyIAGSServerConnectionFactory3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "02d56c6d-9134-42c7-b6b0-6804a125b7a9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerConnectionFactory3_GetHR(PyIAGSServerConnectionFactory3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerConnectionFactory3_GetIgnoreFailures(PyIAGSServerConnectionFactory3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerConnectionFactory3_SetIgnoreFailures(PyIAGSServerConnectionFactory3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerConnectionFactory3_SupportsInterface(PyIAGSServerConnectionFactory3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerConnectionFactory3Method_GetHostedServers(PyIAGSServerConnectionFactory3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;
    IEnumAGSServerConnectionName* ipconnNames = NULL;
    PyObject* py_connNames = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HhWnd))
      goto iagsserverconnectionfactory3_gethostedservers_method_cleanup;

    // Set up initial variable values as needed
    // No setup for hWnd
    // No setup for connNames

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory3->GetHostedServers(HhWnd, &ipconnNames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory3.GetHostedServers() returned %ld", (long)hr);
        goto iagsserverconnectionfactory3_gethostedservers_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd
    Py_XDECREF(py_connNames);
    if (ipconnNames)
    {
        IUnknown* pUnk = NULL;
        ipconnNames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_connNames = IUnknownToPythonIIDObject(pUnk, &IID_IEnumAGSServerConnectionName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_connNames)
    {
        if (py_connNames)
           Py_DECREF(py_connNames);
        py_connNames = Py_None;
        Py_INCREF(py_connNames);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory3_gethostedservers_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_connNames);
    goto iagsserverconnectionfactory3_gethostedservers_method_cleanup;

    iagsserverconnectionfactory3_gethostedservers_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    Py_XDECREF(py_connNames);
    if (ipconnNames)
      ipconnNames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory3.GetHostedServers");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory3Method_GetInServerConnectionName(PyIAGSServerConnectionFactory3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnectionName* ipconnName = NULL;
    PyObject* py_connName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for connName

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory3->GetInServerConnectionName(&ipconnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory3.GetInServerConnectionName() returned %ld", (long)hr);
        goto iagsserverconnectionfactory3_getinserverconnectionname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_connName);
    if (ipconnName)
    {
        IUnknown* pUnk = NULL;
        ipconnName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_connName = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnectionName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_connName)
    {
        if (py_connName)
           Py_DECREF(py_connName);
        py_connName = Py_None;
        Py_INCREF(py_connName);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory3_getinserverconnectionname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_connName);
    goto iagsserverconnectionfactory3_getinserverconnectionname_method_cleanup;

    iagsserverconnectionfactory3_getinserverconnectionname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_connName);
    if (ipconnName)
      ipconnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory3.GetInServerConnectionName");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory3Method_OpenFromFile(PyIAGSServerConnectionFactory3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;
    OLE_HANDLE HhWnd = 0;
    IAGSServerConnection* ipppConnection = NULL;
    PyObject* py_ppConnection = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &pyvar_fileName, &HhWnd))
      goto iagsserverconnectionfactory3_openfromfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory3_openfromfile_method_cleanup;
    
    // No setup for hWnd
    // No setup for ppConnection

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory3->OpenFromFile(bsfileName, HhWnd, &ipppConnection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory3.OpenFromFile() returned %ld", (long)hr);
        goto iagsserverconnectionfactory3_openfromfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName
    // No teardown for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
    {
        IUnknown* pUnk = NULL;
        ipppConnection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnection = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnection)
    {
        if (py_ppConnection)
           Py_DECREF(py_ppConnection);
        py_ppConnection = Py_None;
        Py_INCREF(py_ppConnection);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory3_openfromfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnection);
    goto iagsserverconnectionfactory3_openfromfile_method_cleanup;

    iagsserverconnectionfactory3_openfromfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    // No cleanup for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
      ipppConnection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory3.OpenFromFile");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory3Method_ReadConnectionPropertiesFromFile(PyIAGSServerConnectionFactory3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;
    IPropertySet* ipConnectionProperties = NULL;
    PyObject* py_ConnectionProperties = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iagsserverconnectionfactory3_readconnectionpropertiesfromfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory3_readconnectionpropertiesfromfile_method_cleanup;
    
    // No setup for ConnectionProperties

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory3->ReadConnectionPropertiesFromFile(bsfileName, &ipConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory3.ReadConnectionPropertiesFromFile() returned %ld", (long)hr);
        goto iagsserverconnectionfactory3_readconnectionpropertiesfromfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
    {
        IUnknown* pUnk = NULL;
        ipConnectionProperties->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ConnectionProperties = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ConnectionProperties)
    {
        if (py_ConnectionProperties)
           Py_DECREF(py_ConnectionProperties);
        py_ConnectionProperties = Py_None;
        Py_INCREF(py_ConnectionProperties);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory3_readconnectionpropertiesfromfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ConnectionProperties);
    goto iagsserverconnectionfactory3_readconnectionpropertiesfromfile_method_cleanup;

    iagsserverconnectionfactory3_readconnectionpropertiesfromfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
      ipConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory3.ReadConnectionPropertiesFromFile");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory3Method_put_DefaultHttpTimeout(PyIAGSServerConnectionFactory3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lseconds = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lseconds))
      goto iagsserverconnectionfactory3_put_defaulthttptimeout_method_cleanup;

    // Set up initial variable values as needed
    // No setup for seconds

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory3->put_DefaultHttpTimeout(lseconds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory3.put_DefaultHttpTimeout() returned %ld", (long)hr);
        goto iagsserverconnectionfactory3_put_defaulthttptimeout_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for seconds

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverconnectionfactory3_put_defaulthttptimeout_method_cleanup;

    iagsserverconnectionfactory3_put_defaulthttptimeout_method_cleanup:
    self->m_HR = hr;
    // No cleanup for seconds
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory3.put_DefaultHttpTimeout");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory3Method_get_DefaultHttpTimeout(PyIAGSServerConnectionFactory3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lseconds = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for seconds

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory3->get_DefaultHttpTimeout(&lseconds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory3.get_DefaultHttpTimeout() returned %ld", (long)hr);
        goto iagsserverconnectionfactory3_get_defaulthttptimeout_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for seconds

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lseconds);
    goto iagsserverconnectionfactory3_get_defaulthttptimeout_method_cleanup;

    iagsserverconnectionfactory3_get_defaulthttptimeout_method_cleanup:
    self->m_HR = hr;
    // No cleanup for seconds
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory3.get_DefaultHttpTimeout");
    return return_tuple;
}

static PyObject*
IAGSServerConnectionFactory3Method_Open(PyIAGSServerConnectionFactory3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippConnectionProperties = NULL;
    PyObject* py_pConnectionProperties;
    OLE_HANDLE HhWnd = 0;
    IAGSServerConnection* ipppConnection = NULL;
    PyObject* py_ppConnection = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &py_pConnectionProperties, &HhWnd))
      goto iagsserverconnectionfactory3_open_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConnectionProperties, &IID_IPropertySet, (void**)&ippConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument pConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory3_open_method_cleanup;
    
    // No setup for hWnd
    // No setup for ppConnection

    // Call method on actual COM interface
    hr = self->m_pIAGSServerConnectionFactory3->Open(ippConnectionProperties, HhWnd, &ipppConnection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerConnectionFactory3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerConnectionFactory3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerConnectionFactory3.Open() returned %ld", (long)hr);
        goto iagsserverconnectionfactory3_open_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnectionProperties
    // No teardown for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
    {
        IUnknown* pUnk = NULL;
        ipppConnection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnection = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnection)
    {
        if (py_ppConnection)
           Py_DECREF(py_ppConnection);
        py_ppConnection = Py_None;
        Py_INCREF(py_ppConnection);
    }
    if (PyErr_Occurred())
      goto iagsserverconnectionfactory3_open_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnection);
    goto iagsserverconnectionfactory3_open_method_cleanup;

    iagsserverconnectionfactory3_open_method_cleanup:
    self->m_HR = hr;
    if (ippConnectionProperties)
      ippConnectionProperties->Release();
    // No cleanup for hWnd
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
      ipppConnection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerConnectionFactory3.Open");
    return return_tuple;
}


PyMethodDef PyIAGSServerConnectionFactory3Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerConnectionFactory3_SupportsInterface, METH_O, ""},
    {"GetHostedServers", (PyCFunction)IAGSServerConnectionFactory3Method_GetHostedServers, METH_VARARGS, ""},
    {"GetInServerConnectionName", (PyCFunction)IAGSServerConnectionFactory3Method_GetInServerConnectionName, METH_VARARGS, ""},
    {"OpenFromFile", (PyCFunction)IAGSServerConnectionFactory3Method_OpenFromFile, METH_VARARGS, ""},
    {"ReadConnectionPropertiesFromFile", (PyCFunction)IAGSServerConnectionFactory3Method_ReadConnectionPropertiesFromFile, METH_VARARGS, ""},
    {"put_DefaultHttpTimeout", (PyCFunction)IAGSServerConnectionFactory3Method_put_DefaultHttpTimeout, METH_VARARGS, ""},
    {"get_DefaultHttpTimeout", (PyCFunction)IAGSServerConnectionFactory3Method_get_DefaultHttpTimeout, METH_VARARGS, ""},
    {"Open", (PyCFunction)IAGSServerConnectionFactory3Method_Open, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerConnectionFactory3GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerConnectionFactory3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerConnectionFactory3", NULL},
  {"_pointer", (getter)PyIAGSServerConnectionFactory3_GetPointer, NULL, "Get memory address for IAGSServerConnectionFactory3", NULL},
  {"_IID", (getter)PyIAGSServerConnectionFactory3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerConnectionFactory3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerConnectionFactory3_GetIgnoreFailures, (setter)PyIAGSServerConnectionFactory3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerConnectionFactory3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerConnectionFactory3Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerConnectionFactory3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerConnectionFactory3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerConnectionFactory3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerConnectionFactory3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerConnectionFactory3Object_new,                      
                                              /* tp_new */
};

// Interface ISetDefaultAgsConnectionInfo

typedef struct PyISetDefaultAgsConnectionInfoObject {
    PyObject_HEAD
    ISetDefaultAgsConnectionInfo* m_pISetDefaultAgsConnectionInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISetDefaultAgsConnectionInfoObject;

static PyObject*
PyISetDefaultAgsConnectionInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISetDefaultAgsConnectionInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISetDefaultAgsConnectionInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISetDefaultAgsConnectionInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISetDefaultAgsConnectionInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISetDefaultAgsConnectionInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISetDefaultAgsConnectionInfo");
            return NULL;
        }
        self->m_pISetDefaultAgsConnectionInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISetDefaultAgsConnectionInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISetDefaultAgsConnectionInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISetDefaultAgsConnectionInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISetDefaultAgsConnectionInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISetDefaultAgsConnectionInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISetDefaultAgsConnectionInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISetDefaultAgsConnectionInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISetDefaultAgsConnectionInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISetDefaultAgsConnectionInfoObject_dealloc(PyISetDefaultAgsConnectionInfoObject* self)
{
    if (self->m_pISetDefaultAgsConnectionInfo)
        self->m_pISetDefaultAgsConnectionInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISetDefaultAgsConnectionInfo_GetpUnk(PyISetDefaultAgsConnectionInfoObject* self)
{
    if (!self->m_pISetDefaultAgsConnectionInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISetDefaultAgsConnectionInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISetDefaultAgsConnectionInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISetDefaultAgsConnectionInfo_GetPointer(PyISetDefaultAgsConnectionInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISetDefaultAgsConnectionInfo);
}

static PyObject*
PyISetDefaultAgsConnectionInfo_GetIID(PyISetDefaultAgsConnectionInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "df667332-0e2b-49bf-9df9-ba8b15a37601");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISetDefaultAgsConnectionInfo_GetHR(PyISetDefaultAgsConnectionInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISetDefaultAgsConnectionInfo_GetIgnoreFailures(PyISetDefaultAgsConnectionInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISetDefaultAgsConnectionInfo_SetIgnoreFailures(PyISetDefaultAgsConnectionInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISetDefaultAgsConnectionInfo_SupportsInterface(PyISetDefaultAgsConnectionInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISetDefaultAgsConnectionInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISetDefaultAgsConnectionInfoMethod_ClearParameters(PyISetDefaultAgsConnectionInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippConnectionProperties = NULL;
    PyObject* py_pConnectionProperties;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pConnectionProperties))
      goto isetdefaultagsconnectioninfo_clearparameters_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConnectionProperties, &IID_IPropertySet, (void**)&ippConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument pConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto isetdefaultagsconnectioninfo_clearparameters_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISetDefaultAgsConnectionInfo->ClearParameters(ippConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISetDefaultAgsConnectionInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISetDefaultAgsConnectionInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISetDefaultAgsConnectionInfo.ClearParameters() returned %ld", (long)hr);
        goto isetdefaultagsconnectioninfo_clearparameters_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnectionProperties

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto isetdefaultagsconnectioninfo_clearparameters_method_cleanup;

    isetdefaultagsconnectioninfo_clearparameters_method_cleanup:
    self->m_HR = hr;
    if (ippConnectionProperties)
      ippConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISetDefaultAgsConnectionInfo.ClearParameters");
    return return_tuple;
}


PyMethodDef PyISetDefaultAgsConnectionInfoMethods[] = {
    {"supports", (PyCFunction)PyISetDefaultAgsConnectionInfo_SupportsInterface, METH_O, ""},
    {"ClearParameters", (PyCFunction)ISetDefaultAgsConnectionInfoMethod_ClearParameters, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISetDefaultAgsConnectionInfoGetSet[] = {
  {"_pUnk", (getter)PyISetDefaultAgsConnectionInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISetDefaultAgsConnectionInfo", NULL},
  {"_pointer", (getter)PyISetDefaultAgsConnectionInfo_GetPointer, NULL, "Get memory address for ISetDefaultAgsConnectionInfo", NULL},
  {"_IID", (getter)PyISetDefaultAgsConnectionInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISetDefaultAgsConnectionInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISetDefaultAgsConnectionInfo_GetIgnoreFailures, (setter)PyISetDefaultAgsConnectionInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISetDefaultAgsConnectionInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.ISetDefaultAgsConnectionInfoObject",                          
                                              /* tp_name */
  sizeof(PyISetDefaultAgsConnectionInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISetDefaultAgsConnectionInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISetDefaultAgsConnectionInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISetDefaultAgsConnectionInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISetDefaultAgsConnectionInfoObject_new,                      
                                              /* tp_new */
};

// Interface IAGSServerObject2

typedef struct PyIAGSServerObject2Object {
    PyObject_HEAD
    IAGSServerObject2* m_pIAGSServerObject2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerObject2Object;

static PyObject*
PyIAGSServerObject2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerObject2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerObject2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerObject2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerObject2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerObject2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerObject2");
            return NULL;
        }
        self->m_pIAGSServerObject2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerObject2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerObject2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerObject2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerObject2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerObject2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerObject2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerObject2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerObject2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerObject2Object_dealloc(PyIAGSServerObject2Object* self)
{
    if (self->m_pIAGSServerObject2)
        self->m_pIAGSServerObject2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerObject2_GetpUnk(PyIAGSServerObject2Object* self)
{
    if (!self->m_pIAGSServerObject2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerObject2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerObject2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerObject2_GetPointer(PyIAGSServerObject2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerObject2);
}

static PyObject*
PyIAGSServerObject2_GetIID(PyIAGSServerObject2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2e07daa3-6dec-4dc3-a7ed-2f29e2ecfe4a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerObject2_GetHR(PyIAGSServerObject2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerObject2_GetIgnoreFailures(PyIAGSServerObject2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerObject2_SetIgnoreFailures(PyIAGSServerObject2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerObject2_SupportsInterface(PyIAGSServerObject2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerObject2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerObject2Method_get_FullName(PyIAGSServerObject2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipServerObjectName = NULL;
    PyObject* py_ServerObjectName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ServerObjectName

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObject2->get_FullName(&ipServerObjectName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObject2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObject2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObject2.get_FullName() returned %ld", (long)hr);
        goto iagsserverobject2_get_fullname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ServerObjectName);
    if (ipServerObjectName)
    {
        IUnknown* pUnk = NULL;
        ipServerObjectName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ServerObjectName = IUnknownToPythonIIDObject(pUnk, &IID_IName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ServerObjectName)
    {
        if (py_ServerObjectName)
           Py_DECREF(py_ServerObjectName);
        py_ServerObjectName = Py_None;
        Py_INCREF(py_ServerObjectName);
    }
    if (PyErr_Occurred())
      goto iagsserverobject2_get_fullname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ServerObjectName);
    goto iagsserverobject2_get_fullname_method_cleanup;

    iagsserverobject2_get_fullname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ServerObjectName);
    if (ipServerObjectName)
      ipServerObjectName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObject2.get_FullName");
    return return_tuple;
}

static PyObject*
IAGSServerObject2Method_put_HttpTimeout(PyIAGSServerObject2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lsecs = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lsecs))
      goto iagsserverobject2_put_httptimeout_method_cleanup;

    // Set up initial variable values as needed
    // No setup for secs

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObject2->put_HttpTimeout(lsecs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObject2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObject2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObject2.put_HttpTimeout() returned %ld", (long)hr);
        goto iagsserverobject2_put_httptimeout_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for secs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobject2_put_httptimeout_method_cleanup;

    iagsserverobject2_put_httptimeout_method_cleanup:
    self->m_HR = hr;
    // No cleanup for secs
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObject2.put_HttpTimeout");
    return return_tuple;
}

static PyObject*
IAGSServerObject2Method_get_HttpTimeout(PyIAGSServerObject2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lsecs = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for secs

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObject2->get_HttpTimeout(&lsecs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObject2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObject2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObject2.get_HttpTimeout() returned %ld", (long)hr);
        goto iagsserverobject2_get_httptimeout_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for secs

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lsecs);
    goto iagsserverobject2_get_httptimeout_method_cleanup;

    iagsserverobject2_get_httptimeout_method_cleanup:
    self->m_HR = hr;
    // No cleanup for secs
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObject2.get_HttpTimeout");
    return return_tuple;
}


PyMethodDef PyIAGSServerObject2Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerObject2_SupportsInterface, METH_O, ""},
    {"get_FullName", (PyCFunction)IAGSServerObject2Method_get_FullName, METH_VARARGS, ""},
    {"put_HttpTimeout", (PyCFunction)IAGSServerObject2Method_put_HttpTimeout, METH_VARARGS, ""},
    {"get_HttpTimeout", (PyCFunction)IAGSServerObject2Method_get_HttpTimeout, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerObject2GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerObject2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerObject2", NULL},
  {"_pointer", (getter)PyIAGSServerObject2_GetPointer, NULL, "Get memory address for IAGSServerObject2", NULL},
  {"_IID", (getter)PyIAGSServerObject2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerObject2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerObject2_GetIgnoreFailures, (setter)PyIAGSServerObject2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerObject2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerObject2Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerObject2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerObject2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerObject2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerObject2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerObject2Object_new,                      
                                              /* tp_new */
};

// Interface IAGSServerObjectName2

typedef struct PyIAGSServerObjectName2Object {
    PyObject_HEAD
    IAGSServerObjectName2* m_pIAGSServerObjectName2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerObjectName2Object;

static PyObject*
PyIAGSServerObjectName2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerObjectName2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerObjectName2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerObjectName2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerObjectName2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerObjectName2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerObjectName2");
            return NULL;
        }
        self->m_pIAGSServerObjectName2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerObjectName2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerObjectName2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerObjectName2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerObjectName2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerObjectName2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerObjectName2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerObjectName2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerObjectName2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerObjectName2Object_dealloc(PyIAGSServerObjectName2Object* self)
{
    if (self->m_pIAGSServerObjectName2)
        self->m_pIAGSServerObjectName2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerObjectName2_GetpUnk(PyIAGSServerObjectName2Object* self)
{
    if (!self->m_pIAGSServerObjectName2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerObjectName2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerObjectName2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerObjectName2_GetPointer(PyIAGSServerObjectName2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerObjectName2);
}

static PyObject*
PyIAGSServerObjectName2_GetIID(PyIAGSServerObjectName2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2f311f9a-50f9-45d4-9553-d781a08445e8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerObjectName2_GetHR(PyIAGSServerObjectName2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerObjectName2_GetIgnoreFailures(PyIAGSServerObjectName2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerObjectName2_SetIgnoreFailures(PyIAGSServerObjectName2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerObjectName2_SupportsInterface(PyIAGSServerObjectName2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerObjectName2Method_put_NameString2(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsns = 0;
    PyObject* pyvar_ns;
    PyObject* unicodens = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ns))
      goto iagsserverobjectname2_put_namestring2_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ns))
        unicodens = PyUnicode_FromObject(pyvar_ns);
    else if (PyUnicode_Check(pyvar_ns))
    {
        unicodens = pyvar_ns;
        Py_INCREF(unicodens);
    }
    else if (pyvar_ns != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ns at index 0");
    if (unicodens)
        bsns = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodens), 
                                            (UINT)PyUnicode_GET_SIZE(unicodens));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_put_namestring2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->put_NameString2(bsns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.put_NameString2() returned %ld", (long)hr);
        goto iagsserverobjectname2_put_namestring2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ns

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname2_put_namestring2_method_cleanup;

    iagsserverobjectname2_put_namestring2_method_cleanup:
    self->m_HR = hr;
    if (bsns)
        ::SysFreeString(bsns);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.put_NameString2");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_get_NameString2(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsns;
    PyObject* pyvar_ns = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ns

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->get_NameString2(&bsns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.get_NameString2() returned %ld", (long)hr);
        goto iagsserverobjectname2_get_namestring2_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ns = PyUnicode_FromWideChar(bsns,::SysStringLen(bsns));
    ::SysFreeString(bsns);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_get_namestring2_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ns);
    goto iagsserverobjectname2_get_namestring2_method_cleanup;

    iagsserverobjectname2_get_namestring2_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ns != Py_None)
        Py_XDECREF(pyvar_ns);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.get_NameString2");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_put_ParentType(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsParentType = 0;
    PyObject* pyvar_ParentType;
    PyObject* unicodeParentType = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ParentType))
      goto iagsserverobjectname2_put_parenttype_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ParentType))
        unicodeParentType = PyUnicode_FromObject(pyvar_ParentType);
    else if (PyUnicode_Check(pyvar_ParentType))
    {
        unicodeParentType = pyvar_ParentType;
        Py_INCREF(unicodeParentType);
    }
    else if (pyvar_ParentType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ParentType at index 0");
    if (unicodeParentType)
        bsParentType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeParentType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeParentType));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_put_parenttype_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->put_ParentType(bsParentType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.put_ParentType() returned %ld", (long)hr);
        goto iagsserverobjectname2_put_parenttype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParentType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname2_put_parenttype_method_cleanup;

    iagsserverobjectname2_put_parenttype_method_cleanup:
    self->m_HR = hr;
    if (bsParentType)
        ::SysFreeString(bsParentType);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.put_ParentType");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_get_ParentType(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsParentType;
    PyObject* pyvar_ParentType = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->get_ParentType(&bsParentType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.get_ParentType() returned %ld", (long)hr);
        goto iagsserverobjectname2_get_parenttype_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ParentType = PyUnicode_FromWideChar(bsParentType,::SysStringLen(bsParentType));
    ::SysFreeString(bsParentType);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_get_parenttype_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ParentType);
    goto iagsserverobjectname2_get_parenttype_method_cleanup;

    iagsserverobjectname2_get_parenttype_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ParentType != Py_None)
        Py_XDECREF(pyvar_ParentType);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.get_ParentType");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_put_Capabilities(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscaps = 0;
    PyObject* pyvar_caps;
    PyObject* unicodecaps = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_caps))
      goto iagsserverobjectname2_put_capabilities_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_caps))
        unicodecaps = PyUnicode_FromObject(pyvar_caps);
    else if (PyUnicode_Check(pyvar_caps))
    {
        unicodecaps = pyvar_caps;
        Py_INCREF(unicodecaps);
    }
    else if (pyvar_caps != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter caps at index 0");
    if (unicodecaps)
        bscaps = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecaps), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecaps));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_put_capabilities_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->put_Capabilities(bscaps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.put_Capabilities() returned %ld", (long)hr);
        goto iagsserverobjectname2_put_capabilities_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for caps

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname2_put_capabilities_method_cleanup;

    iagsserverobjectname2_put_capabilities_method_cleanup:
    self->m_HR = hr;
    if (bscaps)
        ::SysFreeString(bscaps);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.put_Capabilities");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_get_Capabilities(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscaps;
    PyObject* pyvar_caps = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for caps

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->get_Capabilities(&bscaps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.get_Capabilities() returned %ld", (long)hr);
        goto iagsserverobjectname2_get_capabilities_method_cleanup;
    }

    // Set up return values as needed
    pyvar_caps = PyUnicode_FromWideChar(bscaps,::SysStringLen(bscaps));
    ::SysFreeString(bscaps);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_get_capabilities_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_caps);
    goto iagsserverobjectname2_get_capabilities_method_cleanup;

    iagsserverobjectname2_get_capabilities_method_cleanup:
    self->m_HR = hr;
    if (pyvar_caps != Py_None)
        Py_XDECREF(pyvar_caps);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.get_Capabilities");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_put_Name(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectName = 0;
    PyObject* pyvar_objectName;
    PyObject* unicodeobjectName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_objectName))
      goto iagsserverobjectname2_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_objectName))
        unicodeobjectName = PyUnicode_FromObject(pyvar_objectName);
    else if (PyUnicode_Check(pyvar_objectName))
    {
        unicodeobjectName = pyvar_objectName;
        Py_INCREF(unicodeobjectName);
    }
    else if (pyvar_objectName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter objectName at index 0");
    if (unicodeobjectName)
        bsobjectName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeobjectName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeobjectName));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->put_Name(bsobjectName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.put_Name() returned %ld", (long)hr);
        goto iagsserverobjectname2_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objectName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname2_put_name_method_cleanup;

    iagsserverobjectname2_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsobjectName)
        ::SysFreeString(bsobjectName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.put_Name");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_get_Name(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectName;
    PyObject* pyvar_objectName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for objectName

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->get_Name(&bsobjectName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.get_Name() returned %ld", (long)hr);
        goto iagsserverobjectname2_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_objectName = PyUnicode_FromWideChar(bsobjectName,::SysStringLen(bsobjectName));
    ::SysFreeString(bsobjectName);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_objectName);
    goto iagsserverobjectname2_get_name_method_cleanup;

    iagsserverobjectname2_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_objectName != Py_None)
        Py_XDECREF(pyvar_objectName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.get_Name");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_put_Type(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsObjectType = 0;
    PyObject* pyvar_ObjectType;
    PyObject* unicodeObjectType = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ObjectType))
      goto iagsserverobjectname2_put_type_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ObjectType))
        unicodeObjectType = PyUnicode_FromObject(pyvar_ObjectType);
    else if (PyUnicode_Check(pyvar_ObjectType))
    {
        unicodeObjectType = pyvar_ObjectType;
        Py_INCREF(unicodeObjectType);
    }
    else if (pyvar_ObjectType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ObjectType at index 0");
    if (unicodeObjectType)
        bsObjectType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeObjectType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeObjectType));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_put_type_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->put_Type(bsObjectType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.put_Type() returned %ld", (long)hr);
        goto iagsserverobjectname2_put_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ObjectType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname2_put_type_method_cleanup;

    iagsserverobjectname2_put_type_method_cleanup:
    self->m_HR = hr;
    if (bsObjectType)
        ::SysFreeString(bsObjectType);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.put_Type");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_get_Type(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsObjectType;
    PyObject* pyvar_ObjectType = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ObjectType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->get_Type(&bsObjectType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.get_Type() returned %ld", (long)hr);
        goto iagsserverobjectname2_get_type_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ObjectType = PyUnicode_FromWideChar(bsObjectType,::SysStringLen(bsObjectType));
    ::SysFreeString(bsObjectType);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_get_type_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ObjectType);
    goto iagsserverobjectname2_get_type_method_cleanup;

    iagsserverobjectname2_get_type_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ObjectType != Py_None)
        Py_XDECREF(pyvar_ObjectType);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.get_Type");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_put_URL(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectURL = 0;
    PyObject* pyvar_objectURL;
    PyObject* unicodeobjectURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_objectURL))
      goto iagsserverobjectname2_put_url_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_objectURL))
        unicodeobjectURL = PyUnicode_FromObject(pyvar_objectURL);
    else if (PyUnicode_Check(pyvar_objectURL))
    {
        unicodeobjectURL = pyvar_objectURL;
        Py_INCREF(unicodeobjectURL);
    }
    else if (pyvar_objectURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter objectURL at index 0");
    if (unicodeobjectURL)
        bsobjectURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeobjectURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeobjectURL));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_put_url_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->put_URL(bsobjectURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.put_URL() returned %ld", (long)hr);
        goto iagsserverobjectname2_put_url_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objectURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname2_put_url_method_cleanup;

    iagsserverobjectname2_put_url_method_cleanup:
    self->m_HR = hr;
    if (bsobjectURL)
        ::SysFreeString(bsobjectURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.put_URL");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_get_URL(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectURL;
    PyObject* pyvar_objectURL = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for objectURL

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->get_URL(&bsobjectURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.get_URL() returned %ld", (long)hr);
        goto iagsserverobjectname2_get_url_method_cleanup;
    }

    // Set up return values as needed
    pyvar_objectURL = PyUnicode_FromWideChar(bsobjectURL,::SysStringLen(bsobjectURL));
    ::SysFreeString(bsobjectURL);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_get_url_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_objectURL);
    goto iagsserverobjectname2_get_url_method_cleanup;

    iagsserverobjectname2_get_url_method_cleanup:
    self->m_HR = hr;
    if (pyvar_objectURL != Py_None)
        Py_XDECREF(pyvar_objectURL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.get_URL");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_get_AGSServerConnectionName(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnectionName* ipppServerConnName = NULL;
    PyObject* py_ppServerConnName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppServerConnName

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->get_AGSServerConnectionName(&ipppServerConnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.get_AGSServerConnectionName() returned %ld", (long)hr);
        goto iagsserverobjectname2_get_agsserverconnectionname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppServerConnName);
    if (ipppServerConnName)
    {
        IUnknown* pUnk = NULL;
        ipppServerConnName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppServerConnName = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnectionName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppServerConnName)
    {
        if (py_ppServerConnName)
           Py_DECREF(py_ppServerConnName);
        py_ppServerConnName = Py_None;
        Py_INCREF(py_ppServerConnName);
    }
    if (PyErr_Occurred())
      goto iagsserverobjectname2_get_agsserverconnectionname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppServerConnName);
    goto iagsserverobjectname2_get_agsserverconnectionname_method_cleanup;

    iagsserverobjectname2_get_agsserverconnectionname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppServerConnName);
    if (ipppServerConnName)
      ipppServerConnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.get_AGSServerConnectionName");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName2Method_putref_AGSServerConnectionName(PyIAGSServerObjectName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnectionName* ipppServerConnName = NULL;
    PyObject* py_ppServerConnName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppServerConnName))
      goto iagsserverobjectname2_putref_agsserverconnectionname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppServerConnName, &IID_IAGSServerConnectionName, (void**)&ipppServerConnName))
        PyErr_SetString(PyExc_TypeError, "Argument ppServerConnName (position 0) is not IAGSServerConnectionName");
    
    if (PyErr_Occurred())
      goto iagsserverobjectname2_putref_agsserverconnectionname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName2->putref_AGSServerConnectionName(ipppServerConnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName2.putref_AGSServerConnectionName() returned %ld", (long)hr);
        goto iagsserverobjectname2_putref_agsserverconnectionname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppServerConnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname2_putref_agsserverconnectionname_method_cleanup;

    iagsserverobjectname2_putref_agsserverconnectionname_method_cleanup:
    self->m_HR = hr;
    if (ipppServerConnName)
      ipppServerConnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName2.putref_AGSServerConnectionName");
    return return_tuple;
}


PyMethodDef PyIAGSServerObjectName2Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerObjectName2_SupportsInterface, METH_O, ""},
    {"put_NameString2", (PyCFunction)IAGSServerObjectName2Method_put_NameString2, METH_VARARGS, ""},
    {"get_NameString2", (PyCFunction)IAGSServerObjectName2Method_get_NameString2, METH_VARARGS, ""},
    {"put_ParentType", (PyCFunction)IAGSServerObjectName2Method_put_ParentType, METH_VARARGS, ""},
    {"get_ParentType", (PyCFunction)IAGSServerObjectName2Method_get_ParentType, METH_VARARGS, ""},
    {"put_Capabilities", (PyCFunction)IAGSServerObjectName2Method_put_Capabilities, METH_VARARGS, ""},
    {"get_Capabilities", (PyCFunction)IAGSServerObjectName2Method_get_Capabilities, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IAGSServerObjectName2Method_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IAGSServerObjectName2Method_get_Name, METH_VARARGS, ""},
    {"put_Type", (PyCFunction)IAGSServerObjectName2Method_put_Type, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IAGSServerObjectName2Method_get_Type, METH_VARARGS, ""},
    {"put_URL", (PyCFunction)IAGSServerObjectName2Method_put_URL, METH_VARARGS, ""},
    {"get_URL", (PyCFunction)IAGSServerObjectName2Method_get_URL, METH_VARARGS, ""},
    {"get_AGSServerConnectionName", (PyCFunction)IAGSServerObjectName2Method_get_AGSServerConnectionName, METH_VARARGS, ""},
    {"putref_AGSServerConnectionName", (PyCFunction)IAGSServerObjectName2Method_putref_AGSServerConnectionName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerObjectName2GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerObjectName2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerObjectName2", NULL},
  {"_pointer", (getter)PyIAGSServerObjectName2_GetPointer, NULL, "Get memory address for IAGSServerObjectName2", NULL},
  {"_IID", (getter)PyIAGSServerObjectName2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerObjectName2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerObjectName2_GetIgnoreFailures, (setter)PyIAGSServerObjectName2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerObjectName2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerObjectName2Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerObjectName2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerObjectName2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerObjectName2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerObjectName2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerObjectName2Object_new,                      
                                              /* tp_new */
};

// Interface IAGSServerObjectName3

typedef struct PyIAGSServerObjectName3Object {
    PyObject_HEAD
    IAGSServerObjectName3* m_pIAGSServerObjectName3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAGSServerObjectName3Object;

static PyObject*
PyIAGSServerObjectName3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAGSServerObjectName3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAGSServerObjectName3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAGSServerObjectName3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAGSServerObjectName3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAGSServerObjectName3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerObjectName3");
            return NULL;
        }
        self->m_pIAGSServerObjectName3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAGSServerObjectName3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAGSServerObjectName3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAGSServerObjectName3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAGSServerObjectName3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAGSServerObjectName3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAGSServerObjectName3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAGSServerObjectName3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAGSServerObjectName3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAGSServerObjectName3Object_dealloc(PyIAGSServerObjectName3Object* self)
{
    if (self->m_pIAGSServerObjectName3)
        self->m_pIAGSServerObjectName3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAGSServerObjectName3_GetpUnk(PyIAGSServerObjectName3Object* self)
{
    if (!self->m_pIAGSServerObjectName3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAGSServerObjectName3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAGSServerObjectName3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAGSServerObjectName3_GetPointer(PyIAGSServerObjectName3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAGSServerObjectName3);
}

static PyObject*
PyIAGSServerObjectName3_GetIID(PyIAGSServerObjectName3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4b815919-7659-4a55-8608-26eb7d6b24f2");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAGSServerObjectName3_GetHR(PyIAGSServerObjectName3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAGSServerObjectName3_GetIgnoreFailures(PyIAGSServerObjectName3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAGSServerObjectName3_SetIgnoreFailures(PyIAGSServerObjectName3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAGSServerObjectName3_SupportsInterface(PyIAGSServerObjectName3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAGSServerObjectName3Method_put_Description(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectURL = 0;
    PyObject* pyvar_objectURL;
    PyObject* unicodeobjectURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_objectURL))
      goto iagsserverobjectname3_put_description_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_objectURL))
        unicodeobjectURL = PyUnicode_FromObject(pyvar_objectURL);
    else if (PyUnicode_Check(pyvar_objectURL))
    {
        unicodeobjectURL = pyvar_objectURL;
        Py_INCREF(unicodeobjectURL);
    }
    else if (pyvar_objectURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter objectURL at index 0");
    if (unicodeobjectURL)
        bsobjectURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeobjectURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeobjectURL));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_put_description_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->put_Description(bsobjectURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.put_Description() returned %ld", (long)hr);
        goto iagsserverobjectname3_put_description_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objectURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname3_put_description_method_cleanup;

    iagsserverobjectname3_put_description_method_cleanup:
    self->m_HR = hr;
    if (bsobjectURL)
        ::SysFreeString(bsobjectURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.put_Description");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_get_Description(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectURL;
    PyObject* pyvar_objectURL = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for objectURL

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->get_Description(&bsobjectURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.get_Description() returned %ld", (long)hr);
        goto iagsserverobjectname3_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_objectURL = PyUnicode_FromWideChar(bsobjectURL,::SysStringLen(bsobjectURL));
    ::SysFreeString(bsobjectURL);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_objectURL);
    goto iagsserverobjectname3_get_description_method_cleanup;

    iagsserverobjectname3_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_objectURL != Py_None)
        Py_XDECREF(pyvar_objectURL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.get_Description");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_put_NameString2(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsns = 0;
    PyObject* pyvar_ns;
    PyObject* unicodens = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ns))
      goto iagsserverobjectname3_put_namestring2_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ns))
        unicodens = PyUnicode_FromObject(pyvar_ns);
    else if (PyUnicode_Check(pyvar_ns))
    {
        unicodens = pyvar_ns;
        Py_INCREF(unicodens);
    }
    else if (pyvar_ns != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ns at index 0");
    if (unicodens)
        bsns = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodens), 
                                            (UINT)PyUnicode_GET_SIZE(unicodens));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_put_namestring2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->put_NameString2(bsns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.put_NameString2() returned %ld", (long)hr);
        goto iagsserverobjectname3_put_namestring2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ns

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname3_put_namestring2_method_cleanup;

    iagsserverobjectname3_put_namestring2_method_cleanup:
    self->m_HR = hr;
    if (bsns)
        ::SysFreeString(bsns);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.put_NameString2");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_get_NameString2(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsns;
    PyObject* pyvar_ns = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ns

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->get_NameString2(&bsns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.get_NameString2() returned %ld", (long)hr);
        goto iagsserverobjectname3_get_namestring2_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ns = PyUnicode_FromWideChar(bsns,::SysStringLen(bsns));
    ::SysFreeString(bsns);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_get_namestring2_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ns);
    goto iagsserverobjectname3_get_namestring2_method_cleanup;

    iagsserverobjectname3_get_namestring2_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ns != Py_None)
        Py_XDECREF(pyvar_ns);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.get_NameString2");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_put_ParentType(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsParentType = 0;
    PyObject* pyvar_ParentType;
    PyObject* unicodeParentType = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ParentType))
      goto iagsserverobjectname3_put_parenttype_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ParentType))
        unicodeParentType = PyUnicode_FromObject(pyvar_ParentType);
    else if (PyUnicode_Check(pyvar_ParentType))
    {
        unicodeParentType = pyvar_ParentType;
        Py_INCREF(unicodeParentType);
    }
    else if (pyvar_ParentType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ParentType at index 0");
    if (unicodeParentType)
        bsParentType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeParentType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeParentType));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_put_parenttype_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->put_ParentType(bsParentType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.put_ParentType() returned %ld", (long)hr);
        goto iagsserverobjectname3_put_parenttype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParentType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname3_put_parenttype_method_cleanup;

    iagsserverobjectname3_put_parenttype_method_cleanup:
    self->m_HR = hr;
    if (bsParentType)
        ::SysFreeString(bsParentType);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.put_ParentType");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_get_ParentType(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsParentType;
    PyObject* pyvar_ParentType = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->get_ParentType(&bsParentType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.get_ParentType() returned %ld", (long)hr);
        goto iagsserverobjectname3_get_parenttype_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ParentType = PyUnicode_FromWideChar(bsParentType,::SysStringLen(bsParentType));
    ::SysFreeString(bsParentType);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_get_parenttype_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ParentType);
    goto iagsserverobjectname3_get_parenttype_method_cleanup;

    iagsserverobjectname3_get_parenttype_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ParentType != Py_None)
        Py_XDECREF(pyvar_ParentType);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.get_ParentType");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_put_Capabilities(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscaps = 0;
    PyObject* pyvar_caps;
    PyObject* unicodecaps = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_caps))
      goto iagsserverobjectname3_put_capabilities_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_caps))
        unicodecaps = PyUnicode_FromObject(pyvar_caps);
    else if (PyUnicode_Check(pyvar_caps))
    {
        unicodecaps = pyvar_caps;
        Py_INCREF(unicodecaps);
    }
    else if (pyvar_caps != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter caps at index 0");
    if (unicodecaps)
        bscaps = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecaps), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecaps));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_put_capabilities_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->put_Capabilities(bscaps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.put_Capabilities() returned %ld", (long)hr);
        goto iagsserverobjectname3_put_capabilities_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for caps

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname3_put_capabilities_method_cleanup;

    iagsserverobjectname3_put_capabilities_method_cleanup:
    self->m_HR = hr;
    if (bscaps)
        ::SysFreeString(bscaps);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.put_Capabilities");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_get_Capabilities(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscaps;
    PyObject* pyvar_caps = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for caps

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->get_Capabilities(&bscaps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.get_Capabilities() returned %ld", (long)hr);
        goto iagsserverobjectname3_get_capabilities_method_cleanup;
    }

    // Set up return values as needed
    pyvar_caps = PyUnicode_FromWideChar(bscaps,::SysStringLen(bscaps));
    ::SysFreeString(bscaps);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_get_capabilities_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_caps);
    goto iagsserverobjectname3_get_capabilities_method_cleanup;

    iagsserverobjectname3_get_capabilities_method_cleanup:
    self->m_HR = hr;
    if (pyvar_caps != Py_None)
        Py_XDECREF(pyvar_caps);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.get_Capabilities");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_put_Name(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectName = 0;
    PyObject* pyvar_objectName;
    PyObject* unicodeobjectName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_objectName))
      goto iagsserverobjectname3_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_objectName))
        unicodeobjectName = PyUnicode_FromObject(pyvar_objectName);
    else if (PyUnicode_Check(pyvar_objectName))
    {
        unicodeobjectName = pyvar_objectName;
        Py_INCREF(unicodeobjectName);
    }
    else if (pyvar_objectName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter objectName at index 0");
    if (unicodeobjectName)
        bsobjectName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeobjectName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeobjectName));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->put_Name(bsobjectName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.put_Name() returned %ld", (long)hr);
        goto iagsserverobjectname3_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objectName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname3_put_name_method_cleanup;

    iagsserverobjectname3_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsobjectName)
        ::SysFreeString(bsobjectName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.put_Name");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_get_Name(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectName;
    PyObject* pyvar_objectName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for objectName

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->get_Name(&bsobjectName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.get_Name() returned %ld", (long)hr);
        goto iagsserverobjectname3_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_objectName = PyUnicode_FromWideChar(bsobjectName,::SysStringLen(bsobjectName));
    ::SysFreeString(bsobjectName);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_objectName);
    goto iagsserverobjectname3_get_name_method_cleanup;

    iagsserverobjectname3_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_objectName != Py_None)
        Py_XDECREF(pyvar_objectName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.get_Name");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_put_Type(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsObjectType = 0;
    PyObject* pyvar_ObjectType;
    PyObject* unicodeObjectType = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ObjectType))
      goto iagsserverobjectname3_put_type_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ObjectType))
        unicodeObjectType = PyUnicode_FromObject(pyvar_ObjectType);
    else if (PyUnicode_Check(pyvar_ObjectType))
    {
        unicodeObjectType = pyvar_ObjectType;
        Py_INCREF(unicodeObjectType);
    }
    else if (pyvar_ObjectType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ObjectType at index 0");
    if (unicodeObjectType)
        bsObjectType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeObjectType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeObjectType));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_put_type_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->put_Type(bsObjectType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.put_Type() returned %ld", (long)hr);
        goto iagsserverobjectname3_put_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ObjectType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname3_put_type_method_cleanup;

    iagsserverobjectname3_put_type_method_cleanup:
    self->m_HR = hr;
    if (bsObjectType)
        ::SysFreeString(bsObjectType);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.put_Type");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_get_Type(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsObjectType;
    PyObject* pyvar_ObjectType = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ObjectType

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->get_Type(&bsObjectType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.get_Type() returned %ld", (long)hr);
        goto iagsserverobjectname3_get_type_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ObjectType = PyUnicode_FromWideChar(bsObjectType,::SysStringLen(bsObjectType));
    ::SysFreeString(bsObjectType);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_get_type_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ObjectType);
    goto iagsserverobjectname3_get_type_method_cleanup;

    iagsserverobjectname3_get_type_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ObjectType != Py_None)
        Py_XDECREF(pyvar_ObjectType);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.get_Type");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_put_URL(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectURL = 0;
    PyObject* pyvar_objectURL;
    PyObject* unicodeobjectURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_objectURL))
      goto iagsserverobjectname3_put_url_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_objectURL))
        unicodeobjectURL = PyUnicode_FromObject(pyvar_objectURL);
    else if (PyUnicode_Check(pyvar_objectURL))
    {
        unicodeobjectURL = pyvar_objectURL;
        Py_INCREF(unicodeobjectURL);
    }
    else if (pyvar_objectURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter objectURL at index 0");
    if (unicodeobjectURL)
        bsobjectURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeobjectURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeobjectURL));
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_put_url_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->put_URL(bsobjectURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.put_URL() returned %ld", (long)hr);
        goto iagsserverobjectname3_put_url_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objectURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname3_put_url_method_cleanup;

    iagsserverobjectname3_put_url_method_cleanup:
    self->m_HR = hr;
    if (bsobjectURL)
        ::SysFreeString(bsobjectURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.put_URL");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_get_URL(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsobjectURL;
    PyObject* pyvar_objectURL = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for objectURL

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->get_URL(&bsobjectURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.get_URL() returned %ld", (long)hr);
        goto iagsserverobjectname3_get_url_method_cleanup;
    }

    // Set up return values as needed
    pyvar_objectURL = PyUnicode_FromWideChar(bsobjectURL,::SysStringLen(bsobjectURL));
    ::SysFreeString(bsobjectURL);
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_get_url_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_objectURL);
    goto iagsserverobjectname3_get_url_method_cleanup;

    iagsserverobjectname3_get_url_method_cleanup:
    self->m_HR = hr;
    if (pyvar_objectURL != Py_None)
        Py_XDECREF(pyvar_objectURL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.get_URL");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_get_AGSServerConnectionName(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnectionName* ipppServerConnName = NULL;
    PyObject* py_ppServerConnName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppServerConnName

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->get_AGSServerConnectionName(&ipppServerConnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.get_AGSServerConnectionName() returned %ld", (long)hr);
        goto iagsserverobjectname3_get_agsserverconnectionname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppServerConnName);
    if (ipppServerConnName)
    {
        IUnknown* pUnk = NULL;
        ipppServerConnName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppServerConnName = IUnknownToPythonIIDObject(pUnk, &IID_IAGSServerConnectionName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppServerConnName)
    {
        if (py_ppServerConnName)
           Py_DECREF(py_ppServerConnName);
        py_ppServerConnName = Py_None;
        Py_INCREF(py_ppServerConnName);
    }
    if (PyErr_Occurred())
      goto iagsserverobjectname3_get_agsserverconnectionname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppServerConnName);
    goto iagsserverobjectname3_get_agsserverconnectionname_method_cleanup;

    iagsserverobjectname3_get_agsserverconnectionname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppServerConnName);
    if (ipppServerConnName)
      ipppServerConnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.get_AGSServerConnectionName");
    return return_tuple;
}

static PyObject*
IAGSServerObjectName3Method_putref_AGSServerConnectionName(PyIAGSServerObjectName3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnectionName* ipppServerConnName = NULL;
    PyObject* py_ppServerConnName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppServerConnName))
      goto iagsserverobjectname3_putref_agsserverconnectionname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppServerConnName, &IID_IAGSServerConnectionName, (void**)&ipppServerConnName))
        PyErr_SetString(PyExc_TypeError, "Argument ppServerConnName (position 0) is not IAGSServerConnectionName");
    
    if (PyErr_Occurred())
      goto iagsserverobjectname3_putref_agsserverconnectionname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAGSServerObjectName3->putref_AGSServerConnectionName(ipppServerConnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAGSServerObjectName3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAGSServerObjectName3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAGSServerObjectName3.putref_AGSServerConnectionName() returned %ld", (long)hr);
        goto iagsserverobjectname3_putref_agsserverconnectionname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppServerConnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iagsserverobjectname3_putref_agsserverconnectionname_method_cleanup;

    iagsserverobjectname3_putref_agsserverconnectionname_method_cleanup:
    self->m_HR = hr;
    if (ipppServerConnName)
      ipppServerConnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAGSServerObjectName3.putref_AGSServerConnectionName");
    return return_tuple;
}


PyMethodDef PyIAGSServerObjectName3Methods[] = {
    {"supports", (PyCFunction)PyIAGSServerObjectName3_SupportsInterface, METH_O, ""},
    {"put_Description", (PyCFunction)IAGSServerObjectName3Method_put_Description, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)IAGSServerObjectName3Method_get_Description, METH_VARARGS, ""},
    {"put_NameString2", (PyCFunction)IAGSServerObjectName3Method_put_NameString2, METH_VARARGS, ""},
    {"get_NameString2", (PyCFunction)IAGSServerObjectName3Method_get_NameString2, METH_VARARGS, ""},
    {"put_ParentType", (PyCFunction)IAGSServerObjectName3Method_put_ParentType, METH_VARARGS, ""},
    {"get_ParentType", (PyCFunction)IAGSServerObjectName3Method_get_ParentType, METH_VARARGS, ""},
    {"put_Capabilities", (PyCFunction)IAGSServerObjectName3Method_put_Capabilities, METH_VARARGS, ""},
    {"get_Capabilities", (PyCFunction)IAGSServerObjectName3Method_get_Capabilities, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IAGSServerObjectName3Method_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IAGSServerObjectName3Method_get_Name, METH_VARARGS, ""},
    {"put_Type", (PyCFunction)IAGSServerObjectName3Method_put_Type, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IAGSServerObjectName3Method_get_Type, METH_VARARGS, ""},
    {"put_URL", (PyCFunction)IAGSServerObjectName3Method_put_URL, METH_VARARGS, ""},
    {"get_URL", (PyCFunction)IAGSServerObjectName3Method_get_URL, METH_VARARGS, ""},
    {"get_AGSServerConnectionName", (PyCFunction)IAGSServerObjectName3Method_get_AGSServerConnectionName, METH_VARARGS, ""},
    {"putref_AGSServerConnectionName", (PyCFunction)IAGSServerObjectName3Method_putref_AGSServerConnectionName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAGSServerObjectName3GetSet[] = {
  {"_pUnk", (getter)PyIAGSServerObjectName3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAGSServerObjectName3", NULL},
  {"_pointer", (getter)PyIAGSServerObjectName3_GetPointer, NULL, "Get memory address for IAGSServerObjectName3", NULL},
  {"_IID", (getter)PyIAGSServerObjectName3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAGSServerObjectName3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAGSServerObjectName3_GetIgnoreFailures, (setter)PyIAGSServerObjectName3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAGSServerObjectName3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAGSServerObjectName3Object",                          
                                              /* tp_name */
  sizeof(PyIAGSServerObjectName3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAGSServerObjectName3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAGSServerObjectName3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAGSServerObjectName3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAGSServerObjectName3Object_new,                      
                                              /* tp_new */
};

// Interface IServerObjectDescription

typedef struct PyIServerObjectDescriptionObject {
    PyObject_HEAD
    IServerObjectDescription* m_pIServerObjectDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIServerObjectDescriptionObject;

static PyObject*
PyIServerObjectDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIServerObjectDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IServerObjectDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IServerObjectDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IServerObjectDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIServerObjectDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IServerObjectDescription");
            return NULL;
        }
        self->m_pIServerObjectDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IServerObjectDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IServerObjectDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IServerObjectDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IServerObjectDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IServerObjectDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIServerObjectDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IServerObjectDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIServerObjectDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIServerObjectDescriptionObject_dealloc(PyIServerObjectDescriptionObject* self)
{
    if (self->m_pIServerObjectDescription)
        self->m_pIServerObjectDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIServerObjectDescription_GetpUnk(PyIServerObjectDescriptionObject* self)
{
    if (!self->m_pIServerObjectDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIServerObjectDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IServerObjectDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIServerObjectDescription_GetPointer(PyIServerObjectDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIServerObjectDescription);
}

static PyObject*
PyIServerObjectDescription_GetIID(PyIServerObjectDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fbb35630-af4a-4423-976a-762d53991e5e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIServerObjectDescription_GetHR(PyIServerObjectDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIServerObjectDescription_GetIgnoreFailures(PyIServerObjectDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIServerObjectDescription_SetIgnoreFailures(PyIServerObjectDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIServerObjectDescription_SupportsInterface(PyIServerObjectDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIServerObjectDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IServerObjectDescriptionMethod_get_Type(PyIServerObjectDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsType;
    PyObject* pyvar_Type = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIServerObjectDescription->get_Type(&bsType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIServerObjectDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IServerObjectDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IServerObjectDescription.get_Type() returned %ld", (long)hr);
        goto iserverobjectdescription_get_type_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Type = PyUnicode_FromWideChar(bsType,::SysStringLen(bsType));
    ::SysFreeString(bsType);
    
    if (PyErr_Occurred())
      goto iserverobjectdescription_get_type_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Type);
    goto iserverobjectdescription_get_type_method_cleanup;

    iserverobjectdescription_get_type_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Type != Py_None)
        Py_XDECREF(pyvar_Type);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IServerObjectDescription.get_Type");
    return return_tuple;
}

static PyObject*
IServerObjectDescriptionMethod_get_ClientProxyCLSID(PyIServerObjectDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriAGSConnectionType econnType;
    IUID* ipppClsid = NULL;
    PyObject* py_ppClsid = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&econnType))
      goto iserverobjectdescription_get_clientproxyclsid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for connType
    // No setup for ppClsid

    // Call method on actual COM interface
    hr = self->m_pIServerObjectDescription->get_ClientProxyCLSID(econnType, &ipppClsid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIServerObjectDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IServerObjectDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IServerObjectDescription.get_ClientProxyCLSID() returned %ld", (long)hr);
        goto iserverobjectdescription_get_clientproxyclsid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for connType
    Py_XDECREF(py_ppClsid);
    if (ipppClsid)
    {
        IUnknown* pUnk = NULL;
        ipppClsid->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppClsid = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppClsid)
    {
        if (py_ppClsid)
           Py_DECREF(py_ppClsid);
        py_ppClsid = Py_None;
        Py_INCREF(py_ppClsid);
    }
    if (PyErr_Occurred())
      goto iserverobjectdescription_get_clientproxyclsid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppClsid);
    goto iserverobjectdescription_get_clientproxyclsid_method_cleanup;

    iserverobjectdescription_get_clientproxyclsid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for connType
    Py_XDECREF(py_ppClsid);
    if (ipppClsid)
      ipppClsid->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IServerObjectDescription.get_ClientProxyCLSID");
    return return_tuple;
}


PyMethodDef PyIServerObjectDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIServerObjectDescription_SupportsInterface, METH_O, ""},
    {"get_Type", (PyCFunction)IServerObjectDescriptionMethod_get_Type, METH_VARARGS, ""},
    {"get_ClientProxyCLSID", (PyCFunction)IServerObjectDescriptionMethod_get_ClientProxyCLSID, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIServerObjectDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIServerObjectDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IServerObjectDescription", NULL},
  {"_pointer", (getter)PyIServerObjectDescription_GetPointer, NULL, "Get memory address for IServerObjectDescription", NULL},
  {"_IID", (getter)PyIServerObjectDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIServerObjectDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIServerObjectDescription_GetIgnoreFailures, (setter)PyIServerObjectDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIServerObjectDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IServerObjectDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIServerObjectDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIServerObjectDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIServerObjectDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIServerObjectDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIServerObjectDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IRESTServerObjectAdmin

typedef struct PyIRESTServerObjectAdminObject {
    PyObject_HEAD
    IRESTServerObjectAdmin* m_pIRESTServerObjectAdmin;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIRESTServerObjectAdminObject;

static PyObject*
PyIRESTServerObjectAdminObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIRESTServerObjectAdminObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IRESTServerObjectAdmin* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IRESTServerObjectAdmin, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IRESTServerObjectAdmin with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIRESTServerObjectAdminObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IRESTServerObjectAdmin");
            return NULL;
        }
        self->m_pIRESTServerObjectAdmin = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IRESTServerObjectAdmin");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IRESTServerObjectAdmin");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IRESTServerObjectAdmin* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IRESTServerObjectAdmin, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IRESTServerObjectAdmin");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIRESTServerObjectAdminObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IRESTServerObjectAdmin");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIRESTServerObjectAdmin = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIRESTServerObjectAdminObject_dealloc(PyIRESTServerObjectAdminObject* self)
{
    if (self->m_pIRESTServerObjectAdmin)
        self->m_pIRESTServerObjectAdmin->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIRESTServerObjectAdmin_GetpUnk(PyIRESTServerObjectAdminObject* self)
{
    if (!self->m_pIRESTServerObjectAdmin)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIRESTServerObjectAdmin->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IRESTServerObjectAdmin to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIRESTServerObjectAdmin_GetPointer(PyIRESTServerObjectAdminObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIRESTServerObjectAdmin);
}

static PyObject*
PyIRESTServerObjectAdmin_GetIID(PyIRESTServerObjectAdminObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f21f82a2-6317-4a00-9877-8431c74a6707");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIRESTServerObjectAdmin_GetHR(PyIRESTServerObjectAdminObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIRESTServerObjectAdmin_GetIgnoreFailures(PyIRESTServerObjectAdminObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIRESTServerObjectAdmin_SetIgnoreFailures(PyIRESTServerObjectAdminObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIRESTServerObjectAdmin_SupportsInterface(PyIRESTServerObjectAdminObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIRESTServerObjectAdmin->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IRESTServerObjectAdminMethod_GetConfigurationInfos(PyIRESTServerObjectAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFolderName = 0;
    PyObject* pyvar_FolderName;
    PyObject* unicodeFolderName = NULL;
    IEnumServerObjectConfigurationInfo* ipppConfigInfos = NULL;
    PyObject* py_ppConfigInfos = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FolderName))
      goto irestserverobjectadmin_getconfigurationinfos_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FolderName))
        unicodeFolderName = PyUnicode_FromObject(pyvar_FolderName);
    else if (PyUnicode_Check(pyvar_FolderName))
    {
        unicodeFolderName = pyvar_FolderName;
        Py_INCREF(unicodeFolderName);
    }
    else if (pyvar_FolderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FolderName at index 0");
    if (unicodeFolderName)
        bsFolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFolderName));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getconfigurationinfos_method_cleanup;
    
    // No setup for ppConfigInfos

    // Call method on actual COM interface
    hr = self->m_pIRESTServerObjectAdmin->GetConfigurationInfos(bsFolderName, &ipppConfigInfos);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRESTServerObjectAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRESTServerObjectAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRESTServerObjectAdmin.GetConfigurationInfos() returned %ld", (long)hr);
        goto irestserverobjectadmin_getconfigurationinfos_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FolderName
    Py_XDECREF(py_ppConfigInfos);
    if (ipppConfigInfos)
    {
        IUnknown* pUnk = NULL;
        ipppConfigInfos->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConfigInfos = IUnknownToPythonIIDObject(pUnk, &IID_IEnumServerObjectConfigurationInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConfigInfos)
    {
        if (py_ppConfigInfos)
           Py_DECREF(py_ppConfigInfos);
        py_ppConfigInfos = Py_None;
        Py_INCREF(py_ppConfigInfos);
    }
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getconfigurationinfos_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConfigInfos);
    goto irestserverobjectadmin_getconfigurationinfos_method_cleanup;

    irestserverobjectadmin_getconfigurationinfos_method_cleanup:
    self->m_HR = hr;
    if (bsFolderName)
        ::SysFreeString(bsFolderName);
    
    Py_XDECREF(py_ppConfigInfos);
    if (ipppConfigInfos)
      ipppConfigInfos->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRESTServerObjectAdmin.GetConfigurationInfos");
    return return_tuple;
}

static PyObject*
IRESTServerObjectAdminMethod_get_AdminVersion(PyIRESTServerObjectAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpAdminVersion = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pAdminVersion

    // Call method on actual COM interface
    hr = self->m_pIRESTServerObjectAdmin->get_AdminVersion(&dpAdminVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRESTServerObjectAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRESTServerObjectAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRESTServerObjectAdmin.get_AdminVersion() returned %ld", (long)hr);
        goto irestserverobjectadmin_get_adminversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAdminVersion

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpAdminVersion);
    goto irestserverobjectadmin_get_adminversion_method_cleanup;

    irestserverobjectadmin_get_adminversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAdminVersion
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRESTServerObjectAdmin.get_AdminVersion");
    return return_tuple;
}

static PyObject*
IRESTServerObjectAdminMethod_GetItemInfo(PyIRESTServerObjectAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bsType = 0;
    PyObject* pyvar_Type;
    PyObject* unicodeType = NULL;
    BSTR bssoeType = 0;
    PyObject* pyvar_soeType;
    PyObject* unicodesoeType = NULL;
    IItemInfo* ipppItemInfo = NULL;
    PyObject* py_ppItemInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_Name, &pyvar_Type, &pyvar_soeType))
      goto irestserverobjectadmin_getiteminfo_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getiteminfo_method_cleanup;
    
    if (PyString_Check(pyvar_Type))
        unicodeType = PyUnicode_FromObject(pyvar_Type);
    else if (PyUnicode_Check(pyvar_Type))
    {
        unicodeType = pyvar_Type;
        Py_INCREF(unicodeType);
    }
    else if (pyvar_Type != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Type at index 1");
    if (unicodeType)
        bsType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeType));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getiteminfo_method_cleanup;
    
    if (PyString_Check(pyvar_soeType))
        unicodesoeType = PyUnicode_FromObject(pyvar_soeType);
    else if (PyUnicode_Check(pyvar_soeType))
    {
        unicodesoeType = pyvar_soeType;
        Py_INCREF(unicodesoeType);
    }
    else if (pyvar_soeType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter soeType at index 2");
    if (unicodesoeType)
        bssoeType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesoeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesoeType));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getiteminfo_method_cleanup;
    
    // No setup for ppItemInfo

    // Call method on actual COM interface
    hr = self->m_pIRESTServerObjectAdmin->GetItemInfo(bsName, bsType, bssoeType, &ipppItemInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRESTServerObjectAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRESTServerObjectAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRESTServerObjectAdmin.GetItemInfo() returned %ld", (long)hr);
        goto irestserverobjectadmin_getiteminfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for Type
    // No teardown for soeType
    Py_XDECREF(py_ppItemInfo);
    if (ipppItemInfo)
    {
        IUnknown* pUnk = NULL;
        ipppItemInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppItemInfo = IUnknownToPythonIIDObject(pUnk, &IID_IItemInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppItemInfo)
    {
        if (py_ppItemInfo)
           Py_DECREF(py_ppItemInfo);
        py_ppItemInfo = Py_None;
        Py_INCREF(py_ppItemInfo);
    }
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getiteminfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppItemInfo);
    goto irestserverobjectadmin_getiteminfo_method_cleanup;

    irestserverobjectadmin_getiteminfo_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bsType)
        ::SysFreeString(bsType);
    
    if (bssoeType)
        ::SysFreeString(bssoeType);
    
    Py_XDECREF(py_ppItemInfo);
    if (ipppItemInfo)
      ipppItemInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRESTServerObjectAdmin.GetItemInfo");
    return return_tuple;
}

static PyObject*
IRESTServerObjectAdminMethod_PutItemInfo(PyIRESTServerObjectAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bsType = 0;
    PyObject* pyvar_Type;
    PyObject* unicodeType = NULL;
    BSTR bssoeType = 0;
    PyObject* pyvar_soeType;
    PyObject* unicodesoeType = NULL;
    IItemInfo* ippItemInfo = NULL;
    PyObject* py_pItemInfo;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_Name, &pyvar_Type, &pyvar_soeType, &py_pItemInfo))
      goto irestserverobjectadmin_putiteminfo_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_putiteminfo_method_cleanup;
    
    if (PyString_Check(pyvar_Type))
        unicodeType = PyUnicode_FromObject(pyvar_Type);
    else if (PyUnicode_Check(pyvar_Type))
    {
        unicodeType = pyvar_Type;
        Py_INCREF(unicodeType);
    }
    else if (pyvar_Type != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Type at index 1");
    if (unicodeType)
        bsType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeType));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_putiteminfo_method_cleanup;
    
    if (PyString_Check(pyvar_soeType))
        unicodesoeType = PyUnicode_FromObject(pyvar_soeType);
    else if (PyUnicode_Check(pyvar_soeType))
    {
        unicodesoeType = pyvar_soeType;
        Py_INCREF(unicodesoeType);
    }
    else if (pyvar_soeType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter soeType at index 2");
    if (unicodesoeType)
        bssoeType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesoeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesoeType));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_putiteminfo_method_cleanup;
    
    if (!IFaceFromPyObject(py_pItemInfo, &IID_IItemInfo, (void**)&ippItemInfo))
        PyErr_SetString(PyExc_TypeError, "Argument pItemInfo (position 3) is not IItemInfo");
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_putiteminfo_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRESTServerObjectAdmin->PutItemInfo(bsName, bsType, bssoeType, ippItemInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRESTServerObjectAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRESTServerObjectAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRESTServerObjectAdmin.PutItemInfo() returned %ld", (long)hr);
        goto irestserverobjectadmin_putiteminfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for Type
    // No teardown for soeType
    // No teardown for pItemInfo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto irestserverobjectadmin_putiteminfo_method_cleanup;

    irestserverobjectadmin_putiteminfo_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bsType)
        ::SysFreeString(bsType);
    
    if (bssoeType)
        ::SysFreeString(bssoeType);
    
    if (ippItemInfo)
      ippItemInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRESTServerObjectAdmin.PutItemInfo");
    return return_tuple;
}

static PyObject*
IRESTServerObjectAdminMethod_GetMetadata(PyIRESTServerObjectAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bsType = 0;
    PyObject* pyvar_Type;
    PyObject* unicodeType = NULL;
    BSTR bssoeType = 0;
    PyObject* pyvar_soeType;
    PyObject* unicodesoeType = NULL;
    IPropertySet* ipppMetadata = NULL;
    PyObject* py_ppMetadata = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_Name, &pyvar_Type, &pyvar_soeType))
      goto irestserverobjectadmin_getmetadata_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getmetadata_method_cleanup;
    
    if (PyString_Check(pyvar_Type))
        unicodeType = PyUnicode_FromObject(pyvar_Type);
    else if (PyUnicode_Check(pyvar_Type))
    {
        unicodeType = pyvar_Type;
        Py_INCREF(unicodeType);
    }
    else if (pyvar_Type != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Type at index 1");
    if (unicodeType)
        bsType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeType));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getmetadata_method_cleanup;
    
    if (PyString_Check(pyvar_soeType))
        unicodesoeType = PyUnicode_FromObject(pyvar_soeType);
    else if (PyUnicode_Check(pyvar_soeType))
    {
        unicodesoeType = pyvar_soeType;
        Py_INCREF(unicodesoeType);
    }
    else if (pyvar_soeType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter soeType at index 2");
    if (unicodesoeType)
        bssoeType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesoeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesoeType));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getmetadata_method_cleanup;
    
    // No setup for ppMetadata

    // Call method on actual COM interface
    hr = self->m_pIRESTServerObjectAdmin->GetMetadata(bsName, bsType, bssoeType, &ipppMetadata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRESTServerObjectAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRESTServerObjectAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRESTServerObjectAdmin.GetMetadata() returned %ld", (long)hr);
        goto irestserverobjectadmin_getmetadata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for Type
    // No teardown for soeType
    Py_XDECREF(py_ppMetadata);
    if (ipppMetadata)
    {
        IUnknown* pUnk = NULL;
        ipppMetadata->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppMetadata = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppMetadata)
    {
        if (py_ppMetadata)
           Py_DECREF(py_ppMetadata);
        py_ppMetadata = Py_None;
        Py_INCREF(py_ppMetadata);
    }
    if (PyErr_Occurred())
      goto irestserverobjectadmin_getmetadata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppMetadata);
    goto irestserverobjectadmin_getmetadata_method_cleanup;

    irestserverobjectadmin_getmetadata_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bsType)
        ::SysFreeString(bsType);
    
    if (bssoeType)
        ::SysFreeString(bssoeType);
    
    Py_XDECREF(py_ppMetadata);
    if (ipppMetadata)
      ipppMetadata->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRESTServerObjectAdmin.GetMetadata");
    return return_tuple;
}

static PyObject*
IRESTServerObjectAdminMethod_PutMetadata(PyIRESTServerObjectAdminObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bsType = 0;
    PyObject* pyvar_Type;
    PyObject* unicodeType = NULL;
    BSTR bssoeType = 0;
    PyObject* pyvar_soeType;
    PyObject* unicodesoeType = NULL;
    IPropertySet* ippMetadata = NULL;
    PyObject* py_pMetadata;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_Name, &pyvar_Type, &pyvar_soeType, &py_pMetadata))
      goto irestserverobjectadmin_putmetadata_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_putmetadata_method_cleanup;
    
    if (PyString_Check(pyvar_Type))
        unicodeType = PyUnicode_FromObject(pyvar_Type);
    else if (PyUnicode_Check(pyvar_Type))
    {
        unicodeType = pyvar_Type;
        Py_INCREF(unicodeType);
    }
    else if (pyvar_Type != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Type at index 1");
    if (unicodeType)
        bsType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeType));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_putmetadata_method_cleanup;
    
    if (PyString_Check(pyvar_soeType))
        unicodesoeType = PyUnicode_FromObject(pyvar_soeType);
    else if (PyUnicode_Check(pyvar_soeType))
    {
        unicodesoeType = pyvar_soeType;
        Py_INCREF(unicodesoeType);
    }
    else if (pyvar_soeType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter soeType at index 2");
    if (unicodesoeType)
        bssoeType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesoeType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesoeType));
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_putmetadata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pMetadata, &IID_IPropertySet, (void**)&ippMetadata))
        PyErr_SetString(PyExc_TypeError, "Argument pMetadata (position 3) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto irestserverobjectadmin_putmetadata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRESTServerObjectAdmin->PutMetadata(bsName, bsType, bssoeType, ippMetadata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRESTServerObjectAdmin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRESTServerObjectAdmin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRESTServerObjectAdmin.PutMetadata() returned %ld", (long)hr);
        goto irestserverobjectadmin_putmetadata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for Type
    // No teardown for soeType
    // No teardown for pMetadata

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto irestserverobjectadmin_putmetadata_method_cleanup;

    irestserverobjectadmin_putmetadata_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bsType)
        ::SysFreeString(bsType);
    
    if (bssoeType)
        ::SysFreeString(bssoeType);
    
    if (ippMetadata)
      ippMetadata->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRESTServerObjectAdmin.PutMetadata");
    return return_tuple;
}


PyMethodDef PyIRESTServerObjectAdminMethods[] = {
    {"supports", (PyCFunction)PyIRESTServerObjectAdmin_SupportsInterface, METH_O, ""},
    {"GetConfigurationInfos", (PyCFunction)IRESTServerObjectAdminMethod_GetConfigurationInfos, METH_VARARGS, ""},
    {"get_AdminVersion", (PyCFunction)IRESTServerObjectAdminMethod_get_AdminVersion, METH_VARARGS, ""},
    {"GetItemInfo", (PyCFunction)IRESTServerObjectAdminMethod_GetItemInfo, METH_VARARGS, ""},
    {"PutItemInfo", (PyCFunction)IRESTServerObjectAdminMethod_PutItemInfo, METH_VARARGS, ""},
    {"GetMetadata", (PyCFunction)IRESTServerObjectAdminMethod_GetMetadata, METH_VARARGS, ""},
    {"PutMetadata", (PyCFunction)IRESTServerObjectAdminMethod_PutMetadata, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIRESTServerObjectAdminGetSet[] = {
  {"_pUnk", (getter)PyIRESTServerObjectAdmin_GetpUnk, NULL, "Get opaque pointer to an Unknown from IRESTServerObjectAdmin", NULL},
  {"_pointer", (getter)PyIRESTServerObjectAdmin_GetPointer, NULL, "Get memory address for IRESTServerObjectAdmin", NULL},
  {"_IID", (getter)PyIRESTServerObjectAdmin_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIRESTServerObjectAdmin_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIRESTServerObjectAdmin_GetIgnoreFailures, (setter)PyIRESTServerObjectAdmin_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIRESTServerObjectAdminObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IRESTServerObjectAdminObject",                          
                                              /* tp_name */
  sizeof(PyIRESTServerObjectAdminObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIRESTServerObjectAdminObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIRESTServerObjectAdminMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIRESTServerObjectAdminGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIRESTServerObjectAdminObject_new,                      
                                              /* tp_new */
};

// Interface IIMSWorkspace2

typedef struct PyIIMSWorkspace2Object {
    PyObject_HEAD
    IIMSWorkspace2* m_pIIMSWorkspace2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIIMSWorkspace2Object;

static PyObject*
PyIIMSWorkspace2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIIMSWorkspace2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IIMSWorkspace2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IIMSWorkspace2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IIMSWorkspace2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIIMSWorkspace2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSWorkspace2");
            return NULL;
        }
        self->m_pIIMSWorkspace2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IIMSWorkspace2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IIMSWorkspace2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IIMSWorkspace2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IIMSWorkspace2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IIMSWorkspace2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIIMSWorkspace2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSWorkspace2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIIMSWorkspace2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIIMSWorkspace2Object_dealloc(PyIIMSWorkspace2Object* self)
{
    if (self->m_pIIMSWorkspace2)
        self->m_pIIMSWorkspace2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIIMSWorkspace2_GetpUnk(PyIIMSWorkspace2Object* self)
{
    if (!self->m_pIIMSWorkspace2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIIMSWorkspace2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IIMSWorkspace2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIIMSWorkspace2_GetPointer(PyIIMSWorkspace2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIIMSWorkspace2);
}

static PyObject*
PyIIMSWorkspace2_GetIID(PyIIMSWorkspace2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e4a0f674-b705-405a-b356-3cc81f283622");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIIMSWorkspace2_GetHR(PyIIMSWorkspace2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIIMSWorkspace2_GetIgnoreFailures(PyIIMSWorkspace2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIIMSWorkspace2_SetIgnoreFailures(PyIIMSWorkspace2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIIMSWorkspace2_SupportsInterface(PyIIMSWorkspace2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIIMSWorkspace2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IIMSWorkspace2Method_get_QueryCapabilities(PyIIMSWorkspace2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppCapabilities = NULL;
    PyObject* py_ppCapabilities = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppCapabilities

    // Call method on actual COM interface
    hr = self->m_pIIMSWorkspace2->get_QueryCapabilities(&ipppCapabilities);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSWorkspace2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSWorkspace2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSWorkspace2.get_QueryCapabilities() returned %ld", (long)hr);
        goto iimsworkspace2_get_querycapabilities_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppCapabilities);
    if (ipppCapabilities)
    {
        IUnknown* pUnk = NULL;
        ipppCapabilities->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCapabilities = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCapabilities)
    {
        if (py_ppCapabilities)
           Py_DECREF(py_ppCapabilities);
        py_ppCapabilities = Py_None;
        Py_INCREF(py_ppCapabilities);
    }
    if (PyErr_Occurred())
      goto iimsworkspace2_get_querycapabilities_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCapabilities);
    goto iimsworkspace2_get_querycapabilities_method_cleanup;

    iimsworkspace2_get_querycapabilities_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppCapabilities);
    if (ipppCapabilities)
      ipppCapabilities->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSWorkspace2.get_QueryCapabilities");
    return return_tuple;
}

static PyObject*
IIMSWorkspace2Method_get_SpatialReference(PyIIMSWorkspace2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipSpatialReference = NULL;
    PyObject* py_SpatialReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SpatialReference

    // Call method on actual COM interface
    hr = self->m_pIIMSWorkspace2->get_SpatialReference(&ipSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSWorkspace2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSWorkspace2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSWorkspace2.get_SpatialReference() returned %ld", (long)hr);
        goto iimsworkspace2_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_SpatialReference);
    if (ipSpatialReference)
    {
        IUnknown* pUnk = NULL;
        ipSpatialReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_SpatialReference = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_SpatialReference)
    {
        if (py_SpatialReference)
           Py_DECREF(py_SpatialReference);
        py_SpatialReference = Py_None;
        Py_INCREF(py_SpatialReference);
    }
    if (PyErr_Occurred())
      goto iimsworkspace2_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_SpatialReference);
    goto iimsworkspace2_get_spatialreference_method_cleanup;

    iimsworkspace2_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_SpatialReference);
    if (ipSpatialReference)
      ipSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSWorkspace2.get_SpatialReference");
    return return_tuple;
}

static PyObject*
IIMSWorkspace2Method_get_AreaOfInterest(PyIIMSWorkspace2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipenvelope = NULL;
    PyObject* py_envelope = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for envelope

    // Call method on actual COM interface
    hr = self->m_pIIMSWorkspace2->get_AreaOfInterest(&ipenvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSWorkspace2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSWorkspace2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSWorkspace2.get_AreaOfInterest() returned %ld", (long)hr);
        goto iimsworkspace2_get_areaofinterest_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_envelope);
    if (ipenvelope)
    {
        IUnknown* pUnk = NULL;
        ipenvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_envelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_envelope)
    {
        if (py_envelope)
           Py_DECREF(py_envelope);
        py_envelope = Py_None;
        Py_INCREF(py_envelope);
    }
    if (PyErr_Occurred())
      goto iimsworkspace2_get_areaofinterest_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_envelope);
    goto iimsworkspace2_get_areaofinterest_method_cleanup;

    iimsworkspace2_get_areaofinterest_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_envelope);
    if (ipenvelope)
      ipenvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSWorkspace2.get_AreaOfInterest");
    return return_tuple;
}

static PyObject*
IIMSWorkspace2Method_get_MapUnits(PyIIMSWorkspace2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acMapUnits eMapUnits;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MapUnits

    // Call method on actual COM interface
    hr = self->m_pIIMSWorkspace2->get_MapUnits(&eMapUnits);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSWorkspace2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSWorkspace2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSWorkspace2.get_MapUnits() returned %ld", (long)hr);
        goto iimsworkspace2_get_mapunits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MapUnits

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eMapUnits);
    goto iimsworkspace2_get_mapunits_method_cleanup;

    iimsworkspace2_get_mapunits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for MapUnits
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSWorkspace2.get_MapUnits");
    return return_tuple;
}


PyMethodDef PyIIMSWorkspace2Methods[] = {
    {"supports", (PyCFunction)PyIIMSWorkspace2_SupportsInterface, METH_O, ""},
    {"get_QueryCapabilities", (PyCFunction)IIMSWorkspace2Method_get_QueryCapabilities, METH_VARARGS, ""},
    {"get_SpatialReference", (PyCFunction)IIMSWorkspace2Method_get_SpatialReference, METH_VARARGS, ""},
    {"get_AreaOfInterest", (PyCFunction)IIMSWorkspace2Method_get_AreaOfInterest, METH_VARARGS, ""},
    {"get_MapUnits", (PyCFunction)IIMSWorkspace2Method_get_MapUnits, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIIMSWorkspace2GetSet[] = {
  {"_pUnk", (getter)PyIIMSWorkspace2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IIMSWorkspace2", NULL},
  {"_pointer", (getter)PyIIMSWorkspace2_GetPointer, NULL, "Get memory address for IIMSWorkspace2", NULL},
  {"_IID", (getter)PyIIMSWorkspace2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIIMSWorkspace2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIIMSWorkspace2_GetIgnoreFailures, (setter)PyIIMSWorkspace2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIIMSWorkspace2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IIMSWorkspace2Object",                          
                                              /* tp_name */
  sizeof(PyIIMSWorkspace2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIIMSWorkspace2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIIMSWorkspace2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIIMSWorkspace2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIIMSWorkspace2Object_new,                      
                                              /* tp_new */
};

// Interface IIMSWorkspace

typedef struct PyIIMSWorkspaceObject {
    PyObject_HEAD
    IIMSWorkspace* m_pIIMSWorkspace;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIIMSWorkspaceObject;

static PyObject*
PyIIMSWorkspaceObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIIMSWorkspaceObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IIMSWorkspace* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IIMSWorkspace, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IIMSWorkspace with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIIMSWorkspaceObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSWorkspace");
            return NULL;
        }
        self->m_pIIMSWorkspace = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IIMSWorkspace");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IIMSWorkspace");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IIMSWorkspace* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IIMSWorkspace, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IIMSWorkspace");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIIMSWorkspaceObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSWorkspace");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIIMSWorkspace = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIIMSWorkspaceObject_dealloc(PyIIMSWorkspaceObject* self)
{
    if (self->m_pIIMSWorkspace)
        self->m_pIIMSWorkspace->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIIMSWorkspace_GetpUnk(PyIIMSWorkspaceObject* self)
{
    if (!self->m_pIIMSWorkspace)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIIMSWorkspace->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IIMSWorkspace to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIIMSWorkspace_GetPointer(PyIIMSWorkspaceObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIIMSWorkspace);
}

static PyObject*
PyIIMSWorkspace_GetIID(PyIIMSWorkspaceObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5e773ec1-f5e7-11d3-9f48-00c04f79927c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIIMSWorkspace_GetHR(PyIIMSWorkspaceObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIIMSWorkspace_GetIgnoreFailures(PyIIMSWorkspaceObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIIMSWorkspace_SetIgnoreFailures(PyIIMSWorkspaceObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIIMSWorkspace_SupportsInterface(PyIIMSWorkspaceObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIIMSWorkspace->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IIMSWorkspaceMethod_get_SpatialReference(PyIIMSWorkspaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipSpatialReference = NULL;
    PyObject* py_SpatialReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SpatialReference

    // Call method on actual COM interface
    hr = self->m_pIIMSWorkspace->get_SpatialReference(&ipSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSWorkspace->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSWorkspace) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSWorkspace.get_SpatialReference() returned %ld", (long)hr);
        goto iimsworkspace_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_SpatialReference);
    if (ipSpatialReference)
    {
        IUnknown* pUnk = NULL;
        ipSpatialReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_SpatialReference = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_SpatialReference)
    {
        if (py_SpatialReference)
           Py_DECREF(py_SpatialReference);
        py_SpatialReference = Py_None;
        Py_INCREF(py_SpatialReference);
    }
    if (PyErr_Occurred())
      goto iimsworkspace_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_SpatialReference);
    goto iimsworkspace_get_spatialreference_method_cleanup;

    iimsworkspace_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_SpatialReference);
    if (ipSpatialReference)
      ipSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSWorkspace.get_SpatialReference");
    return return_tuple;
}

static PyObject*
IIMSWorkspaceMethod_get_AreaOfInterest(PyIIMSWorkspaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipenvelope = NULL;
    PyObject* py_envelope = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for envelope

    // Call method on actual COM interface
    hr = self->m_pIIMSWorkspace->get_AreaOfInterest(&ipenvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSWorkspace->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSWorkspace) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSWorkspace.get_AreaOfInterest() returned %ld", (long)hr);
        goto iimsworkspace_get_areaofinterest_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_envelope);
    if (ipenvelope)
    {
        IUnknown* pUnk = NULL;
        ipenvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_envelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_envelope)
    {
        if (py_envelope)
           Py_DECREF(py_envelope);
        py_envelope = Py_None;
        Py_INCREF(py_envelope);
    }
    if (PyErr_Occurred())
      goto iimsworkspace_get_areaofinterest_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_envelope);
    goto iimsworkspace_get_areaofinterest_method_cleanup;

    iimsworkspace_get_areaofinterest_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_envelope);
    if (ipenvelope)
      ipenvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSWorkspace.get_AreaOfInterest");
    return return_tuple;
}

static PyObject*
IIMSWorkspaceMethod_get_MapUnits(PyIIMSWorkspaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acMapUnits eMapUnits;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MapUnits

    // Call method on actual COM interface
    hr = self->m_pIIMSWorkspace->get_MapUnits(&eMapUnits);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSWorkspace->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSWorkspace) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSWorkspace.get_MapUnits() returned %ld", (long)hr);
        goto iimsworkspace_get_mapunits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MapUnits

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eMapUnits);
    goto iimsworkspace_get_mapunits_method_cleanup;

    iimsworkspace_get_mapunits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for MapUnits
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSWorkspace.get_MapUnits");
    return return_tuple;
}


PyMethodDef PyIIMSWorkspaceMethods[] = {
    {"supports", (PyCFunction)PyIIMSWorkspace_SupportsInterface, METH_O, ""},
    {"get_SpatialReference", (PyCFunction)IIMSWorkspaceMethod_get_SpatialReference, METH_VARARGS, ""},
    {"get_AreaOfInterest", (PyCFunction)IIMSWorkspaceMethod_get_AreaOfInterest, METH_VARARGS, ""},
    {"get_MapUnits", (PyCFunction)IIMSWorkspaceMethod_get_MapUnits, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIIMSWorkspaceGetSet[] = {
  {"_pUnk", (getter)PyIIMSWorkspace_GetpUnk, NULL, "Get opaque pointer to an Unknown from IIMSWorkspace", NULL},
  {"_pointer", (getter)PyIIMSWorkspace_GetPointer, NULL, "Get memory address for IIMSWorkspace", NULL},
  {"_IID", (getter)PyIIMSWorkspace_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIIMSWorkspace_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIIMSWorkspace_GetIgnoreFailures, (setter)PyIIMSWorkspace_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIIMSWorkspaceObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IIMSWorkspaceObject",                          
                                              /* tp_name */
  sizeof(PyIIMSWorkspaceObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIIMSWorkspaceObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIIMSWorkspaceMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIIMSWorkspaceGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIIMSWorkspaceObject_new,                      
                                              /* tp_new */
};

// Interface IIMSFeatureClass

typedef struct PyIIMSFeatureClassObject {
    PyObject_HEAD
    IIMSFeatureClass* m_pIIMSFeatureClass;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIIMSFeatureClassObject;

static PyObject*
PyIIMSFeatureClassObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIIMSFeatureClassObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IIMSFeatureClass* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IIMSFeatureClass, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IIMSFeatureClass with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIIMSFeatureClassObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSFeatureClass");
            return NULL;
        }
        self->m_pIIMSFeatureClass = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IIMSFeatureClass");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IIMSFeatureClass");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IIMSFeatureClass* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IIMSFeatureClass, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IIMSFeatureClass");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIIMSFeatureClassObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSFeatureClass");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIIMSFeatureClass = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIIMSFeatureClassObject_dealloc(PyIIMSFeatureClassObject* self)
{
    if (self->m_pIIMSFeatureClass)
        self->m_pIIMSFeatureClass->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIIMSFeatureClass_GetpUnk(PyIIMSFeatureClassObject* self)
{
    if (!self->m_pIIMSFeatureClass)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIIMSFeatureClass->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IIMSFeatureClass to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIIMSFeatureClass_GetPointer(PyIIMSFeatureClassObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIIMSFeatureClass);
}

static PyObject*
PyIIMSFeatureClass_GetIID(PyIIMSFeatureClassObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b6f0197b-ea28-11d3-9f47-00c04f79927c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIIMSFeatureClass_GetHR(PyIIMSFeatureClassObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIIMSFeatureClass_GetIgnoreFailures(PyIIMSFeatureClassObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIIMSFeatureClass_SetIgnoreFailures(PyIIMSFeatureClassObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIIMSFeatureClass_SupportsInterface(PyIIMSFeatureClassObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIIMSFeatureClass->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IIMSFeatureClassMethod_get_Axl(PyIIMSFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAxl;
    PyObject* pyvar_Axl = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Axl

    // Call method on actual COM interface
    hr = self->m_pIIMSFeatureClass->get_Axl(&bsAxl);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSFeatureClass.get_Axl() returned %ld", (long)hr);
        goto iimsfeatureclass_get_axl_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Axl = PyUnicode_FromWideChar(bsAxl,::SysStringLen(bsAxl));
    ::SysFreeString(bsAxl);
    
    if (PyErr_Occurred())
      goto iimsfeatureclass_get_axl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Axl);
    goto iimsfeatureclass_get_axl_method_cleanup;

    iimsfeatureclass_get_axl_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Axl != Py_None)
        Py_XDECREF(pyvar_Axl);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSFeatureClass.get_Axl");
    return return_tuple;
}

static PyObject*
IIMSFeatureClassMethod_get_LayerID(PyIIMSFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsLayerID;
    PyObject* pyvar_LayerID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for LayerID

    // Call method on actual COM interface
    hr = self->m_pIIMSFeatureClass->get_LayerID(&bsLayerID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSFeatureClass.get_LayerID() returned %ld", (long)hr);
        goto iimsfeatureclass_get_layerid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_LayerID = PyUnicode_FromWideChar(bsLayerID,::SysStringLen(bsLayerID));
    ::SysFreeString(bsLayerID);
    
    if (PyErr_Occurred())
      goto iimsfeatureclass_get_layerid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_LayerID);
    goto iimsfeatureclass_get_layerid_method_cleanup;

    iimsfeatureclass_get_layerid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_LayerID != Py_None)
        Py_XDECREF(pyvar_LayerID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSFeatureClass.get_LayerID");
    return return_tuple;
}

static PyObject*
IIMSFeatureClassMethod_get_MapUnits(PyIIMSFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acMapUnits eMapUnits;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MapUnits

    // Call method on actual COM interface
    hr = self->m_pIIMSFeatureClass->get_MapUnits(&eMapUnits);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSFeatureClass.get_MapUnits() returned %ld", (long)hr);
        goto iimsfeatureclass_get_mapunits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MapUnits

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eMapUnits);
    goto iimsfeatureclass_get_mapunits_method_cleanup;

    iimsfeatureclass_get_mapunits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for MapUnits
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSFeatureClass.get_MapUnits");
    return return_tuple;
}


PyMethodDef PyIIMSFeatureClassMethods[] = {
    {"supports", (PyCFunction)PyIIMSFeatureClass_SupportsInterface, METH_O, ""},
    {"get_Axl", (PyCFunction)IIMSFeatureClassMethod_get_Axl, METH_VARARGS, ""},
    {"get_LayerID", (PyCFunction)IIMSFeatureClassMethod_get_LayerID, METH_VARARGS, ""},
    {"get_MapUnits", (PyCFunction)IIMSFeatureClassMethod_get_MapUnits, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIIMSFeatureClassGetSet[] = {
  {"_pUnk", (getter)PyIIMSFeatureClass_GetpUnk, NULL, "Get opaque pointer to an Unknown from IIMSFeatureClass", NULL},
  {"_pointer", (getter)PyIIMSFeatureClass_GetPointer, NULL, "Get memory address for IIMSFeatureClass", NULL},
  {"_IID", (getter)PyIIMSFeatureClass_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIIMSFeatureClass_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIIMSFeatureClass_GetIgnoreFailures, (setter)PyIIMSFeatureClass_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIIMSFeatureClassObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IIMSFeatureClassObject",                          
                                              /* tp_name */
  sizeof(PyIIMSFeatureClassObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIIMSFeatureClassObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIIMSFeatureClassMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIIMSFeatureClassGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIIMSFeatureClassObject_new,                      
                                              /* tp_new */
};

// Interface IIMSServiceDescription

typedef struct PyIIMSServiceDescriptionObject {
    PyObject_HEAD
    IIMSServiceDescription* m_pIIMSServiceDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIIMSServiceDescriptionObject;

static PyObject*
PyIIMSServiceDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIIMSServiceDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IIMSServiceDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IIMSServiceDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IIMSServiceDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIIMSServiceDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSServiceDescription");
            return NULL;
        }
        self->m_pIIMSServiceDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IIMSServiceDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IIMSServiceDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IIMSServiceDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IIMSServiceDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IIMSServiceDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIIMSServiceDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSServiceDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIIMSServiceDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIIMSServiceDescriptionObject_dealloc(PyIIMSServiceDescriptionObject* self)
{
    if (self->m_pIIMSServiceDescription)
        self->m_pIIMSServiceDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIIMSServiceDescription_GetpUnk(PyIIMSServiceDescriptionObject* self)
{
    if (!self->m_pIIMSServiceDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIIMSServiceDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IIMSServiceDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIIMSServiceDescription_GetPointer(PyIIMSServiceDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIIMSServiceDescription);
}

static PyObject*
PyIIMSServiceDescription_GetIID(PyIIMSServiceDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fe9f959a-06b5-4d52-8148-3bd33c29c0c5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIIMSServiceDescription_GetHR(PyIIMSServiceDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIIMSServiceDescription_GetIgnoreFailures(PyIIMSServiceDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIIMSServiceDescription_SetIgnoreFailures(PyIIMSServiceDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIIMSServiceDescription_SupportsInterface(PyIIMSServiceDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IIMSServiceDescriptionMethod_get_Name(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_Name() returned %ld", (long)hr);
        goto iimsservicedescription_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iimsservicedescription_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iimsservicedescription_get_name_method_cleanup;

    iimsservicedescription_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_Name");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_Name(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iimsservicedescription_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iimsservicedescription_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_Name() returned %ld", (long)hr);
        goto iimsservicedescription_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_name_method_cleanup;

    iimsservicedescription_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_Name");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_get_URL(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL;
    PyObject* pyvar_URL = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for URL

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_URL(&bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_URL() returned %ld", (long)hr);
        goto iimsservicedescription_get_url_method_cleanup;
    }

    // Set up return values as needed
    pyvar_URL = PyUnicode_FromWideChar(bsURL,::SysStringLen(bsURL));
    ::SysFreeString(bsURL);
    
    if (PyErr_Occurred())
      goto iimsservicedescription_get_url_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_URL);
    goto iimsservicedescription_get_url_method_cleanup;

    iimsservicedescription_get_url_method_cleanup:
    self->m_HR = hr;
    if (pyvar_URL != Py_None)
        Py_XDECREF(pyvar_URL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_URL");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_URL(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_URL))
      goto iimsservicedescription_put_url_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 0");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto iimsservicedescription_put_url_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_URL(bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_URL() returned %ld", (long)hr);
        goto iimsservicedescription_put_url_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for URL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_url_method_cleanup;

    iimsservicedescription_put_url_method_cleanup:
    self->m_HR = hr;
    if (bsURL)
        ::SysFreeString(bsURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_URL");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_UserName(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsUserName = 0;
    PyObject* pyvar_UserName;
    PyObject* unicodeUserName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_UserName))
      goto iimsservicedescription_put_username_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_UserName))
        unicodeUserName = PyUnicode_FromObject(pyvar_UserName);
    else if (PyUnicode_Check(pyvar_UserName))
    {
        unicodeUserName = pyvar_UserName;
        Py_INCREF(unicodeUserName);
    }
    else if (pyvar_UserName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter UserName at index 0");
    if (unicodeUserName)
        bsUserName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeUserName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeUserName));
    
    if (PyErr_Occurred())
      goto iimsservicedescription_put_username_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_UserName(bsUserName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_UserName() returned %ld", (long)hr);
        goto iimsservicedescription_put_username_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for UserName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_username_method_cleanup;

    iimsservicedescription_put_username_method_cleanup:
    self->m_HR = hr;
    if (bsUserName)
        ::SysFreeString(bsUserName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_UserName");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_get_UserName(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsUserName;
    PyObject* pyvar_UserName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for UserName

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_UserName(&bsUserName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_UserName() returned %ld", (long)hr);
        goto iimsservicedescription_get_username_method_cleanup;
    }

    // Set up return values as needed
    pyvar_UserName = PyUnicode_FromWideChar(bsUserName,::SysStringLen(bsUserName));
    ::SysFreeString(bsUserName);
    
    if (PyErr_Occurred())
      goto iimsservicedescription_get_username_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_UserName);
    goto iimsservicedescription_get_username_method_cleanup;

    iimsservicedescription_get_username_method_cleanup:
    self->m_HR = hr;
    if (pyvar_UserName != Py_None)
        Py_XDECREF(pyvar_UserName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_UserName");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_get_Password(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vPassword;
    ::VariantInit(&vPassword);
    PyObject* pyvar_Password = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Password

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_Password(&vPassword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_Password() returned %ld", (long)hr);
        goto iimsservicedescription_get_password_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Password = Variant_AsPyObject(&vPassword);
    if (PyErr_Occurred())
      goto iimsservicedescription_get_password_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Password);
    goto iimsservicedescription_get_password_method_cleanup;

    iimsservicedescription_get_password_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vPassword);
    Py_XDECREF(pyvar_Password);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_Password");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_Password(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPassword = 0;
    PyObject* pyvar_Password;
    PyObject* unicodePassword = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Password))
      goto iimsservicedescription_put_password_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Password))
        unicodePassword = PyUnicode_FromObject(pyvar_Password);
    else if (PyUnicode_Check(pyvar_Password))
    {
        unicodePassword = pyvar_Password;
        Py_INCREF(unicodePassword);
    }
    else if (pyvar_Password != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Password at index 0");
    if (unicodePassword)
        bsPassword = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodePassword), 
                                            (UINT)PyUnicode_GET_SIZE(unicodePassword));
    
    if (PyErr_Occurred())
      goto iimsservicedescription_put_password_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_Password(bsPassword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_Password() returned %ld", (long)hr);
        goto iimsservicedescription_put_password_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Password

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_password_method_cleanup;

    iimsservicedescription_put_password_method_cleanup:
    self->m_HR = hr;
    if (bsPassword)
        ::SysFreeString(bsPassword);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_Password");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_get_SavePassword(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_flag = VARIANT_FALSE;
    PyObject* pyvar_flag = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for flag

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_SavePassword(&b_flag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_SavePassword() returned %ld", (long)hr);
        goto iimsservicedescription_get_savepassword_method_cleanup;
    }

    // Set up return values as needed
    pyvar_flag = ((b_flag == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iimsservicedescription_get_savepassword_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_flag);
    goto iimsservicedescription_get_savepassword_method_cleanup;

    iimsservicedescription_get_savepassword_method_cleanup:
    self->m_HR = hr;
    // No cleanup for flag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_SavePassword");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_SavePassword(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_flag = VARIANT_FALSE;
    PyObject* pyvar_flag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_flag))
      goto iimsservicedescription_put_savepassword_method_cleanup;

    // Set up initial variable values as needed
    b_flag = ((PyObject_IsTrue(pyvar_flag) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsservicedescription_put_savepassword_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_SavePassword(b_flag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_SavePassword() returned %ld", (long)hr);
        goto iimsservicedescription_put_savepassword_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for flag

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_savepassword_method_cleanup;

    iimsservicedescription_put_savepassword_method_cleanup:
    self->m_HR = hr;
    // No cleanup for flag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_SavePassword");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_get_ServiceType(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acServiceType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_ServiceType(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_ServiceType() returned %ld", (long)hr);
        goto iimsservicedescription_get_servicetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto iimsservicedescription_get_servicetype_method_cleanup;

    iimsservicedescription_get_servicetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_ServiceType");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_ServiceType(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acServiceType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto iimsservicedescription_put_servicetype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_ServiceType(eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_ServiceType() returned %ld", (long)hr);
        goto iimsservicedescription_put_servicetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_servicetype_method_cleanup;

    iimsservicedescription_put_servicetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_ServiceType");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_get_Security(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lSecurity = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Security

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_Security(&lSecurity);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_Security() returned %ld", (long)hr);
        goto iimsservicedescription_get_security_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Security

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lSecurity);
    goto iimsservicedescription_get_security_method_cleanup;

    iimsservicedescription_get_security_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Security
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_Security");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_Security(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lSecurity = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lSecurity))
      goto iimsservicedescription_put_security_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Security

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_Security(lSecurity);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_Security() returned %ld", (long)hr);
        goto iimsservicedescription_put_security_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Security

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_security_method_cleanup;

    iimsservicedescription_put_security_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Security
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_Security");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_get_IsPrivate(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsPrivate = VARIANT_FALSE;
    PyObject* pyvar_IsPrivate = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsPrivate

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_IsPrivate(&b_IsPrivate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_IsPrivate() returned %ld", (long)hr);
        goto iimsservicedescription_get_isprivate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsPrivate = ((b_IsPrivate == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iimsservicedescription_get_isprivate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsPrivate);
    goto iimsservicedescription_get_isprivate_method_cleanup;

    iimsservicedescription_get_isprivate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsPrivate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_IsPrivate");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_IsPrivate(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsPrivate = VARIANT_FALSE;
    PyObject* pyvar_IsPrivate = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_IsPrivate))
      goto iimsservicedescription_put_isprivate_method_cleanup;

    // Set up initial variable values as needed
    b_IsPrivate = ((PyObject_IsTrue(pyvar_IsPrivate) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsservicedescription_put_isprivate_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_IsPrivate(b_IsPrivate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_IsPrivate() returned %ld", (long)hr);
        goto iimsservicedescription_put_isprivate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for IsPrivate

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_isprivate_method_cleanup;

    iimsservicedescription_put_isprivate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsPrivate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_IsPrivate");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_get_ConnectionProperties(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipConnectionProperties = NULL;
    PyObject* py_ConnectionProperties = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ConnectionProperties

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->get_ConnectionProperties(&ipConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.get_ConnectionProperties() returned %ld", (long)hr);
        goto iimsservicedescription_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
    {
        IUnknown* pUnk = NULL;
        ipConnectionProperties->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ConnectionProperties = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ConnectionProperties)
    {
        if (py_ConnectionProperties)
           Py_DECREF(py_ConnectionProperties);
        py_ConnectionProperties = Py_None;
        Py_INCREF(py_ConnectionProperties);
    }
    if (PyErr_Occurred())
      goto iimsservicedescription_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ConnectionProperties);
    goto iimsservicedescription_get_connectionproperties_method_cleanup;

    iimsservicedescription_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
      ipConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.get_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IIMSServiceDescriptionMethod_put_ConnectionProperties(PyIIMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipConnectionProperties = NULL;
    PyObject* py_ConnectionProperties;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ConnectionProperties))
      goto iimsservicedescription_put_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ConnectionProperties, &IID_IPropertySet, (void**)&ipConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument ConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iimsservicedescription_put_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIIMSServiceDescription->put_ConnectionProperties(ipConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSServiceDescription.put_ConnectionProperties() returned %ld", (long)hr);
        goto iimsservicedescription_put_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ConnectionProperties

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsservicedescription_put_connectionproperties_method_cleanup;

    iimsservicedescription_put_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipConnectionProperties)
      ipConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSServiceDescription.put_ConnectionProperties");
    return return_tuple;
}


PyMethodDef PyIIMSServiceDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIIMSServiceDescription_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IIMSServiceDescriptionMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IIMSServiceDescriptionMethod_put_Name, METH_VARARGS, ""},
    {"get_URL", (PyCFunction)IIMSServiceDescriptionMethod_get_URL, METH_VARARGS, ""},
    {"put_URL", (PyCFunction)IIMSServiceDescriptionMethod_put_URL, METH_VARARGS, ""},
    {"put_UserName", (PyCFunction)IIMSServiceDescriptionMethod_put_UserName, METH_VARARGS, ""},
    {"get_UserName", (PyCFunction)IIMSServiceDescriptionMethod_get_UserName, METH_VARARGS, ""},
    {"get_Password", (PyCFunction)IIMSServiceDescriptionMethod_get_Password, METH_VARARGS, ""},
    {"put_Password", (PyCFunction)IIMSServiceDescriptionMethod_put_Password, METH_VARARGS, ""},
    {"get_SavePassword", (PyCFunction)IIMSServiceDescriptionMethod_get_SavePassword, METH_VARARGS, ""},
    {"put_SavePassword", (PyCFunction)IIMSServiceDescriptionMethod_put_SavePassword, METH_VARARGS, ""},
    {"get_ServiceType", (PyCFunction)IIMSServiceDescriptionMethod_get_ServiceType, METH_VARARGS, ""},
    {"put_ServiceType", (PyCFunction)IIMSServiceDescriptionMethod_put_ServiceType, METH_VARARGS, ""},
    {"get_Security", (PyCFunction)IIMSServiceDescriptionMethod_get_Security, METH_VARARGS, ""},
    {"put_Security", (PyCFunction)IIMSServiceDescriptionMethod_put_Security, METH_VARARGS, ""},
    {"get_IsPrivate", (PyCFunction)IIMSServiceDescriptionMethod_get_IsPrivate, METH_VARARGS, ""},
    {"put_IsPrivate", (PyCFunction)IIMSServiceDescriptionMethod_put_IsPrivate, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IIMSServiceDescriptionMethod_get_ConnectionProperties, METH_VARARGS, ""},
    {"put_ConnectionProperties", (PyCFunction)IIMSServiceDescriptionMethod_put_ConnectionProperties, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIIMSServiceDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIIMSServiceDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IIMSServiceDescription", NULL},
  {"_pointer", (getter)PyIIMSServiceDescription_GetPointer, NULL, "Get memory address for IIMSServiceDescription", NULL},
  {"_IID", (getter)PyIIMSServiceDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIIMSServiceDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIIMSServiceDescription_GetIgnoreFailures, (setter)PyIIMSServiceDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIIMSServiceDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IIMSServiceDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIIMSServiceDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIIMSServiceDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIIMSServiceDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIIMSServiceDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIIMSServiceDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IIMSAxlRequest

typedef struct PyIIMSAxlRequestObject {
    PyObject_HEAD
    IIMSAxlRequest* m_pIIMSAxlRequest;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIIMSAxlRequestObject;

static PyObject*
PyIIMSAxlRequestObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIIMSAxlRequestObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IIMSAxlRequest* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IIMSAxlRequest, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IIMSAxlRequest with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIIMSAxlRequestObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSAxlRequest");
            return NULL;
        }
        self->m_pIIMSAxlRequest = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IIMSAxlRequest");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IIMSAxlRequest");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IIMSAxlRequest* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IIMSAxlRequest, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IIMSAxlRequest");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIIMSAxlRequestObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSAxlRequest");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIIMSAxlRequest = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIIMSAxlRequestObject_dealloc(PyIIMSAxlRequestObject* self)
{
    if (self->m_pIIMSAxlRequest)
        self->m_pIIMSAxlRequest->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIIMSAxlRequest_GetpUnk(PyIIMSAxlRequestObject* self)
{
    if (!self->m_pIIMSAxlRequest)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIIMSAxlRequest->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IIMSAxlRequest to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIIMSAxlRequest_GetPointer(PyIIMSAxlRequestObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIIMSAxlRequest);
}

static PyObject*
PyIIMSAxlRequest_GetIID(PyIIMSAxlRequestObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2844f4ef-098f-4858-80a6-b6a29eb5f140");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIIMSAxlRequest_GetHR(PyIIMSAxlRequestObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIIMSAxlRequest_GetIgnoreFailures(PyIIMSAxlRequestObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIIMSAxlRequest_SetIgnoreFailures(PyIIMSAxlRequestObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIIMSAxlRequest_SupportsInterface(PyIIMSAxlRequestObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIIMSAxlRequest->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IIMSAxlRequestMethod_SendAxlRequest(PyIIMSAxlRequestObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAxl = 0;
    PyObject* pyvar_Axl;
    PyObject* unicodeAxl = NULL;
    VARIANT_BOOL b_queryRequest = VARIANT_FALSE;
    PyObject* pyvar_queryRequest = NULL;
    ITrackCancel* iptrackCancel = NULL;
    PyObject* py_trackCancel;
    VARIANT_BOOL b_showConnectingAVI = VARIANT_FALSE;
    PyObject* pyvar_showConnectingAVI = NULL;
    VARIANT_BOOL b_processMessages = VARIANT_FALSE;
    PyObject* pyvar_processMessages = NULL;
    BSTR bsresponse;
    PyObject* pyvar_response = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOO", &pyvar_Axl, &pyvar_queryRequest, &py_trackCancel, &pyvar_showConnectingAVI, &pyvar_processMessages))
      goto iimsaxlrequest_sendaxlrequest_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Axl))
        unicodeAxl = PyUnicode_FromObject(pyvar_Axl);
    else if (PyUnicode_Check(pyvar_Axl))
    {
        unicodeAxl = pyvar_Axl;
        Py_INCREF(unicodeAxl);
    }
    else if (pyvar_Axl != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Axl at index 0");
    if (unicodeAxl)
        bsAxl = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeAxl), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeAxl));
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequest_method_cleanup;
    
    b_queryRequest = ((PyObject_IsTrue(pyvar_queryRequest) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequest_method_cleanup;
    
    if (!IFaceFromPyObject(py_trackCancel, &IID_ITrackCancel, (void**)&iptrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument trackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequest_method_cleanup;
    
    b_showConnectingAVI = ((PyObject_IsTrue(pyvar_showConnectingAVI) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequest_method_cleanup;
    
    b_processMessages = ((PyObject_IsTrue(pyvar_processMessages) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequest_method_cleanup;
    
    // No setup for response

    // Call method on actual COM interface
    hr = self->m_pIIMSAxlRequest->SendAxlRequest(bsAxl, b_queryRequest, iptrackCancel, b_showConnectingAVI, b_processMessages, &bsresponse);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSAxlRequest->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSAxlRequest) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSAxlRequest.SendAxlRequest() returned %ld", (long)hr);
        goto iimsaxlrequest_sendaxlrequest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Axl
    // No teardown for queryRequest
    // No teardown for trackCancel
    // No teardown for showConnectingAVI
    // No teardown for processMessages
    pyvar_response = PyUnicode_FromWideChar(bsresponse,::SysStringLen(bsresponse));
    ::SysFreeString(bsresponse);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequest_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_response);
    goto iimsaxlrequest_sendaxlrequest_method_cleanup;

    iimsaxlrequest_sendaxlrequest_method_cleanup:
    self->m_HR = hr;
    if (bsAxl)
        ::SysFreeString(bsAxl);
    
    // No cleanup for queryRequest
    if (iptrackCancel)
      iptrackCancel->Release();
    // No cleanup for showConnectingAVI
    // No cleanup for processMessages
    if (pyvar_response != Py_None)
        Py_XDECREF(pyvar_response);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSAxlRequest.SendAxlRequest");
    return return_tuple;
}

static PyObject*
IIMSAxlRequestMethod_SendAxlRequestStream(PyIIMSAxlRequestObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAxl = 0;
    PyObject* pyvar_Axl;
    PyObject* unicodeAxl = NULL;
    VARIANT_BOOL b_queryRequest = VARIANT_FALSE;
    PyObject* pyvar_queryRequest = NULL;
    ITrackCancel* iptrackCancel = NULL;
    PyObject* py_trackCancel;
    VARIANT_BOOL b_showConnectingAVI = VARIANT_FALSE;
    PyObject* pyvar_showConnectingAVI = NULL;
    VARIANT_BOOL b_processMessages = VARIANT_FALSE;
    PyObject* pyvar_processMessages = NULL;
    IStream* ipresponse = NULL;
    PyObject* py_response = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOO", &pyvar_Axl, &pyvar_queryRequest, &py_trackCancel, &pyvar_showConnectingAVI, &pyvar_processMessages))
      goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Axl))
        unicodeAxl = PyUnicode_FromObject(pyvar_Axl);
    else if (PyUnicode_Check(pyvar_Axl))
    {
        unicodeAxl = pyvar_Axl;
        Py_INCREF(unicodeAxl);
    }
    else if (pyvar_Axl != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Axl at index 0");
    if (unicodeAxl)
        bsAxl = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeAxl), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeAxl));
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;
    
    b_queryRequest = ((PyObject_IsTrue(pyvar_queryRequest) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;
    
    if (!IFaceFromPyObject(py_trackCancel, &IID_ITrackCancel, (void**)&iptrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument trackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;
    
    b_showConnectingAVI = ((PyObject_IsTrue(pyvar_showConnectingAVI) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;
    
    b_processMessages = ((PyObject_IsTrue(pyvar_processMessages) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;
    
    // No setup for response

    // Call method on actual COM interface
    hr = self->m_pIIMSAxlRequest->SendAxlRequestStream(bsAxl, b_queryRequest, iptrackCancel, b_showConnectingAVI, b_processMessages, &ipresponse);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSAxlRequest->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSAxlRequest) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSAxlRequest.SendAxlRequestStream() returned %ld", (long)hr);
        goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Axl
    // No teardown for queryRequest
    // No teardown for trackCancel
    // No teardown for showConnectingAVI
    // No teardown for processMessages
    Py_XDECREF(py_response);
    if (ipresponse)
    {
        IUnknown* pUnk = NULL;
        ipresponse->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_response = IUnknownToPythonIIDObject(pUnk, &IID_IStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_response)
    {
        if (py_response)
           Py_DECREF(py_response);
        py_response = Py_None;
        Py_INCREF(py_response);
    }
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_response);
    goto iimsaxlrequest_sendaxlrequeststream_method_cleanup;

    iimsaxlrequest_sendaxlrequeststream_method_cleanup:
    self->m_HR = hr;
    if (bsAxl)
        ::SysFreeString(bsAxl);
    
    // No cleanup for queryRequest
    if (iptrackCancel)
      iptrackCancel->Release();
    // No cleanup for showConnectingAVI
    // No cleanup for processMessages
    Py_XDECREF(py_response);
    if (ipresponse)
      ipresponse->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSAxlRequest.SendAxlRequestStream");
    return return_tuple;
}

static PyObject*
IIMSAxlRequestMethod_SendCommandRequest(PyIIMSAxlRequestObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscommand = 0;
    PyObject* pyvar_command;
    PyObject* unicodecommand = NULL;
    ITrackCancel* iptrackCancel = NULL;
    PyObject* py_trackCancel;
    VARIANT_BOOL b_showConnectingAVI = VARIANT_FALSE;
    PyObject* pyvar_showConnectingAVI = NULL;
    VARIANT_BOOL b_processMessages = VARIANT_FALSE;
    PyObject* pyvar_processMessages = NULL;
    BSTR bsresponse;
    PyObject* pyvar_response = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_command, &py_trackCancel, &pyvar_showConnectingAVI, &pyvar_processMessages))
      goto iimsaxlrequest_sendcommandrequest_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_command))
        unicodecommand = PyUnicode_FromObject(pyvar_command);
    else if (PyUnicode_Check(pyvar_command))
    {
        unicodecommand = pyvar_command;
        Py_INCREF(unicodecommand);
    }
    else if (pyvar_command != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter command at index 0");
    if (unicodecommand)
        bscommand = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecommand), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecommand));
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendcommandrequest_method_cleanup;
    
    if (!IFaceFromPyObject(py_trackCancel, &IID_ITrackCancel, (void**)&iptrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument trackCancel (position 1) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendcommandrequest_method_cleanup;
    
    b_showConnectingAVI = ((PyObject_IsTrue(pyvar_showConnectingAVI) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendcommandrequest_method_cleanup;
    
    b_processMessages = ((PyObject_IsTrue(pyvar_processMessages) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendcommandrequest_method_cleanup;
    
    // No setup for response

    // Call method on actual COM interface
    hr = self->m_pIIMSAxlRequest->SendCommandRequest(bscommand, iptrackCancel, b_showConnectingAVI, b_processMessages, &bsresponse);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSAxlRequest->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSAxlRequest) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSAxlRequest.SendCommandRequest() returned %ld", (long)hr);
        goto iimsaxlrequest_sendcommandrequest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for command
    // No teardown for trackCancel
    // No teardown for showConnectingAVI
    // No teardown for processMessages
    pyvar_response = PyUnicode_FromWideChar(bsresponse,::SysStringLen(bsresponse));
    ::SysFreeString(bsresponse);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_sendcommandrequest_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_response);
    goto iimsaxlrequest_sendcommandrequest_method_cleanup;

    iimsaxlrequest_sendcommandrequest_method_cleanup:
    self->m_HR = hr;
    if (bscommand)
        ::SysFreeString(bscommand);
    
    if (iptrackCancel)
      iptrackCancel->Release();
    // No cleanup for showConnectingAVI
    // No cleanup for processMessages
    if (pyvar_response != Py_None)
        Py_XDECREF(pyvar_response);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSAxlRequest.SendCommandRequest");
    return return_tuple;
}

static PyObject*
IIMSAxlRequestMethod_get_ServerVersion(PyIIMSAxlRequestObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* iptrackCancel = NULL;
    PyObject* py_trackCancel;
    VARIANT_BOOL b_showConnectingAVI = VARIANT_FALSE;
    PyObject* pyvar_showConnectingAVI = NULL;
    VARIANT_BOOL b_processMessages = VARIANT_FALSE;
    PyObject* pyvar_processMessages = NULL;
    BSTR bsServerVersion;
    PyObject* pyvar_ServerVersion = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_trackCancel, &pyvar_showConnectingAVI, &pyvar_processMessages))
      goto iimsaxlrequest_get_serverversion_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_trackCancel, &IID_ITrackCancel, (void**)&iptrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument trackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_get_serverversion_method_cleanup;
    
    b_showConnectingAVI = ((PyObject_IsTrue(pyvar_showConnectingAVI) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_get_serverversion_method_cleanup;
    
    b_processMessages = ((PyObject_IsTrue(pyvar_processMessages) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_get_serverversion_method_cleanup;
    
    // No setup for ServerVersion

    // Call method on actual COM interface
    hr = self->m_pIIMSAxlRequest->get_ServerVersion(iptrackCancel, b_showConnectingAVI, b_processMessages, &bsServerVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSAxlRequest->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSAxlRequest) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSAxlRequest.get_ServerVersion() returned %ld", (long)hr);
        goto iimsaxlrequest_get_serverversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for trackCancel
    // No teardown for showConnectingAVI
    // No teardown for processMessages
    pyvar_ServerVersion = PyUnicode_FromWideChar(bsServerVersion,::SysStringLen(bsServerVersion));
    ::SysFreeString(bsServerVersion);
    
    if (PyErr_Occurred())
      goto iimsaxlrequest_get_serverversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ServerVersion);
    goto iimsaxlrequest_get_serverversion_method_cleanup;

    iimsaxlrequest_get_serverversion_method_cleanup:
    self->m_HR = hr;
    if (iptrackCancel)
      iptrackCancel->Release();
    // No cleanup for showConnectingAVI
    // No cleanup for processMessages
    if (pyvar_ServerVersion != Py_None)
        Py_XDECREF(pyvar_ServerVersion);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSAxlRequest.get_ServerVersion");
    return return_tuple;
}


PyMethodDef PyIIMSAxlRequestMethods[] = {
    {"supports", (PyCFunction)PyIIMSAxlRequest_SupportsInterface, METH_O, ""},
    {"SendAxlRequest", (PyCFunction)IIMSAxlRequestMethod_SendAxlRequest, METH_VARARGS, ""},
    {"SendAxlRequestStream", (PyCFunction)IIMSAxlRequestMethod_SendAxlRequestStream, METH_VARARGS, ""},
    {"SendCommandRequest", (PyCFunction)IIMSAxlRequestMethod_SendCommandRequest, METH_VARARGS, ""},
    {"get_ServerVersion", (PyCFunction)IIMSAxlRequestMethod_get_ServerVersion, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIIMSAxlRequestGetSet[] = {
  {"_pUnk", (getter)PyIIMSAxlRequest_GetpUnk, NULL, "Get opaque pointer to an Unknown from IIMSAxlRequest", NULL},
  {"_pointer", (getter)PyIIMSAxlRequest_GetPointer, NULL, "Get memory address for IIMSAxlRequest", NULL},
  {"_IID", (getter)PyIIMSAxlRequest_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIIMSAxlRequest_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIIMSAxlRequest_GetIgnoreFailures, (setter)PyIIMSAxlRequest_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIIMSAxlRequestObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IIMSAxlRequestObject",                          
                                              /* tp_name */
  sizeof(PyIIMSAxlRequestObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIIMSAxlRequestObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIIMSAxlRequestMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIIMSAxlRequestGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIIMSAxlRequestObject_new,                      
                                              /* tp_new */
};

// Interface IIMSUserRole

typedef struct PyIIMSUserRoleObject {
    PyObject_HEAD
    IIMSUserRole* m_pIIMSUserRole;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIIMSUserRoleObject;

static PyObject*
PyIIMSUserRoleObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIIMSUserRoleObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IIMSUserRole* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IIMSUserRole, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IIMSUserRole with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIIMSUserRoleObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSUserRole");
            return NULL;
        }
        self->m_pIIMSUserRole = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IIMSUserRole");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IIMSUserRole");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IIMSUserRole* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IIMSUserRole, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IIMSUserRole");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIIMSUserRoleObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSUserRole");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIIMSUserRole = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIIMSUserRoleObject_dealloc(PyIIMSUserRoleObject* self)
{
    if (self->m_pIIMSUserRole)
        self->m_pIIMSUserRole->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIIMSUserRole_GetpUnk(PyIIMSUserRoleObject* self)
{
    if (!self->m_pIIMSUserRole)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIIMSUserRole->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IIMSUserRole to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIIMSUserRole_GetPointer(PyIIMSUserRoleObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIIMSUserRole);
}

static PyObject*
PyIIMSUserRole_GetIID(PyIIMSUserRoleObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "448631a6-2bda-4f54-a341-76cc7ffd70a7");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIIMSUserRole_GetHR(PyIIMSUserRoleObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIIMSUserRole_GetIgnoreFailures(PyIIMSUserRoleObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIIMSUserRole_SetIgnoreFailures(PyIIMSUserRoleObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIIMSUserRole_SupportsInterface(PyIIMSUserRoleObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIIMSUserRole->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IIMSUserRoleMethod_get_UserRole(PyIIMSUserRoleObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acUserRole erole;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for role

    // Call method on actual COM interface
    hr = self->m_pIIMSUserRole->get_UserRole(&erole);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSUserRole->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSUserRole) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSUserRole.get_UserRole() returned %ld", (long)hr);
        goto iimsuserrole_get_userrole_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for role

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)erole);
    goto iimsuserrole_get_userrole_method_cleanup;

    iimsuserrole_get_userrole_method_cleanup:
    self->m_HR = hr;
    // No cleanup for role
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSUserRole.get_UserRole");
    return return_tuple;
}

static PyObject*
IIMSUserRoleMethod_put_UserRole(PyIIMSUserRoleObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acUserRole erole;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&erole))
      goto iimsuserrole_put_userrole_method_cleanup;

    // Set up initial variable values as needed
    // No setup for role

    // Call method on actual COM interface
    hr = self->m_pIIMSUserRole->put_UserRole(erole);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSUserRole->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSUserRole) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSUserRole.put_UserRole() returned %ld", (long)hr);
        goto iimsuserrole_put_userrole_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for role

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimsuserrole_put_userrole_method_cleanup;

    iimsuserrole_put_userrole_method_cleanup:
    self->m_HR = hr;
    // No cleanup for role
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSUserRole.put_UserRole");
    return return_tuple;
}


PyMethodDef PyIIMSUserRoleMethods[] = {
    {"supports", (PyCFunction)PyIIMSUserRole_SupportsInterface, METH_O, ""},
    {"get_UserRole", (PyCFunction)IIMSUserRoleMethod_get_UserRole, METH_VARARGS, ""},
    {"put_UserRole", (PyCFunction)IIMSUserRoleMethod_put_UserRole, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIIMSUserRoleGetSet[] = {
  {"_pUnk", (getter)PyIIMSUserRole_GetpUnk, NULL, "Get opaque pointer to an Unknown from IIMSUserRole", NULL},
  {"_pointer", (getter)PyIIMSUserRole_GetPointer, NULL, "Get memory address for IIMSUserRole", NULL},
  {"_IID", (getter)PyIIMSUserRole_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIIMSUserRole_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIIMSUserRole_GetIgnoreFailures, (setter)PyIIMSUserRole_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIIMSUserRoleObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IIMSUserRoleObject",                          
                                              /* tp_name */
  sizeof(PyIIMSUserRoleObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIIMSUserRoleObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIIMSUserRoleMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIIMSUserRoleGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIIMSUserRoleObject_new,                      
                                              /* tp_new */
};

// Interface IRemoteMetadataName

typedef struct PyIRemoteMetadataNameObject {
    PyObject_HEAD
    IRemoteMetadataName* m_pIRemoteMetadataName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIRemoteMetadataNameObject;

static PyObject*
PyIRemoteMetadataNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIRemoteMetadataNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IRemoteMetadataName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IRemoteMetadataName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IRemoteMetadataName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIRemoteMetadataNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IRemoteMetadataName");
            return NULL;
        }
        self->m_pIRemoteMetadataName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IRemoteMetadataName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IRemoteMetadataName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IRemoteMetadataName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IRemoteMetadataName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IRemoteMetadataName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIRemoteMetadataNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IRemoteMetadataName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIRemoteMetadataName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIRemoteMetadataNameObject_dealloc(PyIRemoteMetadataNameObject* self)
{
    if (self->m_pIRemoteMetadataName)
        self->m_pIRemoteMetadataName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIRemoteMetadataName_GetpUnk(PyIRemoteMetadataNameObject* self)
{
    if (!self->m_pIRemoteMetadataName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIRemoteMetadataName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IRemoteMetadataName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIRemoteMetadataName_GetPointer(PyIRemoteMetadataNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIRemoteMetadataName);
}

static PyObject*
PyIRemoteMetadataName_GetIID(PyIRemoteMetadataNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c7535706-3898-419c-b65b-9faf0d8bfc83");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIRemoteMetadataName_GetHR(PyIRemoteMetadataNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIRemoteMetadataName_GetIgnoreFailures(PyIRemoteMetadataNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIRemoteMetadataName_SetIgnoreFailures(PyIRemoteMetadataNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIRemoteMetadataName_SupportsInterface(PyIRemoteMetadataNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IRemoteMetadataNameMethod_put_Dataset(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDataset = 0;
    PyObject* pyvar_pDataset;
    PyObject* unicodepDataset = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pDataset))
      goto iremotemetadataname_put_dataset_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pDataset))
        unicodepDataset = PyUnicode_FromObject(pyvar_pDataset);
    else if (PyUnicode_Check(pyvar_pDataset))
    {
        unicodepDataset = pyvar_pDataset;
        Py_INCREF(unicodepDataset);
    }
    else if (pyvar_pDataset != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pDataset at index 0");
    if (unicodepDataset)
        bspDataset = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepDataset), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepDataset));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_dataset_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_Dataset(bspDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_Dataset() returned %ld", (long)hr);
        goto iremotemetadataname_put_dataset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDataset

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_dataset_method_cleanup;

    iremotemetadataname_put_dataset_method_cleanup:
    self->m_HR = hr;
    if (bspDataset)
        ::SysFreeString(bspDataset);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_Dataset");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_Dataset(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDataset;
    PyObject* pyvar_pDataset = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDataset

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_Dataset(&bspDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_Dataset() returned %ld", (long)hr);
        goto iremotemetadataname_get_dataset_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pDataset = PyUnicode_FromWideChar(bspDataset,::SysStringLen(bspDataset));
    ::SysFreeString(bspDataset);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_dataset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pDataset);
    goto iremotemetadataname_get_dataset_method_cleanup;

    iremotemetadataname_get_dataset_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pDataset != Py_None)
        Py_XDECREF(pyvar_pDataset);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_Dataset");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_Owner(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspOwner = 0;
    PyObject* pyvar_pOwner;
    PyObject* unicodepOwner = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pOwner))
      goto iremotemetadataname_put_owner_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pOwner))
        unicodepOwner = PyUnicode_FromObject(pyvar_pOwner);
    else if (PyUnicode_Check(pyvar_pOwner))
    {
        unicodepOwner = pyvar_pOwner;
        Py_INCREF(unicodepOwner);
    }
    else if (pyvar_pOwner != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pOwner at index 0");
    if (unicodepOwner)
        bspOwner = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepOwner), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepOwner));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_owner_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_Owner(bspOwner);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_Owner() returned %ld", (long)hr);
        goto iremotemetadataname_put_owner_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOwner

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_owner_method_cleanup;

    iremotemetadataname_put_owner_method_cleanup:
    self->m_HR = hr;
    if (bspOwner)
        ::SysFreeString(bspOwner);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_Owner");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_Owner(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspOwner;
    PyObject* pyvar_pOwner = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pOwner

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_Owner(&bspOwner);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_Owner() returned %ld", (long)hr);
        goto iremotemetadataname_get_owner_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pOwner = PyUnicode_FromWideChar(bspOwner,::SysStringLen(bspOwner));
    ::SysFreeString(bspOwner);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_owner_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pOwner);
    goto iremotemetadataname_get_owner_method_cleanup;

    iremotemetadataname_get_owner_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pOwner != Py_None)
        Py_XDECREF(pyvar_pOwner);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_Owner");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_UserID(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspUserID = 0;
    PyObject* pyvar_pUserID;
    PyObject* unicodepUserID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pUserID))
      goto iremotemetadataname_put_userid_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pUserID))
        unicodepUserID = PyUnicode_FromObject(pyvar_pUserID);
    else if (PyUnicode_Check(pyvar_pUserID))
    {
        unicodepUserID = pyvar_pUserID;
        Py_INCREF(unicodepUserID);
    }
    else if (pyvar_pUserID != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pUserID at index 0");
    if (unicodepUserID)
        bspUserID = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepUserID), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepUserID));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_userid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_UserID(bspUserID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_UserID() returned %ld", (long)hr);
        goto iremotemetadataname_put_userid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUserID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_userid_method_cleanup;

    iremotemetadataname_put_userid_method_cleanup:
    self->m_HR = hr;
    if (bspUserID)
        ::SysFreeString(bspUserID);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_UserID");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_UserID(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspUserID;
    PyObject* pyvar_pUserID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pUserID

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_UserID(&bspUserID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_UserID() returned %ld", (long)hr);
        goto iremotemetadataname_get_userid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pUserID = PyUnicode_FromWideChar(bspUserID,::SysStringLen(bspUserID));
    ::SysFreeString(bspUserID);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_userid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pUserID);
    goto iremotemetadataname_get_userid_method_cleanup;

    iremotemetadataname_get_userid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pUserID != Py_None)
        Py_XDECREF(pyvar_pUserID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_UserID");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_ParentDataset(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDataset = 0;
    PyObject* pyvar_pDataset;
    PyObject* unicodepDataset = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pDataset))
      goto iremotemetadataname_put_parentdataset_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pDataset))
        unicodepDataset = PyUnicode_FromObject(pyvar_pDataset);
    else if (PyUnicode_Check(pyvar_pDataset))
    {
        unicodepDataset = pyvar_pDataset;
        Py_INCREF(unicodepDataset);
    }
    else if (pyvar_pDataset != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pDataset at index 0");
    if (unicodepDataset)
        bspDataset = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepDataset), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepDataset));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_parentdataset_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_ParentDataset(bspDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_ParentDataset() returned %ld", (long)hr);
        goto iremotemetadataname_put_parentdataset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDataset

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_parentdataset_method_cleanup;

    iremotemetadataname_put_parentdataset_method_cleanup:
    self->m_HR = hr;
    if (bspDataset)
        ::SysFreeString(bspDataset);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_ParentDataset");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_ParentDataset(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDataset;
    PyObject* pyvar_pDataset = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDataset

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_ParentDataset(&bspDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_ParentDataset() returned %ld", (long)hr);
        goto iremotemetadataname_get_parentdataset_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pDataset = PyUnicode_FromWideChar(bspDataset,::SysStringLen(bspDataset));
    ::SysFreeString(bspDataset);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_parentdataset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pDataset);
    goto iremotemetadataname_get_parentdataset_method_cleanup;

    iremotemetadataname_get_parentdataset_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pDataset != Py_None)
        Py_XDECREF(pyvar_pDataset);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_ParentDataset");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_ParentOwner(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspOwner = 0;
    PyObject* pyvar_pOwner;
    PyObject* unicodepOwner = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pOwner))
      goto iremotemetadataname_put_parentowner_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pOwner))
        unicodepOwner = PyUnicode_FromObject(pyvar_pOwner);
    else if (PyUnicode_Check(pyvar_pOwner))
    {
        unicodepOwner = pyvar_pOwner;
        Py_INCREF(unicodepOwner);
    }
    else if (pyvar_pOwner != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pOwner at index 0");
    if (unicodepOwner)
        bspOwner = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepOwner), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepOwner));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_parentowner_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_ParentOwner(bspOwner);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_ParentOwner() returned %ld", (long)hr);
        goto iremotemetadataname_put_parentowner_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOwner

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_parentowner_method_cleanup;

    iremotemetadataname_put_parentowner_method_cleanup:
    self->m_HR = hr;
    if (bspOwner)
        ::SysFreeString(bspOwner);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_ParentOwner");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_ParentOwner(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspOwner;
    PyObject* pyvar_pOwner = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pOwner

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_ParentOwner(&bspOwner);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_ParentOwner() returned %ld", (long)hr);
        goto iremotemetadataname_get_parentowner_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pOwner = PyUnicode_FromWideChar(bspOwner,::SysStringLen(bspOwner));
    ::SysFreeString(bspOwner);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_parentowner_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pOwner);
    goto iremotemetadataname_get_parentowner_method_cleanup;

    iremotemetadataname_get_parentowner_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pOwner != Py_None)
        Py_XDECREF(pyvar_pOwner);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_ParentOwner");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_ParentUserID(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspUserID = 0;
    PyObject* pyvar_pUserID;
    PyObject* unicodepUserID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pUserID))
      goto iremotemetadataname_put_parentuserid_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pUserID))
        unicodepUserID = PyUnicode_FromObject(pyvar_pUserID);
    else if (PyUnicode_Check(pyvar_pUserID))
    {
        unicodepUserID = pyvar_pUserID;
        Py_INCREF(unicodepUserID);
    }
    else if (pyvar_pUserID != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pUserID at index 0");
    if (unicodepUserID)
        bspUserID = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepUserID), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepUserID));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_parentuserid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_ParentUserID(bspUserID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_ParentUserID() returned %ld", (long)hr);
        goto iremotemetadataname_put_parentuserid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUserID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_parentuserid_method_cleanup;

    iremotemetadataname_put_parentuserid_method_cleanup:
    self->m_HR = hr;
    if (bspUserID)
        ::SysFreeString(bspUserID);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_ParentUserID");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_ParentUserID(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspUserID;
    PyObject* pyvar_pUserID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pUserID

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_ParentUserID(&bspUserID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_ParentUserID() returned %ld", (long)hr);
        goto iremotemetadataname_get_parentuserid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pUserID = PyUnicode_FromWideChar(bspUserID,::SysStringLen(bspUserID));
    ::SysFreeString(bspUserID);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_parentuserid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pUserID);
    goto iremotemetadataname_get_parentuserid_method_cleanup;

    iremotemetadataname_get_parentuserid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pUserID != Py_None)
        Py_XDECREF(pyvar_pUserID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_ParentUserID");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_MetadataURL(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspUrl = 0;
    PyObject* pyvar_pUrl;
    PyObject* unicodepUrl = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pUrl))
      goto iremotemetadataname_put_metadataurl_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pUrl))
        unicodepUrl = PyUnicode_FromObject(pyvar_pUrl);
    else if (PyUnicode_Check(pyvar_pUrl))
    {
        unicodepUrl = pyvar_pUrl;
        Py_INCREF(unicodepUrl);
    }
    else if (pyvar_pUrl != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pUrl at index 0");
    if (unicodepUrl)
        bspUrl = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepUrl), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepUrl));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_metadataurl_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_MetadataURL(bspUrl);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_MetadataURL() returned %ld", (long)hr);
        goto iremotemetadataname_put_metadataurl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUrl

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_metadataurl_method_cleanup;

    iremotemetadataname_put_metadataurl_method_cleanup:
    self->m_HR = hr;
    if (bspUrl)
        ::SysFreeString(bspUrl);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_MetadataURL");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_MetadataURL(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspUrl;
    PyObject* pyvar_pUrl = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pUrl

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_MetadataURL(&bspUrl);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_MetadataURL() returned %ld", (long)hr);
        goto iremotemetadataname_get_metadataurl_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pUrl = PyUnicode_FromWideChar(bspUrl,::SysStringLen(bspUrl));
    ::SysFreeString(bspUrl);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_metadataurl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pUrl);
    goto iremotemetadataname_get_metadataurl_method_cleanup;

    iremotemetadataname_get_metadataurl_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pUrl != Py_None)
        Py_XDECREF(pyvar_pUrl);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_MetadataURL");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_ThumbnailURL(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspUrl = 0;
    PyObject* pyvar_pUrl;
    PyObject* unicodepUrl = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pUrl))
      goto iremotemetadataname_put_thumbnailurl_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pUrl))
        unicodepUrl = PyUnicode_FromObject(pyvar_pUrl);
    else if (PyUnicode_Check(pyvar_pUrl))
    {
        unicodepUrl = pyvar_pUrl;
        Py_INCREF(unicodepUrl);
    }
    else if (pyvar_pUrl != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pUrl at index 0");
    if (unicodepUrl)
        bspUrl = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepUrl), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepUrl));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_thumbnailurl_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_ThumbnailURL(bspUrl);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_ThumbnailURL() returned %ld", (long)hr);
        goto iremotemetadataname_put_thumbnailurl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUrl

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_thumbnailurl_method_cleanup;

    iremotemetadataname_put_thumbnailurl_method_cleanup:
    self->m_HR = hr;
    if (bspUrl)
        ::SysFreeString(bspUrl);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_ThumbnailURL");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_ThumbnailURL(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspUrl;
    PyObject* pyvar_pUrl = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pUrl

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_ThumbnailURL(&bspUrl);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_ThumbnailURL() returned %ld", (long)hr);
        goto iremotemetadataname_get_thumbnailurl_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pUrl = PyUnicode_FromWideChar(bspUrl,::SysStringLen(bspUrl));
    ::SysFreeString(bspUrl);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_thumbnailurl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pUrl);
    goto iremotemetadataname_get_thumbnailurl_method_cleanup;

    iremotemetadataname_get_thumbnailurl_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pUrl != Py_None)
        Py_XDECREF(pyvar_pUrl);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_ThumbnailURL");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_isFolder(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsFolder = VARIANT_FALSE;
    PyObject* pyvar_pIsFolder = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pIsFolder))
      goto iremotemetadataname_put_isfolder_method_cleanup;

    // Set up initial variable values as needed
    b_pIsFolder = ((PyObject_IsTrue(pyvar_pIsFolder) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_isfolder_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_isFolder(b_pIsFolder);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_isFolder() returned %ld", (long)hr);
        goto iremotemetadataname_put_isfolder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIsFolder

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_isfolder_method_cleanup;

    iremotemetadataname_put_isfolder_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsFolder
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_isFolder");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_isFolder(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsFolder = VARIANT_FALSE;
    PyObject* pyvar_pIsFolder = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIsFolder

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_isFolder(&b_pIsFolder);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_isFolder() returned %ld", (long)hr);
        goto iremotemetadataname_get_isfolder_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pIsFolder = ((b_pIsFolder == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iremotemetadataname_get_isfolder_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pIsFolder);
    goto iremotemetadataname_get_isfolder_method_cleanup;

    iremotemetadataname_get_isfolder_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsFolder
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_isFolder");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_IsRoot(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsRoot = VARIANT_FALSE;
    PyObject* pyvar_pIsRoot = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pIsRoot))
      goto iremotemetadataname_put_isroot_method_cleanup;

    // Set up initial variable values as needed
    b_pIsRoot = ((PyObject_IsTrue(pyvar_pIsRoot) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_isroot_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_IsRoot(b_pIsRoot);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_IsRoot() returned %ld", (long)hr);
        goto iremotemetadataname_put_isroot_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIsRoot

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_isroot_method_cleanup;

    iremotemetadataname_put_isroot_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsRoot
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_IsRoot");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_IsRoot(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsRoot = VARIANT_FALSE;
    PyObject* pyvar_pIsRoot = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIsRoot

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_IsRoot(&b_pIsRoot);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_IsRoot() returned %ld", (long)hr);
        goto iremotemetadataname_get_isroot_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pIsRoot = ((b_pIsRoot == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iremotemetadataname_get_isroot_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pIsRoot);
    goto iremotemetadataname_get_isroot_method_cleanup;

    iremotemetadataname_get_isroot_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsRoot
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_IsRoot");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_IsPrivateDocument(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsPrivate = VARIANT_FALSE;
    PyObject* pyvar_pIsPrivate = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pIsPrivate))
      goto iremotemetadataname_put_isprivatedocument_method_cleanup;

    // Set up initial variable values as needed
    b_pIsPrivate = ((PyObject_IsTrue(pyvar_pIsPrivate) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_isprivatedocument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_IsPrivateDocument(b_pIsPrivate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_IsPrivateDocument() returned %ld", (long)hr);
        goto iremotemetadataname_put_isprivatedocument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIsPrivate

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_isprivatedocument_method_cleanup;

    iremotemetadataname_put_isprivatedocument_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsPrivate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_IsPrivateDocument");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_IsPrivateDocument(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsPrivate = VARIANT_FALSE;
    PyObject* pyvar_pIsPrivate = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIsPrivate

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_IsPrivateDocument(&b_pIsPrivate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_IsPrivateDocument() returned %ld", (long)hr);
        goto iremotemetadataname_get_isprivatedocument_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pIsPrivate = ((b_pIsPrivate == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iremotemetadataname_get_isprivatedocument_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pIsPrivate);
    goto iremotemetadataname_get_isprivatedocument_method_cleanup;

    iremotemetadataname_get_isprivatedocument_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsPrivate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_IsPrivateDocument");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_RefCount(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpRefCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpRefCount))
      goto iremotemetadataname_put_refcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pRefCount

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_RefCount(lpRefCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_RefCount() returned %ld", (long)hr);
        goto iremotemetadataname_put_refcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRefCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_refcount_method_cleanup;

    iremotemetadataname_put_refcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pRefCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_RefCount");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_RefCount(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpRefCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pRefCount

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_RefCount(&lpRefCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_RefCount() returned %ld", (long)hr);
        goto iremotemetadataname_get_refcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRefCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpRefCount);
    goto iremotemetadataname_get_refcount_method_cleanup;

    iremotemetadataname_get_refcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pRefCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_RefCount");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_putref_Extent(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppExtent))
      goto iremotemetadataname_putref_extent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppExtent, &IID_IEnvelope, (void**)&ipppExtent))
        PyErr_SetString(PyExc_TypeError, "Argument ppExtent (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iremotemetadataname_putref_extent_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->putref_Extent(ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.putref_Extent() returned %ld", (long)hr);
        goto iremotemetadataname_putref_extent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppExtent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_putref_extent_method_cleanup;

    iremotemetadataname_putref_extent_method_cleanup:
    self->m_HR = hr;
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.putref_Extent");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_Extent(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExtent

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_Extent(&ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_Extent() returned %ld", (long)hr);
        goto iremotemetadataname_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
    {
        IUnknown* pUnk = NULL;
        ipppExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtent)
    {
        if (py_ppExtent)
           Py_DECREF(py_ppExtent);
        py_ppExtent = Py_None;
        Py_INCREF(py_ppExtent);
    }
    if (PyErr_Occurred())
      goto iremotemetadataname_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExtent);
    goto iremotemetadataname_get_extent_method_cleanup;

    iremotemetadataname_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_Extent");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_Onlink(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsOnlink = 0;
    PyObject* pyvar_Onlink;
    PyObject* unicodeOnlink = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Onlink))
      goto iremotemetadataname_put_onlink_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Onlink))
        unicodeOnlink = PyUnicode_FromObject(pyvar_Onlink);
    else if (PyUnicode_Check(pyvar_Onlink))
    {
        unicodeOnlink = pyvar_Onlink;
        Py_INCREF(unicodeOnlink);
    }
    else if (pyvar_Onlink != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Onlink at index 0");
    if (unicodeOnlink)
        bsOnlink = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeOnlink), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeOnlink));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_onlink_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_Onlink(bsOnlink);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_Onlink() returned %ld", (long)hr);
        goto iremotemetadataname_put_onlink_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Onlink

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_onlink_method_cleanup;

    iremotemetadataname_put_onlink_method_cleanup:
    self->m_HR = hr;
    if (bsOnlink)
        ::SysFreeString(bsOnlink);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_Onlink");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_Onlink(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsOnlink;
    PyObject* pyvar_Onlink = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Onlink

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_Onlink(&bsOnlink);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_Onlink() returned %ld", (long)hr);
        goto iremotemetadataname_get_onlink_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Onlink = PyUnicode_FromWideChar(bsOnlink,::SysStringLen(bsOnlink));
    ::SysFreeString(bsOnlink);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_onlink_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Onlink);
    goto iremotemetadataname_get_onlink_method_cleanup;

    iremotemetadataname_get_onlink_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Onlink != Py_None)
        Py_XDECREF(pyvar_Onlink);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_Onlink");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_server(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsserver = 0;
    PyObject* pyvar_server;
    PyObject* unicodeserver = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_server))
      goto iremotemetadataname_put_server_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_server))
        unicodeserver = PyUnicode_FromObject(pyvar_server);
    else if (PyUnicode_Check(pyvar_server))
    {
        unicodeserver = pyvar_server;
        Py_INCREF(unicodeserver);
    }
    else if (pyvar_server != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter server at index 0");
    if (unicodeserver)
        bsserver = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeserver), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeserver));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_server_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_server(bsserver);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_server() returned %ld", (long)hr);
        goto iremotemetadataname_put_server_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for server

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_server_method_cleanup;

    iremotemetadataname_put_server_method_cleanup:
    self->m_HR = hr;
    if (bsserver)
        ::SysFreeString(bsserver);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_server");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_server(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsserver;
    PyObject* pyvar_server = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for server

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_server(&bsserver);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_server() returned %ld", (long)hr);
        goto iremotemetadataname_get_server_method_cleanup;
    }

    // Set up return values as needed
    pyvar_server = PyUnicode_FromWideChar(bsserver,::SysStringLen(bsserver));
    ::SysFreeString(bsserver);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_server_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_server);
    goto iremotemetadataname_get_server_method_cleanup;

    iremotemetadataname_get_server_method_cleanup:
    self->m_HR = hr;
    if (pyvar_server != Py_None)
        Py_XDECREF(pyvar_server);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_server");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_Service(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsService = 0;
    PyObject* pyvar_Service;
    PyObject* unicodeService = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Service))
      goto iremotemetadataname_put_service_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Service))
        unicodeService = PyUnicode_FromObject(pyvar_Service);
    else if (PyUnicode_Check(pyvar_Service))
    {
        unicodeService = pyvar_Service;
        Py_INCREF(unicodeService);
    }
    else if (pyvar_Service != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Service at index 0");
    if (unicodeService)
        bsService = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeService), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeService));
    
    if (PyErr_Occurred())
      goto iremotemetadataname_put_service_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_Service(bsService);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_Service() returned %ld", (long)hr);
        goto iremotemetadataname_put_service_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Service

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_service_method_cleanup;

    iremotemetadataname_put_service_method_cleanup:
    self->m_HR = hr;
    if (bsService)
        ::SysFreeString(bsService);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_Service");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_Service(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsService;
    PyObject* pyvar_Service = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Service

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_Service(&bsService);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_Service() returned %ld", (long)hr);
        goto iremotemetadataname_get_service_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Service = PyUnicode_FromWideChar(bsService,::SysStringLen(bsService));
    ::SysFreeString(bsService);
    
    if (PyErr_Occurred())
      goto iremotemetadataname_get_service_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Service);
    goto iremotemetadataname_get_service_method_cleanup;

    iremotemetadataname_get_service_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Service != Py_None)
        Py_XDECREF(pyvar_Service);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_Service");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_get_IndexStatus(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acIndexStatus epIndexStatus;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIndexStatus

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->get_IndexStatus(&epIndexStatus);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.get_IndexStatus() returned %ld", (long)hr);
        goto iremotemetadataname_get_indexstatus_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIndexStatus

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epIndexStatus);
    goto iremotemetadataname_get_indexstatus_method_cleanup;

    iremotemetadataname_get_indexstatus_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIndexStatus
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.get_IndexStatus");
    return return_tuple;
}

static PyObject*
IRemoteMetadataNameMethod_put_IndexStatus(PyIRemoteMetadataNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    acIndexStatus epIndexStatus;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epIndexStatus))
      goto iremotemetadataname_put_indexstatus_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pIndexStatus

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName->put_IndexStatus(epIndexStatus);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName.put_IndexStatus() returned %ld", (long)hr);
        goto iremotemetadataname_put_indexstatus_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIndexStatus

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname_put_indexstatus_method_cleanup;

    iremotemetadataname_put_indexstatus_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIndexStatus
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName.put_IndexStatus");
    return return_tuple;
}


PyMethodDef PyIRemoteMetadataNameMethods[] = {
    {"supports", (PyCFunction)PyIRemoteMetadataName_SupportsInterface, METH_O, ""},
    {"put_Dataset", (PyCFunction)IRemoteMetadataNameMethod_put_Dataset, METH_VARARGS, ""},
    {"get_Dataset", (PyCFunction)IRemoteMetadataNameMethod_get_Dataset, METH_VARARGS, ""},
    {"put_Owner", (PyCFunction)IRemoteMetadataNameMethod_put_Owner, METH_VARARGS, ""},
    {"get_Owner", (PyCFunction)IRemoteMetadataNameMethod_get_Owner, METH_VARARGS, ""},
    {"put_UserID", (PyCFunction)IRemoteMetadataNameMethod_put_UserID, METH_VARARGS, ""},
    {"get_UserID", (PyCFunction)IRemoteMetadataNameMethod_get_UserID, METH_VARARGS, ""},
    {"put_ParentDataset", (PyCFunction)IRemoteMetadataNameMethod_put_ParentDataset, METH_VARARGS, ""},
    {"get_ParentDataset", (PyCFunction)IRemoteMetadataNameMethod_get_ParentDataset, METH_VARARGS, ""},
    {"put_ParentOwner", (PyCFunction)IRemoteMetadataNameMethod_put_ParentOwner, METH_VARARGS, ""},
    {"get_ParentOwner", (PyCFunction)IRemoteMetadataNameMethod_get_ParentOwner, METH_VARARGS, ""},
    {"put_ParentUserID", (PyCFunction)IRemoteMetadataNameMethod_put_ParentUserID, METH_VARARGS, ""},
    {"get_ParentUserID", (PyCFunction)IRemoteMetadataNameMethod_get_ParentUserID, METH_VARARGS, ""},
    {"put_MetadataURL", (PyCFunction)IRemoteMetadataNameMethod_put_MetadataURL, METH_VARARGS, ""},
    {"get_MetadataURL", (PyCFunction)IRemoteMetadataNameMethod_get_MetadataURL, METH_VARARGS, ""},
    {"put_ThumbnailURL", (PyCFunction)IRemoteMetadataNameMethod_put_ThumbnailURL, METH_VARARGS, ""},
    {"get_ThumbnailURL", (PyCFunction)IRemoteMetadataNameMethod_get_ThumbnailURL, METH_VARARGS, ""},
    {"put_isFolder", (PyCFunction)IRemoteMetadataNameMethod_put_isFolder, METH_VARARGS, ""},
    {"get_isFolder", (PyCFunction)IRemoteMetadataNameMethod_get_isFolder, METH_VARARGS, ""},
    {"put_IsRoot", (PyCFunction)IRemoteMetadataNameMethod_put_IsRoot, METH_VARARGS, ""},
    {"get_IsRoot", (PyCFunction)IRemoteMetadataNameMethod_get_IsRoot, METH_VARARGS, ""},
    {"put_IsPrivateDocument", (PyCFunction)IRemoteMetadataNameMethod_put_IsPrivateDocument, METH_VARARGS, ""},
    {"get_IsPrivateDocument", (PyCFunction)IRemoteMetadataNameMethod_get_IsPrivateDocument, METH_VARARGS, ""},
    {"put_RefCount", (PyCFunction)IRemoteMetadataNameMethod_put_RefCount, METH_VARARGS, ""},
    {"get_RefCount", (PyCFunction)IRemoteMetadataNameMethod_get_RefCount, METH_VARARGS, ""},
    {"putref_Extent", (PyCFunction)IRemoteMetadataNameMethod_putref_Extent, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)IRemoteMetadataNameMethod_get_Extent, METH_VARARGS, ""},
    {"put_Onlink", (PyCFunction)IRemoteMetadataNameMethod_put_Onlink, METH_VARARGS, ""},
    {"get_Onlink", (PyCFunction)IRemoteMetadataNameMethod_get_Onlink, METH_VARARGS, ""},
    {"put_server", (PyCFunction)IRemoteMetadataNameMethod_put_server, METH_VARARGS, ""},
    {"get_server", (PyCFunction)IRemoteMetadataNameMethod_get_server, METH_VARARGS, ""},
    {"put_Service", (PyCFunction)IRemoteMetadataNameMethod_put_Service, METH_VARARGS, ""},
    {"get_Service", (PyCFunction)IRemoteMetadataNameMethod_get_Service, METH_VARARGS, ""},
    {"get_IndexStatus", (PyCFunction)IRemoteMetadataNameMethod_get_IndexStatus, METH_VARARGS, ""},
    {"put_IndexStatus", (PyCFunction)IRemoteMetadataNameMethod_put_IndexStatus, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIRemoteMetadataNameGetSet[] = {
  {"_pUnk", (getter)PyIRemoteMetadataName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IRemoteMetadataName", NULL},
  {"_pointer", (getter)PyIRemoteMetadataName_GetPointer, NULL, "Get memory address for IRemoteMetadataName", NULL},
  {"_IID", (getter)PyIRemoteMetadataName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIRemoteMetadataName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIRemoteMetadataName_GetIgnoreFailures, (setter)PyIRemoteMetadataName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIRemoteMetadataNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IRemoteMetadataNameObject",                          
                                              /* tp_name */
  sizeof(PyIRemoteMetadataNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIRemoteMetadataNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIRemoteMetadataNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIRemoteMetadataNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIRemoteMetadataNameObject_new,                      
                                              /* tp_new */
};

// Interface IRemoteMetadataName2

typedef struct PyIRemoteMetadataName2Object {
    PyObject_HEAD
    IRemoteMetadataName2* m_pIRemoteMetadataName2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIRemoteMetadataName2Object;

static PyObject*
PyIRemoteMetadataName2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIRemoteMetadataName2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IRemoteMetadataName2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IRemoteMetadataName2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IRemoteMetadataName2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIRemoteMetadataName2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IRemoteMetadataName2");
            return NULL;
        }
        self->m_pIRemoteMetadataName2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IRemoteMetadataName2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IRemoteMetadataName2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IRemoteMetadataName2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IRemoteMetadataName2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IRemoteMetadataName2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIRemoteMetadataName2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IRemoteMetadataName2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIRemoteMetadataName2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIRemoteMetadataName2Object_dealloc(PyIRemoteMetadataName2Object* self)
{
    if (self->m_pIRemoteMetadataName2)
        self->m_pIRemoteMetadataName2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIRemoteMetadataName2_GetpUnk(PyIRemoteMetadataName2Object* self)
{
    if (!self->m_pIRemoteMetadataName2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIRemoteMetadataName2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IRemoteMetadataName2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIRemoteMetadataName2_GetPointer(PyIRemoteMetadataName2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIRemoteMetadataName2);
}

static PyObject*
PyIRemoteMetadataName2_GetIID(PyIRemoteMetadataName2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "edc3739d-807f-47ea-978d-e6ae0fc67018");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIRemoteMetadataName2_GetHR(PyIRemoteMetadataName2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIRemoteMetadataName2_GetIgnoreFailures(PyIRemoteMetadataName2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIRemoteMetadataName2_SetIgnoreFailures(PyIRemoteMetadataName2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIRemoteMetadataName2_SupportsInterface(PyIRemoteMetadataName2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIRemoteMetadataName2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IRemoteMetadataName2Method_get_ContentType(PyIRemoteMetadataName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspContentType;
    PyObject* pyvar_pContentType = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pContentType

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName2->get_ContentType(&bspContentType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName2.get_ContentType() returned %ld", (long)hr);
        goto iremotemetadataname2_get_contenttype_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pContentType = PyUnicode_FromWideChar(bspContentType,::SysStringLen(bspContentType));
    ::SysFreeString(bspContentType);
    
    if (PyErr_Occurred())
      goto iremotemetadataname2_get_contenttype_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pContentType);
    goto iremotemetadataname2_get_contenttype_method_cleanup;

    iremotemetadataname2_get_contenttype_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pContentType != Py_None)
        Py_XDECREF(pyvar_pContentType);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName2.get_ContentType");
    return return_tuple;
}

static PyObject*
IRemoteMetadataName2Method_put_ContentType(PyIRemoteMetadataName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspContentType = 0;
    PyObject* pyvar_pContentType;
    PyObject* unicodepContentType = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pContentType))
      goto iremotemetadataname2_put_contenttype_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pContentType))
        unicodepContentType = PyUnicode_FromObject(pyvar_pContentType);
    else if (PyUnicode_Check(pyvar_pContentType))
    {
        unicodepContentType = pyvar_pContentType;
        Py_INCREF(unicodepContentType);
    }
    else if (pyvar_pContentType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pContentType at index 0");
    if (unicodepContentType)
        bspContentType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepContentType), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepContentType));
    
    if (PyErr_Occurred())
      goto iremotemetadataname2_put_contenttype_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName2->put_ContentType(bspContentType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName2.put_ContentType() returned %ld", (long)hr);
        goto iremotemetadataname2_put_contenttype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pContentType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname2_put_contenttype_method_cleanup;

    iremotemetadataname2_put_contenttype_method_cleanup:
    self->m_HR = hr;
    if (bspContentType)
        ::SysFreeString(bspContentType);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName2.put_ContentType");
    return return_tuple;
}

static PyObject*
IRemoteMetadataName2Method_get_ModifiedTime(PyIRemoteMetadataName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspModifiedTime;
    PyObject* pyvar_pModifiedTime = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pModifiedTime

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName2->get_ModifiedTime(&bspModifiedTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName2.get_ModifiedTime() returned %ld", (long)hr);
        goto iremotemetadataname2_get_modifiedtime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pModifiedTime = PyUnicode_FromWideChar(bspModifiedTime,::SysStringLen(bspModifiedTime));
    ::SysFreeString(bspModifiedTime);
    
    if (PyErr_Occurred())
      goto iremotemetadataname2_get_modifiedtime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pModifiedTime);
    goto iremotemetadataname2_get_modifiedtime_method_cleanup;

    iremotemetadataname2_get_modifiedtime_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pModifiedTime != Py_None)
        Py_XDECREF(pyvar_pModifiedTime);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName2.get_ModifiedTime");
    return return_tuple;
}

static PyObject*
IRemoteMetadataName2Method_put_ModifiedTime(PyIRemoteMetadataName2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspModifiedTime = 0;
    PyObject* pyvar_pModifiedTime;
    PyObject* unicodepModifiedTime = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pModifiedTime))
      goto iremotemetadataname2_put_modifiedtime_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pModifiedTime))
        unicodepModifiedTime = PyUnicode_FromObject(pyvar_pModifiedTime);
    else if (PyUnicode_Check(pyvar_pModifiedTime))
    {
        unicodepModifiedTime = pyvar_pModifiedTime;
        Py_INCREF(unicodepModifiedTime);
    }
    else if (pyvar_pModifiedTime != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pModifiedTime at index 0");
    if (unicodepModifiedTime)
        bspModifiedTime = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepModifiedTime), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepModifiedTime));
    
    if (PyErr_Occurred())
      goto iremotemetadataname2_put_modifiedtime_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIRemoteMetadataName2->put_ModifiedTime(bspModifiedTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIRemoteMetadataName2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IRemoteMetadataName2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IRemoteMetadataName2.put_ModifiedTime() returned %ld", (long)hr);
        goto iremotemetadataname2_put_modifiedtime_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pModifiedTime

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iremotemetadataname2_put_modifiedtime_method_cleanup;

    iremotemetadataname2_put_modifiedtime_method_cleanup:
    self->m_HR = hr;
    if (bspModifiedTime)
        ::SysFreeString(bspModifiedTime);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IRemoteMetadataName2.put_ModifiedTime");
    return return_tuple;
}


PyMethodDef PyIRemoteMetadataName2Methods[] = {
    {"supports", (PyCFunction)PyIRemoteMetadataName2_SupportsInterface, METH_O, ""},
    {"get_ContentType", (PyCFunction)IRemoteMetadataName2Method_get_ContentType, METH_VARARGS, ""},
    {"put_ContentType", (PyCFunction)IRemoteMetadataName2Method_put_ContentType, METH_VARARGS, ""},
    {"get_ModifiedTime", (PyCFunction)IRemoteMetadataName2Method_get_ModifiedTime, METH_VARARGS, ""},
    {"put_ModifiedTime", (PyCFunction)IRemoteMetadataName2Method_put_ModifiedTime, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIRemoteMetadataName2GetSet[] = {
  {"_pUnk", (getter)PyIRemoteMetadataName2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IRemoteMetadataName2", NULL},
  {"_pointer", (getter)PyIRemoteMetadataName2_GetPointer, NULL, "Get memory address for IRemoteMetadataName2", NULL},
  {"_IID", (getter)PyIRemoteMetadataName2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIRemoteMetadataName2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIRemoteMetadataName2_GetIgnoreFailures, (setter)PyIRemoteMetadataName2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIRemoteMetadataName2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IRemoteMetadataName2Object",                          
                                              /* tp_name */
  sizeof(PyIRemoteMetadataName2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIRemoteMetadataName2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIRemoteMetadataName2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIRemoteMetadataName2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIRemoteMetadataName2Object_new,                      
                                              /* tp_new */
};

// Interface IIMSMetadataAxlRequest

typedef struct PyIIMSMetadataAxlRequestObject {
    PyObject_HEAD
    IIMSMetadataAxlRequest* m_pIIMSMetadataAxlRequest;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIIMSMetadataAxlRequestObject;

static PyObject*
PyIIMSMetadataAxlRequestObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIIMSMetadataAxlRequestObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IIMSMetadataAxlRequest* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IIMSMetadataAxlRequest, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IIMSMetadataAxlRequest with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIIMSMetadataAxlRequestObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSMetadataAxlRequest");
            return NULL;
        }
        self->m_pIIMSMetadataAxlRequest = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IIMSMetadataAxlRequest");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IIMSMetadataAxlRequest");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IIMSMetadataAxlRequest* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IIMSMetadataAxlRequest, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IIMSMetadataAxlRequest");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIIMSMetadataAxlRequestObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IIMSMetadataAxlRequest");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIIMSMetadataAxlRequest = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIIMSMetadataAxlRequestObject_dealloc(PyIIMSMetadataAxlRequestObject* self)
{
    if (self->m_pIIMSMetadataAxlRequest)
        self->m_pIIMSMetadataAxlRequest->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIIMSMetadataAxlRequest_GetpUnk(PyIIMSMetadataAxlRequestObject* self)
{
    if (!self->m_pIIMSMetadataAxlRequest)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIIMSMetadataAxlRequest->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IIMSMetadataAxlRequest to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIIMSMetadataAxlRequest_GetPointer(PyIIMSMetadataAxlRequestObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIIMSMetadataAxlRequest);
}

static PyObject*
PyIIMSMetadataAxlRequest_GetIID(PyIIMSMetadataAxlRequestObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "64c58b58-b932-4f91-8a60-4a85964af693");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIIMSMetadataAxlRequest_GetHR(PyIIMSMetadataAxlRequestObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIIMSMetadataAxlRequest_GetIgnoreFailures(PyIIMSMetadataAxlRequestObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIIMSMetadataAxlRequest_SetIgnoreFailures(PyIIMSMetadataAxlRequestObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIIMSMetadataAxlRequest_SupportsInterface(PyIIMSMetadataAxlRequestObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIIMSMetadataAxlRequest->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IIMSMetadataAxlRequestMethod_SendMetadataAxlRequest(PyIIMSMetadataAxlRequestObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAxl = 0;
    PyObject* pyvar_Axl;
    PyObject* unicodeAxl = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    BSTR bsresponse;
    PyObject* pyvar_response = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_Axl, &py_pTrackCancel))
      goto iimsmetadataaxlrequest_sendmetadataaxlrequest_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Axl))
        unicodeAxl = PyUnicode_FromObject(pyvar_Axl);
    else if (PyUnicode_Check(pyvar_Axl))
    {
        unicodeAxl = pyvar_Axl;
        Py_INCREF(unicodeAxl);
    }
    else if (pyvar_Axl != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Axl at index 0");
    if (unicodeAxl)
        bsAxl = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeAxl), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeAxl));
    
    if (PyErr_Occurred())
      goto iimsmetadataaxlrequest_sendmetadataaxlrequest_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 1) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iimsmetadataaxlrequest_sendmetadataaxlrequest_method_cleanup;
    
    // No setup for response

    // Call method on actual COM interface
    hr = self->m_pIIMSMetadataAxlRequest->SendMetadataAxlRequest(bsAxl, ippTrackCancel, &bsresponse);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIIMSMetadataAxlRequest->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IIMSMetadataAxlRequest) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IIMSMetadataAxlRequest.SendMetadataAxlRequest() returned %ld", (long)hr);
        goto iimsmetadataaxlrequest_sendmetadataaxlrequest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Axl
    // No teardown for pTrackCancel
    pyvar_response = PyUnicode_FromWideChar(bsresponse,::SysStringLen(bsresponse));
    ::SysFreeString(bsresponse);
    
    if (PyErr_Occurred())
      goto iimsmetadataaxlrequest_sendmetadataaxlrequest_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_response);
    goto iimsmetadataaxlrequest_sendmetadataaxlrequest_method_cleanup;

    iimsmetadataaxlrequest_sendmetadataaxlrequest_method_cleanup:
    self->m_HR = hr;
    if (bsAxl)
        ::SysFreeString(bsAxl);
    
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (pyvar_response != Py_None)
        Py_XDECREF(pyvar_response);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IIMSMetadataAxlRequest.SendMetadataAxlRequest");
    return return_tuple;
}


PyMethodDef PyIIMSMetadataAxlRequestMethods[] = {
    {"supports", (PyCFunction)PyIIMSMetadataAxlRequest_SupportsInterface, METH_O, ""},
    {"SendMetadataAxlRequest", (PyCFunction)IIMSMetadataAxlRequestMethod_SendMetadataAxlRequest, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIIMSMetadataAxlRequestGetSet[] = {
  {"_pUnk", (getter)PyIIMSMetadataAxlRequest_GetpUnk, NULL, "Get opaque pointer to an Unknown from IIMSMetadataAxlRequest", NULL},
  {"_pointer", (getter)PyIIMSMetadataAxlRequest_GetPointer, NULL, "Get memory address for IIMSMetadataAxlRequest", NULL},
  {"_IID", (getter)PyIIMSMetadataAxlRequest_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIIMSMetadataAxlRequest_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIIMSMetadataAxlRequest_GetIgnoreFailures, (setter)PyIIMSMetadataAxlRequest_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIIMSMetadataAxlRequestObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IIMSMetadataAxlRequestObject",                          
                                              /* tp_name */
  sizeof(PyIIMSMetadataAxlRequestObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIIMSMetadataAxlRequestObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIIMSMetadataAxlRequestMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIIMSMetadataAxlRequestGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIIMSMetadataAxlRequestObject_new,                      
                                              /* tp_new */
};

// Interface IWMSLayerStyleDescription

typedef struct PyIWMSLayerStyleDescriptionObject {
    PyObject_HEAD
    IWMSLayerStyleDescription* m_pIWMSLayerStyleDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMSLayerStyleDescriptionObject;

static PyObject*
PyIWMSLayerStyleDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMSLayerStyleDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMSLayerStyleDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMSLayerStyleDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMSLayerStyleDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMSLayerStyleDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSLayerStyleDescription");
            return NULL;
        }
        self->m_pIWMSLayerStyleDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMSLayerStyleDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMSLayerStyleDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMSLayerStyleDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMSLayerStyleDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMSLayerStyleDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMSLayerStyleDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSLayerStyleDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMSLayerStyleDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMSLayerStyleDescriptionObject_dealloc(PyIWMSLayerStyleDescriptionObject* self)
{
    if (self->m_pIWMSLayerStyleDescription)
        self->m_pIWMSLayerStyleDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMSLayerStyleDescription_GetpUnk(PyIWMSLayerStyleDescriptionObject* self)
{
    if (!self->m_pIWMSLayerStyleDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMSLayerStyleDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMSLayerStyleDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMSLayerStyleDescription_GetPointer(PyIWMSLayerStyleDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMSLayerStyleDescription);
}

static PyObject*
PyIWMSLayerStyleDescription_GetIID(PyIWMSLayerStyleDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0e5d8d4c-a8cd-4eb9-a311-af312dc308bc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMSLayerStyleDescription_GetHR(PyIWMSLayerStyleDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMSLayerStyleDescription_GetIgnoreFailures(PyIWMSLayerStyleDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMSLayerStyleDescription_SetIgnoreFailures(PyIWMSLayerStyleDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMSLayerStyleDescription_SupportsInterface(PyIWMSLayerStyleDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMSLayerStyleDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMSLayerStyleDescriptionMethod_get_Name(PyIWMSLayerStyleDescriptionObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'BSTR', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IWMSLayerStyleDescription.get_Name not implemented.");
    return NULL;
}

static PyObject*
IWMSLayerStyleDescriptionMethod_get_Title(PyIWMSLayerStyleDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerStyleDescription->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerStyleDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerStyleDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerStyleDescription.get_Title() returned %ld", (long)hr);
        goto iwmslayerstyledescription_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmslayerstyledescription_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmslayerstyledescription_get_title_method_cleanup;

    iwmslayerstyledescription_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerStyleDescription.get_Title");
    return return_tuple;
}

static PyObject*
IWMSLayerStyleDescriptionMethod_get_Abstract(PyIWMSLayerStyleDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerStyleDescription->get_Abstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerStyleDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerStyleDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerStyleDescription.get_Abstract() returned %ld", (long)hr);
        goto iwmslayerstyledescription_get_abstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwmslayerstyledescription_get_abstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwmslayerstyledescription_get_abstract_method_cleanup;

    iwmslayerstyledescription_get_abstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerStyleDescription.get_Abstract");
    return return_tuple;
}

static PyObject*
IWMSLayerStyleDescriptionMethod_get_Width(PyIWMSLayerStyleDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerStyleDescription->get_Width(&dWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerStyleDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerStyleDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerStyleDescription.get_Width() returned %ld", (long)hr);
        goto iwmslayerstyledescription_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dWidth);
    goto iwmslayerstyledescription_get_width_method_cleanup;

    iwmslayerstyledescription_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerStyleDescription.get_Width");
    return return_tuple;
}

static PyObject*
IWMSLayerStyleDescriptionMethod_get_Height(PyIWMSLayerStyleDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerStyleDescription->get_Height(&dHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerStyleDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerStyleDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerStyleDescription.get_Height() returned %ld", (long)hr);
        goto iwmslayerstyledescription_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dHeight);
    goto iwmslayerstyledescription_get_height_method_cleanup;

    iwmslayerstyledescription_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerStyleDescription.get_Height");
    return return_tuple;
}

static PyObject*
IWMSLayerStyleDescriptionMethod_get_URL(PyIWMSLayerStyleDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL;
    PyObject* pyvar_URL = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for URL

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerStyleDescription->get_URL(&bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerStyleDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerStyleDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerStyleDescription.get_URL() returned %ld", (long)hr);
        goto iwmslayerstyledescription_get_url_method_cleanup;
    }

    // Set up return values as needed
    pyvar_URL = PyUnicode_FromWideChar(bsURL,::SysStringLen(bsURL));
    ::SysFreeString(bsURL);
    
    if (PyErr_Occurred())
      goto iwmslayerstyledescription_get_url_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_URL);
    goto iwmslayerstyledescription_get_url_method_cleanup;

    iwmslayerstyledescription_get_url_method_cleanup:
    self->m_HR = hr;
    if (pyvar_URL != Py_None)
        Py_XDECREF(pyvar_URL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerStyleDescription.get_URL");
    return return_tuple;
}

static PyObject*
IWMSLayerStyleDescriptionMethod_get_ImageFormatCount(PyIWMSLayerStyleDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerStyleDescription->get_ImageFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerStyleDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerStyleDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerStyleDescription.get_ImageFormatCount() returned %ld", (long)hr);
        goto iwmslayerstyledescription_get_imageformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmslayerstyledescription_get_imageformatcount_method_cleanup;

    iwmslayerstyledescription_get_imageformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerStyleDescription.get_ImageFormatCount");
    return return_tuple;
}

static PyObject*
IWMSLayerStyleDescriptionMethod_get_ImageFormat(PyIWMSLayerStyleDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmslayerstyledescription_get_imageformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerStyleDescription->get_ImageFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerStyleDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerStyleDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerStyleDescription.get_ImageFormat() returned %ld", (long)hr);
        goto iwmslayerstyledescription_get_imageformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmslayerstyledescription_get_imageformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmslayerstyledescription_get_imageformat_method_cleanup;

    iwmslayerstyledescription_get_imageformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerStyleDescription.get_ImageFormat");
    return return_tuple;
}


PyMethodDef PyIWMSLayerStyleDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIWMSLayerStyleDescription_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IWMSLayerStyleDescriptionMethod_get_Name, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IWMSLayerStyleDescriptionMethod_get_Title, METH_VARARGS, ""},
    {"get_Abstract", (PyCFunction)IWMSLayerStyleDescriptionMethod_get_Abstract, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IWMSLayerStyleDescriptionMethod_get_Width, METH_VARARGS, ""},
    {"get_Height", (PyCFunction)IWMSLayerStyleDescriptionMethod_get_Height, METH_VARARGS, ""},
    {"get_URL", (PyCFunction)IWMSLayerStyleDescriptionMethod_get_URL, METH_VARARGS, ""},
    {"get_ImageFormatCount", (PyCFunction)IWMSLayerStyleDescriptionMethod_get_ImageFormatCount, METH_VARARGS, ""},
    {"get_ImageFormat", (PyCFunction)IWMSLayerStyleDescriptionMethod_get_ImageFormat, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMSLayerStyleDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIWMSLayerStyleDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMSLayerStyleDescription", NULL},
  {"_pointer", (getter)PyIWMSLayerStyleDescription_GetPointer, NULL, "Get memory address for IWMSLayerStyleDescription", NULL},
  {"_IID", (getter)PyIWMSLayerStyleDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMSLayerStyleDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMSLayerStyleDescription_GetIgnoreFailures, (setter)PyIWMSLayerStyleDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMSLayerStyleDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMSLayerStyleDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIWMSLayerStyleDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMSLayerStyleDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMSLayerStyleDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMSLayerStyleDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMSLayerStyleDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IWMSLayerDescription

typedef struct PyIWMSLayerDescriptionObject {
    PyObject_HEAD
    IWMSLayerDescription* m_pIWMSLayerDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMSLayerDescriptionObject;

static PyObject*
PyIWMSLayerDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMSLayerDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMSLayerDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMSLayerDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMSLayerDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMSLayerDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSLayerDescription");
            return NULL;
        }
        self->m_pIWMSLayerDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMSLayerDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMSLayerDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMSLayerDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMSLayerDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMSLayerDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMSLayerDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSLayerDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMSLayerDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMSLayerDescriptionObject_dealloc(PyIWMSLayerDescriptionObject* self)
{
    if (self->m_pIWMSLayerDescription)
        self->m_pIWMSLayerDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMSLayerDescription_GetpUnk(PyIWMSLayerDescriptionObject* self)
{
    if (!self->m_pIWMSLayerDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMSLayerDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMSLayerDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMSLayerDescription_GetPointer(PyIWMSLayerDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMSLayerDescription);
}

static PyObject*
PyIWMSLayerDescription_GetIID(PyIWMSLayerDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2290f5ac-8561-4b1d-8fda-482a063f1ef4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMSLayerDescription_GetHR(PyIWMSLayerDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMSLayerDescription_GetIgnoreFailures(PyIWMSLayerDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMSLayerDescription_SetIgnoreFailures(PyIWMSLayerDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMSLayerDescription_SupportsInterface(PyIWMSLayerDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMSLayerDescriptionMethod_get_Name(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_Name() returned %ld", (long)hr);
        goto iwmslayerdescription_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwmslayerdescription_get_name_method_cleanup;

    iwmslayerdescription_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_Name");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_Title(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_Title() returned %ld", (long)hr);
        goto iwmslayerdescription_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmslayerdescription_get_title_method_cleanup;

    iwmslayerdescription_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_Title");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_Abstract(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_Abstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_Abstract() returned %ld", (long)hr);
        goto iwmslayerdescription_get_abstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_abstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwmslayerdescription_get_abstract_method_cleanup;

    iwmslayerdescription_get_abstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_Abstract");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_IsQueryable(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_isQuaryable = VARIANT_FALSE;
    PyObject* pyvar_isQuaryable = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for isQuaryable

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_IsQueryable(&b_isQuaryable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_IsQueryable() returned %ld", (long)hr);
        goto iwmslayerdescription_get_isqueryable_method_cleanup;
    }

    // Set up return values as needed
    pyvar_isQuaryable = ((b_isQuaryable == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_isqueryable_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isQuaryable);
    goto iwmslayerdescription_get_isqueryable_method_cleanup;

    iwmslayerdescription_get_isqueryable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for isQuaryable
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_IsQueryable");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_IsOpaque(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsOpaque = VARIANT_FALSE;
    PyObject* pyvar_IsOpaque = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsOpaque

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_IsOpaque(&b_IsOpaque);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_IsOpaque() returned %ld", (long)hr);
        goto iwmslayerdescription_get_isopaque_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsOpaque = ((b_IsOpaque == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_isopaque_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsOpaque);
    goto iwmslayerdescription_get_isopaque_method_cleanup;

    iwmslayerdescription_get_isopaque_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsOpaque
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_IsOpaque");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_IsCascaded(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIsCascaded = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsCascaded

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_IsCascaded(&lIsCascaded);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_IsCascaded() returned %ld", (long)hr);
        goto iwmslayerdescription_get_iscascaded_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for IsCascaded

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lIsCascaded);
    goto iwmslayerdescription_get_iscascaded_method_cleanup;

    iwmslayerdescription_get_iscascaded_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsCascaded
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_IsCascaded");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_IsSubsettable(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsSubsettable = VARIANT_FALSE;
    PyObject* pyvar_IsSubsettable = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsSubsettable

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_IsSubsettable(&b_IsSubsettable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_IsSubsettable() returned %ld", (long)hr);
        goto iwmslayerdescription_get_issubsettable_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsSubsettable = ((b_IsSubsettable == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_issubsettable_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsSubsettable);
    goto iwmslayerdescription_get_issubsettable_method_cleanup;

    iwmslayerdescription_get_issubsettable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsSubsettable
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_IsSubsettable");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_FixedWidth(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_FixedWidth(&dWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_FixedWidth() returned %ld", (long)hr);
        goto iwmslayerdescription_get_fixedwidth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dWidth);
    goto iwmslayerdescription_get_fixedwidth_method_cleanup;

    iwmslayerdescription_get_fixedwidth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_FixedWidth");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_FixedHeight(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_FixedHeight(&dHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_FixedHeight() returned %ld", (long)hr);
        goto iwmslayerdescription_get_fixedheight_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dHeight);
    goto iwmslayerdescription_get_fixedheight_method_cleanup;

    iwmslayerdescription_get_fixedheight_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_FixedHeight");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_LayerDescriptionCount(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_LayerDescriptionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_LayerDescriptionCount() returned %ld", (long)hr);
        goto iwmslayerdescription_get_layerdescriptioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmslayerdescription_get_layerdescriptioncount_method_cleanup;

    iwmslayerdescription_get_layerdescriptioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_LayerDescriptionCount");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_LayerDescription(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMSLayerDescription* ipppLayerDescription = NULL;
    PyObject* py_ppLayerDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmslayerdescription_get_layerdescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppLayerDescription

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_LayerDescription(lindex, &ipppLayerDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_LayerDescription() returned %ld", (long)hr);
        goto iwmslayerdescription_get_layerdescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppLayerDescription);
    if (ipppLayerDescription)
    {
        IUnknown* pUnk = NULL;
        ipppLayerDescription->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppLayerDescription = IUnknownToPythonIIDObject(pUnk, &IID_IWMSLayerDescription);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppLayerDescription)
    {
        if (py_ppLayerDescription)
           Py_DECREF(py_ppLayerDescription);
        py_ppLayerDescription = Py_None;
        Py_INCREF(py_ppLayerDescription);
    }
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_layerdescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppLayerDescription);
    goto iwmslayerdescription_get_layerdescription_method_cleanup;

    iwmslayerdescription_get_layerdescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppLayerDescription);
    if (ipppLayerDescription)
      ipppLayerDescription->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_LayerDescription");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_ScaleHintMin(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dScale = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Scale

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_ScaleHintMin(&dScale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_ScaleHintMin() returned %ld", (long)hr);
        goto iwmslayerdescription_get_scalehintmin_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Scale

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dScale);
    goto iwmslayerdescription_get_scalehintmin_method_cleanup;

    iwmslayerdescription_get_scalehintmin_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Scale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_ScaleHintMin");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_ScaleHintMax(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dScale = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Scale

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_ScaleHintMax(&dScale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_ScaleHintMax() returned %ld", (long)hr);
        goto iwmslayerdescription_get_scalehintmax_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Scale

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dScale);
    goto iwmslayerdescription_get_scalehintmax_method_cleanup;

    iwmslayerdescription_get_scalehintmax_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Scale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_ScaleHintMax");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_LatLongBoundingBox(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipenvelope = NULL;
    PyObject* py_envelope = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for envelope

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_LatLongBoundingBox(&ipenvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_LatLongBoundingBox() returned %ld", (long)hr);
        goto iwmslayerdescription_get_latlongboundingbox_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_envelope);
    if (ipenvelope)
    {
        IUnknown* pUnk = NULL;
        ipenvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_envelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_envelope)
    {
        if (py_envelope)
           Py_DECREF(py_envelope);
        py_envelope = Py_None;
        Py_INCREF(py_envelope);
    }
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_latlongboundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_envelope);
    goto iwmslayerdescription_get_latlongboundingbox_method_cleanup;

    iwmslayerdescription_get_latlongboundingbox_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_envelope);
    if (ipenvelope)
      ipenvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_LatLongBoundingBox");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_BoundingBoxCount(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_BoundingBoxCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_BoundingBoxCount() returned %ld", (long)hr);
        goto iwmslayerdescription_get_boundingboxcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmslayerdescription_get_boundingboxcount_method_cleanup;

    iwmslayerdescription_get_boundingboxcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_BoundingBoxCount");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_BoundingBox(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ipenvelope = NULL;
    PyObject* py_envelope = NULL;
    BSTR bssrsCode;
    PyObject* pyvar_srsCode = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmslayerdescription_get_boundingbox_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for envelope
    // No setup for srsCode

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_BoundingBox(lindex, &ipenvelope, &bssrsCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_BoundingBox() returned %ld", (long)hr);
        goto iwmslayerdescription_get_boundingbox_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_envelope);
    if (ipenvelope)
    {
        IUnknown* pUnk = NULL;
        ipenvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_envelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_envelope)
    {
        if (py_envelope)
           Py_DECREF(py_envelope);
        py_envelope = Py_None;
        Py_INCREF(py_envelope);
    }
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_boundingbox_method_cleanup;
    
    pyvar_srsCode = PyUnicode_FromWideChar(bssrsCode,::SysStringLen(bssrsCode));
    ::SysFreeString(bssrsCode);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_boundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_envelope, pyvar_srsCode);
    goto iwmslayerdescription_get_boundingbox_method_cleanup;

    iwmslayerdescription_get_boundingbox_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_envelope);
    if (ipenvelope)
      ipenvelope->Release();
    if (pyvar_srsCode != Py_None)
        Py_XDECREF(pyvar_srsCode);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_BoundingBox");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_StyleDescriptionCount(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_StyleDescriptionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_StyleDescriptionCount() returned %ld", (long)hr);
        goto iwmslayerdescription_get_styledescriptioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmslayerdescription_get_styledescriptioncount_method_cleanup;

    iwmslayerdescription_get_styledescriptioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_StyleDescriptionCount");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_StyleDescription(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMSLayerStyleDescription* ipStyleDescription = NULL;
    PyObject* py_StyleDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmslayerdescription_get_styledescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for StyleDescription

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_StyleDescription(lindex, &ipStyleDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_StyleDescription() returned %ld", (long)hr);
        goto iwmslayerdescription_get_styledescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_StyleDescription);
    if (ipStyleDescription)
    {
        IUnknown* pUnk = NULL;
        ipStyleDescription->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_StyleDescription = IUnknownToPythonIIDObject(pUnk, &IID_IWMSLayerStyleDescription);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_StyleDescription)
    {
        if (py_StyleDescription)
           Py_DECREF(py_StyleDescription);
        py_StyleDescription = Py_None;
        Py_INCREF(py_StyleDescription);
    }
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_styledescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_StyleDescription);
    goto iwmslayerdescription_get_styledescription_method_cleanup;

    iwmslayerdescription_get_styledescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_StyleDescription);
    if (ipStyleDescription)
      ipStyleDescription->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_StyleDescription");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_SRSCount(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_SRSCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_SRSCount() returned %ld", (long)hr);
        goto iwmslayerdescription_get_srscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmslayerdescription_get_srscount_method_cleanup;

    iwmslayerdescription_get_srscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_SRSCount");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_SRS(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsSRS;
    PyObject* pyvar_SRS = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmslayerdescription_get_srs_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for SRS

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_SRS(lindex, &bsSRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_SRS() returned %ld", (long)hr);
        goto iwmslayerdescription_get_srs_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_SRS = PyUnicode_FromWideChar(bsSRS,::SysStringLen(bsSRS));
    ::SysFreeString(bsSRS);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_srs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_SRS);
    goto iwmslayerdescription_get_srs_method_cleanup;

    iwmslayerdescription_get_srs_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_SRS != Py_None)
        Py_XDECREF(pyvar_SRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_SRS");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_WMSVersion(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsWMSVersion;
    PyObject* pyvar_WMSVersion = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for WMSVersion

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_WMSVersion(&bsWMSVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_WMSVersion() returned %ld", (long)hr);
        goto iwmslayerdescription_get_wmsversion_method_cleanup;
    }

    // Set up return values as needed
    pyvar_WMSVersion = PyUnicode_FromWideChar(bsWMSVersion,::SysStringLen(bsWMSVersion));
    ::SysFreeString(bsWMSVersion);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_wmsversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_WMSVersion);
    goto iwmslayerdescription_get_wmsversion_method_cleanup;

    iwmslayerdescription_get_wmsversion_method_cleanup:
    self->m_HR = hr;
    if (pyvar_WMSVersion != Py_None)
        Py_XDECREF(pyvar_WMSVersion);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_WMSVersion");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_ImageFormatCount(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_ImageFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_ImageFormatCount() returned %ld", (long)hr);
        goto iwmslayerdescription_get_imageformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmslayerdescription_get_imageformatcount_method_cleanup;

    iwmslayerdescription_get_imageformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_ImageFormatCount");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_ImageFormat(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmslayerdescription_get_imageformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_ImageFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_ImageFormat() returned %ld", (long)hr);
        goto iwmslayerdescription_get_imageformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_imageformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmslayerdescription_get_imageformat_method_cleanup;

    iwmslayerdescription_get_imageformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_ImageFormat");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_FeatureInfoFormatCount(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_FeatureInfoFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_FeatureInfoFormatCount() returned %ld", (long)hr);
        goto iwmslayerdescription_get_featureinfoformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmslayerdescription_get_featureinfoformatcount_method_cleanup;

    iwmslayerdescription_get_featureinfoformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_FeatureInfoFormatCount");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_FeatureInfoFormat(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmslayerdescription_get_featureinfoformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_FeatureInfoFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_FeatureInfoFormat() returned %ld", (long)hr);
        goto iwmslayerdescription_get_featureinfoformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_featureinfoformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmslayerdescription_get_featureinfoformat_method_cleanup;

    iwmslayerdescription_get_featureinfoformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_FeatureInfoFormat");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_ExceptionFormatCount(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_ExceptionFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_ExceptionFormatCount() returned %ld", (long)hr);
        goto iwmslayerdescription_get_exceptionformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmslayerdescription_get_exceptionformatcount_method_cleanup;

    iwmslayerdescription_get_exceptionformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_ExceptionFormatCount");
    return return_tuple;
}

static PyObject*
IWMSLayerDescriptionMethod_get_ExceptionFormat(PyIWMSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsExceptionFormat;
    PyObject* pyvar_ExceptionFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmslayerdescription_get_exceptionformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ExceptionFormat

    // Call method on actual COM interface
    hr = self->m_pIWMSLayerDescription->get_ExceptionFormat(lindex, &bsExceptionFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSLayerDescription.get_ExceptionFormat() returned %ld", (long)hr);
        goto iwmslayerdescription_get_exceptionformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ExceptionFormat = PyUnicode_FromWideChar(bsExceptionFormat,::SysStringLen(bsExceptionFormat));
    ::SysFreeString(bsExceptionFormat);
    
    if (PyErr_Occurred())
      goto iwmslayerdescription_get_exceptionformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ExceptionFormat);
    goto iwmslayerdescription_get_exceptionformat_method_cleanup;

    iwmslayerdescription_get_exceptionformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ExceptionFormat != Py_None)
        Py_XDECREF(pyvar_ExceptionFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSLayerDescription.get_ExceptionFormat");
    return return_tuple;
}


PyMethodDef PyIWMSLayerDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIWMSLayerDescription_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IWMSLayerDescriptionMethod_get_Name, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IWMSLayerDescriptionMethod_get_Title, METH_VARARGS, ""},
    {"get_Abstract", (PyCFunction)IWMSLayerDescriptionMethod_get_Abstract, METH_VARARGS, ""},
    {"get_IsQueryable", (PyCFunction)IWMSLayerDescriptionMethod_get_IsQueryable, METH_VARARGS, ""},
    {"get_IsOpaque", (PyCFunction)IWMSLayerDescriptionMethod_get_IsOpaque, METH_VARARGS, ""},
    {"get_IsCascaded", (PyCFunction)IWMSLayerDescriptionMethod_get_IsCascaded, METH_VARARGS, ""},
    {"get_IsSubsettable", (PyCFunction)IWMSLayerDescriptionMethod_get_IsSubsettable, METH_VARARGS, ""},
    {"get_FixedWidth", (PyCFunction)IWMSLayerDescriptionMethod_get_FixedWidth, METH_VARARGS, ""},
    {"get_FixedHeight", (PyCFunction)IWMSLayerDescriptionMethod_get_FixedHeight, METH_VARARGS, ""},
    {"get_LayerDescriptionCount", (PyCFunction)IWMSLayerDescriptionMethod_get_LayerDescriptionCount, METH_VARARGS, ""},
    {"get_LayerDescription", (PyCFunction)IWMSLayerDescriptionMethod_get_LayerDescription, METH_VARARGS, ""},
    {"get_ScaleHintMin", (PyCFunction)IWMSLayerDescriptionMethod_get_ScaleHintMin, METH_VARARGS, ""},
    {"get_ScaleHintMax", (PyCFunction)IWMSLayerDescriptionMethod_get_ScaleHintMax, METH_VARARGS, ""},
    {"get_LatLongBoundingBox", (PyCFunction)IWMSLayerDescriptionMethod_get_LatLongBoundingBox, METH_VARARGS, ""},
    {"get_BoundingBoxCount", (PyCFunction)IWMSLayerDescriptionMethod_get_BoundingBoxCount, METH_VARARGS, ""},
    {"get_BoundingBox", (PyCFunction)IWMSLayerDescriptionMethod_get_BoundingBox, METH_VARARGS, ""},
    {"get_StyleDescriptionCount", (PyCFunction)IWMSLayerDescriptionMethod_get_StyleDescriptionCount, METH_VARARGS, ""},
    {"get_StyleDescription", (PyCFunction)IWMSLayerDescriptionMethod_get_StyleDescription, METH_VARARGS, ""},
    {"get_SRSCount", (PyCFunction)IWMSLayerDescriptionMethod_get_SRSCount, METH_VARARGS, ""},
    {"get_SRS", (PyCFunction)IWMSLayerDescriptionMethod_get_SRS, METH_VARARGS, ""},
    {"get_WMSVersion", (PyCFunction)IWMSLayerDescriptionMethod_get_WMSVersion, METH_VARARGS, ""},
    {"get_ImageFormatCount", (PyCFunction)IWMSLayerDescriptionMethod_get_ImageFormatCount, METH_VARARGS, ""},
    {"get_ImageFormat", (PyCFunction)IWMSLayerDescriptionMethod_get_ImageFormat, METH_VARARGS, ""},
    {"get_FeatureInfoFormatCount", (PyCFunction)IWMSLayerDescriptionMethod_get_FeatureInfoFormatCount, METH_VARARGS, ""},
    {"get_FeatureInfoFormat", (PyCFunction)IWMSLayerDescriptionMethod_get_FeatureInfoFormat, METH_VARARGS, ""},
    {"get_ExceptionFormatCount", (PyCFunction)IWMSLayerDescriptionMethod_get_ExceptionFormatCount, METH_VARARGS, ""},
    {"get_ExceptionFormat", (PyCFunction)IWMSLayerDescriptionMethod_get_ExceptionFormat, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMSLayerDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIWMSLayerDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMSLayerDescription", NULL},
  {"_pointer", (getter)PyIWMSLayerDescription_GetPointer, NULL, "Get memory address for IWMSLayerDescription", NULL},
  {"_IID", (getter)PyIWMSLayerDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMSLayerDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMSLayerDescription_GetIgnoreFailures, (setter)PyIWMSLayerDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMSLayerDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMSLayerDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIWMSLayerDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMSLayerDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMSLayerDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMSLayerDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMSLayerDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IWCSConnectionName

typedef struct PyIWCSConnectionNameObject {
    PyObject_HEAD
    IWCSConnectionName* m_pIWCSConnectionName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSConnectionNameObject;

static PyObject*
PyIWCSConnectionNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSConnectionNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSConnectionName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSConnectionName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSConnectionName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSConnectionNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSConnectionName");
            return NULL;
        }
        self->m_pIWCSConnectionName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSConnectionName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSConnectionName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSConnectionName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSConnectionNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSConnectionName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSConnectionName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSConnectionNameObject_dealloc(PyIWCSConnectionNameObject* self)
{
    if (self->m_pIWCSConnectionName)
        self->m_pIWCSConnectionName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSConnectionName_GetpUnk(PyIWCSConnectionNameObject* self)
{
    if (!self->m_pIWCSConnectionName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSConnectionName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSConnectionName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSConnectionName_GetPointer(PyIWCSConnectionNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSConnectionName);
}

static PyObject*
PyIWCSConnectionName_GetIID(PyIWCSConnectionNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e1a24fde-e0cb-4c17-bdc0-b5520df063cb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSConnectionName_GetHR(PyIWCSConnectionNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSConnectionName_GetIgnoreFailures(PyIWCSConnectionNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSConnectionName_SetIgnoreFailures(PyIWCSConnectionNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSConnectionName_SupportsInterface(PyIWCSConnectionNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSConnectionName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSConnectionNameMethod_put_ConnectionProperties(PyIWCSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnProps = NULL;
    PyObject* py_ppConnProps;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppConnProps))
      goto iwcsconnectionname_put_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppConnProps, &IID_IPropertySet, (void**)&ipppConnProps))
        PyErr_SetString(PyExc_TypeError, "Argument ppConnProps (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iwcsconnectionname_put_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSConnectionName->put_ConnectionProperties(ipppConnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnectionName.put_ConnectionProperties() returned %ld", (long)hr);
        goto iwcsconnectionname_put_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppConnProps

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsconnectionname_put_connectionproperties_method_cleanup;

    iwcsconnectionname_put_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipppConnProps)
      ipppConnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnectionName.put_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IWCSConnectionNameMethod_get_ConnectionProperties(PyIWCSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnProps = NULL;
    PyObject* py_ppConnProps = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppConnProps

    // Call method on actual COM interface
    hr = self->m_pIWCSConnectionName->get_ConnectionProperties(&ipppConnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnectionName.get_ConnectionProperties() returned %ld", (long)hr);
        goto iwcsconnectionname_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppConnProps);
    if (ipppConnProps)
    {
        IUnknown* pUnk = NULL;
        ipppConnProps->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnProps = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnProps)
    {
        if (py_ppConnProps)
           Py_DECREF(py_ppConnProps);
        py_ppConnProps = Py_None;
        Py_INCREF(py_ppConnProps);
    }
    if (PyErr_Occurred())
      goto iwcsconnectionname_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnProps);
    goto iwcsconnectionname_get_connectionproperties_method_cleanup;

    iwcsconnectionname_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppConnProps);
    if (ipppConnProps)
      ipppConnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnectionName.get_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IWCSConnectionNameMethod_put_ConnectionInfo(PyIWCSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnInfo = NULL;
    PyObject* py_ppConnInfo;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppConnInfo))
      goto iwcsconnectionname_put_connectioninfo_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppConnInfo, &IID_IPropertySet, (void**)&ipppConnInfo))
        PyErr_SetString(PyExc_TypeError, "Argument ppConnInfo (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iwcsconnectionname_put_connectioninfo_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSConnectionName->put_ConnectionInfo(ipppConnInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnectionName.put_ConnectionInfo() returned %ld", (long)hr);
        goto iwcsconnectionname_put_connectioninfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppConnInfo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsconnectionname_put_connectioninfo_method_cleanup;

    iwcsconnectionname_put_connectioninfo_method_cleanup:
    self->m_HR = hr;
    if (ipppConnInfo)
      ipppConnInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnectionName.put_ConnectionInfo");
    return return_tuple;
}

static PyObject*
IWCSConnectionNameMethod_get_ConnectionInfo(PyIWCSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppConnInfo = NULL;
    PyObject* py_ppConnInfo = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppConnInfo

    // Call method on actual COM interface
    hr = self->m_pIWCSConnectionName->get_ConnectionInfo(&ipppConnInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnectionName.get_ConnectionInfo() returned %ld", (long)hr);
        goto iwcsconnectionname_get_connectioninfo_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppConnInfo);
    if (ipppConnInfo)
    {
        IUnknown* pUnk = NULL;
        ipppConnInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnInfo = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnInfo)
    {
        if (py_ppConnInfo)
           Py_DECREF(py_ppConnInfo);
        py_ppConnInfo = Py_None;
        Py_INCREF(py_ppConnInfo);
    }
    if (PyErr_Occurred())
      goto iwcsconnectionname_get_connectioninfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnInfo);
    goto iwcsconnectionname_get_connectioninfo_method_cleanup;

    iwcsconnectionname_get_connectioninfo_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppConnInfo);
    if (ipppConnInfo)
      ipppConnInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnectionName.get_ConnectionInfo");
    return return_tuple;
}

static PyObject*
IWCSConnectionNameMethod_OpenEx(PyIWCSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IUnknown* ipppUnknown = NULL;
    PyObject* py_ppUnknown = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto iwcsconnectionname_openex_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iwcsconnectionname_openex_method_cleanup;
    
    // No setup for ppUnknown

    // Call method on actual COM interface
    hr = self->m_pIWCSConnectionName->OpenEx(ippTrackCancel, &ipppUnknown);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnectionName.OpenEx() returned %ld", (long)hr);
        goto iwcsconnectionname_openex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppUnknown);
    if (ipppUnknown)
    {
        IUnknown* pUnk = NULL;
        ipppUnknown->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUnknown = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUnknown)
    {
        if (py_ppUnknown)
           Py_DECREF(py_ppUnknown);
        py_ppUnknown = Py_None;
        Py_INCREF(py_ppUnknown);
    }
    if (PyErr_Occurred())
      goto iwcsconnectionname_openex_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUnknown);
    goto iwcsconnectionname_openex_method_cleanup;

    iwcsconnectionname_openex_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppUnknown);
    if (ipppUnknown)
      ipppUnknown->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnectionName.OpenEx");
    return return_tuple;
}


PyMethodDef PyIWCSConnectionNameMethods[] = {
    {"supports", (PyCFunction)PyIWCSConnectionName_SupportsInterface, METH_O, ""},
    {"put_ConnectionProperties", (PyCFunction)IWCSConnectionNameMethod_put_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IWCSConnectionNameMethod_get_ConnectionProperties, METH_VARARGS, ""},
    {"put_ConnectionInfo", (PyCFunction)IWCSConnectionNameMethod_put_ConnectionInfo, METH_VARARGS, ""},
    {"get_ConnectionInfo", (PyCFunction)IWCSConnectionNameMethod_get_ConnectionInfo, METH_VARARGS, ""},
    {"OpenEx", (PyCFunction)IWCSConnectionNameMethod_OpenEx, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSConnectionNameGetSet[] = {
  {"_pUnk", (getter)PyIWCSConnectionName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSConnectionName", NULL},
  {"_pointer", (getter)PyIWCSConnectionName_GetPointer, NULL, "Get memory address for IWCSConnectionName", NULL},
  {"_IID", (getter)PyIWCSConnectionName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSConnectionName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSConnectionName_GetIgnoreFailures, (setter)PyIWCSConnectionName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSConnectionNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSConnectionNameObject",                          
                                              /* tp_name */
  sizeof(PyIWCSConnectionNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSConnectionNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSConnectionNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSConnectionNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSConnectionNameObject_new,                      
                                              /* tp_new */
};

// Interface IWCSCoverageName

typedef struct PyIWCSCoverageNameObject {
    PyObject_HEAD
    IWCSCoverageName* m_pIWCSCoverageName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSCoverageNameObject;

static PyObject*
PyIWCSCoverageNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSCoverageNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSCoverageName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSCoverageName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSCoverageName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSCoverageNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSCoverageName");
            return NULL;
        }
        self->m_pIWCSCoverageName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSCoverageName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSCoverageName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSCoverageName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSCoverageName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSCoverageName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSCoverageNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSCoverageName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSCoverageName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSCoverageNameObject_dealloc(PyIWCSCoverageNameObject* self)
{
    if (self->m_pIWCSCoverageName)
        self->m_pIWCSCoverageName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSCoverageName_GetpUnk(PyIWCSCoverageNameObject* self)
{
    if (!self->m_pIWCSCoverageName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSCoverageName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSCoverageName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSCoverageName_GetPointer(PyIWCSCoverageNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSCoverageName);
}

static PyObject*
PyIWCSCoverageName_GetIID(PyIWCSCoverageNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cb717bf3-f1ec-4beb-a6c8-ec80a11e9010");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSCoverageName_GetHR(PyIWCSCoverageNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSCoverageName_GetIgnoreFailures(PyIWCSCoverageNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSCoverageName_SetIgnoreFailures(PyIWCSCoverageNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSCoverageName_SupportsInterface(PyIWCSCoverageNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSCoverageName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSCoverageNameMethod_put_Name(PyIWCSCoverageNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iwcscoveragename_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iwcscoveragename_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageName->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageName.put_Name() returned %ld", (long)hr);
        goto iwcscoveragename_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcscoveragename_put_name_method_cleanup;

    iwcscoveragename_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageName.put_Name");
    return return_tuple;
}

static PyObject*
IWCSCoverageNameMethod_get_Name(PyIWCSCoverageNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageName->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageName.get_Name() returned %ld", (long)hr);
        goto iwcscoveragename_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwcscoveragename_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwcscoveragename_get_name_method_cleanup;

    iwcscoveragename_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageName.get_Name");
    return return_tuple;
}

static PyObject*
IWCSCoverageNameMethod_get_WCSConnectionName(PyIWCSCoverageNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWCSConnectionName* ipppServerConnName = NULL;
    PyObject* py_ppServerConnName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppServerConnName

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageName->get_WCSConnectionName(&ipppServerConnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageName.get_WCSConnectionName() returned %ld", (long)hr);
        goto iwcscoveragename_get_wcsconnectionname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppServerConnName);
    if (ipppServerConnName)
    {
        IUnknown* pUnk = NULL;
        ipppServerConnName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppServerConnName = IUnknownToPythonIIDObject(pUnk, &IID_IWCSConnectionName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppServerConnName)
    {
        if (py_ppServerConnName)
           Py_DECREF(py_ppServerConnName);
        py_ppServerConnName = Py_None;
        Py_INCREF(py_ppServerConnName);
    }
    if (PyErr_Occurred())
      goto iwcscoveragename_get_wcsconnectionname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppServerConnName);
    goto iwcscoveragename_get_wcsconnectionname_method_cleanup;

    iwcscoveragename_get_wcsconnectionname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppServerConnName);
    if (ipppServerConnName)
      ipppServerConnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageName.get_WCSConnectionName");
    return return_tuple;
}

static PyObject*
IWCSCoverageNameMethod_putref_WCSConnectionName(PyIWCSCoverageNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWCSConnectionName* ipppServerConnName = NULL;
    PyObject* py_ppServerConnName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppServerConnName))
      goto iwcscoveragename_putref_wcsconnectionname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppServerConnName, &IID_IWCSConnectionName, (void**)&ipppServerConnName))
        PyErr_SetString(PyExc_TypeError, "Argument ppServerConnName (position 0) is not IWCSConnectionName");
    
    if (PyErr_Occurred())
      goto iwcscoveragename_putref_wcsconnectionname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageName->putref_WCSConnectionName(ipppServerConnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageName.putref_WCSConnectionName() returned %ld", (long)hr);
        goto iwcscoveragename_putref_wcsconnectionname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppServerConnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcscoveragename_putref_wcsconnectionname_method_cleanup;

    iwcscoveragename_putref_wcsconnectionname_method_cleanup:
    self->m_HR = hr;
    if (ipppServerConnName)
      ipppServerConnName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageName.putref_WCSConnectionName");
    return return_tuple;
}


PyMethodDef PyIWCSCoverageNameMethods[] = {
    {"supports", (PyCFunction)PyIWCSCoverageName_SupportsInterface, METH_O, ""},
    {"put_Name", (PyCFunction)IWCSCoverageNameMethod_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IWCSCoverageNameMethod_get_Name, METH_VARARGS, ""},
    {"get_WCSConnectionName", (PyCFunction)IWCSCoverageNameMethod_get_WCSConnectionName, METH_VARARGS, ""},
    {"putref_WCSConnectionName", (PyCFunction)IWCSCoverageNameMethod_putref_WCSConnectionName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSCoverageNameGetSet[] = {
  {"_pUnk", (getter)PyIWCSCoverageName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSCoverageName", NULL},
  {"_pointer", (getter)PyIWCSCoverageName_GetPointer, NULL, "Get memory address for IWCSCoverageName", NULL},
  {"_IID", (getter)PyIWCSCoverageName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSCoverageName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSCoverageName_GetIgnoreFailures, (setter)PyIWCSCoverageName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSCoverageNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSCoverageNameObject",                          
                                              /* tp_name */
  sizeof(PyIWCSCoverageNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSCoverageNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSCoverageNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSCoverageNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSCoverageNameObject_new,                      
                                              /* tp_new */
};

// Interface IWCSBoundingBoxInfo

typedef struct PyIWCSBoundingBoxInfoObject {
    PyObject_HEAD
    IWCSBoundingBoxInfo* m_pIWCSBoundingBoxInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSBoundingBoxInfoObject;

static PyObject*
PyIWCSBoundingBoxInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSBoundingBoxInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSBoundingBoxInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSBoundingBoxInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSBoundingBoxInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSBoundingBoxInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSBoundingBoxInfo");
            return NULL;
        }
        self->m_pIWCSBoundingBoxInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSBoundingBoxInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSBoundingBoxInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSBoundingBoxInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSBoundingBoxInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSBoundingBoxInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSBoundingBoxInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSBoundingBoxInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSBoundingBoxInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSBoundingBoxInfoObject_dealloc(PyIWCSBoundingBoxInfoObject* self)
{
    if (self->m_pIWCSBoundingBoxInfo)
        self->m_pIWCSBoundingBoxInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSBoundingBoxInfo_GetpUnk(PyIWCSBoundingBoxInfoObject* self)
{
    if (!self->m_pIWCSBoundingBoxInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSBoundingBoxInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSBoundingBoxInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSBoundingBoxInfo_GetPointer(PyIWCSBoundingBoxInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSBoundingBoxInfo);
}

static PyObject*
PyIWCSBoundingBoxInfo_GetIID(PyIWCSBoundingBoxInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ed79b15f-9133-4d1c-8bac-170562b5ff9d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSBoundingBoxInfo_GetHR(PyIWCSBoundingBoxInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSBoundingBoxInfo_GetIgnoreFailures(PyIWCSBoundingBoxInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSBoundingBoxInfo_SetIgnoreFailures(PyIWCSBoundingBoxInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSBoundingBoxInfo_SupportsInterface(PyIWCSBoundingBoxInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSBoundingBoxInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSBoundingBoxInfoMethod_get_CRS(PyIWCSBoundingBoxInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCRS;
    PyObject* pyvar_CRS = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CRS

    // Call method on actual COM interface
    hr = self->m_pIWCSBoundingBoxInfo->get_CRS(&bsCRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSBoundingBoxInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSBoundingBoxInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSBoundingBoxInfo.get_CRS() returned %ld", (long)hr);
        goto iwcsboundingboxinfo_get_crs_method_cleanup;
    }

    // Set up return values as needed
    pyvar_CRS = PyUnicode_FromWideChar(bsCRS,::SysStringLen(bsCRS));
    ::SysFreeString(bsCRS);
    
    if (PyErr_Occurred())
      goto iwcsboundingboxinfo_get_crs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CRS);
    goto iwcsboundingboxinfo_get_crs_method_cleanup;

    iwcsboundingboxinfo_get_crs_method_cleanup:
    self->m_HR = hr;
    if (pyvar_CRS != Py_None)
        Py_XDECREF(pyvar_CRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSBoundingBoxInfo.get_CRS");
    return return_tuple;
}

static PyObject*
IWCSBoundingBoxInfoMethod_get_BoundingBox(PyIWCSBoundingBoxInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppEnvelope = NULL;
    PyObject* py_ppEnvelope = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppEnvelope

    // Call method on actual COM interface
    hr = self->m_pIWCSBoundingBoxInfo->get_BoundingBox(&ipppEnvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSBoundingBoxInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSBoundingBoxInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSBoundingBoxInfo.get_BoundingBox() returned %ld", (long)hr);
        goto iwcsboundingboxinfo_get_boundingbox_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
    {
        IUnknown* pUnk = NULL;
        ipppEnvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppEnvelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppEnvelope)
    {
        if (py_ppEnvelope)
           Py_DECREF(py_ppEnvelope);
        py_ppEnvelope = Py_None;
        Py_INCREF(py_ppEnvelope);
    }
    if (PyErr_Occurred())
      goto iwcsboundingboxinfo_get_boundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppEnvelope);
    goto iwcsboundingboxinfo_get_boundingbox_method_cleanup;

    iwcsboundingboxinfo_get_boundingbox_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
      ipppEnvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSBoundingBoxInfo.get_BoundingBox");
    return return_tuple;
}


PyMethodDef PyIWCSBoundingBoxInfoMethods[] = {
    {"supports", (PyCFunction)PyIWCSBoundingBoxInfo_SupportsInterface, METH_O, ""},
    {"get_CRS", (PyCFunction)IWCSBoundingBoxInfoMethod_get_CRS, METH_VARARGS, ""},
    {"get_BoundingBox", (PyCFunction)IWCSBoundingBoxInfoMethod_get_BoundingBox, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSBoundingBoxInfoGetSet[] = {
  {"_pUnk", (getter)PyIWCSBoundingBoxInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSBoundingBoxInfo", NULL},
  {"_pointer", (getter)PyIWCSBoundingBoxInfo_GetPointer, NULL, "Get memory address for IWCSBoundingBoxInfo", NULL},
  {"_IID", (getter)PyIWCSBoundingBoxInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSBoundingBoxInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSBoundingBoxInfo_GetIgnoreFailures, (setter)PyIWCSBoundingBoxInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSBoundingBoxInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSBoundingBoxInfoObject",                          
                                              /* tp_name */
  sizeof(PyIWCSBoundingBoxInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSBoundingBoxInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSBoundingBoxInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSBoundingBoxInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSBoundingBoxInfoObject_new,                      
                                              /* tp_new */
};

// Interface IWCSSpatialDomain

typedef struct PyIWCSSpatialDomainObject {
    PyObject_HEAD
    IWCSSpatialDomain* m_pIWCSSpatialDomain;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSSpatialDomainObject;

static PyObject*
PyIWCSSpatialDomainObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSSpatialDomainObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSSpatialDomain* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSSpatialDomain, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSSpatialDomain with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSSpatialDomainObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSSpatialDomain");
            return NULL;
        }
        self->m_pIWCSSpatialDomain = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSSpatialDomain");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSSpatialDomain");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSSpatialDomain* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSSpatialDomain, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSSpatialDomain");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSSpatialDomainObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSSpatialDomain");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSSpatialDomain = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSSpatialDomainObject_dealloc(PyIWCSSpatialDomainObject* self)
{
    if (self->m_pIWCSSpatialDomain)
        self->m_pIWCSSpatialDomain->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSSpatialDomain_GetpUnk(PyIWCSSpatialDomainObject* self)
{
    if (!self->m_pIWCSSpatialDomain)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSSpatialDomain->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSSpatialDomain to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSSpatialDomain_GetPointer(PyIWCSSpatialDomainObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSSpatialDomain);
}

static PyObject*
PyIWCSSpatialDomain_GetIID(PyIWCSSpatialDomainObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b7ec7893-efb4-4b61-8fe0-e746cf0422b5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSSpatialDomain_GetHR(PyIWCSSpatialDomainObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSSpatialDomain_GetIgnoreFailures(PyIWCSSpatialDomainObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSSpatialDomain_SetIgnoreFailures(PyIWCSSpatialDomainObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSSpatialDomain_SupportsInterface(PyIWCSSpatialDomainObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSSpatialDomainMethod_get_BoundingBoxInfoCount(PyIWCSSpatialDomainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSSpatialDomain->get_BoundingBoxInfoCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSSpatialDomain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSSpatialDomain.get_BoundingBoxInfoCount() returned %ld", (long)hr);
        goto iwcsspatialdomain_get_boundingboxinfocount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcsspatialdomain_get_boundingboxinfocount_method_cleanup;

    iwcsspatialdomain_get_boundingboxinfocount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSSpatialDomain.get_BoundingBoxInfoCount");
    return return_tuple;
}

static PyObject*
IWCSSpatialDomainMethod_get_BoundingBoxInfo(PyIWCSSpatialDomainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWCSBoundingBoxInfo* ipppWCSBBInfo = NULL;
    PyObject* py_ppWCSBBInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcsspatialdomain_get_boundingboxinfo_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppWCSBBInfo

    // Call method on actual COM interface
    hr = self->m_pIWCSSpatialDomain->get_BoundingBoxInfo(lindex, &ipppWCSBBInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSSpatialDomain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSSpatialDomain.get_BoundingBoxInfo() returned %ld", (long)hr);
        goto iwcsspatialdomain_get_boundingboxinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppWCSBBInfo);
    if (ipppWCSBBInfo)
    {
        IUnknown* pUnk = NULL;
        ipppWCSBBInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppWCSBBInfo = IUnknownToPythonIIDObject(pUnk, &IID_IWCSBoundingBoxInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppWCSBBInfo)
    {
        if (py_ppWCSBBInfo)
           Py_DECREF(py_ppWCSBBInfo);
        py_ppWCSBBInfo = Py_None;
        Py_INCREF(py_ppWCSBBInfo);
    }
    if (PyErr_Occurred())
      goto iwcsspatialdomain_get_boundingboxinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppWCSBBInfo);
    goto iwcsspatialdomain_get_boundingboxinfo_method_cleanup;

    iwcsspatialdomain_get_boundingboxinfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppWCSBBInfo);
    if (ipppWCSBBInfo)
      ipppWCSBBInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSSpatialDomain.get_BoundingBoxInfo");
    return return_tuple;
}

static PyObject*
IWCSSpatialDomainMethod_get_GridBaseCRS(PyIWCSSpatialDomainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCRS;
    PyObject* pyvar_CRS = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CRS

    // Call method on actual COM interface
    hr = self->m_pIWCSSpatialDomain->get_GridBaseCRS(&bsCRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSSpatialDomain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSSpatialDomain.get_GridBaseCRS() returned %ld", (long)hr);
        goto iwcsspatialdomain_get_gridbasecrs_method_cleanup;
    }

    // Set up return values as needed
    pyvar_CRS = PyUnicode_FromWideChar(bsCRS,::SysStringLen(bsCRS));
    ::SysFreeString(bsCRS);
    
    if (PyErr_Occurred())
      goto iwcsspatialdomain_get_gridbasecrs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CRS);
    goto iwcsspatialdomain_get_gridbasecrs_method_cleanup;

    iwcsspatialdomain_get_gridbasecrs_method_cleanup:
    self->m_HR = hr;
    if (pyvar_CRS != Py_None)
        Py_XDECREF(pyvar_CRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSSpatialDomain.get_GridBaseCRS");
    return return_tuple;
}

static PyObject*
IWCSSpatialDomainMethod_get_GridOrigin_X(PyIWCSSpatialDomainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dx = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for x

    // Call method on actual COM interface
    hr = self->m_pIWCSSpatialDomain->get_GridOrigin_X(&dx);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSSpatialDomain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSSpatialDomain.get_GridOrigin_X() returned %ld", (long)hr);
        goto iwcsspatialdomain_get_gridorigin_x_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for x

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dx);
    goto iwcsspatialdomain_get_gridorigin_x_method_cleanup;

    iwcsspatialdomain_get_gridorigin_x_method_cleanup:
    self->m_HR = hr;
    // No cleanup for x
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSSpatialDomain.get_GridOrigin_X");
    return return_tuple;
}

static PyObject*
IWCSSpatialDomainMethod_get_GridOrigin_Y(PyIWCSSpatialDomainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dy = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for y

    // Call method on actual COM interface
    hr = self->m_pIWCSSpatialDomain->get_GridOrigin_Y(&dy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSSpatialDomain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSSpatialDomain.get_GridOrigin_Y() returned %ld", (long)hr);
        goto iwcsspatialdomain_get_gridorigin_y_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for y

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dy);
    goto iwcsspatialdomain_get_gridorigin_y_method_cleanup;

    iwcsspatialdomain_get_gridorigin_y_method_cleanup:
    self->m_HR = hr;
    // No cleanup for y
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSSpatialDomain.get_GridOrigin_Y");
    return return_tuple;
}

static PyObject*
IWCSSpatialDomainMethod_get_GridOffsets_X(PyIWCSSpatialDomainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dx = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for x

    // Call method on actual COM interface
    hr = self->m_pIWCSSpatialDomain->get_GridOffsets_X(&dx);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSSpatialDomain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSSpatialDomain.get_GridOffsets_X() returned %ld", (long)hr);
        goto iwcsspatialdomain_get_gridoffsets_x_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for x

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dx);
    goto iwcsspatialdomain_get_gridoffsets_x_method_cleanup;

    iwcsspatialdomain_get_gridoffsets_x_method_cleanup:
    self->m_HR = hr;
    // No cleanup for x
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSSpatialDomain.get_GridOffsets_X");
    return return_tuple;
}

static PyObject*
IWCSSpatialDomainMethod_get_GridOffsets_Y(PyIWCSSpatialDomainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dy = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for y

    // Call method on actual COM interface
    hr = self->m_pIWCSSpatialDomain->get_GridOffsets_Y(&dy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSSpatialDomain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSSpatialDomain.get_GridOffsets_Y() returned %ld", (long)hr);
        goto iwcsspatialdomain_get_gridoffsets_y_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for y

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dy);
    goto iwcsspatialdomain_get_gridoffsets_y_method_cleanup;

    iwcsspatialdomain_get_gridoffsets_y_method_cleanup:
    self->m_HR = hr;
    // No cleanup for y
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSSpatialDomain.get_GridOffsets_Y");
    return return_tuple;
}

static PyObject*
IWCSSpatialDomainMethod_get_GridOffsetsBoundingBox(PyIWCSSpatialDomainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppEnvelope = NULL;
    PyObject* py_ppEnvelope = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppEnvelope

    // Call method on actual COM interface
    hr = self->m_pIWCSSpatialDomain->get_GridOffsetsBoundingBox(&ipppEnvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSSpatialDomain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSSpatialDomain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSSpatialDomain.get_GridOffsetsBoundingBox() returned %ld", (long)hr);
        goto iwcsspatialdomain_get_gridoffsetsboundingbox_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
    {
        IUnknown* pUnk = NULL;
        ipppEnvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppEnvelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppEnvelope)
    {
        if (py_ppEnvelope)
           Py_DECREF(py_ppEnvelope);
        py_ppEnvelope = Py_None;
        Py_INCREF(py_ppEnvelope);
    }
    if (PyErr_Occurred())
      goto iwcsspatialdomain_get_gridoffsetsboundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppEnvelope);
    goto iwcsspatialdomain_get_gridoffsetsboundingbox_method_cleanup;

    iwcsspatialdomain_get_gridoffsetsboundingbox_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
      ipppEnvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSSpatialDomain.get_GridOffsetsBoundingBox");
    return return_tuple;
}


PyMethodDef PyIWCSSpatialDomainMethods[] = {
    {"supports", (PyCFunction)PyIWCSSpatialDomain_SupportsInterface, METH_O, ""},
    {"get_BoundingBoxInfoCount", (PyCFunction)IWCSSpatialDomainMethod_get_BoundingBoxInfoCount, METH_VARARGS, ""},
    {"get_BoundingBoxInfo", (PyCFunction)IWCSSpatialDomainMethod_get_BoundingBoxInfo, METH_VARARGS, ""},
    {"get_GridBaseCRS", (PyCFunction)IWCSSpatialDomainMethod_get_GridBaseCRS, METH_VARARGS, ""},
    {"get_GridOrigin_X", (PyCFunction)IWCSSpatialDomainMethod_get_GridOrigin_X, METH_VARARGS, ""},
    {"get_GridOrigin_Y", (PyCFunction)IWCSSpatialDomainMethod_get_GridOrigin_Y, METH_VARARGS, ""},
    {"get_GridOffsets_X", (PyCFunction)IWCSSpatialDomainMethod_get_GridOffsets_X, METH_VARARGS, ""},
    {"get_GridOffsets_Y", (PyCFunction)IWCSSpatialDomainMethod_get_GridOffsets_Y, METH_VARARGS, ""},
    {"get_GridOffsetsBoundingBox", (PyCFunction)IWCSSpatialDomainMethod_get_GridOffsetsBoundingBox, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSSpatialDomainGetSet[] = {
  {"_pUnk", (getter)PyIWCSSpatialDomain_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSSpatialDomain", NULL},
  {"_pointer", (getter)PyIWCSSpatialDomain_GetPointer, NULL, "Get memory address for IWCSSpatialDomain", NULL},
  {"_IID", (getter)PyIWCSSpatialDomain_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSSpatialDomain_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSSpatialDomain_GetIgnoreFailures, (setter)PyIWCSSpatialDomain_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSSpatialDomainObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSSpatialDomainObject",                          
                                              /* tp_name */
  sizeof(PyIWCSSpatialDomainObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSSpatialDomainObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSSpatialDomainMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSSpatialDomainGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSSpatialDomainObject_new,                      
                                              /* tp_new */
};

// Interface IWCSCoverageField

typedef struct PyIWCSCoverageFieldObject {
    PyObject_HEAD
    IWCSCoverageField* m_pIWCSCoverageField;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSCoverageFieldObject;

static PyObject*
PyIWCSCoverageFieldObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSCoverageFieldObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSCoverageField* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSCoverageField, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSCoverageField with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSCoverageFieldObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSCoverageField");
            return NULL;
        }
        self->m_pIWCSCoverageField = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSCoverageField");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSCoverageField");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSCoverageField* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSCoverageField, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSCoverageField");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSCoverageFieldObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSCoverageField");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSCoverageField = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSCoverageFieldObject_dealloc(PyIWCSCoverageFieldObject* self)
{
    if (self->m_pIWCSCoverageField)
        self->m_pIWCSCoverageField->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSCoverageField_GetpUnk(PyIWCSCoverageFieldObject* self)
{
    if (!self->m_pIWCSCoverageField)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSCoverageField->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSCoverageField to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSCoverageField_GetPointer(PyIWCSCoverageFieldObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSCoverageField);
}

static PyObject*
PyIWCSCoverageField_GetIID(PyIWCSCoverageFieldObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d970569f-8f77-42cb-98be-b7c0d8b87795");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSCoverageField_GetHR(PyIWCSCoverageFieldObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSCoverageField_GetIgnoreFailures(PyIWCSCoverageFieldObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSCoverageField_SetIgnoreFailures(PyIWCSCoverageFieldObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSCoverageField_SupportsInterface(PyIWCSCoverageFieldObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSCoverageFieldMethod_get_Title(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_Title() returned %ld", (long)hr);
        goto iwcscoveragefield_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwcscoveragefield_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwcscoveragefield_get_title_method_cleanup;

    iwcscoveragefield_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_Title");
    return return_tuple;
}

static PyObject*
IWCSCoverageFieldMethod_get_Abstract(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_Abstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_Abstract() returned %ld", (long)hr);
        goto iwcscoveragefield_get_abstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwcscoveragefield_get_abstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwcscoveragefield_get_abstract_method_cleanup;

    iwcscoveragefield_get_abstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_Abstract");
    return return_tuple;
}

static PyObject*
IWCSCoverageFieldMethod_get_Identifier(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsIdentifier;
    PyObject* pyvar_Identifier = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Identifier

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_Identifier(&bsIdentifier);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_Identifier() returned %ld", (long)hr);
        goto iwcscoveragefield_get_identifier_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Identifier = PyUnicode_FromWideChar(bsIdentifier,::SysStringLen(bsIdentifier));
    ::SysFreeString(bsIdentifier);
    
    if (PyErr_Occurred())
      goto iwcscoveragefield_get_identifier_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Identifier);
    goto iwcscoveragefield_get_identifier_method_cleanup;

    iwcscoveragefield_get_identifier_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Identifier != Py_None)
        Py_XDECREF(pyvar_Identifier);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_Identifier");
    return return_tuple;
}

static PyObject*
IWCSCoverageFieldMethod_get_AxisID(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAxisID;
    PyObject* pyvar_AxisID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for AxisID

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_AxisID(&bsAxisID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_AxisID() returned %ld", (long)hr);
        goto iwcscoveragefield_get_axisid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_AxisID = PyUnicode_FromWideChar(bsAxisID,::SysStringLen(bsAxisID));
    ::SysFreeString(bsAxisID);
    
    if (PyErr_Occurred())
      goto iwcscoveragefield_get_axisid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_AxisID);
    goto iwcscoveragefield_get_axisid_method_cleanup;

    iwcscoveragefield_get_axisid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_AxisID != Py_None)
        Py_XDECREF(pyvar_AxisID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_AxisID");
    return return_tuple;
}

static PyObject*
IWCSCoverageFieldMethod_get_AxisKeysCount(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_AxisKeysCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_AxisKeysCount() returned %ld", (long)hr);
        goto iwcscoveragefield_get_axiskeyscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcscoveragefield_get_axiskeyscount_method_cleanup;

    iwcscoveragefield_get_axiskeyscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_AxisKeysCount");
    return return_tuple;
}

static PyObject*
IWCSCoverageFieldMethod_get_AxisKey(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bskey;
    PyObject* pyvar_key = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcscoveragefield_get_axiskey_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for key

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_AxisKey(lindex, &bskey);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_AxisKey() returned %ld", (long)hr);
        goto iwcscoveragefield_get_axiskey_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_key = PyUnicode_FromWideChar(bskey,::SysStringLen(bskey));
    ::SysFreeString(bskey);
    
    if (PyErr_Occurred())
      goto iwcscoveragefield_get_axiskey_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_key);
    goto iwcscoveragefield_get_axiskey_method_cleanup;

    iwcscoveragefield_get_axiskey_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_key != Py_None)
        Py_XDECREF(pyvar_key);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_AxisKey");
    return return_tuple;
}

static PyObject*
IWCSCoverageFieldMethod_get_DefaultInterpolation(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsInterpolation;
    PyObject* pyvar_Interpolation = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Interpolation

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_DefaultInterpolation(&bsInterpolation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_DefaultInterpolation() returned %ld", (long)hr);
        goto iwcscoveragefield_get_defaultinterpolation_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Interpolation = PyUnicode_FromWideChar(bsInterpolation,::SysStringLen(bsInterpolation));
    ::SysFreeString(bsInterpolation);
    
    if (PyErr_Occurred())
      goto iwcscoveragefield_get_defaultinterpolation_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Interpolation);
    goto iwcscoveragefield_get_defaultinterpolation_method_cleanup;

    iwcscoveragefield_get_defaultinterpolation_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Interpolation != Py_None)
        Py_XDECREF(pyvar_Interpolation);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_DefaultInterpolation");
    return return_tuple;
}

static PyObject*
IWCSCoverageFieldMethod_get_InterpolationCount(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_InterpolationCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_InterpolationCount() returned %ld", (long)hr);
        goto iwcscoveragefield_get_interpolationcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcscoveragefield_get_interpolationcount_method_cleanup;

    iwcscoveragefield_get_interpolationcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_InterpolationCount");
    return return_tuple;
}

static PyObject*
IWCSCoverageFieldMethod_get_Interpolation(PyIWCSCoverageFieldObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsInterpolation;
    PyObject* pyvar_Interpolation = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcscoveragefield_get_interpolation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for Interpolation

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageField->get_Interpolation(lindex, &bsInterpolation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageField->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageField) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageField.get_Interpolation() returned %ld", (long)hr);
        goto iwcscoveragefield_get_interpolation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_Interpolation = PyUnicode_FromWideChar(bsInterpolation,::SysStringLen(bsInterpolation));
    ::SysFreeString(bsInterpolation);
    
    if (PyErr_Occurred())
      goto iwcscoveragefield_get_interpolation_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Interpolation);
    goto iwcscoveragefield_get_interpolation_method_cleanup;

    iwcscoveragefield_get_interpolation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_Interpolation != Py_None)
        Py_XDECREF(pyvar_Interpolation);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageField.get_Interpolation");
    return return_tuple;
}


PyMethodDef PyIWCSCoverageFieldMethods[] = {
    {"supports", (PyCFunction)PyIWCSCoverageField_SupportsInterface, METH_O, ""},
    {"get_Title", (PyCFunction)IWCSCoverageFieldMethod_get_Title, METH_VARARGS, ""},
    {"get_Abstract", (PyCFunction)IWCSCoverageFieldMethod_get_Abstract, METH_VARARGS, ""},
    {"get_Identifier", (PyCFunction)IWCSCoverageFieldMethod_get_Identifier, METH_VARARGS, ""},
    {"get_AxisID", (PyCFunction)IWCSCoverageFieldMethod_get_AxisID, METH_VARARGS, ""},
    {"get_AxisKeysCount", (PyCFunction)IWCSCoverageFieldMethod_get_AxisKeysCount, METH_VARARGS, ""},
    {"get_AxisKey", (PyCFunction)IWCSCoverageFieldMethod_get_AxisKey, METH_VARARGS, ""},
    {"get_DefaultInterpolation", (PyCFunction)IWCSCoverageFieldMethod_get_DefaultInterpolation, METH_VARARGS, ""},
    {"get_InterpolationCount", (PyCFunction)IWCSCoverageFieldMethod_get_InterpolationCount, METH_VARARGS, ""},
    {"get_Interpolation", (PyCFunction)IWCSCoverageFieldMethod_get_Interpolation, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSCoverageFieldGetSet[] = {
  {"_pUnk", (getter)PyIWCSCoverageField_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSCoverageField", NULL},
  {"_pointer", (getter)PyIWCSCoverageField_GetPointer, NULL, "Get memory address for IWCSCoverageField", NULL},
  {"_IID", (getter)PyIWCSCoverageField_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSCoverageField_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSCoverageField_GetIgnoreFailures, (setter)PyIWCSCoverageField_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSCoverageFieldObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSCoverageFieldObject",                          
                                              /* tp_name */
  sizeof(PyIWCSCoverageFieldObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSCoverageFieldObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSCoverageFieldMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSCoverageFieldGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSCoverageFieldObject_new,                      
                                              /* tp_new */
};

// Interface IWCSRange

typedef struct PyIWCSRangeObject {
    PyObject_HEAD
    IWCSRange* m_pIWCSRange;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSRangeObject;

static PyObject*
PyIWCSRangeObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSRangeObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSRange* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSRange, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSRange with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSRangeObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSRange");
            return NULL;
        }
        self->m_pIWCSRange = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSRange");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSRange");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSRange* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSRange, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSRange");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSRangeObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSRange");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSRange = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSRangeObject_dealloc(PyIWCSRangeObject* self)
{
    if (self->m_pIWCSRange)
        self->m_pIWCSRange->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSRange_GetpUnk(PyIWCSRangeObject* self)
{
    if (!self->m_pIWCSRange)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSRange->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSRange to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSRange_GetPointer(PyIWCSRangeObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSRange);
}

static PyObject*
PyIWCSRange_GetIID(PyIWCSRangeObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7f5b3583-a7b7-47a9-b517-6e30ab0c1333");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSRange_GetHR(PyIWCSRangeObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSRange_GetIgnoreFailures(PyIWCSRangeObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSRange_SetIgnoreFailures(PyIWCSRangeObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSRange_SupportsInterface(PyIWCSRangeObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSRange->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSRangeMethod_get_FieldCount(PyIWCSRangeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSRange->get_FieldCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSRange->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSRange) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSRange.get_FieldCount() returned %ld", (long)hr);
        goto iwcsrange_get_fieldcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcsrange_get_fieldcount_method_cleanup;

    iwcsrange_get_fieldcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSRange.get_FieldCount");
    return return_tuple;
}

static PyObject*
IWCSRangeMethod_get_Field(PyIWCSRangeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWCSCoverageField* ipppField = NULL;
    PyObject* py_ppField = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcsrange_get_field_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppField

    // Call method on actual COM interface
    hr = self->m_pIWCSRange->get_Field(lindex, &ipppField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSRange->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSRange) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSRange.get_Field() returned %ld", (long)hr);
        goto iwcsrange_get_field_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppField);
    if (ipppField)
    {
        IUnknown* pUnk = NULL;
        ipppField->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppField = IUnknownToPythonIIDObject(pUnk, &IID_IWCSCoverageField);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppField)
    {
        if (py_ppField)
           Py_DECREF(py_ppField);
        py_ppField = Py_None;
        Py_INCREF(py_ppField);
    }
    if (PyErr_Occurred())
      goto iwcsrange_get_field_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppField);
    goto iwcsrange_get_field_method_cleanup;

    iwcsrange_get_field_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppField);
    if (ipppField)
      ipppField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSRange.get_Field");
    return return_tuple;
}


PyMethodDef PyIWCSRangeMethods[] = {
    {"supports", (PyCFunction)PyIWCSRange_SupportsInterface, METH_O, ""},
    {"get_FieldCount", (PyCFunction)IWCSRangeMethod_get_FieldCount, METH_VARARGS, ""},
    {"get_Field", (PyCFunction)IWCSRangeMethod_get_Field, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSRangeGetSet[] = {
  {"_pUnk", (getter)PyIWCSRange_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSRange", NULL},
  {"_pointer", (getter)PyIWCSRange_GetPointer, NULL, "Get memory address for IWCSRange", NULL},
  {"_IID", (getter)PyIWCSRange_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSRange_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSRange_GetIgnoreFailures, (setter)PyIWCSRange_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSRangeObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSRangeObject",                          
                                              /* tp_name */
  sizeof(PyIWCSRangeObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSRangeObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSRangeMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSRangeGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSRangeObject_new,                      
                                              /* tp_new */
};

// Interface IWCSCoverageDescription

typedef struct PyIWCSCoverageDescriptionObject {
    PyObject_HEAD
    IWCSCoverageDescription* m_pIWCSCoverageDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSCoverageDescriptionObject;

static PyObject*
PyIWCSCoverageDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSCoverageDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSCoverageDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSCoverageDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSCoverageDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSCoverageDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSCoverageDescription");
            return NULL;
        }
        self->m_pIWCSCoverageDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSCoverageDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSCoverageDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSCoverageDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSCoverageDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSCoverageDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSCoverageDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSCoverageDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSCoverageDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSCoverageDescriptionObject_dealloc(PyIWCSCoverageDescriptionObject* self)
{
    if (self->m_pIWCSCoverageDescription)
        self->m_pIWCSCoverageDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSCoverageDescription_GetpUnk(PyIWCSCoverageDescriptionObject* self)
{
    if (!self->m_pIWCSCoverageDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSCoverageDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSCoverageDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSCoverageDescription_GetPointer(PyIWCSCoverageDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSCoverageDescription);
}

static PyObject*
PyIWCSCoverageDescription_GetIID(PyIWCSCoverageDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "165f657d-6e52-4ce6-984a-7300acb2e291");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSCoverageDescription_GetHR(PyIWCSCoverageDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSCoverageDescription_GetIgnoreFailures(PyIWCSCoverageDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSCoverageDescription_SetIgnoreFailures(PyIWCSCoverageDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSCoverageDescription_SupportsInterface(PyIWCSCoverageDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSCoverageDescriptionMethod_get_Name(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_Name() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwcscoveragedescription_get_name_method_cleanup;

    iwcscoveragedescription_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_Name");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_Title(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_Title() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwcscoveragedescription_get_title_method_cleanup;

    iwcscoveragedescription_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_Title");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_Abstract(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_Abstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_Abstract() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_abstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_abstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwcscoveragedescription_get_abstract_method_cleanup;

    iwcscoveragedescription_get_abstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_Abstract");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_Identifier(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsIdentifier;
    PyObject* pyvar_Identifier = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Identifier

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_Identifier(&bsIdentifier);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_Identifier() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_identifier_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Identifier = PyUnicode_FromWideChar(bsIdentifier,::SysStringLen(bsIdentifier));
    ::SysFreeString(bsIdentifier);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_identifier_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Identifier);
    goto iwcscoveragedescription_get_identifier_method_cleanup;

    iwcscoveragedescription_get_identifier_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Identifier != Py_None)
        Py_XDECREF(pyvar_Identifier);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_Identifier");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_IsSelected(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pIsSelected = VARIANT_FALSE;
    PyObject* pyvar_pIsSelected = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIsSelected

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_IsSelected(&b_pIsSelected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_IsSelected() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_isselected_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pIsSelected = ((b_pIsSelected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_isselected_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pIsSelected);
    goto iwcscoveragedescription_get_isselected_method_cleanup;

    iwcscoveragedescription_get_isselected_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIsSelected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_IsSelected");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_WCSCoverageName(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWCSCoverageName* ipppName = NULL;
    PyObject* py_ppName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppName

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_WCSCoverageName(&ipppName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_WCSCoverageName() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_wcscoveragename_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppName);
    if (ipppName)
    {
        IUnknown* pUnk = NULL;
        ipppName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppName = IUnknownToPythonIIDObject(pUnk, &IID_IWCSCoverageName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppName)
    {
        if (py_ppName)
           Py_DECREF(py_ppName);
        py_ppName = Py_None;
        Py_INCREF(py_ppName);
    }
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_wcscoveragename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppName);
    goto iwcscoveragedescription_get_wcscoveragename_method_cleanup;

    iwcscoveragedescription_get_wcscoveragename_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppName);
    if (ipppName)
      ipppName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_WCSCoverageName");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_put_LonLatSRSName(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsSRS = 0;
    PyObject* pyvar_SRS;
    PyObject* unicodeSRS = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_SRS))
      goto iwcscoveragedescription_put_lonlatsrsname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_SRS))
        unicodeSRS = PyUnicode_FromObject(pyvar_SRS);
    else if (PyUnicode_Check(pyvar_SRS))
    {
        unicodeSRS = pyvar_SRS;
        Py_INCREF(unicodeSRS);
    }
    else if (pyvar_SRS != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter SRS at index 0");
    if (unicodeSRS)
        bsSRS = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeSRS), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeSRS));
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_put_lonlatsrsname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->put_LonLatSRSName(bsSRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.put_LonLatSRSName() returned %ld", (long)hr);
        goto iwcscoveragedescription_put_lonlatsrsname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SRS

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcscoveragedescription_put_lonlatsrsname_method_cleanup;

    iwcscoveragedescription_put_lonlatsrsname_method_cleanup:
    self->m_HR = hr;
    if (bsSRS)
        ::SysFreeString(bsSRS);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.put_LonLatSRSName");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_LonLatSRSName(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsSRS;
    PyObject* pyvar_SRS = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SRS

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_LonLatSRSName(&bsSRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_LonLatSRSName() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_lonlatsrsname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_SRS = PyUnicode_FromWideChar(bsSRS,::SysStringLen(bsSRS));
    ::SysFreeString(bsSRS);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_lonlatsrsname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_SRS);
    goto iwcscoveragedescription_get_lonlatsrsname_method_cleanup;

    iwcscoveragedescription_get_lonlatsrsname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_SRS != Py_None)
        Py_XDECREF(pyvar_SRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_LonLatSRSName");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_LonLatBoundingBox(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppEnvelope = NULL;
    PyObject* py_ppEnvelope = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppEnvelope

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_LonLatBoundingBox(&ipppEnvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_LonLatBoundingBox() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_lonlatboundingbox_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
    {
        IUnknown* pUnk = NULL;
        ipppEnvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppEnvelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppEnvelope)
    {
        if (py_ppEnvelope)
           Py_DECREF(py_ppEnvelope);
        py_ppEnvelope = Py_None;
        Py_INCREF(py_ppEnvelope);
    }
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_lonlatboundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppEnvelope);
    goto iwcscoveragedescription_get_lonlatboundingbox_method_cleanup;

    iwcscoveragedescription_get_lonlatboundingbox_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
      ipppEnvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_LonLatBoundingBox");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_DefaultBoundingBox(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCRS = 0;
    PyObject* pyvar_CRS;
    PyObject* unicodeCRS = NULL;
    IEnvelope* ipppEnvelope = NULL;
    PyObject* py_ppEnvelope = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_CRS))
      goto iwcscoveragedescription_get_defaultboundingbox_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_CRS))
        unicodeCRS = PyUnicode_FromObject(pyvar_CRS);
    else if (PyUnicode_Check(pyvar_CRS))
    {
        unicodeCRS = pyvar_CRS;
        Py_INCREF(unicodeCRS);
    }
    else if (pyvar_CRS != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter CRS at index 0");
    if (unicodeCRS)
        bsCRS = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeCRS), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeCRS));
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_defaultboundingbox_method_cleanup;
    
    // No setup for ppEnvelope

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_DefaultBoundingBox(bsCRS, &ipppEnvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_DefaultBoundingBox() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_defaultboundingbox_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for CRS
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
    {
        IUnknown* pUnk = NULL;
        ipppEnvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppEnvelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppEnvelope)
    {
        if (py_ppEnvelope)
           Py_DECREF(py_ppEnvelope);
        py_ppEnvelope = Py_None;
        Py_INCREF(py_ppEnvelope);
    }
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_defaultboundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppEnvelope);
    goto iwcscoveragedescription_get_defaultboundingbox_method_cleanup;

    iwcscoveragedescription_get_defaultboundingbox_method_cleanup:
    self->m_HR = hr;
    if (bsCRS)
        ::SysFreeString(bsCRS);
    
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
      ipppEnvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_DefaultBoundingBox");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_DefaultBoundingCRS(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCRS;
    PyObject* pyvar_CRS = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CRS

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_DefaultBoundingCRS(&bsCRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_DefaultBoundingCRS() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_defaultboundingcrs_method_cleanup;
    }

    // Set up return values as needed
    pyvar_CRS = PyUnicode_FromWideChar(bsCRS,::SysStringLen(bsCRS));
    ::SysFreeString(bsCRS);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_defaultboundingcrs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CRS);
    goto iwcscoveragedescription_get_defaultboundingcrs_method_cleanup;

    iwcscoveragedescription_get_defaultboundingcrs_method_cleanup:
    self->m_HR = hr;
    if (pyvar_CRS != Py_None)
        Py_XDECREF(pyvar_CRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_DefaultBoundingCRS");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_SpatialDomain(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWCSSpatialDomain* ipppSpatailDomain = NULL;
    PyObject* py_ppSpatailDomain = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatailDomain

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_SpatialDomain(&ipppSpatailDomain);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_SpatialDomain() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_spatialdomain_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatailDomain);
    if (ipppSpatailDomain)
    {
        IUnknown* pUnk = NULL;
        ipppSpatailDomain->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatailDomain = IUnknownToPythonIIDObject(pUnk, &IID_IWCSSpatialDomain);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatailDomain)
    {
        if (py_ppSpatailDomain)
           Py_DECREF(py_ppSpatailDomain);
        py_ppSpatailDomain = Py_None;
        Py_INCREF(py_ppSpatailDomain);
    }
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_spatialdomain_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatailDomain);
    goto iwcscoveragedescription_get_spatialdomain_method_cleanup;

    iwcscoveragedescription_get_spatialdomain_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatailDomain);
    if (ipppSpatailDomain)
      ipppSpatailDomain->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_SpatialDomain");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_Range(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWCSRange* ipppRange = NULL;
    PyObject* py_ppRange = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppRange

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_Range(&ipppRange);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_Range() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_range_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppRange);
    if (ipppRange)
    {
        IUnknown* pUnk = NULL;
        ipppRange->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppRange = IUnknownToPythonIIDObject(pUnk, &IID_IWCSRange);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppRange)
    {
        if (py_ppRange)
           Py_DECREF(py_ppRange);
        py_ppRange = Py_None;
        Py_INCREF(py_ppRange);
    }
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_range_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppRange);
    goto iwcscoveragedescription_get_range_method_cleanup;

    iwcscoveragedescription_get_range_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppRange);
    if (ipppRange)
      ipppRange->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_Range");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_DefaultInterpolation(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsInterpolation;
    PyObject* pyvar_Interpolation = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Interpolation

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_DefaultInterpolation(&bsInterpolation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_DefaultInterpolation() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_defaultinterpolation_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Interpolation = PyUnicode_FromWideChar(bsInterpolation,::SysStringLen(bsInterpolation));
    ::SysFreeString(bsInterpolation);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_defaultinterpolation_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Interpolation);
    goto iwcscoveragedescription_get_defaultinterpolation_method_cleanup;

    iwcscoveragedescription_get_defaultinterpolation_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Interpolation != Py_None)
        Py_XDECREF(pyvar_Interpolation);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_DefaultInterpolation");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_InterpolationCount(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_InterpolationCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_InterpolationCount() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_interpolationcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcscoveragedescription_get_interpolationcount_method_cleanup;

    iwcscoveragedescription_get_interpolationcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_InterpolationCount");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_Interpolation(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsInterpolation;
    PyObject* pyvar_Interpolation = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcscoveragedescription_get_interpolation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for Interpolation

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_Interpolation(lindex, &bsInterpolation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_Interpolation() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_interpolation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_Interpolation = PyUnicode_FromWideChar(bsInterpolation,::SysStringLen(bsInterpolation));
    ::SysFreeString(bsInterpolation);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_interpolation_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Interpolation);
    goto iwcscoveragedescription_get_interpolation_method_cleanup;

    iwcscoveragedescription_get_interpolation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_Interpolation != Py_None)
        Py_XDECREF(pyvar_Interpolation);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_Interpolation");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_CRSCount(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_CRSCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_CRSCount() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_crscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcscoveragedescription_get_crscount_method_cleanup;

    iwcscoveragedescription_get_crscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_CRSCount");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_CRS(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsCRS;
    PyObject* pyvar_CRS = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcscoveragedescription_get_crs_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for CRS

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_CRS(lindex, &bsCRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_CRS() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_crs_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_CRS = PyUnicode_FromWideChar(bsCRS,::SysStringLen(bsCRS));
    ::SysFreeString(bsCRS);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_crs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CRS);
    goto iwcscoveragedescription_get_crs_method_cleanup;

    iwcscoveragedescription_get_crs_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_CRS != Py_None)
        Py_XDECREF(pyvar_CRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_CRS");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_NativeCRS(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCRS;
    PyObject* pyvar_CRS = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CRS

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_NativeCRS(&bsCRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_NativeCRS() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_nativecrs_method_cleanup;
    }

    // Set up return values as needed
    pyvar_CRS = PyUnicode_FromWideChar(bsCRS,::SysStringLen(bsCRS));
    ::SysFreeString(bsCRS);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_nativecrs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CRS);
    goto iwcscoveragedescription_get_nativecrs_method_cleanup;

    iwcscoveragedescription_get_nativecrs_method_cleanup:
    self->m_HR = hr;
    if (pyvar_CRS != Py_None)
        Py_XDECREF(pyvar_CRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_NativeCRS");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_ImageFormatCount(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_ImageFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_ImageFormatCount() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_imageformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcscoveragedescription_get_imageformatcount_method_cleanup;

    iwcscoveragedescription_get_imageformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_ImageFormatCount");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_ImageFormat(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsformat;
    PyObject* pyvar_format = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcscoveragedescription_get_imageformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for format

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_ImageFormat(lindex, &bsformat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_ImageFormat() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_imageformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_format = PyUnicode_FromWideChar(bsformat,::SysStringLen(bsformat));
    ::SysFreeString(bsformat);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_imageformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_format);
    goto iwcscoveragedescription_get_imageformat_method_cleanup;

    iwcscoveragedescription_get_imageformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_format != Py_None)
        Py_XDECREF(pyvar_format);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_ImageFormat");
    return return_tuple;
}

static PyObject*
IWCSCoverageDescriptionMethod_get_NativeImageFormat(PyIWCSCoverageDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsformat;
    PyObject* pyvar_format = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for format

    // Call method on actual COM interface
    hr = self->m_pIWCSCoverageDescription->get_NativeImageFormat(&bsformat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSCoverageDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSCoverageDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSCoverageDescription.get_NativeImageFormat() returned %ld", (long)hr);
        goto iwcscoveragedescription_get_nativeimageformat_method_cleanup;
    }

    // Set up return values as needed
    pyvar_format = PyUnicode_FromWideChar(bsformat,::SysStringLen(bsformat));
    ::SysFreeString(bsformat);
    
    if (PyErr_Occurred())
      goto iwcscoveragedescription_get_nativeimageformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_format);
    goto iwcscoveragedescription_get_nativeimageformat_method_cleanup;

    iwcscoveragedescription_get_nativeimageformat_method_cleanup:
    self->m_HR = hr;
    if (pyvar_format != Py_None)
        Py_XDECREF(pyvar_format);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSCoverageDescription.get_NativeImageFormat");
    return return_tuple;
}


PyMethodDef PyIWCSCoverageDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIWCSCoverageDescription_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IWCSCoverageDescriptionMethod_get_Name, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IWCSCoverageDescriptionMethod_get_Title, METH_VARARGS, ""},
    {"get_Abstract", (PyCFunction)IWCSCoverageDescriptionMethod_get_Abstract, METH_VARARGS, ""},
    {"get_Identifier", (PyCFunction)IWCSCoverageDescriptionMethod_get_Identifier, METH_VARARGS, ""},
    {"get_IsSelected", (PyCFunction)IWCSCoverageDescriptionMethod_get_IsSelected, METH_VARARGS, ""},
    {"get_WCSCoverageName", (PyCFunction)IWCSCoverageDescriptionMethod_get_WCSCoverageName, METH_VARARGS, ""},
    {"put_LonLatSRSName", (PyCFunction)IWCSCoverageDescriptionMethod_put_LonLatSRSName, METH_VARARGS, ""},
    {"get_LonLatSRSName", (PyCFunction)IWCSCoverageDescriptionMethod_get_LonLatSRSName, METH_VARARGS, ""},
    {"get_LonLatBoundingBox", (PyCFunction)IWCSCoverageDescriptionMethod_get_LonLatBoundingBox, METH_VARARGS, ""},
    {"get_DefaultBoundingBox", (PyCFunction)IWCSCoverageDescriptionMethod_get_DefaultBoundingBox, METH_VARARGS, ""},
    {"get_DefaultBoundingCRS", (PyCFunction)IWCSCoverageDescriptionMethod_get_DefaultBoundingCRS, METH_VARARGS, ""},
    {"get_SpatialDomain", (PyCFunction)IWCSCoverageDescriptionMethod_get_SpatialDomain, METH_VARARGS, ""},
    {"get_Range", (PyCFunction)IWCSCoverageDescriptionMethod_get_Range, METH_VARARGS, ""},
    {"get_DefaultInterpolation", (PyCFunction)IWCSCoverageDescriptionMethod_get_DefaultInterpolation, METH_VARARGS, ""},
    {"get_InterpolationCount", (PyCFunction)IWCSCoverageDescriptionMethod_get_InterpolationCount, METH_VARARGS, ""},
    {"get_Interpolation", (PyCFunction)IWCSCoverageDescriptionMethod_get_Interpolation, METH_VARARGS, ""},
    {"get_CRSCount", (PyCFunction)IWCSCoverageDescriptionMethod_get_CRSCount, METH_VARARGS, ""},
    {"get_CRS", (PyCFunction)IWCSCoverageDescriptionMethod_get_CRS, METH_VARARGS, ""},
    {"get_NativeCRS", (PyCFunction)IWCSCoverageDescriptionMethod_get_NativeCRS, METH_VARARGS, ""},
    {"get_ImageFormatCount", (PyCFunction)IWCSCoverageDescriptionMethod_get_ImageFormatCount, METH_VARARGS, ""},
    {"get_ImageFormat", (PyCFunction)IWCSCoverageDescriptionMethod_get_ImageFormat, METH_VARARGS, ""},
    {"get_NativeImageFormat", (PyCFunction)IWCSCoverageDescriptionMethod_get_NativeImageFormat, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSCoverageDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIWCSCoverageDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSCoverageDescription", NULL},
  {"_pointer", (getter)PyIWCSCoverageDescription_GetPointer, NULL, "Get memory address for IWCSCoverageDescription", NULL},
  {"_IID", (getter)PyIWCSCoverageDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSCoverageDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSCoverageDescription_GetIgnoreFailures, (setter)PyIWCSCoverageDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSCoverageDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSCoverageDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIWCSCoverageDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSCoverageDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSCoverageDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSCoverageDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSCoverageDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSDimension

typedef struct PyIWMTSDimensionObject {
    PyObject_HEAD
    IWMTSDimension* m_pIWMTSDimension;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSDimensionObject;

static PyObject*
PyIWMTSDimensionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSDimensionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSDimension* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSDimension, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSDimension with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSDimensionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSDimension");
            return NULL;
        }
        self->m_pIWMTSDimension = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSDimension");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSDimension");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSDimension* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSDimension, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSDimension");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSDimensionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSDimension");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSDimension = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSDimensionObject_dealloc(PyIWMTSDimensionObject* self)
{
    if (self->m_pIWMTSDimension)
        self->m_pIWMTSDimension->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSDimension_GetpUnk(PyIWMTSDimensionObject* self)
{
    if (!self->m_pIWMTSDimension)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSDimension->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSDimension to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSDimension_GetPointer(PyIWMTSDimensionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSDimension);
}

static PyObject*
PyIWMTSDimension_GetIID(PyIWMTSDimensionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "dbc40029-335f-47c2-8cb0-75473fef52bf");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSDimension_GetHR(PyIWMTSDimensionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSDimension_GetIgnoreFailures(PyIWMTSDimensionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSDimension_SetIgnoreFailures(PyIWMTSDimensionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSDimension_SupportsInterface(PyIWMTSDimensionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSDimensionMethod_get_Identifier(PyIWMTSDimensionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsID;
    PyObject* pyvar_ID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ID

    // Call method on actual COM interface
    hr = self->m_pIWMTSDimension->get_Identifier(&bsID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSDimension) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSDimension.get_Identifier() returned %ld", (long)hr);
        goto iwmtsdimension_get_identifier_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ID = PyUnicode_FromWideChar(bsID,::SysStringLen(bsID));
    ::SysFreeString(bsID);
    
    if (PyErr_Occurred())
      goto iwmtsdimension_get_identifier_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ID);
    goto iwmtsdimension_get_identifier_method_cleanup;

    iwmtsdimension_get_identifier_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ID != Py_None)
        Py_XDECREF(pyvar_ID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSDimension.get_Identifier");
    return return_tuple;
}

static PyObject*
IWMTSDimensionMethod_get_Title(PyIWMTSDimensionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMTSDimension->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSDimension) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSDimension.get_Title() returned %ld", (long)hr);
        goto iwmtsdimension_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmtsdimension_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmtsdimension_get_title_method_cleanup;

    iwmtsdimension_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSDimension.get_Title");
    return return_tuple;
}

static PyObject*
IWMTSDimensionMethod_get_Abstract(PyIWMTSDimensionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWMTSDimension->get_Abstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSDimension) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSDimension.get_Abstract() returned %ld", (long)hr);
        goto iwmtsdimension_get_abstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwmtsdimension_get_abstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwmtsdimension_get_abstract_method_cleanup;

    iwmtsdimension_get_abstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSDimension.get_Abstract");
    return return_tuple;
}

static PyObject*
IWMTSDimensionMethod_get_ValueCount(PyIWMTSDimensionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSDimension->get_ValueCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSDimension) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSDimension.get_ValueCount() returned %ld", (long)hr);
        goto iwmtsdimension_get_valuecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtsdimension_get_valuecount_method_cleanup;

    iwmtsdimension_get_valuecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSDimension.get_ValueCount");
    return return_tuple;
}

static PyObject*
IWMTSDimensionMethod_get_Value(PyIWMTSDimensionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lix = 0;
    BSTR bsValue;
    PyObject* pyvar_Value = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lix))
      goto iwmtsdimension_get_value_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ix
    // No setup for Value

    // Call method on actual COM interface
    hr = self->m_pIWMTSDimension->get_Value(lix, &bsValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSDimension) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSDimension.get_Value() returned %ld", (long)hr);
        goto iwmtsdimension_get_value_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ix
    pyvar_Value = PyUnicode_FromWideChar(bsValue,::SysStringLen(bsValue));
    ::SysFreeString(bsValue);
    
    if (PyErr_Occurred())
      goto iwmtsdimension_get_value_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Value);
    goto iwmtsdimension_get_value_method_cleanup;

    iwmtsdimension_get_value_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ix
    if (pyvar_Value != Py_None)
        Py_XDECREF(pyvar_Value);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSDimension.get_Value");
    return return_tuple;
}

static PyObject*
IWMTSDimensionMethod_get_DefaultValue(PyIWMTSDimensionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsValue;
    PyObject* pyvar_Value = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Value

    // Call method on actual COM interface
    hr = self->m_pIWMTSDimension->get_DefaultValue(&bsValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSDimension) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSDimension.get_DefaultValue() returned %ld", (long)hr);
        goto iwmtsdimension_get_defaultvalue_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Value = PyUnicode_FromWideChar(bsValue,::SysStringLen(bsValue));
    ::SysFreeString(bsValue);
    
    if (PyErr_Occurred())
      goto iwmtsdimension_get_defaultvalue_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Value);
    goto iwmtsdimension_get_defaultvalue_method_cleanup;

    iwmtsdimension_get_defaultvalue_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Value != Py_None)
        Py_XDECREF(pyvar_Value);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSDimension.get_DefaultValue");
    return return_tuple;
}

static PyObject*
IWMTSDimensionMethod_get_SupportsCurrentValue(PyIWMTSDimensionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_supports = VARIANT_FALSE;
    PyObject* pyvar_supports = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for supports

    // Call method on actual COM interface
    hr = self->m_pIWMTSDimension->get_SupportsCurrentValue(&b_supports);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSDimension) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSDimension.get_SupportsCurrentValue() returned %ld", (long)hr);
        goto iwmtsdimension_get_supportscurrentvalue_method_cleanup;
    }

    // Set up return values as needed
    pyvar_supports = ((b_supports == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iwmtsdimension_get_supportscurrentvalue_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_supports);
    goto iwmtsdimension_get_supportscurrentvalue_method_cleanup;

    iwmtsdimension_get_supportscurrentvalue_method_cleanup:
    self->m_HR = hr;
    // No cleanup for supports
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSDimension.get_SupportsCurrentValue");
    return return_tuple;
}

static PyObject*
IWMTSDimensionMethod_get_UnitsSymbol(PyIWMTSDimensionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsValue;
    PyObject* pyvar_Value = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Value

    // Call method on actual COM interface
    hr = self->m_pIWMTSDimension->get_UnitsSymbol(&bsValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSDimension->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSDimension) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSDimension.get_UnitsSymbol() returned %ld", (long)hr);
        goto iwmtsdimension_get_unitssymbol_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Value = PyUnicode_FromWideChar(bsValue,::SysStringLen(bsValue));
    ::SysFreeString(bsValue);
    
    if (PyErr_Occurred())
      goto iwmtsdimension_get_unitssymbol_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Value);
    goto iwmtsdimension_get_unitssymbol_method_cleanup;

    iwmtsdimension_get_unitssymbol_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Value != Py_None)
        Py_XDECREF(pyvar_Value);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSDimension.get_UnitsSymbol");
    return return_tuple;
}


PyMethodDef PyIWMTSDimensionMethods[] = {
    {"supports", (PyCFunction)PyIWMTSDimension_SupportsInterface, METH_O, ""},
    {"get_Identifier", (PyCFunction)IWMTSDimensionMethod_get_Identifier, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IWMTSDimensionMethod_get_Title, METH_VARARGS, ""},
    {"get_Abstract", (PyCFunction)IWMTSDimensionMethod_get_Abstract, METH_VARARGS, ""},
    {"get_ValueCount", (PyCFunction)IWMTSDimensionMethod_get_ValueCount, METH_VARARGS, ""},
    {"get_Value", (PyCFunction)IWMTSDimensionMethod_get_Value, METH_VARARGS, ""},
    {"get_DefaultValue", (PyCFunction)IWMTSDimensionMethod_get_DefaultValue, METH_VARARGS, ""},
    {"get_SupportsCurrentValue", (PyCFunction)IWMTSDimensionMethod_get_SupportsCurrentValue, METH_VARARGS, ""},
    {"get_UnitsSymbol", (PyCFunction)IWMTSDimensionMethod_get_UnitsSymbol, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSDimensionGetSet[] = {
  {"_pUnk", (getter)PyIWMTSDimension_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSDimension", NULL},
  {"_pointer", (getter)PyIWMTSDimension_GetPointer, NULL, "Get memory address for IWMTSDimension", NULL},
  {"_IID", (getter)PyIWMTSDimension_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSDimension_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSDimension_GetIgnoreFailures, (setter)PyIWMTSDimension_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSDimensionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSDimensionObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSDimensionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSDimensionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSDimensionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSDimensionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSDimensionObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSTileMatrixSetLink

typedef struct PyIWMTSTileMatrixSetLinkObject {
    PyObject_HEAD
    IWMTSTileMatrixSetLink* m_pIWMTSTileMatrixSetLink;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSTileMatrixSetLinkObject;

static PyObject*
PyIWMTSTileMatrixSetLinkObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSTileMatrixSetLinkObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSTileMatrixSetLink* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSTileMatrixSetLink, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSTileMatrixSetLink with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSTileMatrixSetLinkObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSTileMatrixSetLink");
            return NULL;
        }
        self->m_pIWMTSTileMatrixSetLink = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSTileMatrixSetLink");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSTileMatrixSetLink");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSTileMatrixSetLink* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSTileMatrixSetLink, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSTileMatrixSetLink");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSTileMatrixSetLinkObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSTileMatrixSetLink");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSTileMatrixSetLink = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSTileMatrixSetLinkObject_dealloc(PyIWMTSTileMatrixSetLinkObject* self)
{
    if (self->m_pIWMTSTileMatrixSetLink)
        self->m_pIWMTSTileMatrixSetLink->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSTileMatrixSetLink_GetpUnk(PyIWMTSTileMatrixSetLinkObject* self)
{
    if (!self->m_pIWMTSTileMatrixSetLink)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSTileMatrixSetLink->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSTileMatrixSetLink to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSTileMatrixSetLink_GetPointer(PyIWMTSTileMatrixSetLinkObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSTileMatrixSetLink);
}

static PyObject*
PyIWMTSTileMatrixSetLink_GetIID(PyIWMTSTileMatrixSetLinkObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "95ad2016-d7ae-44d4-a121-cb2645f4ea42");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSTileMatrixSetLink_GetHR(PyIWMTSTileMatrixSetLinkObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSTileMatrixSetLink_GetIgnoreFailures(PyIWMTSTileMatrixSetLinkObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSTileMatrixSetLink_SetIgnoreFailures(PyIWMTSTileMatrixSetLinkObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSTileMatrixSetLink_SupportsInterface(PyIWMTSTileMatrixSetLinkObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSetLink->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSTileMatrixSetLinkMethod_get_TileMatrixSet(PyIWMTSTileMatrixSetLinkObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsID;
    PyObject* pyvar_ID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ID

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSetLink->get_TileMatrixSet(&bsID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSetLink->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSetLink) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSetLink.get_TileMatrixSet() returned %ld", (long)hr);
        goto iwmtstilematrixsetlink_get_tilematrixset_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ID = PyUnicode_FromWideChar(bsID,::SysStringLen(bsID));
    ::SysFreeString(bsID);
    
    if (PyErr_Occurred())
      goto iwmtstilematrixsetlink_get_tilematrixset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ID);
    goto iwmtstilematrixsetlink_get_tilematrixset_method_cleanup;

    iwmtstilematrixsetlink_get_tilematrixset_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ID != Py_None)
        Py_XDECREF(pyvar_ID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSetLink.get_TileMatrixSet");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetLinkMethod_get_TileMatrixSetLimitsCount(PyIWMTSTileMatrixSetLinkObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSetLink->get_TileMatrixSetLimitsCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSetLink->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSetLink) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSetLink.get_TileMatrixSetLimitsCount() returned %ld", (long)hr);
        goto iwmtstilematrixsetlink_get_tilematrixsetlimitscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtstilematrixsetlink_get_tilematrixsetlimitscount_method_cleanup;

    iwmtstilematrixsetlink_get_tilematrixsetlimitscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSetLink.get_TileMatrixSetLimitsCount");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetLinkMethod_get_TileMatrixSetLimits(PyIWMTSTileMatrixSetLinkObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lix = 0;
    IPropertySet* iplimitsAsProps = NULL;
    PyObject* py_limitsAsProps = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lix))
      goto iwmtstilematrixsetlink_get_tilematrixsetlimits_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ix
    // No setup for limitsAsProps

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSetLink->get_TileMatrixSetLimits(lix, &iplimitsAsProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSetLink->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSetLink) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSetLink.get_TileMatrixSetLimits() returned %ld", (long)hr);
        goto iwmtstilematrixsetlink_get_tilematrixsetlimits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ix
    Py_XDECREF(py_limitsAsProps);
    if (iplimitsAsProps)
    {
        IUnknown* pUnk = NULL;
        iplimitsAsProps->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_limitsAsProps = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_limitsAsProps)
    {
        if (py_limitsAsProps)
           Py_DECREF(py_limitsAsProps);
        py_limitsAsProps = Py_None;
        Py_INCREF(py_limitsAsProps);
    }
    if (PyErr_Occurred())
      goto iwmtstilematrixsetlink_get_tilematrixsetlimits_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_limitsAsProps);
    goto iwmtstilematrixsetlink_get_tilematrixsetlimits_method_cleanup;

    iwmtstilematrixsetlink_get_tilematrixsetlimits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ix
    Py_XDECREF(py_limitsAsProps);
    if (iplimitsAsProps)
      iplimitsAsProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSetLink.get_TileMatrixSetLimits");
    return return_tuple;
}


PyMethodDef PyIWMTSTileMatrixSetLinkMethods[] = {
    {"supports", (PyCFunction)PyIWMTSTileMatrixSetLink_SupportsInterface, METH_O, ""},
    {"get_TileMatrixSet", (PyCFunction)IWMTSTileMatrixSetLinkMethod_get_TileMatrixSet, METH_VARARGS, ""},
    {"get_TileMatrixSetLimitsCount", (PyCFunction)IWMTSTileMatrixSetLinkMethod_get_TileMatrixSetLimitsCount, METH_VARARGS, ""},
    {"get_TileMatrixSetLimits", (PyCFunction)IWMTSTileMatrixSetLinkMethod_get_TileMatrixSetLimits, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSTileMatrixSetLinkGetSet[] = {
  {"_pUnk", (getter)PyIWMTSTileMatrixSetLink_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSTileMatrixSetLink", NULL},
  {"_pointer", (getter)PyIWMTSTileMatrixSetLink_GetPointer, NULL, "Get memory address for IWMTSTileMatrixSetLink", NULL},
  {"_IID", (getter)PyIWMTSTileMatrixSetLink_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSTileMatrixSetLink_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSTileMatrixSetLink_GetIgnoreFailures, (setter)PyIWMTSTileMatrixSetLink_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSTileMatrixSetLinkObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSTileMatrixSetLinkObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSTileMatrixSetLinkObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSTileMatrixSetLinkObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSTileMatrixSetLinkMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSTileMatrixSetLinkGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSTileMatrixSetLinkObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSLayerDescription

typedef struct PyIWMTSLayerDescriptionObject {
    PyObject_HEAD
    IWMTSLayerDescription* m_pIWMTSLayerDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSLayerDescriptionObject;

static PyObject*
PyIWMTSLayerDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSLayerDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSLayerDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSLayerDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSLayerDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSLayerDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSLayerDescription");
            return NULL;
        }
        self->m_pIWMTSLayerDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSLayerDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSLayerDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSLayerDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSLayerDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSLayerDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSLayerDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSLayerDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSLayerDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSLayerDescriptionObject_dealloc(PyIWMTSLayerDescriptionObject* self)
{
    if (self->m_pIWMTSLayerDescription)
        self->m_pIWMTSLayerDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSLayerDescription_GetpUnk(PyIWMTSLayerDescriptionObject* self)
{
    if (!self->m_pIWMTSLayerDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSLayerDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSLayerDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSLayerDescription_GetPointer(PyIWMTSLayerDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSLayerDescription);
}

static PyObject*
PyIWMTSLayerDescription_GetIID(PyIWMTSLayerDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e28b0014-208c-4c9b-8e24-ac882d0b4c36");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSLayerDescription_GetHR(PyIWMTSLayerDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSLayerDescription_GetIgnoreFailures(PyIWMTSLayerDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSLayerDescription_SetIgnoreFailures(PyIWMTSLayerDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSLayerDescription_SupportsInterface(PyIWMTSLayerDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSLayerDescriptionMethod_get_Identifier(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsstringId;
    PyObject* pyvar_stringId = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for stringId

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_Identifier(&bsstringId);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_Identifier() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_identifier_method_cleanup;
    }

    // Set up return values as needed
    pyvar_stringId = PyUnicode_FromWideChar(bsstringId,::SysStringLen(bsstringId));
    ::SysFreeString(bsstringId);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_identifier_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_stringId);
    goto iwmtslayerdescription_get_identifier_method_cleanup;

    iwmtslayerdescription_get_identifier_method_cleanup:
    self->m_HR = hr;
    if (pyvar_stringId != Py_None)
        Py_XDECREF(pyvar_stringId);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_Identifier");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_Title(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_Title() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmtslayerdescription_get_title_method_cleanup;

    iwmtslayerdescription_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_Title");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_Abstract(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_Abstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_Abstract() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_abstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_abstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwmtslayerdescription_get_abstract_method_cleanup;

    iwmtslayerdescription_get_abstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_Abstract");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_WGS84BoundingBox(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipenvelope = NULL;
    PyObject* py_envelope = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for envelope

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_WGS84BoundingBox(&ipenvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_WGS84BoundingBox() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_wgs84boundingbox_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_envelope);
    if (ipenvelope)
    {
        IUnknown* pUnk = NULL;
        ipenvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_envelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_envelope)
    {
        if (py_envelope)
           Py_DECREF(py_envelope);
        py_envelope = Py_None;
        Py_INCREF(py_envelope);
    }
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_wgs84boundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_envelope);
    goto iwmtslayerdescription_get_wgs84boundingbox_method_cleanup;

    iwmtslayerdescription_get_wgs84boundingbox_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_envelope);
    if (ipenvelope)
      ipenvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_WGS84BoundingBox");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_BoundingBoxCount(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_BoundingBoxCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_BoundingBoxCount() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_boundingboxcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtslayerdescription_get_boundingboxcount_method_cleanup;

    iwmtslayerdescription_get_boundingboxcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_BoundingBoxCount");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_BoundingBox(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ipenvelope = NULL;
    PyObject* py_envelope = NULL;
    BSTR bssrsCode;
    PyObject* pyvar_srsCode = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtslayerdescription_get_boundingbox_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for envelope
    // No setup for srsCode

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_BoundingBox(lindex, &ipenvelope, &bssrsCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_BoundingBox() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_boundingbox_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_envelope);
    if (ipenvelope)
    {
        IUnknown* pUnk = NULL;
        ipenvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_envelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_envelope)
    {
        if (py_envelope)
           Py_DECREF(py_envelope);
        py_envelope = Py_None;
        Py_INCREF(py_envelope);
    }
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_boundingbox_method_cleanup;
    
    pyvar_srsCode = PyUnicode_FromWideChar(bssrsCode,::SysStringLen(bssrsCode));
    ::SysFreeString(bssrsCode);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_boundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_envelope, pyvar_srsCode);
    goto iwmtslayerdescription_get_boundingbox_method_cleanup;

    iwmtslayerdescription_get_boundingbox_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_envelope);
    if (ipenvelope)
      ipenvelope->Release();
    if (pyvar_srsCode != Py_None)
        Py_XDECREF(pyvar_srsCode);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_BoundingBox");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_StyleDescriptionCount(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_StyleDescriptionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_StyleDescriptionCount() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_styledescriptioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtslayerdescription_get_styledescriptioncount_method_cleanup;

    iwmtslayerdescription_get_styledescriptioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_StyleDescriptionCount");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_StyleDescription(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMSLayerStyleDescription* ipStyleDescription = NULL;
    PyObject* py_StyleDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtslayerdescription_get_styledescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for StyleDescription

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_StyleDescription(lindex, &ipStyleDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_StyleDescription() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_styledescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_StyleDescription);
    if (ipStyleDescription)
    {
        IUnknown* pUnk = NULL;
        ipStyleDescription->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_StyleDescription = IUnknownToPythonIIDObject(pUnk, &IID_IWMSLayerStyleDescription);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_StyleDescription)
    {
        if (py_StyleDescription)
           Py_DECREF(py_StyleDescription);
        py_StyleDescription = Py_None;
        Py_INCREF(py_StyleDescription);
    }
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_styledescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_StyleDescription);
    goto iwmtslayerdescription_get_styledescription_method_cleanup;

    iwmtslayerdescription_get_styledescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_StyleDescription);
    if (ipStyleDescription)
      ipStyleDescription->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_StyleDescription");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_WMTSVersion(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsWMTSVersion;
    PyObject* pyvar_WMTSVersion = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for WMTSVersion

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_WMTSVersion(&bsWMTSVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_WMTSVersion() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_wmtsversion_method_cleanup;
    }

    // Set up return values as needed
    pyvar_WMTSVersion = PyUnicode_FromWideChar(bsWMTSVersion,::SysStringLen(bsWMTSVersion));
    ::SysFreeString(bsWMTSVersion);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_wmtsversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_WMTSVersion);
    goto iwmtslayerdescription_get_wmtsversion_method_cleanup;

    iwmtslayerdescription_get_wmtsversion_method_cleanup:
    self->m_HR = hr;
    if (pyvar_WMTSVersion != Py_None)
        Py_XDECREF(pyvar_WMTSVersion);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_WMTSVersion");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_ImageFormatCount(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_ImageFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_ImageFormatCount() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_imageformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtslayerdescription_get_imageformatcount_method_cleanup;

    iwmtslayerdescription_get_imageformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_ImageFormatCount");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_ImageFormat(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtslayerdescription_get_imageformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_ImageFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_ImageFormat() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_imageformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_imageformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmtslayerdescription_get_imageformat_method_cleanup;

    iwmtslayerdescription_get_imageformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_ImageFormat");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_FeatureInfoFormatCount(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_FeatureInfoFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_FeatureInfoFormatCount() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_featureinfoformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtslayerdescription_get_featureinfoformatcount_method_cleanup;

    iwmtslayerdescription_get_featureinfoformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_FeatureInfoFormatCount");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_FeatureInfoFormat(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtslayerdescription_get_featureinfoformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_FeatureInfoFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_FeatureInfoFormat() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_featureinfoformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_featureinfoformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmtslayerdescription_get_featureinfoformat_method_cleanup;

    iwmtslayerdescription_get_featureinfoformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_FeatureInfoFormat");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_DimensionCount(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_DimensionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_DimensionCount() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_dimensioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtslayerdescription_get_dimensioncount_method_cleanup;

    iwmtslayerdescription_get_dimensioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_DimensionCount");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_Dimension(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMTSDimension* ipDimension = NULL;
    PyObject* py_Dimension = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtslayerdescription_get_dimension_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for Dimension

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_Dimension(lindex, &ipDimension);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_Dimension() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_dimension_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_Dimension);
    if (ipDimension)
    {
        IUnknown* pUnk = NULL;
        ipDimension->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Dimension = IUnknownToPythonIIDObject(pUnk, &IID_IWMTSDimension);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Dimension)
    {
        if (py_Dimension)
           Py_DECREF(py_Dimension);
        py_Dimension = Py_None;
        Py_INCREF(py_Dimension);
    }
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_dimension_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Dimension);
    goto iwmtslayerdescription_get_dimension_method_cleanup;

    iwmtslayerdescription_get_dimension_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_Dimension);
    if (ipDimension)
      ipDimension->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_Dimension");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_TileMatrixSetLinkCount(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_TileMatrixSetLinkCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_TileMatrixSetLinkCount() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_tilematrixsetlinkcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtslayerdescription_get_tilematrixsetlinkcount_method_cleanup;

    iwmtslayerdescription_get_tilematrixsetlinkcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_TileMatrixSetLinkCount");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_get_TileMatrixSetLink(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMTSTileMatrixSetLink* ipmatrixSetLink = NULL;
    PyObject* py_matrixSetLink = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtslayerdescription_get_tilematrixsetlink_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for matrixSetLink

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->get_TileMatrixSetLink(lindex, &ipmatrixSetLink);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.get_TileMatrixSetLink() returned %ld", (long)hr);
        goto iwmtslayerdescription_get_tilematrixsetlink_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_matrixSetLink);
    if (ipmatrixSetLink)
    {
        IUnknown* pUnk = NULL;
        ipmatrixSetLink->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_matrixSetLink = IUnknownToPythonIIDObject(pUnk, &IID_IWMTSTileMatrixSetLink);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_matrixSetLink)
    {
        if (py_matrixSetLink)
           Py_DECREF(py_matrixSetLink);
        py_matrixSetLink = Py_None;
        Py_INCREF(py_matrixSetLink);
    }
    if (PyErr_Occurred())
      goto iwmtslayerdescription_get_tilematrixsetlink_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_matrixSetLink);
    goto iwmtslayerdescription_get_tilematrixsetlink_method_cleanup;

    iwmtslayerdescription_get_tilematrixsetlink_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_matrixSetLink);
    if (ipmatrixSetLink)
      ipmatrixSetLink->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.get_TileMatrixSetLink");
    return return_tuple;
}

static PyObject*
IWMTSLayerDescriptionMethod_GetRESTResourceInfo(PyIWMTSLayerDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsresourceType = 0;
    PyObject* pyvar_resourceType;
    PyObject* unicoderesourceType = NULL;
    BSTR bstemplateUrl;
    PyObject* pyvar_templateUrl = Py_None;
    BSTR bsformat;
    PyObject* pyvar_format = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_resourceType))
      goto iwmtslayerdescription_getrestresourceinfo_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_resourceType))
        unicoderesourceType = PyUnicode_FromObject(pyvar_resourceType);
    else if (PyUnicode_Check(pyvar_resourceType))
    {
        unicoderesourceType = pyvar_resourceType;
        Py_INCREF(unicoderesourceType);
    }
    else if (pyvar_resourceType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter resourceType at index 0");
    if (unicoderesourceType)
        bsresourceType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderesourceType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderesourceType));
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_getrestresourceinfo_method_cleanup;
    
    // No setup for templateUrl
    // No setup for format

    // Call method on actual COM interface
    hr = self->m_pIWMTSLayerDescription->GetRESTResourceInfo(bsresourceType, &bstemplateUrl, &bsformat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSLayerDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSLayerDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSLayerDescription.GetRESTResourceInfo() returned %ld", (long)hr);
        goto iwmtslayerdescription_getrestresourceinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for resourceType
    pyvar_templateUrl = PyUnicode_FromWideChar(bstemplateUrl,::SysStringLen(bstemplateUrl));
    ::SysFreeString(bstemplateUrl);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_getrestresourceinfo_method_cleanup;
    
    pyvar_format = PyUnicode_FromWideChar(bsformat,::SysStringLen(bsformat));
    ::SysFreeString(bsformat);
    
    if (PyErr_Occurred())
      goto iwmtslayerdescription_getrestresourceinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            pyvar_templateUrl, pyvar_format);
    goto iwmtslayerdescription_getrestresourceinfo_method_cleanup;

    iwmtslayerdescription_getrestresourceinfo_method_cleanup:
    self->m_HR = hr;
    if (bsresourceType)
        ::SysFreeString(bsresourceType);
    
    if (pyvar_templateUrl != Py_None)
        Py_XDECREF(pyvar_templateUrl);
    if (pyvar_format != Py_None)
        Py_XDECREF(pyvar_format);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSLayerDescription.GetRESTResourceInfo");
    return return_tuple;
}


PyMethodDef PyIWMTSLayerDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIWMTSLayerDescription_SupportsInterface, METH_O, ""},
    {"get_Identifier", (PyCFunction)IWMTSLayerDescriptionMethod_get_Identifier, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IWMTSLayerDescriptionMethod_get_Title, METH_VARARGS, ""},
    {"get_Abstract", (PyCFunction)IWMTSLayerDescriptionMethod_get_Abstract, METH_VARARGS, ""},
    {"get_WGS84BoundingBox", (PyCFunction)IWMTSLayerDescriptionMethod_get_WGS84BoundingBox, METH_VARARGS, ""},
    {"get_BoundingBoxCount", (PyCFunction)IWMTSLayerDescriptionMethod_get_BoundingBoxCount, METH_VARARGS, ""},
    {"get_BoundingBox", (PyCFunction)IWMTSLayerDescriptionMethod_get_BoundingBox, METH_VARARGS, ""},
    {"get_StyleDescriptionCount", (PyCFunction)IWMTSLayerDescriptionMethod_get_StyleDescriptionCount, METH_VARARGS, ""},
    {"get_StyleDescription", (PyCFunction)IWMTSLayerDescriptionMethod_get_StyleDescription, METH_VARARGS, ""},
    {"get_WMTSVersion", (PyCFunction)IWMTSLayerDescriptionMethod_get_WMTSVersion, METH_VARARGS, ""},
    {"get_ImageFormatCount", (PyCFunction)IWMTSLayerDescriptionMethod_get_ImageFormatCount, METH_VARARGS, ""},
    {"get_ImageFormat", (PyCFunction)IWMTSLayerDescriptionMethod_get_ImageFormat, METH_VARARGS, ""},
    {"get_FeatureInfoFormatCount", (PyCFunction)IWMTSLayerDescriptionMethod_get_FeatureInfoFormatCount, METH_VARARGS, ""},
    {"get_FeatureInfoFormat", (PyCFunction)IWMTSLayerDescriptionMethod_get_FeatureInfoFormat, METH_VARARGS, ""},
    {"get_DimensionCount", (PyCFunction)IWMTSLayerDescriptionMethod_get_DimensionCount, METH_VARARGS, ""},
    {"get_Dimension", (PyCFunction)IWMTSLayerDescriptionMethod_get_Dimension, METH_VARARGS, ""},
    {"get_TileMatrixSetLinkCount", (PyCFunction)IWMTSLayerDescriptionMethod_get_TileMatrixSetLinkCount, METH_VARARGS, ""},
    {"get_TileMatrixSetLink", (PyCFunction)IWMTSLayerDescriptionMethod_get_TileMatrixSetLink, METH_VARARGS, ""},
    {"GetRESTResourceInfo", (PyCFunction)IWMTSLayerDescriptionMethod_GetRESTResourceInfo, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSLayerDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIWMTSLayerDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSLayerDescription", NULL},
  {"_pointer", (getter)PyIWMTSLayerDescription_GetPointer, NULL, "Get memory address for IWMTSLayerDescription", NULL},
  {"_IID", (getter)PyIWMTSLayerDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSLayerDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSLayerDescription_GetIgnoreFailures, (setter)PyIWMTSLayerDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSLayerDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSLayerDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSLayerDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSLayerDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSLayerDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSLayerDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSLayerDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSTileMatrix

typedef struct PyIWMTSTileMatrixObject {
    PyObject_HEAD
    IWMTSTileMatrix* m_pIWMTSTileMatrix;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSTileMatrixObject;

static PyObject*
PyIWMTSTileMatrixObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSTileMatrixObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSTileMatrix* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSTileMatrix, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSTileMatrix with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSTileMatrixObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSTileMatrix");
            return NULL;
        }
        self->m_pIWMTSTileMatrix = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSTileMatrix");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSTileMatrix");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSTileMatrix* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSTileMatrix, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSTileMatrix");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSTileMatrixObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSTileMatrix");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSTileMatrix = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSTileMatrixObject_dealloc(PyIWMTSTileMatrixObject* self)
{
    if (self->m_pIWMTSTileMatrix)
        self->m_pIWMTSTileMatrix->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSTileMatrix_GetpUnk(PyIWMTSTileMatrixObject* self)
{
    if (!self->m_pIWMTSTileMatrix)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSTileMatrix->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSTileMatrix to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSTileMatrix_GetPointer(PyIWMTSTileMatrixObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSTileMatrix);
}

static PyObject*
PyIWMTSTileMatrix_GetIID(PyIWMTSTileMatrixObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3fc53a77-74d8-4eb5-aa3c-d3797439e2a3");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSTileMatrix_GetHR(PyIWMTSTileMatrixObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSTileMatrix_GetIgnoreFailures(PyIWMTSTileMatrixObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSTileMatrix_SetIgnoreFailures(PyIWMTSTileMatrixObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSTileMatrix_SupportsInterface(PyIWMTSTileMatrixObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSTileMatrix->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSTileMatrixMethod_get_Identifier(PyIWMTSTileMatrixObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsID;
    PyObject* pyvar_ID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ID

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrix->get_Identifier(&bsID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrix->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrix) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrix.get_Identifier() returned %ld", (long)hr);
        goto iwmtstilematrix_get_identifier_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ID = PyUnicode_FromWideChar(bsID,::SysStringLen(bsID));
    ::SysFreeString(bsID);
    
    if (PyErr_Occurred())
      goto iwmtstilematrix_get_identifier_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ID);
    goto iwmtstilematrix_get_identifier_method_cleanup;

    iwmtstilematrix_get_identifier_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ID != Py_None)
        Py_XDECREF(pyvar_ID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrix.get_Identifier");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixMethod_get_ScaleDenominator(PyIWMTSTileMatrixObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dScale = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Scale

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrix->get_ScaleDenominator(&dScale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrix->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrix) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrix.get_ScaleDenominator() returned %ld", (long)hr);
        goto iwmtstilematrix_get_scaledenominator_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Scale

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dScale);
    goto iwmtstilematrix_get_scaledenominator_method_cleanup;

    iwmtstilematrix_get_scaledenominator_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Scale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrix.get_ScaleDenominator");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixMethod_get_TopLeftCorner(PyIWMTSTileMatrixObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    WKSPoint sposition;
    PyObject* py_position = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for position

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrix->get_TopLeftCorner(&sposition);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrix->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrix) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrix.get_TopLeftCorner() returned %ld", (long)hr);
        goto iwmtstilematrix_get_topleftcorner_method_cleanup;
    }

    // Set up return values as needed
    py_position = PyByteArray_FromStringAndSize((char*)&sposition, sizeof(WKSPoint));
    PyObject* RecordWrapposition = NULL;
    if (g_pRecordMap && (RecordWrapposition = PyDict_GetItemString(g_pRecordMap, "WKSPoint")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrapposition, py_position, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_position);
            py_position = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrapposition)
        PyErr_Clear();
    Py_XDECREF(RecordWrapposition);
    
    if (PyErr_Occurred())
      goto iwmtstilematrix_get_topleftcorner_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_position);
    goto iwmtstilematrix_get_topleftcorner_method_cleanup;

    iwmtstilematrix_get_topleftcorner_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_position);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrix.get_TopLeftCorner");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixMethod_get_TileWidth(PyIWMTSTileMatrixObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrix->get_TileWidth(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrix->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrix) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrix.get_TileWidth() returned %ld", (long)hr);
        goto iwmtstilematrix_get_tilewidth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto iwmtstilematrix_get_tilewidth_method_cleanup;

    iwmtstilematrix_get_tilewidth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrix.get_TileWidth");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixMethod_get_TileHeight(PyIWMTSTileMatrixObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrix->get_TileHeight(&lHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrix->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrix) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrix.get_TileHeight() returned %ld", (long)hr);
        goto iwmtstilematrix_get_tileheight_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lHeight);
    goto iwmtstilematrix_get_tileheight_method_cleanup;

    iwmtstilematrix_get_tileheight_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrix.get_TileHeight");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixMethod_get_MatrixWidth(PyIWMTSTileMatrixObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrix->get_MatrixWidth(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrix->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrix) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrix.get_MatrixWidth() returned %ld", (long)hr);
        goto iwmtstilematrix_get_matrixwidth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto iwmtstilematrix_get_matrixwidth_method_cleanup;

    iwmtstilematrix_get_matrixwidth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrix.get_MatrixWidth");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixMethod_get_MatrixHeight(PyIWMTSTileMatrixObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrix->get_MatrixHeight(&lHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrix->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrix) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrix.get_MatrixHeight() returned %ld", (long)hr);
        goto iwmtstilematrix_get_matrixheight_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lHeight);
    goto iwmtstilematrix_get_matrixheight_method_cleanup;

    iwmtstilematrix_get_matrixheight_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrix.get_MatrixHeight");
    return return_tuple;
}


PyMethodDef PyIWMTSTileMatrixMethods[] = {
    {"supports", (PyCFunction)PyIWMTSTileMatrix_SupportsInterface, METH_O, ""},
    {"get_Identifier", (PyCFunction)IWMTSTileMatrixMethod_get_Identifier, METH_VARARGS, ""},
    {"get_ScaleDenominator", (PyCFunction)IWMTSTileMatrixMethod_get_ScaleDenominator, METH_VARARGS, ""},
    {"get_TopLeftCorner", (PyCFunction)IWMTSTileMatrixMethod_get_TopLeftCorner, METH_VARARGS, ""},
    {"get_TileWidth", (PyCFunction)IWMTSTileMatrixMethod_get_TileWidth, METH_VARARGS, ""},
    {"get_TileHeight", (PyCFunction)IWMTSTileMatrixMethod_get_TileHeight, METH_VARARGS, ""},
    {"get_MatrixWidth", (PyCFunction)IWMTSTileMatrixMethod_get_MatrixWidth, METH_VARARGS, ""},
    {"get_MatrixHeight", (PyCFunction)IWMTSTileMatrixMethod_get_MatrixHeight, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSTileMatrixGetSet[] = {
  {"_pUnk", (getter)PyIWMTSTileMatrix_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSTileMatrix", NULL},
  {"_pointer", (getter)PyIWMTSTileMatrix_GetPointer, NULL, "Get memory address for IWMTSTileMatrix", NULL},
  {"_IID", (getter)PyIWMTSTileMatrix_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSTileMatrix_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSTileMatrix_GetIgnoreFailures, (setter)PyIWMTSTileMatrix_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSTileMatrixObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSTileMatrixObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSTileMatrixObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSTileMatrixObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSTileMatrixMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSTileMatrixGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSTileMatrixObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSTileMatrixSet

typedef struct PyIWMTSTileMatrixSetObject {
    PyObject_HEAD
    IWMTSTileMatrixSet* m_pIWMTSTileMatrixSet;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSTileMatrixSetObject;

static PyObject*
PyIWMTSTileMatrixSetObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSTileMatrixSetObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSTileMatrixSet* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSTileMatrixSet, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSTileMatrixSet with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSTileMatrixSetObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSTileMatrixSet");
            return NULL;
        }
        self->m_pIWMTSTileMatrixSet = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSTileMatrixSet");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSTileMatrixSet");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSTileMatrixSet* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSTileMatrixSet, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSTileMatrixSet");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSTileMatrixSetObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSTileMatrixSet");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSTileMatrixSet = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSTileMatrixSetObject_dealloc(PyIWMTSTileMatrixSetObject* self)
{
    if (self->m_pIWMTSTileMatrixSet)
        self->m_pIWMTSTileMatrixSet->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSTileMatrixSet_GetpUnk(PyIWMTSTileMatrixSetObject* self)
{
    if (!self->m_pIWMTSTileMatrixSet)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSTileMatrixSet->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSTileMatrixSet to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSTileMatrixSet_GetPointer(PyIWMTSTileMatrixSetObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSTileMatrixSet);
}

static PyObject*
PyIWMTSTileMatrixSet_GetIID(PyIWMTSTileMatrixSetObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b7d67eda-daf2-49b0-8c27-3c4df14b69b5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSTileMatrixSet_GetHR(PyIWMTSTileMatrixSetObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSTileMatrixSet_GetIgnoreFailures(PyIWMTSTileMatrixSetObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSTileMatrixSet_SetIgnoreFailures(PyIWMTSTileMatrixSetObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSTileMatrixSet_SupportsInterface(PyIWMTSTileMatrixSetObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSTileMatrixSetMethod_get_Identifier(PyIWMTSTileMatrixSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsIdentifier;
    PyObject* pyvar_Identifier = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Identifier

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSet->get_Identifier(&bsIdentifier);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSet.get_Identifier() returned %ld", (long)hr);
        goto iwmtstilematrixset_get_identifier_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Identifier = PyUnicode_FromWideChar(bsIdentifier,::SysStringLen(bsIdentifier));
    ::SysFreeString(bsIdentifier);
    
    if (PyErr_Occurred())
      goto iwmtstilematrixset_get_identifier_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Identifier);
    goto iwmtstilematrixset_get_identifier_method_cleanup;

    iwmtstilematrixset_get_identifier_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Identifier != Py_None)
        Py_XDECREF(pyvar_Identifier);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSet.get_Identifier");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetMethod_get_Title(PyIWMTSTileMatrixSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSet->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSet.get_Title() returned %ld", (long)hr);
        goto iwmtstilematrixset_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmtstilematrixset_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmtstilematrixset_get_title_method_cleanup;

    iwmtstilematrixset_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSet.get_Title");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetMethod_get_SupportedCRS(PyIWMTSTileMatrixSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCRS;
    PyObject* pyvar_CRS = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CRS

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSet->get_SupportedCRS(&bsCRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSet.get_SupportedCRS() returned %ld", (long)hr);
        goto iwmtstilematrixset_get_supportedcrs_method_cleanup;
    }

    // Set up return values as needed
    pyvar_CRS = PyUnicode_FromWideChar(bsCRS,::SysStringLen(bsCRS));
    ::SysFreeString(bsCRS);
    
    if (PyErr_Occurred())
      goto iwmtstilematrixset_get_supportedcrs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CRS);
    goto iwmtstilematrixset_get_supportedcrs_method_cleanup;

    iwmtstilematrixset_get_supportedcrs_method_cleanup:
    self->m_HR = hr;
    if (pyvar_CRS != Py_None)
        Py_XDECREF(pyvar_CRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSet.get_SupportedCRS");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetMethod_get_WellKnownScaleSet(PyIWMTSTileMatrixSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsscaleSetUri;
    PyObject* pyvar_scaleSetUri = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for scaleSetUri

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSet->get_WellKnownScaleSet(&bsscaleSetUri);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSet.get_WellKnownScaleSet() returned %ld", (long)hr);
        goto iwmtstilematrixset_get_wellknownscaleset_method_cleanup;
    }

    // Set up return values as needed
    pyvar_scaleSetUri = PyUnicode_FromWideChar(bsscaleSetUri,::SysStringLen(bsscaleSetUri));
    ::SysFreeString(bsscaleSetUri);
    
    if (PyErr_Occurred())
      goto iwmtstilematrixset_get_wellknownscaleset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_scaleSetUri);
    goto iwmtstilematrixset_get_wellknownscaleset_method_cleanup;

    iwmtstilematrixset_get_wellknownscaleset_method_cleanup:
    self->m_HR = hr;
    if (pyvar_scaleSetUri != Py_None)
        Py_XDECREF(pyvar_scaleSetUri);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSet.get_WellKnownScaleSet");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetMethod_get_BoundingBoxCRS(PyIWMTSTileMatrixSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCRS;
    PyObject* pyvar_CRS = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CRS

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSet->get_BoundingBoxCRS(&bsCRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSet.get_BoundingBoxCRS() returned %ld", (long)hr);
        goto iwmtstilematrixset_get_boundingboxcrs_method_cleanup;
    }

    // Set up return values as needed
    pyvar_CRS = PyUnicode_FromWideChar(bsCRS,::SysStringLen(bsCRS));
    ::SysFreeString(bsCRS);
    
    if (PyErr_Occurred())
      goto iwmtstilematrixset_get_boundingboxcrs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CRS);
    goto iwmtstilematrixset_get_boundingboxcrs_method_cleanup;

    iwmtstilematrixset_get_boundingboxcrs_method_cleanup:
    self->m_HR = hr;
    if (pyvar_CRS != Py_None)
        Py_XDECREF(pyvar_CRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSet.get_BoundingBoxCRS");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetMethod_get_BoundingBox(PyIWMTSTileMatrixSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipBoundingBox = NULL;
    PyObject* py_BoundingBox = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for BoundingBox

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSet->get_BoundingBox(&ipBoundingBox);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSet.get_BoundingBox() returned %ld", (long)hr);
        goto iwmtstilematrixset_get_boundingbox_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_BoundingBox);
    if (ipBoundingBox)
    {
        IUnknown* pUnk = NULL;
        ipBoundingBox->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_BoundingBox = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_BoundingBox)
    {
        if (py_BoundingBox)
           Py_DECREF(py_BoundingBox);
        py_BoundingBox = Py_None;
        Py_INCREF(py_BoundingBox);
    }
    if (PyErr_Occurred())
      goto iwmtstilematrixset_get_boundingbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_BoundingBox);
    goto iwmtstilematrixset_get_boundingbox_method_cleanup;

    iwmtstilematrixset_get_boundingbox_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_BoundingBox);
    if (ipBoundingBox)
      ipBoundingBox->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSet.get_BoundingBox");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetMethod_get_TileMatrixCount(PyIWMTSTileMatrixSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSet->get_TileMatrixCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSet.get_TileMatrixCount() returned %ld", (long)hr);
        goto iwmtstilematrixset_get_tilematrixcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtstilematrixset_get_tilematrixcount_method_cleanup;

    iwmtstilematrixset_get_tilematrixcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSet.get_TileMatrixCount");
    return return_tuple;
}

static PyObject*
IWMTSTileMatrixSetMethod_get_TileMatrix(PyIWMTSTileMatrixSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMTSTileMatrix* ipppTileMatrix = NULL;
    PyObject* py_ppTileMatrix = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtstilematrixset_get_tilematrix_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppTileMatrix

    // Call method on actual COM interface
    hr = self->m_pIWMTSTileMatrixSet->get_TileMatrix(lindex, &ipppTileMatrix);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSTileMatrixSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSTileMatrixSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSTileMatrixSet.get_TileMatrix() returned %ld", (long)hr);
        goto iwmtstilematrixset_get_tilematrix_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppTileMatrix);
    if (ipppTileMatrix)
    {
        IUnknown* pUnk = NULL;
        ipppTileMatrix->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTileMatrix = IUnknownToPythonIIDObject(pUnk, &IID_IWMTSTileMatrix);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTileMatrix)
    {
        if (py_ppTileMatrix)
           Py_DECREF(py_ppTileMatrix);
        py_ppTileMatrix = Py_None;
        Py_INCREF(py_ppTileMatrix);
    }
    if (PyErr_Occurred())
      goto iwmtstilematrixset_get_tilematrix_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTileMatrix);
    goto iwmtstilematrixset_get_tilematrix_method_cleanup;

    iwmtstilematrixset_get_tilematrix_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppTileMatrix);
    if (ipppTileMatrix)
      ipppTileMatrix->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSTileMatrixSet.get_TileMatrix");
    return return_tuple;
}


PyMethodDef PyIWMTSTileMatrixSetMethods[] = {
    {"supports", (PyCFunction)PyIWMTSTileMatrixSet_SupportsInterface, METH_O, ""},
    {"get_Identifier", (PyCFunction)IWMTSTileMatrixSetMethod_get_Identifier, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IWMTSTileMatrixSetMethod_get_Title, METH_VARARGS, ""},
    {"get_SupportedCRS", (PyCFunction)IWMTSTileMatrixSetMethod_get_SupportedCRS, METH_VARARGS, ""},
    {"get_WellKnownScaleSet", (PyCFunction)IWMTSTileMatrixSetMethod_get_WellKnownScaleSet, METH_VARARGS, ""},
    {"get_BoundingBoxCRS", (PyCFunction)IWMTSTileMatrixSetMethod_get_BoundingBoxCRS, METH_VARARGS, ""},
    {"get_BoundingBox", (PyCFunction)IWMTSTileMatrixSetMethod_get_BoundingBox, METH_VARARGS, ""},
    {"get_TileMatrixCount", (PyCFunction)IWMTSTileMatrixSetMethod_get_TileMatrixCount, METH_VARARGS, ""},
    {"get_TileMatrix", (PyCFunction)IWMTSTileMatrixSetMethod_get_TileMatrix, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSTileMatrixSetGetSet[] = {
  {"_pUnk", (getter)PyIWMTSTileMatrixSet_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSTileMatrixSet", NULL},
  {"_pointer", (getter)PyIWMTSTileMatrixSet_GetPointer, NULL, "Get memory address for IWMTSTileMatrixSet", NULL},
  {"_IID", (getter)PyIWMTSTileMatrixSet_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSTileMatrixSet_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSTileMatrixSet_GetIgnoreFailures, (setter)PyIWMTSTileMatrixSet_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSTileMatrixSetObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSTileMatrixSetObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSTileMatrixSetObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSTileMatrixSetObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSTileMatrixSetMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSTileMatrixSetGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSTileMatrixSetObject_new,                      
                                              /* tp_new */
};

// Interface IWMSServiceExceptionHandler

typedef struct PyIWMSServiceExceptionHandlerObject {
    PyObject_HEAD
    IWMSServiceExceptionHandler* m_pIWMSServiceExceptionHandler;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMSServiceExceptionHandlerObject;

static PyObject*
PyIWMSServiceExceptionHandlerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMSServiceExceptionHandlerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMSServiceExceptionHandler* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMSServiceExceptionHandler, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMSServiceExceptionHandler with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMSServiceExceptionHandlerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSServiceExceptionHandler");
            return NULL;
        }
        self->m_pIWMSServiceExceptionHandler = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMSServiceExceptionHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMSServiceExceptionHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMSServiceExceptionHandler* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMSServiceExceptionHandler, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMSServiceExceptionHandler");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMSServiceExceptionHandlerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSServiceExceptionHandler");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMSServiceExceptionHandler = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMSServiceExceptionHandlerObject_dealloc(PyIWMSServiceExceptionHandlerObject* self)
{
    if (self->m_pIWMSServiceExceptionHandler)
        self->m_pIWMSServiceExceptionHandler->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMSServiceExceptionHandler_GetpUnk(PyIWMSServiceExceptionHandlerObject* self)
{
    if (!self->m_pIWMSServiceExceptionHandler)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMSServiceExceptionHandler->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMSServiceExceptionHandler to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMSServiceExceptionHandler_GetPointer(PyIWMSServiceExceptionHandlerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMSServiceExceptionHandler);
}

static PyObject*
PyIWMSServiceExceptionHandler_GetIID(PyIWMSServiceExceptionHandlerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cfcaca30-440a-488e-815a-86351cd78ecc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMSServiceExceptionHandler_GetHR(PyIWMSServiceExceptionHandlerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMSServiceExceptionHandler_GetIgnoreFailures(PyIWMSServiceExceptionHandlerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMSServiceExceptionHandler_SetIgnoreFailures(PyIWMSServiceExceptionHandlerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMSServiceExceptionHandler_SupportsInterface(PyIWMSServiceExceptionHandlerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMSServiceExceptionHandler->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMSServiceExceptionHandlerMethod_ParseExceptions(PyIWMSServiceExceptionHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileOrURL = 0;
    PyObject* pyvar_fileOrURL;
    PyObject* unicodefileOrURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileOrURL))
      goto iwmsserviceexceptionhandler_parseexceptions_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileOrURL))
        unicodefileOrURL = PyUnicode_FromObject(pyvar_fileOrURL);
    else if (PyUnicode_Check(pyvar_fileOrURL))
    {
        unicodefileOrURL = pyvar_fileOrURL;
        Py_INCREF(unicodefileOrURL);
    }
    else if (pyvar_fileOrURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileOrURL at index 0");
    if (unicodefileOrURL)
        bsfileOrURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileOrURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileOrURL));
    
    if (PyErr_Occurred())
      goto iwmsserviceexceptionhandler_parseexceptions_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceExceptionHandler->ParseExceptions(bsfileOrURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceExceptionHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceExceptionHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceExceptionHandler.ParseExceptions() returned %ld", (long)hr);
        goto iwmsserviceexceptionhandler_parseexceptions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileOrURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmsserviceexceptionhandler_parseexceptions_method_cleanup;

    iwmsserviceexceptionhandler_parseexceptions_method_cleanup:
    self->m_HR = hr;
    if (bsfileOrURL)
        ::SysFreeString(bsfileOrURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceExceptionHandler.ParseExceptions");
    return return_tuple;
}

static PyObject*
IWMSServiceExceptionHandlerMethod_get_ExceptionCount(PyIWMSServiceExceptionHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceExceptionHandler->get_ExceptionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceExceptionHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceExceptionHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceExceptionHandler.get_ExceptionCount() returned %ld", (long)hr);
        goto iwmsserviceexceptionhandler_get_exceptioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmsserviceexceptionhandler_get_exceptioncount_method_cleanup;

    iwmsserviceexceptionhandler_get_exceptioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceExceptionHandler.get_ExceptionCount");
    return return_tuple;
}

static PyObject*
IWMSServiceExceptionHandlerMethod_get_ExceptionCode(PyIWMSServiceExceptionHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bswmsErrorCode;
    PyObject* pyvar_wmsErrorCode = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmsserviceexceptionhandler_get_exceptioncode_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for wmsErrorCode

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceExceptionHandler->get_ExceptionCode(lindex, &bswmsErrorCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceExceptionHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceExceptionHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceExceptionHandler.get_ExceptionCode() returned %ld", (long)hr);
        goto iwmsserviceexceptionhandler_get_exceptioncode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_wmsErrorCode = PyUnicode_FromWideChar(bswmsErrorCode,::SysStringLen(bswmsErrorCode));
    ::SysFreeString(bswmsErrorCode);
    
    if (PyErr_Occurred())
      goto iwmsserviceexceptionhandler_get_exceptioncode_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_wmsErrorCode);
    goto iwmsserviceexceptionhandler_get_exceptioncode_method_cleanup;

    iwmsserviceexceptionhandler_get_exceptioncode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_wmsErrorCode != Py_None)
        Py_XDECREF(pyvar_wmsErrorCode);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceExceptionHandler.get_ExceptionCode");
    return return_tuple;
}

static PyObject*
IWMSServiceExceptionHandlerMethod_get_ExceptionDescription(PyIWMSServiceExceptionHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bswmsErrorDescription;
    PyObject* pyvar_wmsErrorDescription = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmsserviceexceptionhandler_get_exceptiondescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for wmsErrorDescription

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceExceptionHandler->get_ExceptionDescription(lindex, &bswmsErrorDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceExceptionHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceExceptionHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceExceptionHandler.get_ExceptionDescription() returned %ld", (long)hr);
        goto iwmsserviceexceptionhandler_get_exceptiondescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_wmsErrorDescription = PyUnicode_FromWideChar(bswmsErrorDescription,::SysStringLen(bswmsErrorDescription));
    ::SysFreeString(bswmsErrorDescription);
    
    if (PyErr_Occurred())
      goto iwmsserviceexceptionhandler_get_exceptiondescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_wmsErrorDescription);
    goto iwmsserviceexceptionhandler_get_exceptiondescription_method_cleanup;

    iwmsserviceexceptionhandler_get_exceptiondescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_wmsErrorDescription != Py_None)
        Py_XDECREF(pyvar_wmsErrorDescription);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceExceptionHandler.get_ExceptionDescription");
    return return_tuple;
}


PyMethodDef PyIWMSServiceExceptionHandlerMethods[] = {
    {"supports", (PyCFunction)PyIWMSServiceExceptionHandler_SupportsInterface, METH_O, ""},
    {"ParseExceptions", (PyCFunction)IWMSServiceExceptionHandlerMethod_ParseExceptions, METH_VARARGS, ""},
    {"get_ExceptionCount", (PyCFunction)IWMSServiceExceptionHandlerMethod_get_ExceptionCount, METH_VARARGS, ""},
    {"get_ExceptionCode", (PyCFunction)IWMSServiceExceptionHandlerMethod_get_ExceptionCode, METH_VARARGS, ""},
    {"get_ExceptionDescription", (PyCFunction)IWMSServiceExceptionHandlerMethod_get_ExceptionDescription, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMSServiceExceptionHandlerGetSet[] = {
  {"_pUnk", (getter)PyIWMSServiceExceptionHandler_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMSServiceExceptionHandler", NULL},
  {"_pointer", (getter)PyIWMSServiceExceptionHandler_GetPointer, NULL, "Get memory address for IWMSServiceExceptionHandler", NULL},
  {"_IID", (getter)PyIWMSServiceExceptionHandler_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMSServiceExceptionHandler_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMSServiceExceptionHandler_GetIgnoreFailures, (setter)PyIWMSServiceExceptionHandler_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMSServiceExceptionHandlerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMSServiceExceptionHandlerObject",                          
                                              /* tp_name */
  sizeof(PyIWMSServiceExceptionHandlerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMSServiceExceptionHandlerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMSServiceExceptionHandlerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMSServiceExceptionHandlerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMSServiceExceptionHandlerObject_new,                      
                                              /* tp_new */
};

// Interface IWMSConnectionName

typedef struct PyIWMSConnectionNameObject {
    PyObject_HEAD
    IWMSConnectionName* m_pIWMSConnectionName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMSConnectionNameObject;

static PyObject*
PyIWMSConnectionNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMSConnectionNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMSConnectionName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMSConnectionName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMSConnectionName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMSConnectionNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSConnectionName");
            return NULL;
        }
        self->m_pIWMSConnectionName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMSConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMSConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMSConnectionName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMSConnectionName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMSConnectionName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMSConnectionNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSConnectionName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMSConnectionName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMSConnectionNameObject_dealloc(PyIWMSConnectionNameObject* self)
{
    if (self->m_pIWMSConnectionName)
        self->m_pIWMSConnectionName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMSConnectionName_GetpUnk(PyIWMSConnectionNameObject* self)
{
    if (!self->m_pIWMSConnectionName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMSConnectionName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMSConnectionName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMSConnectionName_GetPointer(PyIWMSConnectionNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMSConnectionName);
}

static PyObject*
PyIWMSConnectionName_GetIID(PyIWMSConnectionNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "07c8fd52-5d97-4b1f-a6bf-4973c9bb4117");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMSConnectionName_GetHR(PyIWMSConnectionNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMSConnectionName_GetIgnoreFailures(PyIWMSConnectionNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMSConnectionName_SetIgnoreFailures(PyIWMSConnectionNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMSConnectionName_SupportsInterface(PyIWMSConnectionNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMSConnectionName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMSConnectionNameMethod_put_ConnectionProperties(PyIWMSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipConnectionProperties = NULL;
    PyObject* py_ConnectionProperties;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ConnectionProperties))
      goto iwmsconnectionname_put_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ConnectionProperties, &IID_IPropertySet, (void**)&ipConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument ConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iwmsconnectionname_put_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMSConnectionName->put_ConnectionProperties(ipConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSConnectionName.put_ConnectionProperties() returned %ld", (long)hr);
        goto iwmsconnectionname_put_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ConnectionProperties

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmsconnectionname_put_connectionproperties_method_cleanup;

    iwmsconnectionname_put_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipConnectionProperties)
      ipConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSConnectionName.put_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IWMSConnectionNameMethod_get_ConnectionProperties(PyIWMSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipConnectionProperties = NULL;
    PyObject* py_ConnectionProperties = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ConnectionProperties

    // Call method on actual COM interface
    hr = self->m_pIWMSConnectionName->get_ConnectionProperties(&ipConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSConnectionName.get_ConnectionProperties() returned %ld", (long)hr);
        goto iwmsconnectionname_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
    {
        IUnknown* pUnk = NULL;
        ipConnectionProperties->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ConnectionProperties = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ConnectionProperties)
    {
        if (py_ConnectionProperties)
           Py_DECREF(py_ConnectionProperties);
        py_ConnectionProperties = Py_None;
        Py_INCREF(py_ConnectionProperties);
    }
    if (PyErr_Occurred())
      goto iwmsconnectionname_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ConnectionProperties);
    goto iwmsconnectionname_get_connectionproperties_method_cleanup;

    iwmsconnectionname_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
      ipConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSConnectionName.get_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IWMSConnectionNameMethod_OpenEx(PyIWMSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IUnknown* ipppUnknown = NULL;
    PyObject* py_ppUnknown = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto iwmsconnectionname_openex_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iwmsconnectionname_openex_method_cleanup;
    
    // No setup for ppUnknown

    // Call method on actual COM interface
    hr = self->m_pIWMSConnectionName->OpenEx(ippTrackCancel, &ipppUnknown);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSConnectionName.OpenEx() returned %ld", (long)hr);
        goto iwmsconnectionname_openex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppUnknown);
    if (ipppUnknown)
    {
        IUnknown* pUnk = NULL;
        ipppUnknown->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUnknown = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUnknown)
    {
        if (py_ppUnknown)
           Py_DECREF(py_ppUnknown);
        py_ppUnknown = Py_None;
        Py_INCREF(py_ppUnknown);
    }
    if (PyErr_Occurred())
      goto iwmsconnectionname_openex_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUnknown);
    goto iwmsconnectionname_openex_method_cleanup;

    iwmsconnectionname_openex_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppUnknown);
    if (ipppUnknown)
      ipppUnknown->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSConnectionName.OpenEx");
    return return_tuple;
}


PyMethodDef PyIWMSConnectionNameMethods[] = {
    {"supports", (PyCFunction)PyIWMSConnectionName_SupportsInterface, METH_O, ""},
    {"put_ConnectionProperties", (PyCFunction)IWMSConnectionNameMethod_put_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IWMSConnectionNameMethod_get_ConnectionProperties, METH_VARARGS, ""},
    {"OpenEx", (PyCFunction)IWMSConnectionNameMethod_OpenEx, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMSConnectionNameGetSet[] = {
  {"_pUnk", (getter)PyIWMSConnectionName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMSConnectionName", NULL},
  {"_pointer", (getter)PyIWMSConnectionName_GetPointer, NULL, "Get memory address for IWMSConnectionName", NULL},
  {"_IID", (getter)PyIWMSConnectionName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMSConnectionName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMSConnectionName_GetIgnoreFailures, (setter)PyIWMSConnectionName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMSConnectionNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMSConnectionNameObject",                          
                                              /* tp_name */
  sizeof(PyIWMSConnectionNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMSConnectionNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMSConnectionNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMSConnectionNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMSConnectionNameObject_new,                      
                                              /* tp_new */
};

// Interface IWMSConnection

typedef struct PyIWMSConnectionObject {
    PyObject_HEAD
    IWMSConnection* m_pIWMSConnection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMSConnectionObject;

static PyObject*
PyIWMSConnectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMSConnectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMSConnection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMSConnection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMSConnection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMSConnectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSConnection");
            return NULL;
        }
        self->m_pIWMSConnection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMSConnection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMSConnection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMSConnection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMSConnection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMSConnection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMSConnectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSConnection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMSConnection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMSConnectionObject_dealloc(PyIWMSConnectionObject* self)
{
    if (self->m_pIWMSConnection)
        self->m_pIWMSConnection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMSConnection_GetpUnk(PyIWMSConnectionObject* self)
{
    if (!self->m_pIWMSConnection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMSConnection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMSConnection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMSConnection_GetPointer(PyIWMSConnectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMSConnection);
}

static PyObject*
PyIWMSConnection_GetIID(PyIWMSConnectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "67bc7de0-0a6d-4ba6-9d26-437c44dbddf3");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMSConnection_GetHR(PyIWMSConnectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMSConnection_GetIgnoreFailures(PyIWMSConnectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMSConnection_SetIgnoreFailures(PyIWMSConnectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMSConnection_SupportsInterface(PyIWMSConnectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMSConnection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMSConnectionMethod_get_Name(PyIWMSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWMSConnection->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSConnection.get_Name() returned %ld", (long)hr);
        goto iwmsconnection_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwmsconnection_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwmsconnection_get_name_method_cleanup;

    iwmsconnection_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSConnection.get_Name");
    return return_tuple;
}

static PyObject*
IWMSConnectionMethod_put_Name(PyIWMSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iwmsconnection_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iwmsconnection_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMSConnection->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSConnection.put_Name() returned %ld", (long)hr);
        goto iwmsconnection_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmsconnection_put_name_method_cleanup;

    iwmsconnection_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSConnection.put_Name");
    return return_tuple;
}

static PyObject*
IWMSConnectionMethod_get_FullName(PyIWMSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppName = NULL;
    PyObject* py_ppName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppName

    // Call method on actual COM interface
    hr = self->m_pIWMSConnection->get_FullName(&ipppName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSConnection.get_FullName() returned %ld", (long)hr);
        goto iwmsconnection_get_fullname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppName);
    if (ipppName)
    {
        IUnknown* pUnk = NULL;
        ipppName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppName = IUnknownToPythonIIDObject(pUnk, &IID_IName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppName)
    {
        if (py_ppName)
           Py_DECREF(py_ppName);
        py_ppName = Py_None;
        Py_INCREF(py_ppName);
    }
    if (PyErr_Occurred())
      goto iwmsconnection_get_fullname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppName);
    goto iwmsconnection_get_fullname_method_cleanup;

    iwmsconnection_get_fullname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppName);
    if (ipppName)
      ipppName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSConnection.get_FullName");
    return return_tuple;
}

static PyObject*
IWMSConnectionMethod_putref_FullName(PyIWMSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppName = NULL;
    PyObject* py_ppName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppName))
      goto iwmsconnection_putref_fullname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppName, &IID_IName, (void**)&ipppName))
        PyErr_SetString(PyExc_TypeError, "Argument ppName (position 0) is not IName");
    
    if (PyErr_Occurred())
      goto iwmsconnection_putref_fullname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMSConnection->putref_FullName(ipppName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSConnection.putref_FullName() returned %ld", (long)hr);
        goto iwmsconnection_putref_fullname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmsconnection_putref_fullname_method_cleanup;

    iwmsconnection_putref_fullname_method_cleanup:
    self->m_HR = hr;
    if (ipppName)
      ipppName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSConnection.putref_FullName");
    return return_tuple;
}


PyMethodDef PyIWMSConnectionMethods[] = {
    {"supports", (PyCFunction)PyIWMSConnection_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IWMSConnectionMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IWMSConnectionMethod_put_Name, METH_VARARGS, ""},
    {"get_FullName", (PyCFunction)IWMSConnectionMethod_get_FullName, METH_VARARGS, ""},
    {"putref_FullName", (PyCFunction)IWMSConnectionMethod_putref_FullName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMSConnectionGetSet[] = {
  {"_pUnk", (getter)PyIWMSConnection_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMSConnection", NULL},
  {"_pointer", (getter)PyIWMSConnection_GetPointer, NULL, "Get memory address for IWMSConnection", NULL},
  {"_IID", (getter)PyIWMSConnection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMSConnection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMSConnection_GetIgnoreFailures, (setter)PyIWMSConnection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMSConnectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMSConnectionObject",                          
                                              /* tp_name */
  sizeof(PyIWMSConnectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMSConnectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMSConnectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMSConnectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMSConnectionObject_new,                      
                                              /* tp_new */
};

// Interface IWMSConnectionFactory

typedef struct PyIWMSConnectionFactoryObject {
    PyObject_HEAD
    IWMSConnectionFactory* m_pIWMSConnectionFactory;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMSConnectionFactoryObject;

static PyObject*
PyIWMSConnectionFactoryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMSConnectionFactoryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMSConnectionFactory* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMSConnectionFactory, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMSConnectionFactory with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMSConnectionFactoryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSConnectionFactory");
            return NULL;
        }
        self->m_pIWMSConnectionFactory = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMSConnectionFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMSConnectionFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMSConnectionFactory* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMSConnectionFactory, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMSConnectionFactory");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMSConnectionFactoryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSConnectionFactory");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMSConnectionFactory = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMSConnectionFactoryObject_dealloc(PyIWMSConnectionFactoryObject* self)
{
    if (self->m_pIWMSConnectionFactory)
        self->m_pIWMSConnectionFactory->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMSConnectionFactory_GetpUnk(PyIWMSConnectionFactoryObject* self)
{
    if (!self->m_pIWMSConnectionFactory)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMSConnectionFactory->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMSConnectionFactory to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMSConnectionFactory_GetPointer(PyIWMSConnectionFactoryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMSConnectionFactory);
}

static PyObject*
PyIWMSConnectionFactory_GetIID(PyIWMSConnectionFactoryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "253c9134-0d0f-45c7-bfdc-d230d0f8ce35");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMSConnectionFactory_GetHR(PyIWMSConnectionFactoryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMSConnectionFactory_GetIgnoreFailures(PyIWMSConnectionFactoryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMSConnectionFactory_SetIgnoreFailures(PyIWMSConnectionFactoryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMSConnectionFactory_SupportsInterface(PyIWMSConnectionFactoryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMSConnectionFactory->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMSConnectionFactoryMethod_Open(PyIWMSConnectionFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippConnectionProperties = NULL;
    PyObject* py_pConnectionProperties;
    OLE_HANDLE HhWnd = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IWMSConnection* ipppConnection = NULL;
    PyObject* py_ppConnection = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OIO", &py_pConnectionProperties, &HhWnd, &py_pTrackCancel))
      goto iwmsconnectionfactory_open_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConnectionProperties, &IID_IPropertySet, (void**)&ippConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument pConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iwmsconnectionfactory_open_method_cleanup;
    
    // No setup for hWnd
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iwmsconnectionfactory_open_method_cleanup;
    
    // No setup for ppConnection

    // Call method on actual COM interface
    hr = self->m_pIWMSConnectionFactory->Open(ippConnectionProperties, HhWnd, ippTrackCancel, &ipppConnection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSConnectionFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSConnectionFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSConnectionFactory.Open() returned %ld", (long)hr);
        goto iwmsconnectionfactory_open_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnectionProperties
    // No teardown for hWnd
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
    {
        IUnknown* pUnk = NULL;
        ipppConnection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnection = IUnknownToPythonIIDObject(pUnk, &IID_IWMSConnection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnection)
    {
        if (py_ppConnection)
           Py_DECREF(py_ppConnection);
        py_ppConnection = Py_None;
        Py_INCREF(py_ppConnection);
    }
    if (PyErr_Occurred())
      goto iwmsconnectionfactory_open_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnection);
    goto iwmsconnectionfactory_open_method_cleanup;

    iwmsconnectionfactory_open_method_cleanup:
    self->m_HR = hr;
    if (ippConnectionProperties)
      ippConnectionProperties->Release();
    // No cleanup for hWnd
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
      ipppConnection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSConnectionFactory.Open");
    return return_tuple;
}


PyMethodDef PyIWMSConnectionFactoryMethods[] = {
    {"supports", (PyCFunction)PyIWMSConnectionFactory_SupportsInterface, METH_O, ""},
    {"Open", (PyCFunction)IWMSConnectionFactoryMethod_Open, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMSConnectionFactoryGetSet[] = {
  {"_pUnk", (getter)PyIWMSConnectionFactory_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMSConnectionFactory", NULL},
  {"_pointer", (getter)PyIWMSConnectionFactory_GetPointer, NULL, "Get memory address for IWMSConnectionFactory", NULL},
  {"_IID", (getter)PyIWMSConnectionFactory_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMSConnectionFactory_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMSConnectionFactory_GetIgnoreFailures, (setter)PyIWMSConnectionFactory_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMSConnectionFactoryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMSConnectionFactoryObject",                          
                                              /* tp_name */
  sizeof(PyIWMSConnectionFactoryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMSConnectionFactoryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMSConnectionFactoryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMSConnectionFactoryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMSConnectionFactoryObject_new,                      
                                              /* tp_new */
};

// Interface IWMSServiceDescription

typedef struct PyIWMSServiceDescriptionObject {
    PyObject_HEAD
    IWMSServiceDescription* m_pIWMSServiceDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMSServiceDescriptionObject;

static PyObject*
PyIWMSServiceDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMSServiceDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMSServiceDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMSServiceDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMSServiceDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMSServiceDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSServiceDescription");
            return NULL;
        }
        self->m_pIWMSServiceDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMSServiceDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMSServiceDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMSServiceDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMSServiceDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMSServiceDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMSServiceDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSServiceDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMSServiceDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMSServiceDescriptionObject_dealloc(PyIWMSServiceDescriptionObject* self)
{
    if (self->m_pIWMSServiceDescription)
        self->m_pIWMSServiceDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMSServiceDescription_GetpUnk(PyIWMSServiceDescriptionObject* self)
{
    if (!self->m_pIWMSServiceDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMSServiceDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMSServiceDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMSServiceDescription_GetPointer(PyIWMSServiceDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMSServiceDescription);
}

static PyObject*
PyIWMSServiceDescription_GetIID(PyIWMSServiceDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "de0e6ebf-8abf-4700-b9f5-b097e14c0e51");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMSServiceDescription_GetHR(PyIWMSServiceDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMSServiceDescription_GetIgnoreFailures(PyIWMSServiceDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMSServiceDescription_SetIgnoreFailures(PyIWMSServiceDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMSServiceDescription_SupportsInterface(PyIWMSServiceDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMSServiceDescriptionMethod_get_WMSName(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_WMSName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_WMSName() returned %ld", (long)hr);
        goto iwmsservicedescription_get_wmsname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_wmsname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwmsservicedescription_get_wmsname_method_cleanup;

    iwmsservicedescription_get_wmsname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_WMSName");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_WMSAbstract(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_WMSAbstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_WMSAbstract() returned %ld", (long)hr);
        goto iwmsservicedescription_get_wmsabstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_wmsabstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwmsservicedescription_get_wmsabstract_method_cleanup;

    iwmsservicedescription_get_wmsabstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_WMSAbstract");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_WMSTitle(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_WMSTitle(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_WMSTitle() returned %ld", (long)hr);
        goto iwmsservicedescription_get_wmstitle_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_wmstitle_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmsservicedescription_get_wmstitle_method_cleanup;

    iwmsservicedescription_get_wmstitle_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_WMSTitle");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_WMSVersion(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_WMSVersion(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_WMSVersion() returned %ld", (long)hr);
        goto iwmsservicedescription_get_wmsversion_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_wmsversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmsservicedescription_get_wmsversion_method_cleanup;

    iwmsservicedescription_get_wmsversion_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_WMSVersion");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_LayerDescriptionCount(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_LayerDescriptionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_LayerDescriptionCount() returned %ld", (long)hr);
        goto iwmsservicedescription_get_layerdescriptioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmsservicedescription_get_layerdescriptioncount_method_cleanup;

    iwmsservicedescription_get_layerdescriptioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_LayerDescriptionCount");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_LayerDescription(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMSLayerDescription* ipppLayerDescription = NULL;
    PyObject* py_ppLayerDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmsservicedescription_get_layerdescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppLayerDescription

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_LayerDescription(lindex, &ipppLayerDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_LayerDescription() returned %ld", (long)hr);
        goto iwmsservicedescription_get_layerdescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppLayerDescription);
    if (ipppLayerDescription)
    {
        IUnknown* pUnk = NULL;
        ipppLayerDescription->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppLayerDescription = IUnknownToPythonIIDObject(pUnk, &IID_IWMSLayerDescription);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppLayerDescription)
    {
        if (py_ppLayerDescription)
           Py_DECREF(py_ppLayerDescription);
        py_ppLayerDescription = Py_None;
        Py_INCREF(py_ppLayerDescription);
    }
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_layerdescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppLayerDescription);
    goto iwmsservicedescription_get_layerdescription_method_cleanup;

    iwmsservicedescription_get_layerdescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppLayerDescription);
    if (ipppLayerDescription)
      ipppLayerDescription->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_LayerDescription");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_SRSCount(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_SRSCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_SRSCount() returned %ld", (long)hr);
        goto iwmsservicedescription_get_srscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmsservicedescription_get_srscount_method_cleanup;

    iwmsservicedescription_get_srscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_SRSCount");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_SRS(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsSRS;
    PyObject* pyvar_SRS = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmsservicedescription_get_srs_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for SRS

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_SRS(lindex, &bsSRS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_SRS() returned %ld", (long)hr);
        goto iwmsservicedescription_get_srs_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_SRS = PyUnicode_FromWideChar(bsSRS,::SysStringLen(bsSRS));
    ::SysFreeString(bsSRS);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_srs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_SRS);
    goto iwmsservicedescription_get_srs_method_cleanup;

    iwmsservicedescription_get_srs_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_SRS != Py_None)
        Py_XDECREF(pyvar_SRS);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_SRS");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_ImageRequestUrl(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ippLayers = NULL;
    PyObject* py_pLayers;
    IEnvelope* ippBoundingBox = NULL;
    PyObject* py_pBoundingBox;
    long limageWidth = 0;
    long limageHeight = 0;
    OLE_COLOR HbgColor = 0;
    BSTR bsresponseFormat = 0;
    PyObject* pyvar_responseFormat;
    PyObject* unicoderesponseFormat = NULL;
    VARIANT_BOOL b_drawTransparent = VARIANT_FALSE;
    PyObject* pyvar_drawTransparent = NULL;
    BSTR bsURL;
    PyObject* pyvar_URL = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOllIOO", &py_pLayers, &py_pBoundingBox, &limageWidth, &limageHeight, &HbgColor, &pyvar_responseFormat, &pyvar_drawTransparent))
      goto iwmsservicedescription_get_imagerequesturl_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pLayers, &IID_IArray, (void**)&ippLayers))
        PyErr_SetString(PyExc_TypeError, "Argument pLayers (position 0) is not IArray");
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_imagerequesturl_method_cleanup;
    
    if (!IFaceFromPyObject(py_pBoundingBox, &IID_IEnvelope, (void**)&ippBoundingBox))
        PyErr_SetString(PyExc_TypeError, "Argument pBoundingBox (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_imagerequesturl_method_cleanup;
    
    // No setup for imageWidth
    // No setup for imageHeight
    // No setup for bgColor
    if (PyString_Check(pyvar_responseFormat))
        unicoderesponseFormat = PyUnicode_FromObject(pyvar_responseFormat);
    else if (PyUnicode_Check(pyvar_responseFormat))
    {
        unicoderesponseFormat = pyvar_responseFormat;
        Py_INCREF(unicoderesponseFormat);
    }
    else if (pyvar_responseFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter responseFormat at index 5");
    if (unicoderesponseFormat)
        bsresponseFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderesponseFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderesponseFormat));
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_imagerequesturl_method_cleanup;
    
    b_drawTransparent = ((PyObject_IsTrue(pyvar_drawTransparent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_imagerequesturl_method_cleanup;
    
    // No setup for URL

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_ImageRequestUrl(ippLayers, ippBoundingBox, limageWidth, limageHeight, HbgColor, bsresponseFormat, b_drawTransparent, &bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_ImageRequestUrl() returned %ld", (long)hr);
        goto iwmsservicedescription_get_imagerequesturl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pLayers
    // No teardown for pBoundingBox
    // No teardown for imageWidth
    // No teardown for imageHeight
    // No teardown for bgColor
    // No teardown for responseFormat
    // No teardown for drawTransparent
    pyvar_URL = PyUnicode_FromWideChar(bsURL,::SysStringLen(bsURL));
    ::SysFreeString(bsURL);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_imagerequesturl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_URL);
    goto iwmsservicedescription_get_imagerequesturl_method_cleanup;

    iwmsservicedescription_get_imagerequesturl_method_cleanup:
    self->m_HR = hr;
    if (ippLayers)
      ippLayers->Release();
    if (ippBoundingBox)
      ippBoundingBox->Release();
    // No cleanup for imageWidth
    // No cleanup for imageHeight
    // No cleanup for bgColor
    if (bsresponseFormat)
        ::SysFreeString(bsresponseFormat);
    
    // No cleanup for drawTransparent
    if (pyvar_URL != Py_None)
        Py_XDECREF(pyvar_URL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_ImageRequestUrl");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_FeatureInfoRequestURL(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ippLayers = NULL;
    PyObject* py_pLayers;
    IEnvelope* ippBoundingBox = NULL;
    PyObject* py_pBoundingBox;
    long limageWidth = 0;
    long limageHeight = 0;
    long lpositionX = 0;
    long lpositionY = 0;
    long lfeatureCount = 0;
    BSTR bsresponseFormat = 0;
    PyObject* pyvar_responseFormat;
    PyObject* unicoderesponseFormat = NULL;
    BSTR bsURL;
    PyObject* pyvar_URL = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOlllllO", &py_pLayers, &py_pBoundingBox, &limageWidth, &limageHeight, &lpositionX, &lpositionY, &lfeatureCount, &pyvar_responseFormat))
      goto iwmsservicedescription_get_featureinforequesturl_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pLayers, &IID_IArray, (void**)&ippLayers))
        PyErr_SetString(PyExc_TypeError, "Argument pLayers (position 0) is not IArray");
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_featureinforequesturl_method_cleanup;
    
    if (!IFaceFromPyObject(py_pBoundingBox, &IID_IEnvelope, (void**)&ippBoundingBox))
        PyErr_SetString(PyExc_TypeError, "Argument pBoundingBox (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_featureinforequesturl_method_cleanup;
    
    // No setup for imageWidth
    // No setup for imageHeight
    // No setup for positionX
    // No setup for positionY
    // No setup for featureCount
    if (PyString_Check(pyvar_responseFormat))
        unicoderesponseFormat = PyUnicode_FromObject(pyvar_responseFormat);
    else if (PyUnicode_Check(pyvar_responseFormat))
    {
        unicoderesponseFormat = pyvar_responseFormat;
        Py_INCREF(unicoderesponseFormat);
    }
    else if (pyvar_responseFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter responseFormat at index 7");
    if (unicoderesponseFormat)
        bsresponseFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderesponseFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderesponseFormat));
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_featureinforequesturl_method_cleanup;
    
    // No setup for URL

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_FeatureInfoRequestURL(ippLayers, ippBoundingBox, limageWidth, limageHeight, lpositionX, lpositionY, lfeatureCount, bsresponseFormat, &bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_FeatureInfoRequestURL() returned %ld", (long)hr);
        goto iwmsservicedescription_get_featureinforequesturl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pLayers
    // No teardown for pBoundingBox
    // No teardown for imageWidth
    // No teardown for imageHeight
    // No teardown for positionX
    // No teardown for positionY
    // No teardown for featureCount
    // No teardown for responseFormat
    pyvar_URL = PyUnicode_FromWideChar(bsURL,::SysStringLen(bsURL));
    ::SysFreeString(bsURL);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_featureinforequesturl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_URL);
    goto iwmsservicedescription_get_featureinforequesturl_method_cleanup;

    iwmsservicedescription_get_featureinforequesturl_method_cleanup:
    self->m_HR = hr;
    if (ippLayers)
      ippLayers->Release();
    if (ippBoundingBox)
      ippBoundingBox->Release();
    // No cleanup for imageWidth
    // No cleanup for imageHeight
    // No cleanup for positionX
    // No cleanup for positionY
    // No cleanup for featureCount
    if (bsresponseFormat)
        ::SysFreeString(bsresponseFormat);
    
    if (pyvar_URL != Py_None)
        Py_XDECREF(pyvar_URL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_FeatureInfoRequestURL");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_ImageFormatCount(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_ImageFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_ImageFormatCount() returned %ld", (long)hr);
        goto iwmsservicedescription_get_imageformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmsservicedescription_get_imageformatcount_method_cleanup;

    iwmsservicedescription_get_imageformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_ImageFormatCount");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_ImageFormat(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmsservicedescription_get_imageformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_ImageFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_ImageFormat() returned %ld", (long)hr);
        goto iwmsservicedescription_get_imageformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_imageformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmsservicedescription_get_imageformat_method_cleanup;

    iwmsservicedescription_get_imageformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_ImageFormat");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_FeatureInfoFormatCount(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_FeatureInfoFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_FeatureInfoFormatCount() returned %ld", (long)hr);
        goto iwmsservicedescription_get_featureinfoformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmsservicedescription_get_featureinfoformatcount_method_cleanup;

    iwmsservicedescription_get_featureinfoformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_FeatureInfoFormatCount");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_FeatureInfoFormat(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmsservicedescription_get_featureinfoformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_FeatureInfoFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_FeatureInfoFormat() returned %ld", (long)hr);
        goto iwmsservicedescription_get_featureinfoformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_featureinfoformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmsservicedescription_get_featureinfoformat_method_cleanup;

    iwmsservicedescription_get_featureinfoformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_FeatureInfoFormat");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_ExceptionFormatCount(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_ExceptionFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_ExceptionFormatCount() returned %ld", (long)hr);
        goto iwmsservicedescription_get_exceptionformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmsservicedescription_get_exceptionformatcount_method_cleanup;

    iwmsservicedescription_get_exceptionformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_ExceptionFormatCount");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_ExceptionFormat(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsExceptionFormat;
    PyObject* pyvar_ExceptionFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmsservicedescription_get_exceptionformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ExceptionFormat

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_ExceptionFormat(lindex, &bsExceptionFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_ExceptionFormat() returned %ld", (long)hr);
        goto iwmsservicedescription_get_exceptionformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ExceptionFormat = PyUnicode_FromWideChar(bsExceptionFormat,::SysStringLen(bsExceptionFormat));
    ::SysFreeString(bsExceptionFormat);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_exceptionformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ExceptionFormat);
    goto iwmsservicedescription_get_exceptionformat_method_cleanup;

    iwmsservicedescription_get_exceptionformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ExceptionFormat != Py_None)
        Py_XDECREF(pyvar_ExceptionFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_ExceptionFormat");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_get_BaseURL(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscapability = 0;
    PyObject* pyvar_capability;
    PyObject* unicodecapability = NULL;
    BSTR bsrequestMethod = 0;
    PyObject* pyvar_requestMethod;
    PyObject* unicoderequestMethod = NULL;
    BSTR bsBaseURL;
    PyObject* pyvar_BaseURL = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_capability, &pyvar_requestMethod))
      goto iwmsservicedescription_get_baseurl_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_capability))
        unicodecapability = PyUnicode_FromObject(pyvar_capability);
    else if (PyUnicode_Check(pyvar_capability))
    {
        unicodecapability = pyvar_capability;
        Py_INCREF(unicodecapability);
    }
    else if (pyvar_capability != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter capability at index 0");
    if (unicodecapability)
        bscapability = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecapability), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecapability));
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_baseurl_method_cleanup;
    
    if (PyString_Check(pyvar_requestMethod))
        unicoderequestMethod = PyUnicode_FromObject(pyvar_requestMethod);
    else if (PyUnicode_Check(pyvar_requestMethod))
    {
        unicoderequestMethod = pyvar_requestMethod;
        Py_INCREF(unicoderequestMethod);
    }
    else if (pyvar_requestMethod != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestMethod at index 1");
    if (unicoderequestMethod)
        bsrequestMethod = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestMethod), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestMethod));
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_baseurl_method_cleanup;
    
    // No setup for BaseURL

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->get_BaseURL(bscapability, bsrequestMethod, &bsBaseURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.get_BaseURL() returned %ld", (long)hr);
        goto iwmsservicedescription_get_baseurl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for capability
    // No teardown for requestMethod
    pyvar_BaseURL = PyUnicode_FromWideChar(bsBaseURL,::SysStringLen(bsBaseURL));
    ::SysFreeString(bsBaseURL);
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_get_baseurl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_BaseURL);
    goto iwmsservicedescription_get_baseurl_method_cleanup;

    iwmsservicedescription_get_baseurl_method_cleanup:
    self->m_HR = hr;
    if (bscapability)
        ::SysFreeString(bscapability);
    
    if (bsrequestMethod)
        ::SysFreeString(bsrequestMethod);
    
    if (pyvar_BaseURL != Py_None)
        Py_XDECREF(pyvar_BaseURL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.get_BaseURL");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_FireWMSRequest(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsrequestType = 0;
    PyObject* pyvar_requestType;
    PyObject* unicoderequestType = NULL;
    BSTR bsrequestURL = 0;
    PyObject* pyvar_requestURL;
    PyObject* unicoderequestURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_requestType, &pyvar_requestURL))
      goto iwmsservicedescription_firewmsrequest_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_requestType))
        unicoderequestType = PyUnicode_FromObject(pyvar_requestType);
    else if (PyUnicode_Check(pyvar_requestType))
    {
        unicoderequestType = pyvar_requestType;
        Py_INCREF(unicoderequestType);
    }
    else if (pyvar_requestType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestType at index 0");
    if (unicoderequestType)
        bsrequestType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestType));
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_firewmsrequest_method_cleanup;
    
    if (PyString_Check(pyvar_requestURL))
        unicoderequestURL = PyUnicode_FromObject(pyvar_requestURL);
    else if (PyUnicode_Check(pyvar_requestURL))
    {
        unicoderequestURL = pyvar_requestURL;
        Py_INCREF(unicoderequestURL);
    }
    else if (pyvar_requestURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestURL at index 1");
    if (unicoderequestURL)
        bsrequestURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestURL));
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_firewmsrequest_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->FireWMSRequest(bsrequestType, bsrequestURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.FireWMSRequest() returned %ld", (long)hr);
        goto iwmsservicedescription_firewmsrequest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for requestType
    // No teardown for requestURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmsservicedescription_firewmsrequest_method_cleanup;

    iwmsservicedescription_firewmsrequest_method_cleanup:
    self->m_HR = hr;
    if (bsrequestType)
        ::SysFreeString(bsrequestType);
    
    if (bsrequestURL)
        ::SysFreeString(bsrequestURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.FireWMSRequest");
    return return_tuple;
}

static PyObject*
IWMSServiceDescriptionMethod_FireWMSException(PyIWMSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsrequestType = 0;
    PyObject* pyvar_requestType;
    PyObject* unicoderequestType = NULL;
    BSTR bsrequestURL = 0;
    PyObject* pyvar_requestURL;
    PyObject* unicoderequestURL = NULL;
    IWMSServiceExceptionHandler* ippException = NULL;
    PyObject* py_pException;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_requestType, &pyvar_requestURL, &py_pException))
      goto iwmsservicedescription_firewmsexception_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_requestType))
        unicoderequestType = PyUnicode_FromObject(pyvar_requestType);
    else if (PyUnicode_Check(pyvar_requestType))
    {
        unicoderequestType = pyvar_requestType;
        Py_INCREF(unicoderequestType);
    }
    else if (pyvar_requestType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestType at index 0");
    if (unicoderequestType)
        bsrequestType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestType));
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_firewmsexception_method_cleanup;
    
    if (PyString_Check(pyvar_requestURL))
        unicoderequestURL = PyUnicode_FromObject(pyvar_requestURL);
    else if (PyUnicode_Check(pyvar_requestURL))
    {
        unicoderequestURL = pyvar_requestURL;
        Py_INCREF(unicoderequestURL);
    }
    else if (pyvar_requestURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestURL at index 1");
    if (unicoderequestURL)
        bsrequestURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestURL));
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_firewmsexception_method_cleanup;
    
    if (!IFaceFromPyObject(py_pException, &IID_IWMSServiceExceptionHandler, (void**)&ippException))
        PyErr_SetString(PyExc_TypeError, "Argument pException (position 2) is not IWMSServiceExceptionHandler");
    
    if (PyErr_Occurred())
      goto iwmsservicedescription_firewmsexception_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMSServiceDescription->FireWMSException(bsrequestType, bsrequestURL, ippException);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSServiceDescription.FireWMSException() returned %ld", (long)hr);
        goto iwmsservicedescription_firewmsexception_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for requestType
    // No teardown for requestURL
    // No teardown for pException

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmsservicedescription_firewmsexception_method_cleanup;

    iwmsservicedescription_firewmsexception_method_cleanup:
    self->m_HR = hr;
    if (bsrequestType)
        ::SysFreeString(bsrequestType);
    
    if (bsrequestURL)
        ::SysFreeString(bsrequestURL);
    
    if (ippException)
      ippException->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSServiceDescription.FireWMSException");
    return return_tuple;
}


PyMethodDef PyIWMSServiceDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIWMSServiceDescription_SupportsInterface, METH_O, ""},
    {"get_WMSName", (PyCFunction)IWMSServiceDescriptionMethod_get_WMSName, METH_VARARGS, ""},
    {"get_WMSAbstract", (PyCFunction)IWMSServiceDescriptionMethod_get_WMSAbstract, METH_VARARGS, ""},
    {"get_WMSTitle", (PyCFunction)IWMSServiceDescriptionMethod_get_WMSTitle, METH_VARARGS, ""},
    {"get_WMSVersion", (PyCFunction)IWMSServiceDescriptionMethod_get_WMSVersion, METH_VARARGS, ""},
    {"get_LayerDescriptionCount", (PyCFunction)IWMSServiceDescriptionMethod_get_LayerDescriptionCount, METH_VARARGS, ""},
    {"get_LayerDescription", (PyCFunction)IWMSServiceDescriptionMethod_get_LayerDescription, METH_VARARGS, ""},
    {"get_SRSCount", (PyCFunction)IWMSServiceDescriptionMethod_get_SRSCount, METH_VARARGS, ""},
    {"get_SRS", (PyCFunction)IWMSServiceDescriptionMethod_get_SRS, METH_VARARGS, ""},
    {"get_ImageRequestUrl", (PyCFunction)IWMSServiceDescriptionMethod_get_ImageRequestUrl, METH_VARARGS, ""},
    {"get_FeatureInfoRequestURL", (PyCFunction)IWMSServiceDescriptionMethod_get_FeatureInfoRequestURL, METH_VARARGS, ""},
    {"get_ImageFormatCount", (PyCFunction)IWMSServiceDescriptionMethod_get_ImageFormatCount, METH_VARARGS, ""},
    {"get_ImageFormat", (PyCFunction)IWMSServiceDescriptionMethod_get_ImageFormat, METH_VARARGS, ""},
    {"get_FeatureInfoFormatCount", (PyCFunction)IWMSServiceDescriptionMethod_get_FeatureInfoFormatCount, METH_VARARGS, ""},
    {"get_FeatureInfoFormat", (PyCFunction)IWMSServiceDescriptionMethod_get_FeatureInfoFormat, METH_VARARGS, ""},
    {"get_ExceptionFormatCount", (PyCFunction)IWMSServiceDescriptionMethod_get_ExceptionFormatCount, METH_VARARGS, ""},
    {"get_ExceptionFormat", (PyCFunction)IWMSServiceDescriptionMethod_get_ExceptionFormat, METH_VARARGS, ""},
    {"get_BaseURL", (PyCFunction)IWMSServiceDescriptionMethod_get_BaseURL, METH_VARARGS, ""},
    {"FireWMSRequest", (PyCFunction)IWMSServiceDescriptionMethod_FireWMSRequest, METH_VARARGS, ""},
    {"FireWMSException", (PyCFunction)IWMSServiceDescriptionMethod_FireWMSException, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMSServiceDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIWMSServiceDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMSServiceDescription", NULL},
  {"_pointer", (getter)PyIWMSServiceDescription_GetPointer, NULL, "Get memory address for IWMSServiceDescription", NULL},
  {"_IID", (getter)PyIWMSServiceDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMSServiceDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMSServiceDescription_GetIgnoreFailures, (setter)PyIWMSServiceDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMSServiceDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMSServiceDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIWMSServiceDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMSServiceDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMSServiceDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMSServiceDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMSServiceDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IWMSClientEvents

typedef struct PyIWMSClientEventsObject {
    PyObject_HEAD
    IWMSClientEvents* m_pIWMSClientEvents;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMSClientEventsObject;

static PyObject*
PyIWMSClientEventsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMSClientEventsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMSClientEvents* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMSClientEvents, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMSClientEvents with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMSClientEventsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSClientEvents");
            return NULL;
        }
        self->m_pIWMSClientEvents = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMSClientEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMSClientEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMSClientEvents* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMSClientEvents, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMSClientEvents");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMSClientEventsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMSClientEvents");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMSClientEvents = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMSClientEventsObject_dealloc(PyIWMSClientEventsObject* self)
{
    if (self->m_pIWMSClientEvents)
        self->m_pIWMSClientEvents->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMSClientEvents_GetpUnk(PyIWMSClientEventsObject* self)
{
    if (!self->m_pIWMSClientEvents)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMSClientEvents->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMSClientEvents to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMSClientEvents_GetPointer(PyIWMSClientEventsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMSClientEvents);
}

static PyObject*
PyIWMSClientEvents_GetIID(PyIWMSClientEventsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4ee28878-3a87-40e5-b25d-6fcc4d683e8c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMSClientEvents_GetHR(PyIWMSClientEventsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMSClientEvents_GetIgnoreFailures(PyIWMSClientEventsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMSClientEvents_SetIgnoreFailures(PyIWMSClientEventsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMSClientEvents_SupportsInterface(PyIWMSClientEventsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMSClientEvents->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMSClientEventsMethod_WMSRequest(PyIWMSClientEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWMSServiceDescription* ippService = NULL;
    PyObject* py_pService;
    BSTR bsrequestType = 0;
    PyObject* pyvar_requestType;
    PyObject* unicoderequestType = NULL;
    BSTR bsrequestURL = 0;
    PyObject* pyvar_requestURL;
    PyObject* unicoderequestURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_pService, &pyvar_requestType, &pyvar_requestURL))
      goto iwmsclientevents_wmsrequest_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pService, &IID_IWMSServiceDescription, (void**)&ippService))
        PyErr_SetString(PyExc_TypeError, "Argument pService (position 0) is not IWMSServiceDescription");
    
    if (PyErr_Occurred())
      goto iwmsclientevents_wmsrequest_method_cleanup;
    
    if (PyString_Check(pyvar_requestType))
        unicoderequestType = PyUnicode_FromObject(pyvar_requestType);
    else if (PyUnicode_Check(pyvar_requestType))
    {
        unicoderequestType = pyvar_requestType;
        Py_INCREF(unicoderequestType);
    }
    else if (pyvar_requestType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestType at index 1");
    if (unicoderequestType)
        bsrequestType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestType));
    
    if (PyErr_Occurred())
      goto iwmsclientevents_wmsrequest_method_cleanup;
    
    if (PyString_Check(pyvar_requestURL))
        unicoderequestURL = PyUnicode_FromObject(pyvar_requestURL);
    else if (PyUnicode_Check(pyvar_requestURL))
    {
        unicoderequestURL = pyvar_requestURL;
        Py_INCREF(unicoderequestURL);
    }
    else if (pyvar_requestURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestURL at index 2");
    if (unicoderequestURL)
        bsrequestURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestURL));
    
    if (PyErr_Occurred())
      goto iwmsclientevents_wmsrequest_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMSClientEvents->WMSRequest(ippService, bsrequestType, bsrequestURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSClientEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSClientEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSClientEvents.WMSRequest() returned %ld", (long)hr);
        goto iwmsclientevents_wmsrequest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pService
    // No teardown for requestType
    // No teardown for requestURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmsclientevents_wmsrequest_method_cleanup;

    iwmsclientevents_wmsrequest_method_cleanup:
    self->m_HR = hr;
    if (ippService)
      ippService->Release();
    if (bsrequestType)
        ::SysFreeString(bsrequestType);
    
    if (bsrequestURL)
        ::SysFreeString(bsrequestURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSClientEvents.WMSRequest");
    return return_tuple;
}

static PyObject*
IWMSClientEventsMethod_WMSException(PyIWMSClientEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWMSServiceDescription* ippService = NULL;
    PyObject* py_pService;
    BSTR bsrequestType = 0;
    PyObject* pyvar_requestType;
    PyObject* unicoderequestType = NULL;
    BSTR bsrequestURL = 0;
    PyObject* pyvar_requestURL;
    PyObject* unicoderequestURL = NULL;
    IWMSServiceExceptionHandler* ippException = NULL;
    PyObject* py_pException;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_pService, &pyvar_requestType, &pyvar_requestURL, &py_pException))
      goto iwmsclientevents_wmsexception_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pService, &IID_IWMSServiceDescription, (void**)&ippService))
        PyErr_SetString(PyExc_TypeError, "Argument pService (position 0) is not IWMSServiceDescription");
    
    if (PyErr_Occurred())
      goto iwmsclientevents_wmsexception_method_cleanup;
    
    if (PyString_Check(pyvar_requestType))
        unicoderequestType = PyUnicode_FromObject(pyvar_requestType);
    else if (PyUnicode_Check(pyvar_requestType))
    {
        unicoderequestType = pyvar_requestType;
        Py_INCREF(unicoderequestType);
    }
    else if (pyvar_requestType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestType at index 1");
    if (unicoderequestType)
        bsrequestType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestType));
    
    if (PyErr_Occurred())
      goto iwmsclientevents_wmsexception_method_cleanup;
    
    if (PyString_Check(pyvar_requestURL))
        unicoderequestURL = PyUnicode_FromObject(pyvar_requestURL);
    else if (PyUnicode_Check(pyvar_requestURL))
    {
        unicoderequestURL = pyvar_requestURL;
        Py_INCREF(unicoderequestURL);
    }
    else if (pyvar_requestURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestURL at index 2");
    if (unicoderequestURL)
        bsrequestURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestURL));
    
    if (PyErr_Occurred())
      goto iwmsclientevents_wmsexception_method_cleanup;
    
    if (!IFaceFromPyObject(py_pException, &IID_IWMSServiceExceptionHandler, (void**)&ippException))
        PyErr_SetString(PyExc_TypeError, "Argument pException (position 3) is not IWMSServiceExceptionHandler");
    
    if (PyErr_Occurred())
      goto iwmsclientevents_wmsexception_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMSClientEvents->WMSException(ippService, bsrequestType, bsrequestURL, ippException);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMSClientEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMSClientEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMSClientEvents.WMSException() returned %ld", (long)hr);
        goto iwmsclientevents_wmsexception_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pService
    // No teardown for requestType
    // No teardown for requestURL
    // No teardown for pException

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmsclientevents_wmsexception_method_cleanup;

    iwmsclientevents_wmsexception_method_cleanup:
    self->m_HR = hr;
    if (ippService)
      ippService->Release();
    if (bsrequestType)
        ::SysFreeString(bsrequestType);
    
    if (bsrequestURL)
        ::SysFreeString(bsrequestURL);
    
    if (ippException)
      ippException->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMSClientEvents.WMSException");
    return return_tuple;
}


PyMethodDef PyIWMSClientEventsMethods[] = {
    {"supports", (PyCFunction)PyIWMSClientEvents_SupportsInterface, METH_O, ""},
    {"WMSRequest", (PyCFunction)IWMSClientEventsMethod_WMSRequest, METH_VARARGS, ""},
    {"WMSException", (PyCFunction)IWMSClientEventsMethod_WMSException, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMSClientEventsGetSet[] = {
  {"_pUnk", (getter)PyIWMSClientEvents_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMSClientEvents", NULL},
  {"_pointer", (getter)PyIWMSClientEvents_GetPointer, NULL, "Get memory address for IWMSClientEvents", NULL},
  {"_IID", (getter)PyIWMSClientEvents_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMSClientEvents_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMSClientEvents_GetIgnoreFailures, (setter)PyIWMSClientEvents_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMSClientEventsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMSClientEventsObject",                          
                                              /* tp_name */
  sizeof(PyIWMSClientEventsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMSClientEventsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMSClientEventsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMSClientEventsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMSClientEventsObject_new,                      
                                              /* tp_new */
};

// Interface IWCSServiceExceptionHandler

typedef struct PyIWCSServiceExceptionHandlerObject {
    PyObject_HEAD
    IWCSServiceExceptionHandler* m_pIWCSServiceExceptionHandler;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSServiceExceptionHandlerObject;

static PyObject*
PyIWCSServiceExceptionHandlerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSServiceExceptionHandlerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSServiceExceptionHandler* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSServiceExceptionHandler, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSServiceExceptionHandler with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSServiceExceptionHandlerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSServiceExceptionHandler");
            return NULL;
        }
        self->m_pIWCSServiceExceptionHandler = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSServiceExceptionHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSServiceExceptionHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSServiceExceptionHandler* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSServiceExceptionHandler, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSServiceExceptionHandler");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSServiceExceptionHandlerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSServiceExceptionHandler");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSServiceExceptionHandler = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSServiceExceptionHandlerObject_dealloc(PyIWCSServiceExceptionHandlerObject* self)
{
    if (self->m_pIWCSServiceExceptionHandler)
        self->m_pIWCSServiceExceptionHandler->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSServiceExceptionHandler_GetpUnk(PyIWCSServiceExceptionHandlerObject* self)
{
    if (!self->m_pIWCSServiceExceptionHandler)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSServiceExceptionHandler->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSServiceExceptionHandler to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSServiceExceptionHandler_GetPointer(PyIWCSServiceExceptionHandlerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSServiceExceptionHandler);
}

static PyObject*
PyIWCSServiceExceptionHandler_GetIID(PyIWCSServiceExceptionHandlerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ad2e4de6-cc7e-41e1-911f-5343cd27f227");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSServiceExceptionHandler_GetHR(PyIWCSServiceExceptionHandlerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSServiceExceptionHandler_GetIgnoreFailures(PyIWCSServiceExceptionHandlerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSServiceExceptionHandler_SetIgnoreFailures(PyIWCSServiceExceptionHandlerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSServiceExceptionHandler_SupportsInterface(PyIWCSServiceExceptionHandlerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSServiceExceptionHandler->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSServiceExceptionHandlerMethod_ParseExceptions(PyIWCSServiceExceptionHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileOrURL = 0;
    PyObject* pyvar_fileOrURL;
    PyObject* unicodefileOrURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileOrURL))
      goto iwcsserviceexceptionhandler_parseexceptions_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileOrURL))
        unicodefileOrURL = PyUnicode_FromObject(pyvar_fileOrURL);
    else if (PyUnicode_Check(pyvar_fileOrURL))
    {
        unicodefileOrURL = pyvar_fileOrURL;
        Py_INCREF(unicodefileOrURL);
    }
    else if (pyvar_fileOrURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileOrURL at index 0");
    if (unicodefileOrURL)
        bsfileOrURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileOrURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileOrURL));
    
    if (PyErr_Occurred())
      goto iwcsserviceexceptionhandler_parseexceptions_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceExceptionHandler->ParseExceptions(bsfileOrURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceExceptionHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceExceptionHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceExceptionHandler.ParseExceptions() returned %ld", (long)hr);
        goto iwcsserviceexceptionhandler_parseexceptions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileOrURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsserviceexceptionhandler_parseexceptions_method_cleanup;

    iwcsserviceexceptionhandler_parseexceptions_method_cleanup:
    self->m_HR = hr;
    if (bsfileOrURL)
        ::SysFreeString(bsfileOrURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceExceptionHandler.ParseExceptions");
    return return_tuple;
}

static PyObject*
IWCSServiceExceptionHandlerMethod_get_ExceptionCount(PyIWCSServiceExceptionHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceExceptionHandler->get_ExceptionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceExceptionHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceExceptionHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceExceptionHandler.get_ExceptionCount() returned %ld", (long)hr);
        goto iwcsserviceexceptionhandler_get_exceptioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcsserviceexceptionhandler_get_exceptioncount_method_cleanup;

    iwcsserviceexceptionhandler_get_exceptioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceExceptionHandler.get_ExceptionCount");
    return return_tuple;
}

static PyObject*
IWCSServiceExceptionHandlerMethod_get_ExceptionCode(PyIWCSServiceExceptionHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bswcsErrorCode;
    PyObject* pyvar_wcsErrorCode = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcsserviceexceptionhandler_get_exceptioncode_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for wcsErrorCode

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceExceptionHandler->get_ExceptionCode(lindex, &bswcsErrorCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceExceptionHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceExceptionHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceExceptionHandler.get_ExceptionCode() returned %ld", (long)hr);
        goto iwcsserviceexceptionhandler_get_exceptioncode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_wcsErrorCode = PyUnicode_FromWideChar(bswcsErrorCode,::SysStringLen(bswcsErrorCode));
    ::SysFreeString(bswcsErrorCode);
    
    if (PyErr_Occurred())
      goto iwcsserviceexceptionhandler_get_exceptioncode_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_wcsErrorCode);
    goto iwcsserviceexceptionhandler_get_exceptioncode_method_cleanup;

    iwcsserviceexceptionhandler_get_exceptioncode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_wcsErrorCode != Py_None)
        Py_XDECREF(pyvar_wcsErrorCode);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceExceptionHandler.get_ExceptionCode");
    return return_tuple;
}

static PyObject*
IWCSServiceExceptionHandlerMethod_get_ExceptionDescription(PyIWCSServiceExceptionHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bswcsErrorDescription;
    PyObject* pyvar_wcsErrorDescription = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcsserviceexceptionhandler_get_exceptiondescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for wcsErrorDescription

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceExceptionHandler->get_ExceptionDescription(lindex, &bswcsErrorDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceExceptionHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceExceptionHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceExceptionHandler.get_ExceptionDescription() returned %ld", (long)hr);
        goto iwcsserviceexceptionhandler_get_exceptiondescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_wcsErrorDescription = PyUnicode_FromWideChar(bswcsErrorDescription,::SysStringLen(bswcsErrorDescription));
    ::SysFreeString(bswcsErrorDescription);
    
    if (PyErr_Occurred())
      goto iwcsserviceexceptionhandler_get_exceptiondescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_wcsErrorDescription);
    goto iwcsserviceexceptionhandler_get_exceptiondescription_method_cleanup;

    iwcsserviceexceptionhandler_get_exceptiondescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_wcsErrorDescription != Py_None)
        Py_XDECREF(pyvar_wcsErrorDescription);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceExceptionHandler.get_ExceptionDescription");
    return return_tuple;
}


PyMethodDef PyIWCSServiceExceptionHandlerMethods[] = {
    {"supports", (PyCFunction)PyIWCSServiceExceptionHandler_SupportsInterface, METH_O, ""},
    {"ParseExceptions", (PyCFunction)IWCSServiceExceptionHandlerMethod_ParseExceptions, METH_VARARGS, ""},
    {"get_ExceptionCount", (PyCFunction)IWCSServiceExceptionHandlerMethod_get_ExceptionCount, METH_VARARGS, ""},
    {"get_ExceptionCode", (PyCFunction)IWCSServiceExceptionHandlerMethod_get_ExceptionCode, METH_VARARGS, ""},
    {"get_ExceptionDescription", (PyCFunction)IWCSServiceExceptionHandlerMethod_get_ExceptionDescription, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSServiceExceptionHandlerGetSet[] = {
  {"_pUnk", (getter)PyIWCSServiceExceptionHandler_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSServiceExceptionHandler", NULL},
  {"_pointer", (getter)PyIWCSServiceExceptionHandler_GetPointer, NULL, "Get memory address for IWCSServiceExceptionHandler", NULL},
  {"_IID", (getter)PyIWCSServiceExceptionHandler_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSServiceExceptionHandler_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSServiceExceptionHandler_GetIgnoreFailures, (setter)PyIWCSServiceExceptionHandler_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSServiceExceptionHandlerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSServiceExceptionHandlerObject",                          
                                              /* tp_name */
  sizeof(PyIWCSServiceExceptionHandlerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSServiceExceptionHandlerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSServiceExceptionHandlerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSServiceExceptionHandlerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSServiceExceptionHandlerObject_new,                      
                                              /* tp_new */
};

// Interface IWCSConnection

typedef struct PyIWCSConnectionObject {
    PyObject_HEAD
    IWCSConnection* m_pIWCSConnection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSConnectionObject;

static PyObject*
PyIWCSConnectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSConnectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSConnection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSConnection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSConnection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSConnectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSConnection");
            return NULL;
        }
        self->m_pIWCSConnection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSConnection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSConnection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSConnection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSConnection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSConnection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSConnectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSConnection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSConnection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSConnectionObject_dealloc(PyIWCSConnectionObject* self)
{
    if (self->m_pIWCSConnection)
        self->m_pIWCSConnection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSConnection_GetpUnk(PyIWCSConnectionObject* self)
{
    if (!self->m_pIWCSConnection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSConnection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSConnection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSConnection_GetPointer(PyIWCSConnectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSConnection);
}

static PyObject*
PyIWCSConnection_GetIID(PyIWCSConnectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2bb26ed5-6774-4ff5-8252-1e973ebd5bdc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSConnection_GetHR(PyIWCSConnectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSConnection_GetIgnoreFailures(PyIWCSConnectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSConnection_SetIgnoreFailures(PyIWCSConnectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSConnection_SupportsInterface(PyIWCSConnectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSConnection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSConnectionMethod_get_Name(PyIWCSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWCSConnection->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnection.get_Name() returned %ld", (long)hr);
        goto iwcsconnection_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwcsconnection_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwcsconnection_get_name_method_cleanup;

    iwcsconnection_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnection.get_Name");
    return return_tuple;
}

static PyObject*
IWCSConnectionMethod_put_Name(PyIWCSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iwcsconnection_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iwcsconnection_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSConnection->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnection.put_Name() returned %ld", (long)hr);
        goto iwcsconnection_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsconnection_put_name_method_cleanup;

    iwcsconnection_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnection.put_Name");
    return return_tuple;
}

static PyObject*
IWCSConnectionMethod_get_FullName(PyIWCSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppName = NULL;
    PyObject* py_ppName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppName

    // Call method on actual COM interface
    hr = self->m_pIWCSConnection->get_FullName(&ipppName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnection.get_FullName() returned %ld", (long)hr);
        goto iwcsconnection_get_fullname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppName);
    if (ipppName)
    {
        IUnknown* pUnk = NULL;
        ipppName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppName = IUnknownToPythonIIDObject(pUnk, &IID_IName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppName)
    {
        if (py_ppName)
           Py_DECREF(py_ppName);
        py_ppName = Py_None;
        Py_INCREF(py_ppName);
    }
    if (PyErr_Occurred())
      goto iwcsconnection_get_fullname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppName);
    goto iwcsconnection_get_fullname_method_cleanup;

    iwcsconnection_get_fullname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppName);
    if (ipppName)
      ipppName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnection.get_FullName");
    return return_tuple;
}

static PyObject*
IWCSConnectionMethod_putref_FullName(PyIWCSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppName = NULL;
    PyObject* py_ppName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppName))
      goto iwcsconnection_putref_fullname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppName, &IID_IName, (void**)&ipppName))
        PyErr_SetString(PyExc_TypeError, "Argument ppName (position 0) is not IName");
    
    if (PyErr_Occurred())
      goto iwcsconnection_putref_fullname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSConnection->putref_FullName(ipppName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnection.putref_FullName() returned %ld", (long)hr);
        goto iwcsconnection_putref_fullname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsconnection_putref_fullname_method_cleanup;

    iwcsconnection_putref_fullname_method_cleanup:
    self->m_HR = hr;
    if (ipppName)
      ipppName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnection.putref_FullName");
    return return_tuple;
}


PyMethodDef PyIWCSConnectionMethods[] = {
    {"supports", (PyCFunction)PyIWCSConnection_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IWCSConnectionMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IWCSConnectionMethod_put_Name, METH_VARARGS, ""},
    {"get_FullName", (PyCFunction)IWCSConnectionMethod_get_FullName, METH_VARARGS, ""},
    {"putref_FullName", (PyCFunction)IWCSConnectionMethod_putref_FullName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSConnectionGetSet[] = {
  {"_pUnk", (getter)PyIWCSConnection_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSConnection", NULL},
  {"_pointer", (getter)PyIWCSConnection_GetPointer, NULL, "Get memory address for IWCSConnection", NULL},
  {"_IID", (getter)PyIWCSConnection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSConnection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSConnection_GetIgnoreFailures, (setter)PyIWCSConnection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSConnectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSConnectionObject",                          
                                              /* tp_name */
  sizeof(PyIWCSConnectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSConnectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSConnectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSConnectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSConnectionObject_new,                      
                                              /* tp_new */
};

// Interface IWCSConnectionFactory

typedef struct PyIWCSConnectionFactoryObject {
    PyObject_HEAD
    IWCSConnectionFactory* m_pIWCSConnectionFactory;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSConnectionFactoryObject;

static PyObject*
PyIWCSConnectionFactoryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSConnectionFactoryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSConnectionFactory* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSConnectionFactory, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSConnectionFactory with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSConnectionFactoryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSConnectionFactory");
            return NULL;
        }
        self->m_pIWCSConnectionFactory = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSConnectionFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSConnectionFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSConnectionFactory* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSConnectionFactory, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSConnectionFactory");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSConnectionFactoryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSConnectionFactory");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSConnectionFactory = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSConnectionFactoryObject_dealloc(PyIWCSConnectionFactoryObject* self)
{
    if (self->m_pIWCSConnectionFactory)
        self->m_pIWCSConnectionFactory->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSConnectionFactory_GetpUnk(PyIWCSConnectionFactoryObject* self)
{
    if (!self->m_pIWCSConnectionFactory)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSConnectionFactory->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSConnectionFactory to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSConnectionFactory_GetPointer(PyIWCSConnectionFactoryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSConnectionFactory);
}

static PyObject*
PyIWCSConnectionFactory_GetIID(PyIWCSConnectionFactoryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a73a11e4-aeb0-4917-b36e-a43865cc9b7b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSConnectionFactory_GetHR(PyIWCSConnectionFactoryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSConnectionFactory_GetIgnoreFailures(PyIWCSConnectionFactoryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSConnectionFactory_SetIgnoreFailures(PyIWCSConnectionFactoryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSConnectionFactory_SupportsInterface(PyIWCSConnectionFactoryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSConnectionFactory->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSConnectionFactoryMethod_Open(PyIWCSConnectionFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippConnectionProperties = NULL;
    PyObject* py_pConnectionProperties;
    OLE_HANDLE HhWnd = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IWCSConnection* ipppConnection = NULL;
    PyObject* py_ppConnection = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OIO", &py_pConnectionProperties, &HhWnd, &py_pTrackCancel))
      goto iwcsconnectionfactory_open_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConnectionProperties, &IID_IPropertySet, (void**)&ippConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument pConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iwcsconnectionfactory_open_method_cleanup;
    
    // No setup for hWnd
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iwcsconnectionfactory_open_method_cleanup;
    
    // No setup for ppConnection

    // Call method on actual COM interface
    hr = self->m_pIWCSConnectionFactory->Open(ippConnectionProperties, HhWnd, ippTrackCancel, &ipppConnection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSConnectionFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSConnectionFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSConnectionFactory.Open() returned %ld", (long)hr);
        goto iwcsconnectionfactory_open_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnectionProperties
    // No teardown for hWnd
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
    {
        IUnknown* pUnk = NULL;
        ipppConnection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnection = IUnknownToPythonIIDObject(pUnk, &IID_IWCSConnection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnection)
    {
        if (py_ppConnection)
           Py_DECREF(py_ppConnection);
        py_ppConnection = Py_None;
        Py_INCREF(py_ppConnection);
    }
    if (PyErr_Occurred())
      goto iwcsconnectionfactory_open_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnection);
    goto iwcsconnectionfactory_open_method_cleanup;

    iwcsconnectionfactory_open_method_cleanup:
    self->m_HR = hr;
    if (ippConnectionProperties)
      ippConnectionProperties->Release();
    // No cleanup for hWnd
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
      ipppConnection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSConnectionFactory.Open");
    return return_tuple;
}


PyMethodDef PyIWCSConnectionFactoryMethods[] = {
    {"supports", (PyCFunction)PyIWCSConnectionFactory_SupportsInterface, METH_O, ""},
    {"Open", (PyCFunction)IWCSConnectionFactoryMethod_Open, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSConnectionFactoryGetSet[] = {
  {"_pUnk", (getter)PyIWCSConnectionFactory_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSConnectionFactory", NULL},
  {"_pointer", (getter)PyIWCSConnectionFactory_GetPointer, NULL, "Get memory address for IWCSConnectionFactory", NULL},
  {"_IID", (getter)PyIWCSConnectionFactory_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSConnectionFactory_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSConnectionFactory_GetIgnoreFailures, (setter)PyIWCSConnectionFactory_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSConnectionFactoryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSConnectionFactoryObject",                          
                                              /* tp_name */
  sizeof(PyIWCSConnectionFactoryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSConnectionFactoryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSConnectionFactoryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSConnectionFactoryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSConnectionFactoryObject_new,                      
                                              /* tp_new */
};

// Interface IWCSServiceDescription

typedef struct PyIWCSServiceDescriptionObject {
    PyObject_HEAD
    IWCSServiceDescription* m_pIWCSServiceDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSServiceDescriptionObject;

static PyObject*
PyIWCSServiceDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSServiceDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSServiceDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSServiceDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSServiceDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSServiceDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSServiceDescription");
            return NULL;
        }
        self->m_pIWCSServiceDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSServiceDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSServiceDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSServiceDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSServiceDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSServiceDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSServiceDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSServiceDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSServiceDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSServiceDescriptionObject_dealloc(PyIWCSServiceDescriptionObject* self)
{
    if (self->m_pIWCSServiceDescription)
        self->m_pIWCSServiceDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSServiceDescription_GetpUnk(PyIWCSServiceDescriptionObject* self)
{
    if (!self->m_pIWCSServiceDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSServiceDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSServiceDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSServiceDescription_GetPointer(PyIWCSServiceDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSServiceDescription);
}

static PyObject*
PyIWCSServiceDescription_GetIID(PyIWCSServiceDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e19a5310-486c-4d32-8d44-93696d6804d4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSServiceDescription_GetHR(PyIWCSServiceDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSServiceDescription_GetIgnoreFailures(PyIWCSServiceDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSServiceDescription_SetIgnoreFailures(PyIWCSServiceDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSServiceDescription_SupportsInterface(PyIWCSServiceDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSServiceDescriptionMethod_get_WCSName(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_WCSName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_WCSName() returned %ld", (long)hr);
        goto iwcsservicedescription_get_wcsname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_wcsname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwcsservicedescription_get_wcsname_method_cleanup;

    iwcsservicedescription_get_wcsname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_WCSName");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_Abstract(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_Abstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_Abstract() returned %ld", (long)hr);
        goto iwcsservicedescription_get_abstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_abstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwcsservicedescription_get_abstract_method_cleanup;

    iwcsservicedescription_get_abstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_Abstract");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_Title(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_Title() returned %ld", (long)hr);
        goto iwcsservicedescription_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwcsservicedescription_get_title_method_cleanup;

    iwcsservicedescription_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_Title");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_Version(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsver;
    PyObject* pyvar_ver = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ver

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_Version(&bsver);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_Version() returned %ld", (long)hr);
        goto iwcsservicedescription_get_version_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ver = PyUnicode_FromWideChar(bsver,::SysStringLen(bsver));
    ::SysFreeString(bsver);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_version_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ver);
    goto iwcsservicedescription_get_version_method_cleanup;

    iwcsservicedescription_get_version_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ver != Py_None)
        Py_XDECREF(pyvar_ver);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_Version");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_AccessConstrains(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsconstrains;
    PyObject* pyvar_constrains = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for constrains

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_AccessConstrains(&bsconstrains);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_AccessConstrains() returned %ld", (long)hr);
        goto iwcsservicedescription_get_accessconstrains_method_cleanup;
    }

    // Set up return values as needed
    pyvar_constrains = PyUnicode_FromWideChar(bsconstrains,::SysStringLen(bsconstrains));
    ::SysFreeString(bsconstrains);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_accessconstrains_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_constrains);
    goto iwcsservicedescription_get_accessconstrains_method_cleanup;

    iwcsservicedescription_get_accessconstrains_method_cleanup:
    self->m_HR = hr;
    if (pyvar_constrains != Py_None)
        Py_XDECREF(pyvar_constrains);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_AccessConstrains");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_BaseURL(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscapability = 0;
    PyObject* pyvar_capability;
    PyObject* unicodecapability = NULL;
    BSTR bsrequestMethod = 0;
    PyObject* pyvar_requestMethod;
    PyObject* unicoderequestMethod = NULL;
    BSTR bsBaseURL;
    PyObject* pyvar_BaseURL = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_capability, &pyvar_requestMethod))
      goto iwcsservicedescription_get_baseurl_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_capability))
        unicodecapability = PyUnicode_FromObject(pyvar_capability);
    else if (PyUnicode_Check(pyvar_capability))
    {
        unicodecapability = pyvar_capability;
        Py_INCREF(unicodecapability);
    }
    else if (pyvar_capability != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter capability at index 0");
    if (unicodecapability)
        bscapability = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecapability), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecapability));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_baseurl_method_cleanup;
    
    if (PyString_Check(pyvar_requestMethod))
        unicoderequestMethod = PyUnicode_FromObject(pyvar_requestMethod);
    else if (PyUnicode_Check(pyvar_requestMethod))
    {
        unicoderequestMethod = pyvar_requestMethod;
        Py_INCREF(unicoderequestMethod);
    }
    else if (pyvar_requestMethod != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestMethod at index 1");
    if (unicoderequestMethod)
        bsrequestMethod = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestMethod), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestMethod));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_baseurl_method_cleanup;
    
    // No setup for BaseURL

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_BaseURL(bscapability, bsrequestMethod, &bsBaseURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_BaseURL() returned %ld", (long)hr);
        goto iwcsservicedescription_get_baseurl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for capability
    // No teardown for requestMethod
    pyvar_BaseURL = PyUnicode_FromWideChar(bsBaseURL,::SysStringLen(bsBaseURL));
    ::SysFreeString(bsBaseURL);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_baseurl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_BaseURL);
    goto iwcsservicedescription_get_baseurl_method_cleanup;

    iwcsservicedescription_get_baseurl_method_cleanup:
    self->m_HR = hr;
    if (bscapability)
        ::SysFreeString(bscapability);
    
    if (bsrequestMethod)
        ::SysFreeString(bsrequestMethod);
    
    if (pyvar_BaseURL != Py_None)
        Py_XDECREF(pyvar_BaseURL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_BaseURL");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_ExceptionFormatCount(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_ExceptionFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_ExceptionFormatCount() returned %ld", (long)hr);
        goto iwcsservicedescription_get_exceptionformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcsservicedescription_get_exceptionformatcount_method_cleanup;

    iwcsservicedescription_get_exceptionformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_ExceptionFormatCount");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_ExceptionFormat(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsExceptionFormat;
    PyObject* pyvar_ExceptionFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcsservicedescription_get_exceptionformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ExceptionFormat

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_ExceptionFormat(lindex, &bsExceptionFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_ExceptionFormat() returned %ld", (long)hr);
        goto iwcsservicedescription_get_exceptionformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ExceptionFormat = PyUnicode_FromWideChar(bsExceptionFormat,::SysStringLen(bsExceptionFormat));
    ::SysFreeString(bsExceptionFormat);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_exceptionformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ExceptionFormat);
    goto iwcsservicedescription_get_exceptionformat_method_cleanup;

    iwcsservicedescription_get_exceptionformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ExceptionFormat != Py_None)
        Py_XDECREF(pyvar_ExceptionFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_ExceptionFormat");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_SupportedVersionsCount(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_SupportedVersionsCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_SupportedVersionsCount() returned %ld", (long)hr);
        goto iwcsservicedescription_get_supportedversionscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcsservicedescription_get_supportedversionscount_method_cleanup;

    iwcsservicedescription_get_supportedversionscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_SupportedVersionsCount");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_SupportedVersion(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsVersion;
    PyObject* pyvar_Version = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcsservicedescription_get_supportedversion_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for Version

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_SupportedVersion(lindex, &bsVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_SupportedVersion() returned %ld", (long)hr);
        goto iwcsservicedescription_get_supportedversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_Version = PyUnicode_FromWideChar(bsVersion,::SysStringLen(bsVersion));
    ::SysFreeString(bsVersion);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_supportedversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Version);
    goto iwcsservicedescription_get_supportedversion_method_cleanup;

    iwcsservicedescription_get_supportedversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_Version != Py_None)
        Py_XDECREF(pyvar_Version);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_SupportedVersion");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_KeywordCount(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_KeywordCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_KeywordCount() returned %ld", (long)hr);
        goto iwcsservicedescription_get_keywordcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcsservicedescription_get_keywordcount_method_cleanup;

    iwcsservicedescription_get_keywordcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_KeywordCount");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_Keyword(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsKeyword;
    PyObject* pyvar_Keyword = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcsservicedescription_get_keyword_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for Keyword

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_Keyword(lindex, &bsKeyword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_Keyword() returned %ld", (long)hr);
        goto iwcsservicedescription_get_keyword_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_Keyword = PyUnicode_FromWideChar(bsKeyword,::SysStringLen(bsKeyword));
    ::SysFreeString(bsKeyword);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_keyword_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Keyword);
    goto iwcsservicedescription_get_keyword_method_cleanup;

    iwcsservicedescription_get_keyword_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_Keyword != Py_None)
        Py_XDECREF(pyvar_Keyword);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_Keyword");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_CoverageDescriptionCount(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_CoverageDescriptionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_CoverageDescriptionCount() returned %ld", (long)hr);
        goto iwcsservicedescription_get_coveragedescriptioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwcsservicedescription_get_coveragedescriptioncount_method_cleanup;

    iwcsservicedescription_get_coveragedescriptioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_CoverageDescriptionCount");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_CoverageDescriptionByIndex(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWCSCoverageDescription* ipppCoverageDescription = NULL;
    PyObject* py_ppCoverageDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwcsservicedescription_get_coveragedescriptionbyindex_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppCoverageDescription

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_CoverageDescriptionByIndex(lindex, &ipppCoverageDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_CoverageDescriptionByIndex() returned %ld", (long)hr);
        goto iwcsservicedescription_get_coveragedescriptionbyindex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppCoverageDescription);
    if (ipppCoverageDescription)
    {
        IUnknown* pUnk = NULL;
        ipppCoverageDescription->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCoverageDescription = IUnknownToPythonIIDObject(pUnk, &IID_IWCSCoverageDescription);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCoverageDescription)
    {
        if (py_ppCoverageDescription)
           Py_DECREF(py_ppCoverageDescription);
        py_ppCoverageDescription = Py_None;
        Py_INCREF(py_ppCoverageDescription);
    }
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_coveragedescriptionbyindex_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCoverageDescription);
    goto iwcsservicedescription_get_coveragedescriptionbyindex_method_cleanup;

    iwcsservicedescription_get_coveragedescriptionbyindex_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppCoverageDescription);
    if (ipppCoverageDescription)
      ipppCoverageDescription->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_CoverageDescriptionByIndex");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_CoverageDescriptionByName(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    IWCSCoverageDescription* ipppCoverageDescription = NULL;
    PyObject* py_ppCoverageDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iwcsservicedescription_get_coveragedescriptionbyname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_coveragedescriptionbyname_method_cleanup;
    
    // No setup for ppCoverageDescription

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_CoverageDescriptionByName(bsName, &ipppCoverageDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_CoverageDescriptionByName() returned %ld", (long)hr);
        goto iwcsservicedescription_get_coveragedescriptionbyname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    Py_XDECREF(py_ppCoverageDescription);
    if (ipppCoverageDescription)
    {
        IUnknown* pUnk = NULL;
        ipppCoverageDescription->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCoverageDescription = IUnknownToPythonIIDObject(pUnk, &IID_IWCSCoverageDescription);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCoverageDescription)
    {
        if (py_ppCoverageDescription)
           Py_DECREF(py_ppCoverageDescription);
        py_ppCoverageDescription = Py_None;
        Py_INCREF(py_ppCoverageDescription);
    }
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_coveragedescriptionbyname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCoverageDescription);
    goto iwcsservicedescription_get_coveragedescriptionbyname_method_cleanup;

    iwcsservicedescription_get_coveragedescriptionbyname_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    Py_XDECREF(py_ppCoverageDescription);
    if (ipppCoverageDescription)
      ipppCoverageDescription->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_CoverageDescriptionByName");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_get_CoverageRequestUrl(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscoverageName = 0;
    PyObject* pyvar_coverageName;
    PyObject* unicodecoverageName = NULL;
    IEnvelope* ippBoundingBox = NULL;
    PyObject* py_pBoundingBox;
    BSTR bsCRS = 0;
    PyObject* pyvar_CRS;
    PyObject* unicodeCRS = NULL;
    BSTR bsresponseFormat = 0;
    PyObject* pyvar_responseFormat;
    PyObject* unicoderesponseFormat = NULL;
    long limageWidth = 0;
    long limageHeight = 0;
    BSTR bsURL;
    PyObject* pyvar_URL = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOll", &pyvar_coverageName, &py_pBoundingBox, &pyvar_CRS, &pyvar_responseFormat, &limageWidth, &limageHeight))
      goto iwcsservicedescription_get_coveragerequesturl_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_coverageName))
        unicodecoverageName = PyUnicode_FromObject(pyvar_coverageName);
    else if (PyUnicode_Check(pyvar_coverageName))
    {
        unicodecoverageName = pyvar_coverageName;
        Py_INCREF(unicodecoverageName);
    }
    else if (pyvar_coverageName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter coverageName at index 0");
    if (unicodecoverageName)
        bscoverageName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecoverageName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecoverageName));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_coveragerequesturl_method_cleanup;
    
    if (!IFaceFromPyObject(py_pBoundingBox, &IID_IEnvelope, (void**)&ippBoundingBox))
        PyErr_SetString(PyExc_TypeError, "Argument pBoundingBox (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_coveragerequesturl_method_cleanup;
    
    if (PyString_Check(pyvar_CRS))
        unicodeCRS = PyUnicode_FromObject(pyvar_CRS);
    else if (PyUnicode_Check(pyvar_CRS))
    {
        unicodeCRS = pyvar_CRS;
        Py_INCREF(unicodeCRS);
    }
    else if (pyvar_CRS != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter CRS at index 2");
    if (unicodeCRS)
        bsCRS = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeCRS), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeCRS));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_coveragerequesturl_method_cleanup;
    
    if (PyString_Check(pyvar_responseFormat))
        unicoderesponseFormat = PyUnicode_FromObject(pyvar_responseFormat);
    else if (PyUnicode_Check(pyvar_responseFormat))
    {
        unicoderesponseFormat = pyvar_responseFormat;
        Py_INCREF(unicoderesponseFormat);
    }
    else if (pyvar_responseFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter responseFormat at index 3");
    if (unicoderesponseFormat)
        bsresponseFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderesponseFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderesponseFormat));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_coveragerequesturl_method_cleanup;
    
    // No setup for imageWidth
    // No setup for imageHeight
    // No setup for URL

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->get_CoverageRequestUrl(bscoverageName, ippBoundingBox, bsCRS, bsresponseFormat, limageWidth, limageHeight, &bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.get_CoverageRequestUrl() returned %ld", (long)hr);
        goto iwcsservicedescription_get_coveragerequesturl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for coverageName
    // No teardown for pBoundingBox
    // No teardown for CRS
    // No teardown for responseFormat
    // No teardown for imageWidth
    // No teardown for imageHeight
    pyvar_URL = PyUnicode_FromWideChar(bsURL,::SysStringLen(bsURL));
    ::SysFreeString(bsURL);
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_get_coveragerequesturl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_URL);
    goto iwcsservicedescription_get_coveragerequesturl_method_cleanup;

    iwcsservicedescription_get_coveragerequesturl_method_cleanup:
    self->m_HR = hr;
    if (bscoverageName)
        ::SysFreeString(bscoverageName);
    
    if (ippBoundingBox)
      ippBoundingBox->Release();
    if (bsCRS)
        ::SysFreeString(bsCRS);
    
    if (bsresponseFormat)
        ::SysFreeString(bsresponseFormat);
    
    // No cleanup for imageWidth
    // No cleanup for imageHeight
    if (pyvar_URL != Py_None)
        Py_XDECREF(pyvar_URL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.get_CoverageRequestUrl");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_FireWCSRequest(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsrequestType = 0;
    PyObject* pyvar_requestType;
    PyObject* unicoderequestType = NULL;
    BSTR bsrequestURL = 0;
    PyObject* pyvar_requestURL;
    PyObject* unicoderequestURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_requestType, &pyvar_requestURL))
      goto iwcsservicedescription_firewcsrequest_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_requestType))
        unicoderequestType = PyUnicode_FromObject(pyvar_requestType);
    else if (PyUnicode_Check(pyvar_requestType))
    {
        unicoderequestType = pyvar_requestType;
        Py_INCREF(unicoderequestType);
    }
    else if (pyvar_requestType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestType at index 0");
    if (unicoderequestType)
        bsrequestType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestType));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_firewcsrequest_method_cleanup;
    
    if (PyString_Check(pyvar_requestURL))
        unicoderequestURL = PyUnicode_FromObject(pyvar_requestURL);
    else if (PyUnicode_Check(pyvar_requestURL))
    {
        unicoderequestURL = pyvar_requestURL;
        Py_INCREF(unicoderequestURL);
    }
    else if (pyvar_requestURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestURL at index 1");
    if (unicoderequestURL)
        bsrequestURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestURL));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_firewcsrequest_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->FireWCSRequest(bsrequestType, bsrequestURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.FireWCSRequest() returned %ld", (long)hr);
        goto iwcsservicedescription_firewcsrequest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for requestType
    // No teardown for requestURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsservicedescription_firewcsrequest_method_cleanup;

    iwcsservicedescription_firewcsrequest_method_cleanup:
    self->m_HR = hr;
    if (bsrequestType)
        ::SysFreeString(bsrequestType);
    
    if (bsrequestURL)
        ::SysFreeString(bsrequestURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.FireWCSRequest");
    return return_tuple;
}

static PyObject*
IWCSServiceDescriptionMethod_FireWCSException(PyIWCSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsrequestType = 0;
    PyObject* pyvar_requestType;
    PyObject* unicoderequestType = NULL;
    BSTR bsrequestURL = 0;
    PyObject* pyvar_requestURL;
    PyObject* unicoderequestURL = NULL;
    IWCSServiceExceptionHandler* ippException = NULL;
    PyObject* py_pException;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_requestType, &pyvar_requestURL, &py_pException))
      goto iwcsservicedescription_firewcsexception_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_requestType))
        unicoderequestType = PyUnicode_FromObject(pyvar_requestType);
    else if (PyUnicode_Check(pyvar_requestType))
    {
        unicoderequestType = pyvar_requestType;
        Py_INCREF(unicoderequestType);
    }
    else if (pyvar_requestType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestType at index 0");
    if (unicoderequestType)
        bsrequestType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestType));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_firewcsexception_method_cleanup;
    
    if (PyString_Check(pyvar_requestURL))
        unicoderequestURL = PyUnicode_FromObject(pyvar_requestURL);
    else if (PyUnicode_Check(pyvar_requestURL))
    {
        unicoderequestURL = pyvar_requestURL;
        Py_INCREF(unicoderequestURL);
    }
    else if (pyvar_requestURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestURL at index 1");
    if (unicoderequestURL)
        bsrequestURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestURL));
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_firewcsexception_method_cleanup;
    
    if (!IFaceFromPyObject(py_pException, &IID_IWCSServiceExceptionHandler, (void**)&ippException))
        PyErr_SetString(PyExc_TypeError, "Argument pException (position 2) is not IWCSServiceExceptionHandler");
    
    if (PyErr_Occurred())
      goto iwcsservicedescription_firewcsexception_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSServiceDescription->FireWCSException(bsrequestType, bsrequestURL, ippException);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSServiceDescription.FireWCSException() returned %ld", (long)hr);
        goto iwcsservicedescription_firewcsexception_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for requestType
    // No teardown for requestURL
    // No teardown for pException

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsservicedescription_firewcsexception_method_cleanup;

    iwcsservicedescription_firewcsexception_method_cleanup:
    self->m_HR = hr;
    if (bsrequestType)
        ::SysFreeString(bsrequestType);
    
    if (bsrequestURL)
        ::SysFreeString(bsrequestURL);
    
    if (ippException)
      ippException->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSServiceDescription.FireWCSException");
    return return_tuple;
}


PyMethodDef PyIWCSServiceDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIWCSServiceDescription_SupportsInterface, METH_O, ""},
    {"get_WCSName", (PyCFunction)IWCSServiceDescriptionMethod_get_WCSName, METH_VARARGS, ""},
    {"get_Abstract", (PyCFunction)IWCSServiceDescriptionMethod_get_Abstract, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IWCSServiceDescriptionMethod_get_Title, METH_VARARGS, ""},
    {"get_Version", (PyCFunction)IWCSServiceDescriptionMethod_get_Version, METH_VARARGS, ""},
    {"get_AccessConstrains", (PyCFunction)IWCSServiceDescriptionMethod_get_AccessConstrains, METH_VARARGS, ""},
    {"get_BaseURL", (PyCFunction)IWCSServiceDescriptionMethod_get_BaseURL, METH_VARARGS, ""},
    {"get_ExceptionFormatCount", (PyCFunction)IWCSServiceDescriptionMethod_get_ExceptionFormatCount, METH_VARARGS, ""},
    {"get_ExceptionFormat", (PyCFunction)IWCSServiceDescriptionMethod_get_ExceptionFormat, METH_VARARGS, ""},
    {"get_SupportedVersionsCount", (PyCFunction)IWCSServiceDescriptionMethod_get_SupportedVersionsCount, METH_VARARGS, ""},
    {"get_SupportedVersion", (PyCFunction)IWCSServiceDescriptionMethod_get_SupportedVersion, METH_VARARGS, ""},
    {"get_KeywordCount", (PyCFunction)IWCSServiceDescriptionMethod_get_KeywordCount, METH_VARARGS, ""},
    {"get_Keyword", (PyCFunction)IWCSServiceDescriptionMethod_get_Keyword, METH_VARARGS, ""},
    {"get_CoverageDescriptionCount", (PyCFunction)IWCSServiceDescriptionMethod_get_CoverageDescriptionCount, METH_VARARGS, ""},
    {"get_CoverageDescriptionByIndex", (PyCFunction)IWCSServiceDescriptionMethod_get_CoverageDescriptionByIndex, METH_VARARGS, ""},
    {"get_CoverageDescriptionByName", (PyCFunction)IWCSServiceDescriptionMethod_get_CoverageDescriptionByName, METH_VARARGS, ""},
    {"get_CoverageRequestUrl", (PyCFunction)IWCSServiceDescriptionMethod_get_CoverageRequestUrl, METH_VARARGS, ""},
    {"FireWCSRequest", (PyCFunction)IWCSServiceDescriptionMethod_FireWCSRequest, METH_VARARGS, ""},
    {"FireWCSException", (PyCFunction)IWCSServiceDescriptionMethod_FireWCSException, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSServiceDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIWCSServiceDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSServiceDescription", NULL},
  {"_pointer", (getter)PyIWCSServiceDescription_GetPointer, NULL, "Get memory address for IWCSServiceDescription", NULL},
  {"_IID", (getter)PyIWCSServiceDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSServiceDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSServiceDescription_GetIgnoreFailures, (setter)PyIWCSServiceDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSServiceDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSServiceDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIWCSServiceDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSServiceDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSServiceDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSServiceDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSServiceDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IWCSClientEvents

typedef struct PyIWCSClientEventsObject {
    PyObject_HEAD
    IWCSClientEvents* m_pIWCSClientEvents;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWCSClientEventsObject;

static PyObject*
PyIWCSClientEventsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWCSClientEventsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWCSClientEvents* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWCSClientEvents, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWCSClientEvents with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWCSClientEventsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSClientEvents");
            return NULL;
        }
        self->m_pIWCSClientEvents = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWCSClientEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWCSClientEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWCSClientEvents* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWCSClientEvents, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWCSClientEvents");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWCSClientEventsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWCSClientEvents");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWCSClientEvents = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWCSClientEventsObject_dealloc(PyIWCSClientEventsObject* self)
{
    if (self->m_pIWCSClientEvents)
        self->m_pIWCSClientEvents->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWCSClientEvents_GetpUnk(PyIWCSClientEventsObject* self)
{
    if (!self->m_pIWCSClientEvents)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWCSClientEvents->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWCSClientEvents to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWCSClientEvents_GetPointer(PyIWCSClientEventsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWCSClientEvents);
}

static PyObject*
PyIWCSClientEvents_GetIID(PyIWCSClientEventsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c8cd44b2-4412-4a12-bded-7225d81056c4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWCSClientEvents_GetHR(PyIWCSClientEventsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWCSClientEvents_GetIgnoreFailures(PyIWCSClientEventsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWCSClientEvents_SetIgnoreFailures(PyIWCSClientEventsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWCSClientEvents_SupportsInterface(PyIWCSClientEventsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWCSClientEvents->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWCSClientEventsMethod_WCSRequest(PyIWCSClientEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWCSServiceDescription* ippService = NULL;
    PyObject* py_pService;
    BSTR bsrequestType = 0;
    PyObject* pyvar_requestType;
    PyObject* unicoderequestType = NULL;
    BSTR bsrequestURL = 0;
    PyObject* pyvar_requestURL;
    PyObject* unicoderequestURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_pService, &pyvar_requestType, &pyvar_requestURL))
      goto iwcsclientevents_wcsrequest_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pService, &IID_IWCSServiceDescription, (void**)&ippService))
        PyErr_SetString(PyExc_TypeError, "Argument pService (position 0) is not IWCSServiceDescription");
    
    if (PyErr_Occurred())
      goto iwcsclientevents_wcsrequest_method_cleanup;
    
    if (PyString_Check(pyvar_requestType))
        unicoderequestType = PyUnicode_FromObject(pyvar_requestType);
    else if (PyUnicode_Check(pyvar_requestType))
    {
        unicoderequestType = pyvar_requestType;
        Py_INCREF(unicoderequestType);
    }
    else if (pyvar_requestType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestType at index 1");
    if (unicoderequestType)
        bsrequestType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestType));
    
    if (PyErr_Occurred())
      goto iwcsclientevents_wcsrequest_method_cleanup;
    
    if (PyString_Check(pyvar_requestURL))
        unicoderequestURL = PyUnicode_FromObject(pyvar_requestURL);
    else if (PyUnicode_Check(pyvar_requestURL))
    {
        unicoderequestURL = pyvar_requestURL;
        Py_INCREF(unicoderequestURL);
    }
    else if (pyvar_requestURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestURL at index 2");
    if (unicoderequestURL)
        bsrequestURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestURL));
    
    if (PyErr_Occurred())
      goto iwcsclientevents_wcsrequest_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSClientEvents->WCSRequest(ippService, bsrequestType, bsrequestURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSClientEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSClientEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSClientEvents.WCSRequest() returned %ld", (long)hr);
        goto iwcsclientevents_wcsrequest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pService
    // No teardown for requestType
    // No teardown for requestURL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsclientevents_wcsrequest_method_cleanup;

    iwcsclientevents_wcsrequest_method_cleanup:
    self->m_HR = hr;
    if (ippService)
      ippService->Release();
    if (bsrequestType)
        ::SysFreeString(bsrequestType);
    
    if (bsrequestURL)
        ::SysFreeString(bsrequestURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSClientEvents.WCSRequest");
    return return_tuple;
}

static PyObject*
IWCSClientEventsMethod_WCSException(PyIWCSClientEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWCSServiceDescription* ippService = NULL;
    PyObject* py_pService;
    BSTR bsrequestType = 0;
    PyObject* pyvar_requestType;
    PyObject* unicoderequestType = NULL;
    BSTR bsrequestURL = 0;
    PyObject* pyvar_requestURL;
    PyObject* unicoderequestURL = NULL;
    IWCSServiceExceptionHandler* ippException = NULL;
    PyObject* py_pException;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_pService, &pyvar_requestType, &pyvar_requestURL, &py_pException))
      goto iwcsclientevents_wcsexception_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pService, &IID_IWCSServiceDescription, (void**)&ippService))
        PyErr_SetString(PyExc_TypeError, "Argument pService (position 0) is not IWCSServiceDescription");
    
    if (PyErr_Occurred())
      goto iwcsclientevents_wcsexception_method_cleanup;
    
    if (PyString_Check(pyvar_requestType))
        unicoderequestType = PyUnicode_FromObject(pyvar_requestType);
    else if (PyUnicode_Check(pyvar_requestType))
    {
        unicoderequestType = pyvar_requestType;
        Py_INCREF(unicoderequestType);
    }
    else if (pyvar_requestType != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestType at index 1");
    if (unicoderequestType)
        bsrequestType = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestType), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestType));
    
    if (PyErr_Occurred())
      goto iwcsclientevents_wcsexception_method_cleanup;
    
    if (PyString_Check(pyvar_requestURL))
        unicoderequestURL = PyUnicode_FromObject(pyvar_requestURL);
    else if (PyUnicode_Check(pyvar_requestURL))
    {
        unicoderequestURL = pyvar_requestURL;
        Py_INCREF(unicoderequestURL);
    }
    else if (pyvar_requestURL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter requestURL at index 2");
    if (unicoderequestURL)
        bsrequestURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequestURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequestURL));
    
    if (PyErr_Occurred())
      goto iwcsclientevents_wcsexception_method_cleanup;
    
    if (!IFaceFromPyObject(py_pException, &IID_IWCSServiceExceptionHandler, (void**)&ippException))
        PyErr_SetString(PyExc_TypeError, "Argument pException (position 3) is not IWCSServiceExceptionHandler");
    
    if (PyErr_Occurred())
      goto iwcsclientevents_wcsexception_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWCSClientEvents->WCSException(ippService, bsrequestType, bsrequestURL, ippException);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWCSClientEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWCSClientEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWCSClientEvents.WCSException() returned %ld", (long)hr);
        goto iwcsclientevents_wcsexception_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pService
    // No teardown for requestType
    // No teardown for requestURL
    // No teardown for pException

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwcsclientevents_wcsexception_method_cleanup;

    iwcsclientevents_wcsexception_method_cleanup:
    self->m_HR = hr;
    if (ippService)
      ippService->Release();
    if (bsrequestType)
        ::SysFreeString(bsrequestType);
    
    if (bsrequestURL)
        ::SysFreeString(bsrequestURL);
    
    if (ippException)
      ippException->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWCSClientEvents.WCSException");
    return return_tuple;
}


PyMethodDef PyIWCSClientEventsMethods[] = {
    {"supports", (PyCFunction)PyIWCSClientEvents_SupportsInterface, METH_O, ""},
    {"WCSRequest", (PyCFunction)IWCSClientEventsMethod_WCSRequest, METH_VARARGS, ""},
    {"WCSException", (PyCFunction)IWCSClientEventsMethod_WCSException, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWCSClientEventsGetSet[] = {
  {"_pUnk", (getter)PyIWCSClientEvents_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWCSClientEvents", NULL},
  {"_pointer", (getter)PyIWCSClientEvents_GetPointer, NULL, "Get memory address for IWCSClientEvents", NULL},
  {"_IID", (getter)PyIWCSClientEvents_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWCSClientEvents_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWCSClientEvents_GetIgnoreFailures, (setter)PyIWCSClientEvents_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWCSClientEventsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWCSClientEventsObject",                          
                                              /* tp_name */
  sizeof(PyIWCSClientEventsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWCSClientEventsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWCSClientEventsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWCSClientEventsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWCSClientEventsObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSConnectionName

typedef struct PyIWMTSConnectionNameObject {
    PyObject_HEAD
    IWMTSConnectionName* m_pIWMTSConnectionName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSConnectionNameObject;

static PyObject*
PyIWMTSConnectionNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSConnectionNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSConnectionName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSConnectionName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSConnectionName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSConnectionNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSConnectionName");
            return NULL;
        }
        self->m_pIWMTSConnectionName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSConnectionName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSConnectionName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSConnectionName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSConnectionName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSConnectionNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSConnectionName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSConnectionName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSConnectionNameObject_dealloc(PyIWMTSConnectionNameObject* self)
{
    if (self->m_pIWMTSConnectionName)
        self->m_pIWMTSConnectionName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSConnectionName_GetpUnk(PyIWMTSConnectionNameObject* self)
{
    if (!self->m_pIWMTSConnectionName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSConnectionName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSConnectionName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSConnectionName_GetPointer(PyIWMTSConnectionNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSConnectionName);
}

static PyObject*
PyIWMTSConnectionName_GetIID(PyIWMTSConnectionNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0a014545-e32c-43c2-aa97-243f43294492");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSConnectionName_GetHR(PyIWMTSConnectionNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSConnectionName_GetIgnoreFailures(PyIWMTSConnectionNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSConnectionName_SetIgnoreFailures(PyIWMTSConnectionNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSConnectionName_SupportsInterface(PyIWMTSConnectionNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSConnectionName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSConnectionNameMethod_put_ConnectionProperties(PyIWMTSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipConnectionProperties = NULL;
    PyObject* py_ConnectionProperties;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ConnectionProperties))
      goto iwmtsconnectionname_put_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ConnectionProperties, &IID_IPropertySet, (void**)&ipConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument ConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iwmtsconnectionname_put_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMTSConnectionName->put_ConnectionProperties(ipConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSConnectionName.put_ConnectionProperties() returned %ld", (long)hr);
        goto iwmtsconnectionname_put_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ConnectionProperties

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmtsconnectionname_put_connectionproperties_method_cleanup;

    iwmtsconnectionname_put_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipConnectionProperties)
      ipConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSConnectionName.put_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IWMTSConnectionNameMethod_get_ConnectionProperties(PyIWMTSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipConnectionProperties = NULL;
    PyObject* py_ConnectionProperties = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ConnectionProperties

    // Call method on actual COM interface
    hr = self->m_pIWMTSConnectionName->get_ConnectionProperties(&ipConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSConnectionName.get_ConnectionProperties() returned %ld", (long)hr);
        goto iwmtsconnectionname_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
    {
        IUnknown* pUnk = NULL;
        ipConnectionProperties->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ConnectionProperties = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ConnectionProperties)
    {
        if (py_ConnectionProperties)
           Py_DECREF(py_ConnectionProperties);
        py_ConnectionProperties = Py_None;
        Py_INCREF(py_ConnectionProperties);
    }
    if (PyErr_Occurred())
      goto iwmtsconnectionname_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ConnectionProperties);
    goto iwmtsconnectionname_get_connectionproperties_method_cleanup;

    iwmtsconnectionname_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ConnectionProperties);
    if (ipConnectionProperties)
      ipConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSConnectionName.get_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IWMTSConnectionNameMethod_OpenEx(PyIWMTSConnectionNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IUnknown* ipppUnknown = NULL;
    PyObject* py_ppUnknown = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto iwmtsconnectionname_openex_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iwmtsconnectionname_openex_method_cleanup;
    
    // No setup for ppUnknown

    // Call method on actual COM interface
    hr = self->m_pIWMTSConnectionName->OpenEx(ippTrackCancel, &ipppUnknown);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSConnectionName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSConnectionName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSConnectionName.OpenEx() returned %ld", (long)hr);
        goto iwmtsconnectionname_openex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppUnknown);
    if (ipppUnknown)
    {
        IUnknown* pUnk = NULL;
        ipppUnknown->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUnknown = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUnknown)
    {
        if (py_ppUnknown)
           Py_DECREF(py_ppUnknown);
        py_ppUnknown = Py_None;
        Py_INCREF(py_ppUnknown);
    }
    if (PyErr_Occurred())
      goto iwmtsconnectionname_openex_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUnknown);
    goto iwmtsconnectionname_openex_method_cleanup;

    iwmtsconnectionname_openex_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppUnknown);
    if (ipppUnknown)
      ipppUnknown->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSConnectionName.OpenEx");
    return return_tuple;
}


PyMethodDef PyIWMTSConnectionNameMethods[] = {
    {"supports", (PyCFunction)PyIWMTSConnectionName_SupportsInterface, METH_O, ""},
    {"put_ConnectionProperties", (PyCFunction)IWMTSConnectionNameMethod_put_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IWMTSConnectionNameMethod_get_ConnectionProperties, METH_VARARGS, ""},
    {"OpenEx", (PyCFunction)IWMTSConnectionNameMethod_OpenEx, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSConnectionNameGetSet[] = {
  {"_pUnk", (getter)PyIWMTSConnectionName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSConnectionName", NULL},
  {"_pointer", (getter)PyIWMTSConnectionName_GetPointer, NULL, "Get memory address for IWMTSConnectionName", NULL},
  {"_IID", (getter)PyIWMTSConnectionName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSConnectionName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSConnectionName_GetIgnoreFailures, (setter)PyIWMTSConnectionName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSConnectionNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSConnectionNameObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSConnectionNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSConnectionNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSConnectionNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSConnectionNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSConnectionNameObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSConnection

typedef struct PyIWMTSConnectionObject {
    PyObject_HEAD
    IWMTSConnection* m_pIWMTSConnection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSConnectionObject;

static PyObject*
PyIWMTSConnectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSConnectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSConnection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSConnection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSConnection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSConnectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSConnection");
            return NULL;
        }
        self->m_pIWMTSConnection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSConnection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSConnection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSConnection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSConnection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSConnection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSConnectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSConnection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSConnection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSConnectionObject_dealloc(PyIWMTSConnectionObject* self)
{
    if (self->m_pIWMTSConnection)
        self->m_pIWMTSConnection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSConnection_GetpUnk(PyIWMTSConnectionObject* self)
{
    if (!self->m_pIWMTSConnection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSConnection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSConnection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSConnection_GetPointer(PyIWMTSConnectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSConnection);
}

static PyObject*
PyIWMTSConnection_GetIID(PyIWMTSConnectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "525ade39-e2e6-418a-bb56-04eab6febbb3");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSConnection_GetHR(PyIWMTSConnectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSConnection_GetIgnoreFailures(PyIWMTSConnectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSConnection_SetIgnoreFailures(PyIWMTSConnectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSConnection_SupportsInterface(PyIWMTSConnectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSConnection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSConnectionMethod_get_Name(PyIWMTSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWMTSConnection->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSConnection.get_Name() returned %ld", (long)hr);
        goto iwmtsconnection_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwmtsconnection_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwmtsconnection_get_name_method_cleanup;

    iwmtsconnection_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSConnection.get_Name");
    return return_tuple;
}

static PyObject*
IWMTSConnectionMethod_put_Name(PyIWMTSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iwmtsconnection_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iwmtsconnection_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMTSConnection->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSConnection.put_Name() returned %ld", (long)hr);
        goto iwmtsconnection_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmtsconnection_put_name_method_cleanup;

    iwmtsconnection_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSConnection.put_Name");
    return return_tuple;
}

static PyObject*
IWMTSConnectionMethod_get_FullName(PyIWMTSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppName = NULL;
    PyObject* py_ppName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppName

    // Call method on actual COM interface
    hr = self->m_pIWMTSConnection->get_FullName(&ipppName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSConnection.get_FullName() returned %ld", (long)hr);
        goto iwmtsconnection_get_fullname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppName);
    if (ipppName)
    {
        IUnknown* pUnk = NULL;
        ipppName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppName = IUnknownToPythonIIDObject(pUnk, &IID_IName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppName)
    {
        if (py_ppName)
           Py_DECREF(py_ppName);
        py_ppName = Py_None;
        Py_INCREF(py_ppName);
    }
    if (PyErr_Occurred())
      goto iwmtsconnection_get_fullname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppName);
    goto iwmtsconnection_get_fullname_method_cleanup;

    iwmtsconnection_get_fullname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppName);
    if (ipppName)
      ipppName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSConnection.get_FullName");
    return return_tuple;
}

static PyObject*
IWMTSConnectionMethod_putref_FullName(PyIWMTSConnectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipppName = NULL;
    PyObject* py_ppName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppName))
      goto iwmtsconnection_putref_fullname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppName, &IID_IName, (void**)&ipppName))
        PyErr_SetString(PyExc_TypeError, "Argument ppName (position 0) is not IName");
    
    if (PyErr_Occurred())
      goto iwmtsconnection_putref_fullname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWMTSConnection->putref_FullName(ipppName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSConnection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSConnection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSConnection.putref_FullName() returned %ld", (long)hr);
        goto iwmtsconnection_putref_fullname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwmtsconnection_putref_fullname_method_cleanup;

    iwmtsconnection_putref_fullname_method_cleanup:
    self->m_HR = hr;
    if (ipppName)
      ipppName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSConnection.putref_FullName");
    return return_tuple;
}


PyMethodDef PyIWMTSConnectionMethods[] = {
    {"supports", (PyCFunction)PyIWMTSConnection_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IWMTSConnectionMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IWMTSConnectionMethod_put_Name, METH_VARARGS, ""},
    {"get_FullName", (PyCFunction)IWMTSConnectionMethod_get_FullName, METH_VARARGS, ""},
    {"putref_FullName", (PyCFunction)IWMTSConnectionMethod_putref_FullName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSConnectionGetSet[] = {
  {"_pUnk", (getter)PyIWMTSConnection_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSConnection", NULL},
  {"_pointer", (getter)PyIWMTSConnection_GetPointer, NULL, "Get memory address for IWMTSConnection", NULL},
  {"_IID", (getter)PyIWMTSConnection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSConnection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSConnection_GetIgnoreFailures, (setter)PyIWMTSConnection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSConnectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSConnectionObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSConnectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSConnectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSConnectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSConnectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSConnectionObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSConnectionFactory

typedef struct PyIWMTSConnectionFactoryObject {
    PyObject_HEAD
    IWMTSConnectionFactory* m_pIWMTSConnectionFactory;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSConnectionFactoryObject;

static PyObject*
PyIWMTSConnectionFactoryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSConnectionFactoryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSConnectionFactory* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSConnectionFactory, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSConnectionFactory with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSConnectionFactoryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSConnectionFactory");
            return NULL;
        }
        self->m_pIWMTSConnectionFactory = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSConnectionFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSConnectionFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSConnectionFactory* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSConnectionFactory, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSConnectionFactory");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSConnectionFactoryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSConnectionFactory");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSConnectionFactory = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSConnectionFactoryObject_dealloc(PyIWMTSConnectionFactoryObject* self)
{
    if (self->m_pIWMTSConnectionFactory)
        self->m_pIWMTSConnectionFactory->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSConnectionFactory_GetpUnk(PyIWMTSConnectionFactoryObject* self)
{
    if (!self->m_pIWMTSConnectionFactory)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSConnectionFactory->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSConnectionFactory to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSConnectionFactory_GetPointer(PyIWMTSConnectionFactoryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSConnectionFactory);
}

static PyObject*
PyIWMTSConnectionFactory_GetIID(PyIWMTSConnectionFactoryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8043c9be-1311-4020-a18f-ec23efec6289");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSConnectionFactory_GetHR(PyIWMTSConnectionFactoryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSConnectionFactory_GetIgnoreFailures(PyIWMTSConnectionFactoryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSConnectionFactory_SetIgnoreFailures(PyIWMTSConnectionFactoryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSConnectionFactory_SupportsInterface(PyIWMTSConnectionFactoryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSConnectionFactory->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSConnectionFactoryMethod_Open(PyIWMTSConnectionFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippConnectionProperties = NULL;
    PyObject* py_pConnectionProperties;
    OLE_HANDLE HhWnd = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IWMTSConnection* ipppConnection = NULL;
    PyObject* py_ppConnection = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OIO", &py_pConnectionProperties, &HhWnd, &py_pTrackCancel))
      goto iwmtsconnectionfactory_open_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConnectionProperties, &IID_IPropertySet, (void**)&ippConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument pConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto iwmtsconnectionfactory_open_method_cleanup;
    
    // No setup for hWnd
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iwmtsconnectionfactory_open_method_cleanup;
    
    // No setup for ppConnection

    // Call method on actual COM interface
    hr = self->m_pIWMTSConnectionFactory->Open(ippConnectionProperties, HhWnd, ippTrackCancel, &ipppConnection);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSConnectionFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSConnectionFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSConnectionFactory.Open() returned %ld", (long)hr);
        goto iwmtsconnectionfactory_open_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConnectionProperties
    // No teardown for hWnd
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
    {
        IUnknown* pUnk = NULL;
        ipppConnection->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConnection = IUnknownToPythonIIDObject(pUnk, &IID_IWMTSConnection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConnection)
    {
        if (py_ppConnection)
           Py_DECREF(py_ppConnection);
        py_ppConnection = Py_None;
        Py_INCREF(py_ppConnection);
    }
    if (PyErr_Occurred())
      goto iwmtsconnectionfactory_open_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConnection);
    goto iwmtsconnectionfactory_open_method_cleanup;

    iwmtsconnectionfactory_open_method_cleanup:
    self->m_HR = hr;
    if (ippConnectionProperties)
      ippConnectionProperties->Release();
    // No cleanup for hWnd
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppConnection);
    if (ipppConnection)
      ipppConnection->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSConnectionFactory.Open");
    return return_tuple;
}


PyMethodDef PyIWMTSConnectionFactoryMethods[] = {
    {"supports", (PyCFunction)PyIWMTSConnectionFactory_SupportsInterface, METH_O, ""},
    {"Open", (PyCFunction)IWMTSConnectionFactoryMethod_Open, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSConnectionFactoryGetSet[] = {
  {"_pUnk", (getter)PyIWMTSConnectionFactory_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSConnectionFactory", NULL},
  {"_pointer", (getter)PyIWMTSConnectionFactory_GetPointer, NULL, "Get memory address for IWMTSConnectionFactory", NULL},
  {"_IID", (getter)PyIWMTSConnectionFactory_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSConnectionFactory_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSConnectionFactory_GetIgnoreFailures, (setter)PyIWMTSConnectionFactory_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSConnectionFactoryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSConnectionFactoryObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSConnectionFactoryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSConnectionFactoryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSConnectionFactoryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSConnectionFactoryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSConnectionFactoryObject_new,                      
                                              /* tp_new */
};

// Interface IWMTSServiceDescription

typedef struct PyIWMTSServiceDescriptionObject {
    PyObject_HEAD
    IWMTSServiceDescription* m_pIWMTSServiceDescription;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWMTSServiceDescriptionObject;

static PyObject*
PyIWMTSServiceDescriptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWMTSServiceDescriptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWMTSServiceDescription* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWMTSServiceDescription, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWMTSServiceDescription with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWMTSServiceDescriptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSServiceDescription");
            return NULL;
        }
        self->m_pIWMTSServiceDescription = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWMTSServiceDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWMTSServiceDescription");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWMTSServiceDescription* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWMTSServiceDescription, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWMTSServiceDescription");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWMTSServiceDescriptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWMTSServiceDescription");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWMTSServiceDescription = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWMTSServiceDescriptionObject_dealloc(PyIWMTSServiceDescriptionObject* self)
{
    if (self->m_pIWMTSServiceDescription)
        self->m_pIWMTSServiceDescription->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWMTSServiceDescription_GetpUnk(PyIWMTSServiceDescriptionObject* self)
{
    if (!self->m_pIWMTSServiceDescription)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWMTSServiceDescription->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWMTSServiceDescription to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWMTSServiceDescription_GetPointer(PyIWMTSServiceDescriptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWMTSServiceDescription);
}

static PyObject*
PyIWMTSServiceDescription_GetIID(PyIWMTSServiceDescriptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b5543b2a-65ef-410c-9819-80ed5bd7e669");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWMTSServiceDescription_GetHR(PyIWMTSServiceDescriptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWMTSServiceDescription_GetIgnoreFailures(PyIWMTSServiceDescriptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWMTSServiceDescription_SetIgnoreFailures(PyIWMTSServiceDescriptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWMTSServiceDescription_SupportsInterface(PyIWMTSServiceDescriptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWMTSServiceDescriptionMethod_get_WMTSName(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_WMTSName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_WMTSName() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_wmtsname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iwmtsservicedescription_get_wmtsname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iwmtsservicedescription_get_wmtsname_method_cleanup;

    iwmtsservicedescription_get_wmtsname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_WMTSName");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_WMTSAbstract(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAbstract;
    PyObject* pyvar_Abstract = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Abstract

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_WMTSAbstract(&bsAbstract);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_WMTSAbstract() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_wmtsabstract_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Abstract = PyUnicode_FromWideChar(bsAbstract,::SysStringLen(bsAbstract));
    ::SysFreeString(bsAbstract);
    
    if (PyErr_Occurred())
      goto iwmtsservicedescription_get_wmtsabstract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Abstract);
    goto iwmtsservicedescription_get_wmtsabstract_method_cleanup;

    iwmtsservicedescription_get_wmtsabstract_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Abstract != Py_None)
        Py_XDECREF(pyvar_Abstract);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_WMTSAbstract");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_WMTSTitle(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_WMTSTitle(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_WMTSTitle() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_wmtstitle_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmtsservicedescription_get_wmtstitle_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmtsservicedescription_get_wmtstitle_method_cleanup;

    iwmtsservicedescription_get_wmtstitle_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_WMTSTitle");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_WMTSVersion(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_WMTSVersion(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_WMTSVersion() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_wmtsversion_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iwmtsservicedescription_get_wmtsversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iwmtsservicedescription_get_wmtsversion_method_cleanup;

    iwmtsservicedescription_get_wmtsversion_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_WMTSVersion");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_LayerDescriptionCount(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_LayerDescriptionCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_LayerDescriptionCount() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_layerdescriptioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtsservicedescription_get_layerdescriptioncount_method_cleanup;

    iwmtsservicedescription_get_layerdescriptioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_LayerDescriptionCount");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_LayerDescription(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMTSLayerDescription* ipppLayerDescription = NULL;
    PyObject* py_ppLayerDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtsservicedescription_get_layerdescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppLayerDescription

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_LayerDescription(lindex, &ipppLayerDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_LayerDescription() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_layerdescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppLayerDescription);
    if (ipppLayerDescription)
    {
        IUnknown* pUnk = NULL;
        ipppLayerDescription->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppLayerDescription = IUnknownToPythonIIDObject(pUnk, &IID_IWMTSLayerDescription);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppLayerDescription)
    {
        if (py_ppLayerDescription)
           Py_DECREF(py_ppLayerDescription);
        py_ppLayerDescription = Py_None;
        Py_INCREF(py_ppLayerDescription);
    }
    if (PyErr_Occurred())
      goto iwmtsservicedescription_get_layerdescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppLayerDescription);
    goto iwmtsservicedescription_get_layerdescription_method_cleanup;

    iwmtsservicedescription_get_layerdescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppLayerDescription);
    if (ipppLayerDescription)
      ipppLayerDescription->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_LayerDescription");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_TileMatrixSetCount(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_TileMatrixSetCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_TileMatrixSetCount() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_tilematrixsetcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtsservicedescription_get_tilematrixsetcount_method_cleanup;

    iwmtsservicedescription_get_tilematrixsetcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_TileMatrixSetCount");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_TileMatrixSet(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IWMTSTileMatrixSet* ipTileMatrix = NULL;
    PyObject* py_TileMatrix = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtsservicedescription_get_tilematrixset_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for TileMatrix

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_TileMatrixSet(lindex, &ipTileMatrix);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_TileMatrixSet() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_tilematrixset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_TileMatrix);
    if (ipTileMatrix)
    {
        IUnknown* pUnk = NULL;
        ipTileMatrix->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_TileMatrix = IUnknownToPythonIIDObject(pUnk, &IID_IWMTSTileMatrixSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_TileMatrix)
    {
        if (py_TileMatrix)
           Py_DECREF(py_TileMatrix);
        py_TileMatrix = Py_None;
        Py_INCREF(py_TileMatrix);
    }
    if (PyErr_Occurred())
      goto iwmtsservicedescription_get_tilematrixset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_TileMatrix);
    goto iwmtsservicedescription_get_tilematrixset_method_cleanup;

    iwmtsservicedescription_get_tilematrixset_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_TileMatrix);
    if (ipTileMatrix)
      ipTileMatrix->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_TileMatrixSet");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_ImageFormatCount(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_ImageFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_ImageFormatCount() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_imageformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtsservicedescription_get_imageformatcount_method_cleanup;

    iwmtsservicedescription_get_imageformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_ImageFormatCount");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_ImageFormat(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtsservicedescription_get_imageformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_ImageFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_ImageFormat() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_imageformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmtsservicedescription_get_imageformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmtsservicedescription_get_imageformat_method_cleanup;

    iwmtsservicedescription_get_imageformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_ImageFormat");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_FeatureInfoFormatCount(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_FeatureInfoFormatCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_FeatureInfoFormatCount() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_featureinfoformatcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iwmtsservicedescription_get_featureinfoformatcount_method_cleanup;

    iwmtsservicedescription_get_featureinfoformatcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_FeatureInfoFormatCount");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_get_FeatureInfoFormat(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsImageFormat;
    PyObject* pyvar_ImageFormat = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iwmtsservicedescription_get_featureinfoformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ImageFormat

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->get_FeatureInfoFormat(lindex, &bsImageFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.get_FeatureInfoFormat() returned %ld", (long)hr);
        goto iwmtsservicedescription_get_featureinfoformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_ImageFormat = PyUnicode_FromWideChar(bsImageFormat,::SysStringLen(bsImageFormat));
    ::SysFreeString(bsImageFormat);
    
    if (PyErr_Occurred())
      goto iwmtsservicedescription_get_featureinfoformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ImageFormat);
    goto iwmtsservicedescription_get_featureinfoformat_method_cleanup;

    iwmtsservicedescription_get_featureinfoformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_ImageFormat != Py_None)
        Py_XDECREF(pyvar_ImageFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.get_FeatureInfoFormat");
    return return_tuple;
}

static PyObject*
IWMTSServiceDescriptionMethod_GetOperationUrl(PyIWMTSServiceDescriptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsoperation = 0;
    PyObject* pyvar_operation;
    PyObject* unicodeoperation = NULL;
    BSTR bsBaseURL;
    PyObject* pyvar_BaseURL = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_operation))
      goto iwmtsservicedescription_getoperationurl_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_operation))
        unicodeoperation = PyUnicode_FromObject(pyvar_operation);
    else if (PyUnicode_Check(pyvar_operation))
    {
        unicodeoperation = pyvar_operation;
        Py_INCREF(unicodeoperation);
    }
    else if (pyvar_operation != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter operation at index 0");
    if (unicodeoperation)
        bsoperation = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeoperation), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeoperation));
    
    if (PyErr_Occurred())
      goto iwmtsservicedescription_getoperationurl_method_cleanup;
    
    // No setup for BaseURL

    // Call method on actual COM interface
    hr = self->m_pIWMTSServiceDescription->GetOperationUrl(bsoperation, &bsBaseURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWMTSServiceDescription->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWMTSServiceDescription) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWMTSServiceDescription.GetOperationUrl() returned %ld", (long)hr);
        goto iwmtsservicedescription_getoperationurl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for operation
    pyvar_BaseURL = PyUnicode_FromWideChar(bsBaseURL,::SysStringLen(bsBaseURL));
    ::SysFreeString(bsBaseURL);
    
    if (PyErr_Occurred())
      goto iwmtsservicedescription_getoperationurl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_BaseURL);
    goto iwmtsservicedescription_getoperationurl_method_cleanup;

    iwmtsservicedescription_getoperationurl_method_cleanup:
    self->m_HR = hr;
    if (bsoperation)
        ::SysFreeString(bsoperation);
    
    if (pyvar_BaseURL != Py_None)
        Py_XDECREF(pyvar_BaseURL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWMTSServiceDescription.GetOperationUrl");
    return return_tuple;
}


PyMethodDef PyIWMTSServiceDescriptionMethods[] = {
    {"supports", (PyCFunction)PyIWMTSServiceDescription_SupportsInterface, METH_O, ""},
    {"get_WMTSName", (PyCFunction)IWMTSServiceDescriptionMethod_get_WMTSName, METH_VARARGS, ""},
    {"get_WMTSAbstract", (PyCFunction)IWMTSServiceDescriptionMethod_get_WMTSAbstract, METH_VARARGS, ""},
    {"get_WMTSTitle", (PyCFunction)IWMTSServiceDescriptionMethod_get_WMTSTitle, METH_VARARGS, ""},
    {"get_WMTSVersion", (PyCFunction)IWMTSServiceDescriptionMethod_get_WMTSVersion, METH_VARARGS, ""},
    {"get_LayerDescriptionCount", (PyCFunction)IWMTSServiceDescriptionMethod_get_LayerDescriptionCount, METH_VARARGS, ""},
    {"get_LayerDescription", (PyCFunction)IWMTSServiceDescriptionMethod_get_LayerDescription, METH_VARARGS, ""},
    {"get_TileMatrixSetCount", (PyCFunction)IWMTSServiceDescriptionMethod_get_TileMatrixSetCount, METH_VARARGS, ""},
    {"get_TileMatrixSet", (PyCFunction)IWMTSServiceDescriptionMethod_get_TileMatrixSet, METH_VARARGS, ""},
    {"get_ImageFormatCount", (PyCFunction)IWMTSServiceDescriptionMethod_get_ImageFormatCount, METH_VARARGS, ""},
    {"get_ImageFormat", (PyCFunction)IWMTSServiceDescriptionMethod_get_ImageFormat, METH_VARARGS, ""},
    {"get_FeatureInfoFormatCount", (PyCFunction)IWMTSServiceDescriptionMethod_get_FeatureInfoFormatCount, METH_VARARGS, ""},
    {"get_FeatureInfoFormat", (PyCFunction)IWMTSServiceDescriptionMethod_get_FeatureInfoFormat, METH_VARARGS, ""},
    {"GetOperationUrl", (PyCFunction)IWMTSServiceDescriptionMethod_GetOperationUrl, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWMTSServiceDescriptionGetSet[] = {
  {"_pUnk", (getter)PyIWMTSServiceDescription_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWMTSServiceDescription", NULL},
  {"_pointer", (getter)PyIWMTSServiceDescription_GetPointer, NULL, "Get memory address for IWMTSServiceDescription", NULL},
  {"_IID", (getter)PyIWMTSServiceDescription_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWMTSServiceDescription_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWMTSServiceDescription_GetIgnoreFailures, (setter)PyIWMTSServiceDescription_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWMTSServiceDescriptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IWMTSServiceDescriptionObject",                          
                                              /* tp_name */
  sizeof(PyIWMTSServiceDescriptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWMTSServiceDescriptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWMTSServiceDescriptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWMTSServiceDescriptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWMTSServiceDescriptionObject_new,                      
                                              /* tp_new */
};

// Interface IUploadItem

typedef struct PyIUploadItemObject {
    PyObject_HEAD
    IUploadItem* m_pIUploadItem;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIUploadItemObject;

static PyObject*
PyIUploadItemObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIUploadItemObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IUploadItem* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUploadItem, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUploadItem with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIUploadItemObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IUploadItem");
            return NULL;
        }
        self->m_pIUploadItem = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUploadItem");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUploadItem");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IUploadItem* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IUploadItem, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IUploadItem");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIUploadItemObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUploadItem");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIUploadItem = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIUploadItemObject_dealloc(PyIUploadItemObject* self)
{
    if (self->m_pIUploadItem)
        self->m_pIUploadItem->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIUploadItem_GetpUnk(PyIUploadItemObject* self)
{
    if (!self->m_pIUploadItem)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIUploadItem->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IUploadItem to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIUploadItem_GetPointer(PyIUploadItemObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIUploadItem);
}

static PyObject*
PyIUploadItem_GetIID(PyIUploadItemObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "68bd2cad-90af-4bfb-9117-4f28aed6cbe0");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIUploadItem_GetHR(PyIUploadItemObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIUploadItem_GetIgnoreFailures(PyIUploadItemObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIUploadItem_SetIgnoreFailures(PyIUploadItemObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIUploadItem_SupportsInterface(PyIUploadItemObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IUploadItemMethod_put_Name(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName = 0;
    PyObject* pyvar_pName;
    PyObject* unicodepName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pName))
      goto iuploaditem_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pName))
        unicodepName = PyUnicode_FromObject(pyvar_pName);
    else if (PyUnicode_Check(pyvar_pName))
    {
        unicodepName = pyvar_pName;
        Py_INCREF(unicodepName);
    }
    else if (pyvar_pName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pName at index 0");
    if (unicodepName)
        bspName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepName));
    
    if (PyErr_Occurred())
      goto iuploaditem_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->put_Name(bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.put_Name() returned %ld", (long)hr);
        goto iuploaditem_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploaditem_put_name_method_cleanup;

    iuploaditem_put_name_method_cleanup:
    self->m_HR = hr;
    if (bspName)
        ::SysFreeString(bspName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.put_Name");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_get_Name(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.get_Name() returned %ld", (long)hr);
        goto iuploaditem_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iuploaditem_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iuploaditem_get_name_method_cleanup;

    iuploaditem_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.get_Name");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_put_ID(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspItemID = 0;
    PyObject* pyvar_pItemID;
    PyObject* unicodepItemID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pItemID))
      goto iuploaditem_put_id_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pItemID))
        unicodepItemID = PyUnicode_FromObject(pyvar_pItemID);
    else if (PyUnicode_Check(pyvar_pItemID))
    {
        unicodepItemID = pyvar_pItemID;
        Py_INCREF(unicodepItemID);
    }
    else if (pyvar_pItemID != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pItemID at index 0");
    if (unicodepItemID)
        bspItemID = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepItemID), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepItemID));
    
    if (PyErr_Occurred())
      goto iuploaditem_put_id_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->put_ID(bspItemID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.put_ID() returned %ld", (long)hr);
        goto iuploaditem_put_id_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pItemID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploaditem_put_id_method_cleanup;

    iuploaditem_put_id_method_cleanup:
    self->m_HR = hr;
    if (bspItemID)
        ::SysFreeString(bspItemID);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.put_ID");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_get_ID(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspItemID;
    PyObject* pyvar_pItemID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pItemID

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->get_ID(&bspItemID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.get_ID() returned %ld", (long)hr);
        goto iuploaditem_get_id_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pItemID = PyUnicode_FromWideChar(bspItemID,::SysStringLen(bspItemID));
    ::SysFreeString(bspItemID);
    
    if (PyErr_Occurred())
      goto iuploaditem_get_id_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pItemID);
    goto iuploaditem_get_id_method_cleanup;

    iuploaditem_get_id_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pItemID != Py_None)
        Py_XDECREF(pyvar_pItemID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.get_ID");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_put_FilePath(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspPath = 0;
    PyObject* pyvar_pPath;
    PyObject* unicodepPath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pPath))
      goto iuploaditem_put_filepath_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pPath))
        unicodepPath = PyUnicode_FromObject(pyvar_pPath);
    else if (PyUnicode_Check(pyvar_pPath))
    {
        unicodepPath = pyvar_pPath;
        Py_INCREF(unicodepPath);
    }
    else if (pyvar_pPath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pPath at index 0");
    if (unicodepPath)
        bspPath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepPath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepPath));
    
    if (PyErr_Occurred())
      goto iuploaditem_put_filepath_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->put_FilePath(bspPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.put_FilePath() returned %ld", (long)hr);
        goto iuploaditem_put_filepath_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploaditem_put_filepath_method_cleanup;

    iuploaditem_put_filepath_method_cleanup:
    self->m_HR = hr;
    if (bspPath)
        ::SysFreeString(bspPath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.put_FilePath");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_get_FilePath(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspPath;
    PyObject* pyvar_pPath = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPath

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->get_FilePath(&bspPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.get_FilePath() returned %ld", (long)hr);
        goto iuploaditem_get_filepath_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pPath = PyUnicode_FromWideChar(bspPath,::SysStringLen(bspPath));
    ::SysFreeString(bspPath);
    
    if (PyErr_Occurred())
      goto iuploaditem_get_filepath_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pPath);
    goto iuploaditem_get_filepath_method_cleanup;

    iuploaditem_get_filepath_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pPath != Py_None)
        Py_XDECREF(pyvar_pPath);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.get_FilePath");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_put_PathOnServer(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspPathOnServer = 0;
    PyObject* pyvar_pPathOnServer;
    PyObject* unicodepPathOnServer = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pPathOnServer))
      goto iuploaditem_put_pathonserver_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pPathOnServer))
        unicodepPathOnServer = PyUnicode_FromObject(pyvar_pPathOnServer);
    else if (PyUnicode_Check(pyvar_pPathOnServer))
    {
        unicodepPathOnServer = pyvar_pPathOnServer;
        Py_INCREF(unicodepPathOnServer);
    }
    else if (pyvar_pPathOnServer != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pPathOnServer at index 0");
    if (unicodepPathOnServer)
        bspPathOnServer = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepPathOnServer), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepPathOnServer));
    
    if (PyErr_Occurred())
      goto iuploaditem_put_pathonserver_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->put_PathOnServer(bspPathOnServer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.put_PathOnServer() returned %ld", (long)hr);
        goto iuploaditem_put_pathonserver_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPathOnServer

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploaditem_put_pathonserver_method_cleanup;

    iuploaditem_put_pathonserver_method_cleanup:
    self->m_HR = hr;
    if (bspPathOnServer)
        ::SysFreeString(bspPathOnServer);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.put_PathOnServer");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_get_PathOnServer(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspPathOnServer;
    PyObject* pyvar_pPathOnServer = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPathOnServer

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->get_PathOnServer(&bspPathOnServer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.get_PathOnServer() returned %ld", (long)hr);
        goto iuploaditem_get_pathonserver_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pPathOnServer = PyUnicode_FromWideChar(bspPathOnServer,::SysStringLen(bspPathOnServer));
    ::SysFreeString(bspPathOnServer);
    
    if (PyErr_Occurred())
      goto iuploaditem_get_pathonserver_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pPathOnServer);
    goto iuploaditem_get_pathonserver_method_cleanup;

    iuploaditem_get_pathonserver_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pPathOnServer != Py_None)
        Py_XDECREF(pyvar_pPathOnServer);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.get_PathOnServer");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_put_Description(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDesc = 0;
    PyObject* pyvar_pDesc;
    PyObject* unicodepDesc = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pDesc))
      goto iuploaditem_put_description_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pDesc))
        unicodepDesc = PyUnicode_FromObject(pyvar_pDesc);
    else if (PyUnicode_Check(pyvar_pDesc))
    {
        unicodepDesc = pyvar_pDesc;
        Py_INCREF(unicodepDesc);
    }
    else if (pyvar_pDesc != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pDesc at index 0");
    if (unicodepDesc)
        bspDesc = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepDesc), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepDesc));
    
    if (PyErr_Occurred())
      goto iuploaditem_put_description_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->put_Description(bspDesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.put_Description() returned %ld", (long)hr);
        goto iuploaditem_put_description_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDesc

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploaditem_put_description_method_cleanup;

    iuploaditem_put_description_method_cleanup:
    self->m_HR = hr;
    if (bspDesc)
        ::SysFreeString(bspDesc);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.put_Description");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_get_Description(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspDesc;
    PyObject* pyvar_pDesc = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDesc

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->get_Description(&bspDesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.get_Description() returned %ld", (long)hr);
        goto iuploaditem_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pDesc = PyUnicode_FromWideChar(bspDesc,::SysStringLen(bspDesc));
    ::SysFreeString(bspDesc);
    
    if (PyErr_Occurred())
      goto iuploaditem_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pDesc);
    goto iuploaditem_get_description_method_cleanup;

    iuploaditem_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pDesc != Py_None)
        Py_XDECREF(pyvar_pDesc);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.get_Description");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_put_Date(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpDate;
    PyObject* py_pDate = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pDate))
      goto iuploaditem_put_date_method_cleanup;

    // Set up initial variable values as needed
    dpDate = PyObject_AsDATE(py_pDate);
    
    if (PyErr_Occurred())
      goto iuploaditem_put_date_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->put_Date(dpDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.put_Date() returned %ld", (long)hr);
        goto iuploaditem_put_date_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDate

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploaditem_put_date_method_cleanup;

    iuploaditem_put_date_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pDate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.put_Date");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_get_Date(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpDate;
    PyObject* py_pDate = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDate

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->get_Date(&dpDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.get_Date() returned %ld", (long)hr);
        goto iuploaditem_get_date_method_cleanup;
    }

    // Set up return values as needed
    py_pDate = DATE_AsPyObject(dpDate);
    if (PyErr_Occurred())
      goto iuploaditem_get_date_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pDate);
    goto iuploaditem_get_date_method_cleanup;

    iuploaditem_get_date_method_cleanup:
    self->m_HR = hr;
    if (py_pDate && (py_pDate != Py_None))
      Py_XDECREF(py_pDate);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.get_Date");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_put_Committed(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Committed = VARIANT_FALSE;
    PyObject* pyvar_Committed = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Committed))
      goto iuploaditem_put_committed_method_cleanup;

    // Set up initial variable values as needed
    b_Committed = ((PyObject_IsTrue(pyvar_Committed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iuploaditem_put_committed_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->put_Committed(b_Committed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.put_Committed() returned %ld", (long)hr);
        goto iuploaditem_put_committed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Committed

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploaditem_put_committed_method_cleanup;

    iuploaditem_put_committed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Committed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.put_Committed");
    return return_tuple;
}

static PyObject*
IUploadItemMethod_get_Committed(PyIUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Committed = VARIANT_FALSE;
    PyObject* pyvar_Committed = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Committed

    // Call method on actual COM interface
    hr = self->m_pIUploadItem->get_Committed(&b_Committed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadItem.get_Committed() returned %ld", (long)hr);
        goto iuploaditem_get_committed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Committed = ((b_Committed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iuploaditem_get_committed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Committed);
    goto iuploaditem_get_committed_method_cleanup;

    iuploaditem_get_committed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Committed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadItem.get_Committed");
    return return_tuple;
}


PyMethodDef PyIUploadItemMethods[] = {
    {"supports", (PyCFunction)PyIUploadItem_SupportsInterface, METH_O, ""},
    {"put_Name", (PyCFunction)IUploadItemMethod_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IUploadItemMethod_get_Name, METH_VARARGS, ""},
    {"put_ID", (PyCFunction)IUploadItemMethod_put_ID, METH_VARARGS, ""},
    {"get_ID", (PyCFunction)IUploadItemMethod_get_ID, METH_VARARGS, ""},
    {"put_FilePath", (PyCFunction)IUploadItemMethod_put_FilePath, METH_VARARGS, ""},
    {"get_FilePath", (PyCFunction)IUploadItemMethod_get_FilePath, METH_VARARGS, ""},
    {"put_PathOnServer", (PyCFunction)IUploadItemMethod_put_PathOnServer, METH_VARARGS, ""},
    {"get_PathOnServer", (PyCFunction)IUploadItemMethod_get_PathOnServer, METH_VARARGS, ""},
    {"put_Description", (PyCFunction)IUploadItemMethod_put_Description, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)IUploadItemMethod_get_Description, METH_VARARGS, ""},
    {"put_Date", (PyCFunction)IUploadItemMethod_put_Date, METH_VARARGS, ""},
    {"get_Date", (PyCFunction)IUploadItemMethod_get_Date, METH_VARARGS, ""},
    {"put_Committed", (PyCFunction)IUploadItemMethod_put_Committed, METH_VARARGS, ""},
    {"get_Committed", (PyCFunction)IUploadItemMethod_get_Committed, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIUploadItemGetSet[] = {
  {"_pUnk", (getter)PyIUploadItem_GetpUnk, NULL, "Get opaque pointer to an Unknown from IUploadItem", NULL},
  {"_pointer", (getter)PyIUploadItem_GetPointer, NULL, "Get memory address for IUploadItem", NULL},
  {"_IID", (getter)PyIUploadItem_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIUploadItem_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIUploadItem_GetIgnoreFailures, (setter)PyIUploadItem_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIUploadItemObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IUploadItemObject",                          
                                              /* tp_name */
  sizeof(PyIUploadItemObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIUploadItemObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIUploadItemMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIUploadItemGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIUploadItemObject_new,                      
                                              /* tp_new */
};

// Interface IUploadsClient

typedef struct PyIUploadsClientObject {
    PyObject_HEAD
    IUploadsClient* m_pIUploadsClient;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIUploadsClientObject;

static PyObject*
PyIUploadsClientObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIUploadsClientObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IUploadsClient* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUploadsClient, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUploadsClient with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIUploadsClientObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IUploadsClient");
            return NULL;
        }
        self->m_pIUploadsClient = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUploadsClient");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUploadsClient");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IUploadsClient* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IUploadsClient, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IUploadsClient");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIUploadsClientObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUploadsClient");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIUploadsClient = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIUploadsClientObject_dealloc(PyIUploadsClientObject* self)
{
    if (self->m_pIUploadsClient)
        self->m_pIUploadsClient->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIUploadsClient_GetpUnk(PyIUploadsClientObject* self)
{
    if (!self->m_pIUploadsClient)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIUploadsClient->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IUploadsClient to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIUploadsClient_GetPointer(PyIUploadsClientObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIUploadsClient);
}

static PyObject*
PyIUploadsClient_GetIID(PyIUploadsClientObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "edb37aff-c199-4063-ab1f-fe936d5b5fd0");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIUploadsClient_GetHR(PyIUploadsClientObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIUploadsClient_GetIgnoreFailures(PyIUploadsClientObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIUploadsClient_SetIgnoreFailures(PyIUploadsClientObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIUploadsClient_SupportsInterface(PyIUploadsClientObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIUploadsClient->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IUploadsClientMethod_Init(PyIUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnection* ippConn = NULL;
    PyObject* py_pConn;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pConn))
      goto iuploadsclient_init_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConn, &IID_IAGSServerConnection, (void**)&ippConn))
        PyErr_SetString(PyExc_TypeError, "Argument pConn (position 0) is not IAGSServerConnection");
    
    if (PyErr_Occurred())
      goto iuploadsclient_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploadsClient->Init(ippConn);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadsClient.Init() returned %ld", (long)hr);
        goto iuploadsclient_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConn

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploadsclient_init_method_cleanup;

    iuploadsclient_init_method_cleanup:
    self->m_HR = hr;
    if (ippConn)
      ippConn->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadsClient.Init");
    return return_tuple;
}

static PyObject*
IUploadsClientMethod_put_TimeoutInSecs(PyIUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipTimeout = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ipTimeout))
      goto iuploadsclient_put_timeoutinsecs_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pTimeout

    // Call method on actual COM interface
    hr = self->m_pIUploadsClient->put_TimeoutInSecs(ipTimeout);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadsClient.put_TimeoutInSecs() returned %ld", (long)hr);
        goto iuploadsclient_put_timeoutinsecs_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTimeout

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploadsclient_put_timeoutinsecs_method_cleanup;

    iuploadsclient_put_timeoutinsecs_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTimeout
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadsClient.put_TimeoutInSecs");
    return return_tuple;
}

static PyObject*
IUploadsClientMethod_get_TimeoutInSecs(PyIUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipTimeout = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pTimeout

    // Call method on actual COM interface
    hr = self->m_pIUploadsClient->get_TimeoutInSecs(&ipTimeout);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploadsClient.get_TimeoutInSecs() returned %ld", (long)hr);
        goto iuploadsclient_get_timeoutinsecs_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTimeout

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ipTimeout);
    goto iuploadsclient_get_timeoutinsecs_method_cleanup;

    iuploadsclient_get_timeoutinsecs_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTimeout
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploadsClient.get_TimeoutInSecs");
    return return_tuple;
}


PyMethodDef PyIUploadsClientMethods[] = {
    {"supports", (PyCFunction)PyIUploadsClient_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)IUploadsClientMethod_Init, METH_VARARGS, ""},
    {"put_TimeoutInSecs", (PyCFunction)IUploadsClientMethod_put_TimeoutInSecs, METH_VARARGS, ""},
    {"get_TimeoutInSecs", (PyCFunction)IUploadsClientMethod_get_TimeoutInSecs, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIUploadsClientGetSet[] = {
  {"_pUnk", (getter)PyIUploadsClient_GetpUnk, NULL, "Get opaque pointer to an Unknown from IUploadsClient", NULL},
  {"_pointer", (getter)PyIUploadsClient_GetPointer, NULL, "Get memory address for IUploadsClient", NULL},
  {"_IID", (getter)PyIUploadsClient_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIUploadsClient_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIUploadsClient_GetIgnoreFailures, (setter)PyIUploadsClient_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIUploadsClientObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IUploadsClientObject",                          
                                              /* tp_name */
  sizeof(PyIUploadsClientObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIUploadsClientObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIUploadsClientMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIUploadsClientGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIUploadsClientObject_new,                      
                                              /* tp_new */
};

// Interface IUploader

typedef struct PyIUploaderObject {
    PyObject_HEAD
    IUploader* m_pIUploader;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIUploaderObject;

static PyObject*
PyIUploaderObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIUploaderObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IUploader* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUploader, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUploader with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIUploaderObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IUploader");
            return NULL;
        }
        self->m_pIUploader = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUploader");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUploader");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IUploader* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IUploader, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IUploader");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIUploaderObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUploader");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIUploader = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIUploaderObject_dealloc(PyIUploaderObject* self)
{
    if (self->m_pIUploader)
        self->m_pIUploader->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIUploader_GetpUnk(PyIUploaderObject* self)
{
    if (!self->m_pIUploader)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIUploader->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IUploader to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIUploader_GetPointer(PyIUploaderObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIUploader);
}

static PyObject*
PyIUploader_GetIID(PyIUploaderObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0788eaf6-42ac-404a-894e-e0330782912a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIUploader_GetHR(PyIUploaderObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIUploader_GetIgnoreFailures(PyIUploaderObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIUploader_SetIgnoreFailures(PyIUploaderObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIUploader_SupportsInterface(PyIUploaderObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIUploader->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IUploaderMethod_put_SingleUploadThresholdInBytes(PyIUploaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipThreshold = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ipThreshold))
      goto iuploader_put_singleuploadthresholdinbytes_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pThreshold

    // Call method on actual COM interface
    hr = self->m_pIUploader->put_SingleUploadThresholdInBytes(ipThreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploader.put_SingleUploadThresholdInBytes() returned %ld", (long)hr);
        goto iuploader_put_singleuploadthresholdinbytes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pThreshold

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploader_put_singleuploadthresholdinbytes_method_cleanup;

    iuploader_put_singleuploadthresholdinbytes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pThreshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploader.put_SingleUploadThresholdInBytes");
    return return_tuple;
}

static PyObject*
IUploaderMethod_get_SingleUploadThresholdInBytes(PyIUploaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipThreshold = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pThreshold

    // Call method on actual COM interface
    hr = self->m_pIUploader->get_SingleUploadThresholdInBytes(&ipThreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploader.get_SingleUploadThresholdInBytes() returned %ld", (long)hr);
        goto iuploader_get_singleuploadthresholdinbytes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pThreshold

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ipThreshold);
    goto iuploader_get_singleuploadthresholdinbytes_method_cleanup;

    iuploader_get_singleuploadthresholdinbytes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pThreshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploader.get_SingleUploadThresholdInBytes");
    return return_tuple;
}

static PyObject*
IUploaderMethod_put_TimeoutInSecs(PyIUploaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipTimeout = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ipTimeout))
      goto iuploader_put_timeoutinsecs_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pTimeout

    // Call method on actual COM interface
    hr = self->m_pIUploader->put_TimeoutInSecs(ipTimeout);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploader.put_TimeoutInSecs() returned %ld", (long)hr);
        goto iuploader_put_timeoutinsecs_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTimeout

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploader_put_timeoutinsecs_method_cleanup;

    iuploader_put_timeoutinsecs_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTimeout
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploader.put_TimeoutInSecs");
    return return_tuple;
}

static PyObject*
IUploaderMethod_get_TimeoutInSecs(PyIUploaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipTimeout = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pTimeout

    // Call method on actual COM interface
    hr = self->m_pIUploader->get_TimeoutInSecs(&ipTimeout);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploader.get_TimeoutInSecs() returned %ld", (long)hr);
        goto iuploader_get_timeoutinsecs_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTimeout

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ipTimeout);
    goto iuploader_get_timeoutinsecs_method_cleanup;

    iuploader_get_timeoutinsecs_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTimeout
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploader.get_TimeoutInSecs");
    return return_tuple;
}

static PyObject*
IUploaderMethod_get_UploadsClient(PyIUploaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUploadsClient* ipppUploadsClient = NULL;
    PyObject* py_ppUploadsClient = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppUploadsClient

    // Call method on actual COM interface
    hr = self->m_pIUploader->get_UploadsClient(&ipppUploadsClient);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploader.get_UploadsClient() returned %ld", (long)hr);
        goto iuploader_get_uploadsclient_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppUploadsClient);
    if (ipppUploadsClient)
    {
        IUnknown* pUnk = NULL;
        ipppUploadsClient->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadsClient = IUnknownToPythonIIDObject(pUnk, &IID_IUploadsClient);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadsClient)
    {
        if (py_ppUploadsClient)
           Py_DECREF(py_ppUploadsClient);
        py_ppUploadsClient = Py_None;
        Py_INCREF(py_ppUploadsClient);
    }
    if (PyErr_Occurred())
      goto iuploader_get_uploadsclient_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadsClient);
    goto iuploader_get_uploadsclient_method_cleanup;

    iuploader_get_uploadsclient_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppUploadsClient);
    if (ipppUploadsClient)
      ipppUploadsClient->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploader.get_UploadsClient");
    return return_tuple;
}

static PyObject*
IUploaderMethod_Init(PyIUploaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAGSServerConnection* ippConn = NULL;
    PyObject* py_pConn;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pConn))
      goto iuploader_init_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pConn, &IID_IAGSServerConnection, (void**)&ippConn))
        PyErr_SetString(PyExc_TypeError, "Argument pConn (position 0) is not IAGSServerConnection");
    
    if (PyErr_Occurred())
      goto iuploader_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIUploader->Init(ippConn);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUploader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUploader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUploader.Init() returned %ld", (long)hr);
        goto iuploader_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConn

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iuploader_init_method_cleanup;

    iuploader_init_method_cleanup:
    self->m_HR = hr;
    if (ippConn)
      ippConn->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUploader.Init");
    return return_tuple;
}


PyMethodDef PyIUploaderMethods[] = {
    {"supports", (PyCFunction)PyIUploader_SupportsInterface, METH_O, ""},
    {"put_SingleUploadThresholdInBytes", (PyCFunction)IUploaderMethod_put_SingleUploadThresholdInBytes, METH_VARARGS, ""},
    {"get_SingleUploadThresholdInBytes", (PyCFunction)IUploaderMethod_get_SingleUploadThresholdInBytes, METH_VARARGS, ""},
    {"put_TimeoutInSecs", (PyCFunction)IUploaderMethod_put_TimeoutInSecs, METH_VARARGS, ""},
    {"get_TimeoutInSecs", (PyCFunction)IUploaderMethod_get_TimeoutInSecs, METH_VARARGS, ""},
    {"get_UploadsClient", (PyCFunction)IUploaderMethod_get_UploadsClient, METH_VARARGS, ""},
    {"Init", (PyCFunction)IUploaderMethod_Init, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIUploaderGetSet[] = {
  {"_pUnk", (getter)PyIUploader_GetpUnk, NULL, "Get opaque pointer to an Unknown from IUploader", NULL},
  {"_pointer", (getter)PyIUploader_GetPointer, NULL, "Get memory address for IUploader", NULL},
  {"_IID", (getter)PyIUploader_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIUploader_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIUploader_GetIgnoreFailures, (setter)PyIUploader_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIUploaderObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IUploaderObject",                          
                                              /* tp_name */
  sizeof(PyIUploaderObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIUploaderObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIUploaderMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIUploaderGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIUploaderObject_new,                      
                                              /* tp_new */
};

// Interface IEnumUploadItem

typedef struct PyIEnumUploadItemObject {
    PyObject_HEAD
    IEnumUploadItem* m_pIEnumUploadItem;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIEnumUploadItemObject;

static PyObject*
PyIEnumUploadItemObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIEnumUploadItemObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IEnumUploadItem* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IEnumUploadItem, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IEnumUploadItem with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIEnumUploadItemObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumUploadItem");
            return NULL;
        }
        self->m_pIEnumUploadItem = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IEnumUploadItem");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IEnumUploadItem");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IEnumUploadItem* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IEnumUploadItem, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IEnumUploadItem");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIEnumUploadItemObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumUploadItem");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIEnumUploadItem = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIEnumUploadItemObject_dealloc(PyIEnumUploadItemObject* self)
{
    if (self->m_pIEnumUploadItem)
        self->m_pIEnumUploadItem->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIEnumUploadItem_GetpUnk(PyIEnumUploadItemObject* self)
{
    if (!self->m_pIEnumUploadItem)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIEnumUploadItem->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IEnumUploadItem to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIEnumUploadItem_GetPointer(PyIEnumUploadItemObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIEnumUploadItem);
}

static PyObject*
PyIEnumUploadItem_GetIID(PyIEnumUploadItemObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f00d29b6-e9d5-4ac2-a8c7-7c8338cf88c6");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIEnumUploadItem_GetHR(PyIEnumUploadItemObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIEnumUploadItem_GetIgnoreFailures(PyIEnumUploadItemObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIEnumUploadItem_SetIgnoreFailures(PyIEnumUploadItemObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIEnumUploadItem_SupportsInterface(PyIEnumUploadItemObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIEnumUploadItem->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IEnumUploadItemMethod_Next(PyIEnumUploadItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUploadItem* ipppUploadItemConfig = NULL;
    PyObject* py_ppUploadItemConfig = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppUploadItemConfig

    // Call method on actual COM interface
    hr = self->m_pIEnumUploadItem->Next(&ipppUploadItemConfig);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumUploadItem.Next() returned %ld", (long)hr);
        goto ienumuploaditem_next_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppUploadItemConfig);
    if (ipppUploadItemConfig)
    {
        IUnknown* pUnk = NULL;
        ipppUploadItemConfig->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadItemConfig = IUnknownToPythonIIDObject(pUnk, &IID_IUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadItemConfig)
    {
        if (py_ppUploadItemConfig)
           Py_DECREF(py_ppUploadItemConfig);
        py_ppUploadItemConfig = Py_None;
        Py_INCREF(py_ppUploadItemConfig);
    }
    if (PyErr_Occurred())
      goto ienumuploaditem_next_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadItemConfig);
    goto ienumuploaditem_next_method_cleanup;

    ienumuploaditem_next_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppUploadItemConfig);
    if (ipppUploadItemConfig)
      ipppUploadItemConfig->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumUploadItem.Next");
    return return_tuple;
}

static PyObject*
IEnumUploadItemMethod_Reset(PyIEnumUploadItemObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIEnumUploadItem->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumUploadItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumUploadItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumUploadItem.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIEnumUploadItemMethods[] = {
    {"supports", (PyCFunction)PyIEnumUploadItem_SupportsInterface, METH_O, ""},
    {"Next", (PyCFunction)IEnumUploadItemMethod_Next, METH_VARARGS, ""},
    {"Reset", (PyCFunction)IEnumUploadItemMethod_Reset, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIEnumUploadItemGetSet[] = {
  {"_pUnk", (getter)PyIEnumUploadItem_GetpUnk, NULL, "Get opaque pointer to an Unknown from IEnumUploadItem", NULL},
  {"_pointer", (getter)PyIEnumUploadItem_GetPointer, NULL, "Get memory address for IEnumUploadItem", NULL},
  {"_IID", (getter)PyIEnumUploadItem_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIEnumUploadItem_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIEnumUploadItem_GetIgnoreFailures, (setter)PyIEnumUploadItem_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIEnumUploadItemObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IEnumUploadItemObject",                          
                                              /* tp_name */
  sizeof(PyIEnumUploadItemObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIEnumUploadItemObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIEnumUploadItemMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIEnumUploadItemGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIEnumUploadItemObject_new,                      
                                              /* tp_new */
};

// Interface IAdminUploadsClient

typedef struct PyIAdminUploadsClientObject {
    PyObject_HEAD
    IAdminUploadsClient* m_pIAdminUploadsClient;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAdminUploadsClientObject;

static PyObject*
PyIAdminUploadsClientObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAdminUploadsClientObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAdminUploadsClient* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAdminUploadsClient, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAdminUploadsClient with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAdminUploadsClientObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAdminUploadsClient");
            return NULL;
        }
        self->m_pIAdminUploadsClient = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAdminUploadsClient");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAdminUploadsClient");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAdminUploadsClient* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAdminUploadsClient, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAdminUploadsClient");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAdminUploadsClientObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAdminUploadsClient");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAdminUploadsClient = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAdminUploadsClientObject_dealloc(PyIAdminUploadsClientObject* self)
{
    if (self->m_pIAdminUploadsClient)
        self->m_pIAdminUploadsClient->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAdminUploadsClient_GetpUnk(PyIAdminUploadsClientObject* self)
{
    if (!self->m_pIAdminUploadsClient)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAdminUploadsClient->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAdminUploadsClient to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAdminUploadsClient_GetPointer(PyIAdminUploadsClientObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAdminUploadsClient);
}

static PyObject*
PyIAdminUploadsClient_GetIID(PyIAdminUploadsClientObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2362ad5f-c545-4bd8-b538-557a1c5b89f1");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAdminUploadsClient_GetHR(PyIAdminUploadsClientObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAdminUploadsClient_GetIgnoreFailures(PyIAdminUploadsClientObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAdminUploadsClient_SetIgnoreFailures(PyIAdminUploadsClientObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAdminUploadsClient_SupportsInterface(PyIAdminUploadsClientObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAdminUploadsClient->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAdminUploadsClientMethod_AdminUploadFile(PyIAdminUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfile = 0;
    PyObject* pyvar_file;
    PyObject* unicodefile = NULL;
    BSTR bsDescription = 0;
    PyObject* pyvar_Description;
    PyObject* unicodeDescription = NULL;
    IUploadItem* ipppUploadedItem = NULL;
    PyObject* py_ppUploadedItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_file, &pyvar_Description))
      goto iadminuploadsclient_adminuploadfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_file))
        unicodefile = PyUnicode_FromObject(pyvar_file);
    else if (PyUnicode_Check(pyvar_file))
    {
        unicodefile = pyvar_file;
        Py_INCREF(unicodefile);
    }
    else if (pyvar_file != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter file at index 0");
    if (unicodefile)
        bsfile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefile));
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_adminuploadfile_method_cleanup;
    
    if (PyString_Check(pyvar_Description))
        unicodeDescription = PyUnicode_FromObject(pyvar_Description);
    else if (PyUnicode_Check(pyvar_Description))
    {
        unicodeDescription = pyvar_Description;
        Py_INCREF(unicodeDescription);
    }
    else if (pyvar_Description != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Description at index 1");
    if (unicodeDescription)
        bsDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDescription));
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_adminuploadfile_method_cleanup;
    
    // No setup for ppUploadedItem

    // Call method on actual COM interface
    hr = self->m_pIAdminUploadsClient->AdminUploadFile(bsfile, bsDescription, &ipppUploadedItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAdminUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAdminUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAdminUploadsClient.AdminUploadFile() returned %ld", (long)hr);
        goto iadminuploadsclient_adminuploadfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for file
    // No teardown for Description
    Py_XDECREF(py_ppUploadedItem);
    if (ipppUploadedItem)
    {
        IUnknown* pUnk = NULL;
        ipppUploadedItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadedItem = IUnknownToPythonIIDObject(pUnk, &IID_IUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadedItem)
    {
        if (py_ppUploadedItem)
           Py_DECREF(py_ppUploadedItem);
        py_ppUploadedItem = Py_None;
        Py_INCREF(py_ppUploadedItem);
    }
    if (PyErr_Occurred())
      goto iadminuploadsclient_adminuploadfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadedItem);
    goto iadminuploadsclient_adminuploadfile_method_cleanup;

    iadminuploadsclient_adminuploadfile_method_cleanup:
    self->m_HR = hr;
    if (bsfile)
        ::SysFreeString(bsfile);
    
    if (bsDescription)
        ::SysFreeString(bsDescription);
    
    Py_XDECREF(py_ppUploadedItem);
    if (ipppUploadedItem)
      ipppUploadedItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAdminUploadsClient.AdminUploadFile");
    return return_tuple;
}

static PyObject*
IAdminUploadsClientMethod_AdminRegister(PyIAdminUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsitemName = 0;
    PyObject* pyvar_itemName;
    PyObject* unicodeitemName = NULL;
    BSTR bsDescription = 0;
    PyObject* pyvar_Description;
    PyObject* unicodeDescription = NULL;
    IUploadItem* ipppUploadsItem = NULL;
    PyObject* py_ppUploadsItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_itemName, &pyvar_Description))
      goto iadminuploadsclient_adminregister_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_itemName))
        unicodeitemName = PyUnicode_FromObject(pyvar_itemName);
    else if (PyUnicode_Check(pyvar_itemName))
    {
        unicodeitemName = pyvar_itemName;
        Py_INCREF(unicodeitemName);
    }
    else if (pyvar_itemName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter itemName at index 0");
    if (unicodeitemName)
        bsitemName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeitemName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeitemName));
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_adminregister_method_cleanup;
    
    if (PyString_Check(pyvar_Description))
        unicodeDescription = PyUnicode_FromObject(pyvar_Description);
    else if (PyUnicode_Check(pyvar_Description))
    {
        unicodeDescription = pyvar_Description;
        Py_INCREF(unicodeDescription);
    }
    else if (pyvar_Description != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Description at index 1");
    if (unicodeDescription)
        bsDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDescription));
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_adminregister_method_cleanup;
    
    // No setup for ppUploadsItem

    // Call method on actual COM interface
    hr = self->m_pIAdminUploadsClient->AdminRegister(bsitemName, bsDescription, &ipppUploadsItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAdminUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAdminUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAdminUploadsClient.AdminRegister() returned %ld", (long)hr);
        goto iadminuploadsclient_adminregister_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for itemName
    // No teardown for Description
    Py_XDECREF(py_ppUploadsItem);
    if (ipppUploadsItem)
    {
        IUnknown* pUnk = NULL;
        ipppUploadsItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadsItem = IUnknownToPythonIIDObject(pUnk, &IID_IUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadsItem)
    {
        if (py_ppUploadsItem)
           Py_DECREF(py_ppUploadsItem);
        py_ppUploadsItem = Py_None;
        Py_INCREF(py_ppUploadsItem);
    }
    if (PyErr_Occurred())
      goto iadminuploadsclient_adminregister_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadsItem);
    goto iadminuploadsclient_adminregister_method_cleanup;

    iadminuploadsclient_adminregister_method_cleanup:
    self->m_HR = hr;
    if (bsitemName)
        ::SysFreeString(bsitemName);
    
    if (bsDescription)
        ::SysFreeString(bsDescription);
    
    Py_XDECREF(py_ppUploadsItem);
    if (ipppUploadsItem)
      ipppUploadsItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAdminUploadsClient.AdminRegister");
    return return_tuple;
}

static PyObject*
IAdminUploadsClientMethod_AdminUploadPart(PyIAdminUploadsClientObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'unsigned', u'__int64']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IAdminUploadsClient.AdminUploadPart not implemented.");
    return NULL;
}

static PyObject*
IAdminUploadsClientMethod_AdminGetPartNumbers(PyIAdminUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUploadItem* ippUploadItem = NULL;
    PyObject* py_pUploadItem;
    ILongArray* ipppPartNumbers = NULL;
    PyObject* py_ppPartNumbers = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pUploadItem))
      goto iadminuploadsclient_admingetpartnumbers_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pUploadItem, &IID_IUploadItem, (void**)&ippUploadItem))
        PyErr_SetString(PyExc_TypeError, "Argument pUploadItem (position 0) is not IUploadItem");
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_admingetpartnumbers_method_cleanup;
    
    // No setup for ppPartNumbers

    // Call method on actual COM interface
    hr = self->m_pIAdminUploadsClient->AdminGetPartNumbers(ippUploadItem, &ipppPartNumbers);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAdminUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAdminUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAdminUploadsClient.AdminGetPartNumbers() returned %ld", (long)hr);
        goto iadminuploadsclient_admingetpartnumbers_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUploadItem
    Py_XDECREF(py_ppPartNumbers);
    if (ipppPartNumbers)
    {
        IUnknown* pUnk = NULL;
        ipppPartNumbers->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppPartNumbers = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppPartNumbers)
    {
        if (py_ppPartNumbers)
           Py_DECREF(py_ppPartNumbers);
        py_ppPartNumbers = Py_None;
        Py_INCREF(py_ppPartNumbers);
    }
    if (PyErr_Occurred())
      goto iadminuploadsclient_admingetpartnumbers_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppPartNumbers);
    goto iadminuploadsclient_admingetpartnumbers_method_cleanup;

    iadminuploadsclient_admingetpartnumbers_method_cleanup:
    self->m_HR = hr;
    if (ippUploadItem)
      ippUploadItem->Release();
    Py_XDECREF(py_ppPartNumbers);
    if (ipppPartNumbers)
      ipppPartNumbers->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAdminUploadsClient.AdminGetPartNumbers");
    return return_tuple;
}

static PyObject*
IAdminUploadsClientMethod_AdminCommit(PyIAdminUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUploadItem* ippUploadItem = NULL;
    PyObject* py_pUploadItem;
    ILongArray* ippPartNumbers = NULL;
    PyObject* py_pPartNumbers;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pUploadItem, &py_pPartNumbers))
      goto iadminuploadsclient_admincommit_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pUploadItem, &IID_IUploadItem, (void**)&ippUploadItem))
        PyErr_SetString(PyExc_TypeError, "Argument pUploadItem (position 0) is not IUploadItem");
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_admincommit_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPartNumbers, &IID_ILongArray, (void**)&ippPartNumbers))
        PyErr_SetString(PyExc_TypeError, "Argument pPartNumbers (position 1) is not ILongArray");
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_admincommit_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAdminUploadsClient->AdminCommit(ippUploadItem, ippPartNumbers);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAdminUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAdminUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAdminUploadsClient.AdminCommit() returned %ld", (long)hr);
        goto iadminuploadsclient_admincommit_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUploadItem
    // No teardown for pPartNumbers

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iadminuploadsclient_admincommit_method_cleanup;

    iadminuploadsclient_admincommit_method_cleanup:
    self->m_HR = hr;
    if (ippUploadItem)
      ippUploadItem->Release();
    if (ippPartNumbers)
      ippPartNumbers->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAdminUploadsClient.AdminCommit");
    return return_tuple;
}

static PyObject*
IAdminUploadsClientMethod_GetUploadItems(PyIAdminUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumUploadItem* ipppUploadItems = NULL;
    PyObject* py_ppUploadItems = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppUploadItems

    // Call method on actual COM interface
    hr = self->m_pIAdminUploadsClient->GetUploadItems(&ipppUploadItems);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAdminUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAdminUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAdminUploadsClient.GetUploadItems() returned %ld", (long)hr);
        goto iadminuploadsclient_getuploaditems_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppUploadItems);
    if (ipppUploadItems)
    {
        IUnknown* pUnk = NULL;
        ipppUploadItems->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadItems = IUnknownToPythonIIDObject(pUnk, &IID_IEnumUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadItems)
    {
        if (py_ppUploadItems)
           Py_DECREF(py_ppUploadItems);
        py_ppUploadItems = Py_None;
        Py_INCREF(py_ppUploadItems);
    }
    if (PyErr_Occurred())
      goto iadminuploadsclient_getuploaditems_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadItems);
    goto iadminuploadsclient_getuploaditems_method_cleanup;

    iadminuploadsclient_getuploaditems_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppUploadItems);
    if (ipppUploadItems)
      ipppUploadItems->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAdminUploadsClient.GetUploadItems");
    return return_tuple;
}

static PyObject*
IAdminUploadsClientMethod_GetUploadItem(PyIAdminUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsItemID = 0;
    PyObject* pyvar_ItemID;
    PyObject* unicodeItemID = NULL;
    IUploadItem* ipppUploadsItem = NULL;
    PyObject* py_ppUploadsItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ItemID))
      goto iadminuploadsclient_getuploaditem_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ItemID))
        unicodeItemID = PyUnicode_FromObject(pyvar_ItemID);
    else if (PyUnicode_Check(pyvar_ItemID))
    {
        unicodeItemID = pyvar_ItemID;
        Py_INCREF(unicodeItemID);
    }
    else if (pyvar_ItemID != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ItemID at index 0");
    if (unicodeItemID)
        bsItemID = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeItemID), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeItemID));
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_getuploaditem_method_cleanup;
    
    // No setup for ppUploadsItem

    // Call method on actual COM interface
    hr = self->m_pIAdminUploadsClient->GetUploadItem(bsItemID, &ipppUploadsItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAdminUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAdminUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAdminUploadsClient.GetUploadItem() returned %ld", (long)hr);
        goto iadminuploadsclient_getuploaditem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ItemID
    Py_XDECREF(py_ppUploadsItem);
    if (ipppUploadsItem)
    {
        IUnknown* pUnk = NULL;
        ipppUploadsItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadsItem = IUnknownToPythonIIDObject(pUnk, &IID_IUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadsItem)
    {
        if (py_ppUploadsItem)
           Py_DECREF(py_ppUploadsItem);
        py_ppUploadsItem = Py_None;
        Py_INCREF(py_ppUploadsItem);
    }
    if (PyErr_Occurred())
      goto iadminuploadsclient_getuploaditem_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadsItem);
    goto iadminuploadsclient_getuploaditem_method_cleanup;

    iadminuploadsclient_getuploaditem_method_cleanup:
    self->m_HR = hr;
    if (bsItemID)
        ::SysFreeString(bsItemID);
    
    Py_XDECREF(py_ppUploadsItem);
    if (ipppUploadsItem)
      ipppUploadsItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAdminUploadsClient.GetUploadItem");
    return return_tuple;
}

static PyObject*
IAdminUploadsClientMethod_AdminDelete(PyIAdminUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUploadItem* ippUploadItem = NULL;
    PyObject* py_pUploadItem;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pUploadItem))
      goto iadminuploadsclient_admindelete_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pUploadItem, &IID_IUploadItem, (void**)&ippUploadItem))
        PyErr_SetString(PyExc_TypeError, "Argument pUploadItem (position 0) is not IUploadItem");
    
    if (PyErr_Occurred())
      goto iadminuploadsclient_admindelete_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAdminUploadsClient->AdminDelete(ippUploadItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAdminUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAdminUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAdminUploadsClient.AdminDelete() returned %ld", (long)hr);
        goto iadminuploadsclient_admindelete_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUploadItem

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iadminuploadsclient_admindelete_method_cleanup;

    iadminuploadsclient_admindelete_method_cleanup:
    self->m_HR = hr;
    if (ippUploadItem)
      ippUploadItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAdminUploadsClient.AdminDelete");
    return return_tuple;
}


PyMethodDef PyIAdminUploadsClientMethods[] = {
    {"supports", (PyCFunction)PyIAdminUploadsClient_SupportsInterface, METH_O, ""},
    {"AdminUploadFile", (PyCFunction)IAdminUploadsClientMethod_AdminUploadFile, METH_VARARGS, ""},
    {"AdminRegister", (PyCFunction)IAdminUploadsClientMethod_AdminRegister, METH_VARARGS, ""},
    {"AdminUploadPart", (PyCFunction)IAdminUploadsClientMethod_AdminUploadPart, METH_VARARGS, ""},
    {"AdminGetPartNumbers", (PyCFunction)IAdminUploadsClientMethod_AdminGetPartNumbers, METH_VARARGS, ""},
    {"AdminCommit", (PyCFunction)IAdminUploadsClientMethod_AdminCommit, METH_VARARGS, ""},
    {"GetUploadItems", (PyCFunction)IAdminUploadsClientMethod_GetUploadItems, METH_VARARGS, ""},
    {"GetUploadItem", (PyCFunction)IAdminUploadsClientMethod_GetUploadItem, METH_VARARGS, ""},
    {"AdminDelete", (PyCFunction)IAdminUploadsClientMethod_AdminDelete, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAdminUploadsClientGetSet[] = {
  {"_pUnk", (getter)PyIAdminUploadsClient_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAdminUploadsClient", NULL},
  {"_pointer", (getter)PyIAdminUploadsClient_GetPointer, NULL, "Get memory address for IAdminUploadsClient", NULL},
  {"_IID", (getter)PyIAdminUploadsClient_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAdminUploadsClient_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAdminUploadsClient_GetIgnoreFailures, (setter)PyIAdminUploadsClient_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAdminUploadsClientObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAdminUploadsClientObject",                          
                                              /* tp_name */
  sizeof(PyIAdminUploadsClientObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAdminUploadsClientObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAdminUploadsClientMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAdminUploadsClientGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAdminUploadsClientObject_new,                      
                                              /* tp_new */
};

// Interface IServiceUploadsClient

typedef struct PyIServiceUploadsClientObject {
    PyObject_HEAD
    IServiceUploadsClient* m_pIServiceUploadsClient;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIServiceUploadsClientObject;

static PyObject*
PyIServiceUploadsClientObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIServiceUploadsClientObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IServiceUploadsClient* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IServiceUploadsClient, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IServiceUploadsClient with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIServiceUploadsClientObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IServiceUploadsClient");
            return NULL;
        }
        self->m_pIServiceUploadsClient = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IServiceUploadsClient");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IServiceUploadsClient");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IServiceUploadsClient* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IServiceUploadsClient, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IServiceUploadsClient");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIServiceUploadsClientObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IServiceUploadsClient");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIServiceUploadsClient = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIServiceUploadsClientObject_dealloc(PyIServiceUploadsClientObject* self)
{
    if (self->m_pIServiceUploadsClient)
        self->m_pIServiceUploadsClient->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIServiceUploadsClient_GetpUnk(PyIServiceUploadsClientObject* self)
{
    if (!self->m_pIServiceUploadsClient)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIServiceUploadsClient->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IServiceUploadsClient to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIServiceUploadsClient_GetPointer(PyIServiceUploadsClientObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIServiceUploadsClient);
}

static PyObject*
PyIServiceUploadsClient_GetIID(PyIServiceUploadsClientObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ddcbdaac-b932-4279-a2c1-5a151632b793");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIServiceUploadsClient_GetHR(PyIServiceUploadsClientObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIServiceUploadsClient_GetIgnoreFailures(PyIServiceUploadsClientObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIServiceUploadsClient_SetIgnoreFailures(PyIServiceUploadsClientObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIServiceUploadsClient_SupportsInterface(PyIServiceUploadsClientObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIServiceUploadsClient->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IServiceUploadsClientMethod_ServiceUploadFile(PyIServiceUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfile = 0;
    PyObject* pyvar_file;
    PyObject* unicodefile = NULL;
    BSTR bsDescription = 0;
    PyObject* pyvar_Description;
    PyObject* unicodeDescription = NULL;
    IAGSServerObjectName* ippTargetService = NULL;
    PyObject* py_pTargetService;
    IUploadItem* ipppUploadedItem = NULL;
    PyObject* py_ppUploadedItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_file, &pyvar_Description, &py_pTargetService))
      goto iserviceuploadsclient_serviceuploadfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_file))
        unicodefile = PyUnicode_FromObject(pyvar_file);
    else if (PyUnicode_Check(pyvar_file))
    {
        unicodefile = pyvar_file;
        Py_INCREF(unicodefile);
    }
    else if (pyvar_file != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter file at index 0");
    if (unicodefile)
        bsfile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefile));
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_serviceuploadfile_method_cleanup;
    
    if (PyString_Check(pyvar_Description))
        unicodeDescription = PyUnicode_FromObject(pyvar_Description);
    else if (PyUnicode_Check(pyvar_Description))
    {
        unicodeDescription = pyvar_Description;
        Py_INCREF(unicodeDescription);
    }
    else if (pyvar_Description != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Description at index 1");
    if (unicodeDescription)
        bsDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDescription));
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_serviceuploadfile_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTargetService, &IID_IAGSServerObjectName, (void**)&ippTargetService))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetService (position 2) is not IAGSServerObjectName");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_serviceuploadfile_method_cleanup;
    
    // No setup for ppUploadedItem

    // Call method on actual COM interface
    hr = self->m_pIServiceUploadsClient->ServiceUploadFile(bsfile, bsDescription, ippTargetService, &ipppUploadedItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIServiceUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IServiceUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IServiceUploadsClient.ServiceUploadFile() returned %ld", (long)hr);
        goto iserviceuploadsclient_serviceuploadfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for file
    // No teardown for Description
    // No teardown for pTargetService
    Py_XDECREF(py_ppUploadedItem);
    if (ipppUploadedItem)
    {
        IUnknown* pUnk = NULL;
        ipppUploadedItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadedItem = IUnknownToPythonIIDObject(pUnk, &IID_IUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadedItem)
    {
        if (py_ppUploadedItem)
           Py_DECREF(py_ppUploadedItem);
        py_ppUploadedItem = Py_None;
        Py_INCREF(py_ppUploadedItem);
    }
    if (PyErr_Occurred())
      goto iserviceuploadsclient_serviceuploadfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadedItem);
    goto iserviceuploadsclient_serviceuploadfile_method_cleanup;

    iserviceuploadsclient_serviceuploadfile_method_cleanup:
    self->m_HR = hr;
    if (bsfile)
        ::SysFreeString(bsfile);
    
    if (bsDescription)
        ::SysFreeString(bsDescription);
    
    if (ippTargetService)
      ippTargetService->Release();
    Py_XDECREF(py_ppUploadedItem);
    if (ipppUploadedItem)
      ipppUploadedItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IServiceUploadsClient.ServiceUploadFile");
    return return_tuple;
}

static PyObject*
IServiceUploadsClientMethod_ServiceRegister(PyIServiceUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsitemName = 0;
    PyObject* pyvar_itemName;
    PyObject* unicodeitemName = NULL;
    BSTR bsDescription = 0;
    PyObject* pyvar_Description;
    PyObject* unicodeDescription = NULL;
    IAGSServerObjectName* ippTargetService = NULL;
    PyObject* py_pTargetService;
    IUploadItem* ipppUploadsItem = NULL;
    PyObject* py_ppUploadsItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_itemName, &pyvar_Description, &py_pTargetService))
      goto iserviceuploadsclient_serviceregister_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_itemName))
        unicodeitemName = PyUnicode_FromObject(pyvar_itemName);
    else if (PyUnicode_Check(pyvar_itemName))
    {
        unicodeitemName = pyvar_itemName;
        Py_INCREF(unicodeitemName);
    }
    else if (pyvar_itemName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter itemName at index 0");
    if (unicodeitemName)
        bsitemName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeitemName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeitemName));
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_serviceregister_method_cleanup;
    
    if (PyString_Check(pyvar_Description))
        unicodeDescription = PyUnicode_FromObject(pyvar_Description);
    else if (PyUnicode_Check(pyvar_Description))
    {
        unicodeDescription = pyvar_Description;
        Py_INCREF(unicodeDescription);
    }
    else if (pyvar_Description != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Description at index 1");
    if (unicodeDescription)
        bsDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDescription));
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_serviceregister_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTargetService, &IID_IAGSServerObjectName, (void**)&ippTargetService))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetService (position 2) is not IAGSServerObjectName");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_serviceregister_method_cleanup;
    
    // No setup for ppUploadsItem

    // Call method on actual COM interface
    hr = self->m_pIServiceUploadsClient->ServiceRegister(bsitemName, bsDescription, ippTargetService, &ipppUploadsItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIServiceUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IServiceUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IServiceUploadsClient.ServiceRegister() returned %ld", (long)hr);
        goto iserviceuploadsclient_serviceregister_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for itemName
    // No teardown for Description
    // No teardown for pTargetService
    Py_XDECREF(py_ppUploadsItem);
    if (ipppUploadsItem)
    {
        IUnknown* pUnk = NULL;
        ipppUploadsItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadsItem = IUnknownToPythonIIDObject(pUnk, &IID_IUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadsItem)
    {
        if (py_ppUploadsItem)
           Py_DECREF(py_ppUploadsItem);
        py_ppUploadsItem = Py_None;
        Py_INCREF(py_ppUploadsItem);
    }
    if (PyErr_Occurred())
      goto iserviceuploadsclient_serviceregister_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadsItem);
    goto iserviceuploadsclient_serviceregister_method_cleanup;

    iserviceuploadsclient_serviceregister_method_cleanup:
    self->m_HR = hr;
    if (bsitemName)
        ::SysFreeString(bsitemName);
    
    if (bsDescription)
        ::SysFreeString(bsDescription);
    
    if (ippTargetService)
      ippTargetService->Release();
    Py_XDECREF(py_ppUploadsItem);
    if (ipppUploadsItem)
      ipppUploadsItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IServiceUploadsClient.ServiceRegister");
    return return_tuple;
}

static PyObject*
IServiceUploadsClientMethod_ServiceUploadPart(PyIServiceUploadsClientObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'unsigned', u'__int64']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IServiceUploadsClient.ServiceUploadPart not implemented.");
    return NULL;
}

static PyObject*
IServiceUploadsClientMethod_ServiceGetPartNumbers(PyIServiceUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUploadItem* ippUploadItem = NULL;
    PyObject* py_pUploadItem;
    IAGSServerObjectName* ippTargetService = NULL;
    PyObject* py_pTargetService;
    ILongArray* ipppPartNumbers = NULL;
    PyObject* py_ppPartNumbers = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pUploadItem, &py_pTargetService))
      goto iserviceuploadsclient_servicegetpartnumbers_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pUploadItem, &IID_IUploadItem, (void**)&ippUploadItem))
        PyErr_SetString(PyExc_TypeError, "Argument pUploadItem (position 0) is not IUploadItem");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_servicegetpartnumbers_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTargetService, &IID_IAGSServerObjectName, (void**)&ippTargetService))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetService (position 1) is not IAGSServerObjectName");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_servicegetpartnumbers_method_cleanup;
    
    // No setup for ppPartNumbers

    // Call method on actual COM interface
    hr = self->m_pIServiceUploadsClient->ServiceGetPartNumbers(ippUploadItem, ippTargetService, &ipppPartNumbers);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIServiceUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IServiceUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IServiceUploadsClient.ServiceGetPartNumbers() returned %ld", (long)hr);
        goto iserviceuploadsclient_servicegetpartnumbers_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUploadItem
    // No teardown for pTargetService
    Py_XDECREF(py_ppPartNumbers);
    if (ipppPartNumbers)
    {
        IUnknown* pUnk = NULL;
        ipppPartNumbers->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppPartNumbers = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppPartNumbers)
    {
        if (py_ppPartNumbers)
           Py_DECREF(py_ppPartNumbers);
        py_ppPartNumbers = Py_None;
        Py_INCREF(py_ppPartNumbers);
    }
    if (PyErr_Occurred())
      goto iserviceuploadsclient_servicegetpartnumbers_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppPartNumbers);
    goto iserviceuploadsclient_servicegetpartnumbers_method_cleanup;

    iserviceuploadsclient_servicegetpartnumbers_method_cleanup:
    self->m_HR = hr;
    if (ippUploadItem)
      ippUploadItem->Release();
    if (ippTargetService)
      ippTargetService->Release();
    Py_XDECREF(py_ppPartNumbers);
    if (ipppPartNumbers)
      ipppPartNumbers->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IServiceUploadsClient.ServiceGetPartNumbers");
    return return_tuple;
}

static PyObject*
IServiceUploadsClientMethod_ServiceCommit(PyIServiceUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUploadItem* ippUploadItem = NULL;
    PyObject* py_pUploadItem;
    IAGSServerObjectName* ippTargetService = NULL;
    PyObject* py_pTargetService;
    ILongArray* ippPartNumbers = NULL;
    PyObject* py_pPartNumbers;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_pUploadItem, &py_pTargetService, &py_pPartNumbers))
      goto iserviceuploadsclient_servicecommit_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pUploadItem, &IID_IUploadItem, (void**)&ippUploadItem))
        PyErr_SetString(PyExc_TypeError, "Argument pUploadItem (position 0) is not IUploadItem");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_servicecommit_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTargetService, &IID_IAGSServerObjectName, (void**)&ippTargetService))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetService (position 1) is not IAGSServerObjectName");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_servicecommit_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPartNumbers, &IID_ILongArray, (void**)&ippPartNumbers))
        PyErr_SetString(PyExc_TypeError, "Argument pPartNumbers (position 2) is not ILongArray");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_servicecommit_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIServiceUploadsClient->ServiceCommit(ippUploadItem, ippTargetService, ippPartNumbers);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIServiceUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IServiceUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IServiceUploadsClient.ServiceCommit() returned %ld", (long)hr);
        goto iserviceuploadsclient_servicecommit_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUploadItem
    // No teardown for pTargetService
    // No teardown for pPartNumbers

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iserviceuploadsclient_servicecommit_method_cleanup;

    iserviceuploadsclient_servicecommit_method_cleanup:
    self->m_HR = hr;
    if (ippUploadItem)
      ippUploadItem->Release();
    if (ippTargetService)
      ippTargetService->Release();
    if (ippPartNumbers)
      ippPartNumbers->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IServiceUploadsClient.ServiceCommit");
    return return_tuple;
}

static PyObject*
IServiceUploadsClientMethod_ServiceDelete(PyIServiceUploadsClientObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUploadItem* ippUploadItem = NULL;
    PyObject* py_pUploadItem;
    IAGSServerObjectName* ippTargetService = NULL;
    PyObject* py_pTargetService;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pUploadItem, &py_pTargetService))
      goto iserviceuploadsclient_servicedelete_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pUploadItem, &IID_IUploadItem, (void**)&ippUploadItem))
        PyErr_SetString(PyExc_TypeError, "Argument pUploadItem (position 0) is not IUploadItem");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_servicedelete_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTargetService, &IID_IAGSServerObjectName, (void**)&ippTargetService))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetService (position 1) is not IAGSServerObjectName");
    
    if (PyErr_Occurred())
      goto iserviceuploadsclient_servicedelete_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIServiceUploadsClient->ServiceDelete(ippUploadItem, ippTargetService);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIServiceUploadsClient->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IServiceUploadsClient) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IServiceUploadsClient.ServiceDelete() returned %ld", (long)hr);
        goto iserviceuploadsclient_servicedelete_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pUploadItem
    // No teardown for pTargetService

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iserviceuploadsclient_servicedelete_method_cleanup;

    iserviceuploadsclient_servicedelete_method_cleanup:
    self->m_HR = hr;
    if (ippUploadItem)
      ippUploadItem->Release();
    if (ippTargetService)
      ippTargetService->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IServiceUploadsClient.ServiceDelete");
    return return_tuple;
}

static PyObject*
IServiceUploadsClientMethod_GetServiceMaxUploadSizeInBytes(PyIServiceUploadsClientObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       OUTPUT [u'unsigned', u'__int64', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IServiceUploadsClient.GetServiceMaxUploadSizeInBytes not implemented.");
    return NULL;
}


PyMethodDef PyIServiceUploadsClientMethods[] = {
    {"supports", (PyCFunction)PyIServiceUploadsClient_SupportsInterface, METH_O, ""},
    {"ServiceUploadFile", (PyCFunction)IServiceUploadsClientMethod_ServiceUploadFile, METH_VARARGS, ""},
    {"ServiceRegister", (PyCFunction)IServiceUploadsClientMethod_ServiceRegister, METH_VARARGS, ""},
    {"ServiceUploadPart", (PyCFunction)IServiceUploadsClientMethod_ServiceUploadPart, METH_VARARGS, ""},
    {"ServiceGetPartNumbers", (PyCFunction)IServiceUploadsClientMethod_ServiceGetPartNumbers, METH_VARARGS, ""},
    {"ServiceCommit", (PyCFunction)IServiceUploadsClientMethod_ServiceCommit, METH_VARARGS, ""},
    {"ServiceDelete", (PyCFunction)IServiceUploadsClientMethod_ServiceDelete, METH_VARARGS, ""},
    {"GetServiceMaxUploadSizeInBytes", (PyCFunction)IServiceUploadsClientMethod_GetServiceMaxUploadSizeInBytes, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIServiceUploadsClientGetSet[] = {
  {"_pUnk", (getter)PyIServiceUploadsClient_GetpUnk, NULL, "Get opaque pointer to an Unknown from IServiceUploadsClient", NULL},
  {"_pointer", (getter)PyIServiceUploadsClient_GetPointer, NULL, "Get memory address for IServiceUploadsClient", NULL},
  {"_IID", (getter)PyIServiceUploadsClient_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIServiceUploadsClient_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIServiceUploadsClient_GetIgnoreFailures, (setter)PyIServiceUploadsClient_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIServiceUploadsClientObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IServiceUploadsClientObject",                          
                                              /* tp_name */
  sizeof(PyIServiceUploadsClientObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIServiceUploadsClientObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIServiceUploadsClientMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIServiceUploadsClientGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIServiceUploadsClientObject_new,                      
                                              /* tp_new */
};

// Interface IAdminUploader

typedef struct PyIAdminUploaderObject {
    PyObject_HEAD
    IAdminUploader* m_pIAdminUploader;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAdminUploaderObject;

static PyObject*
PyIAdminUploaderObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAdminUploaderObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAdminUploader* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAdminUploader, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAdminUploader with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAdminUploaderObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAdminUploader");
            return NULL;
        }
        self->m_pIAdminUploader = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAdminUploader");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAdminUploader");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAdminUploader* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAdminUploader, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAdminUploader");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAdminUploaderObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAdminUploader");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAdminUploader = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAdminUploaderObject_dealloc(PyIAdminUploaderObject* self)
{
    if (self->m_pIAdminUploader)
        self->m_pIAdminUploader->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAdminUploader_GetpUnk(PyIAdminUploaderObject* self)
{
    if (!self->m_pIAdminUploader)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAdminUploader->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAdminUploader to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAdminUploader_GetPointer(PyIAdminUploaderObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAdminUploader);
}

static PyObject*
PyIAdminUploader_GetIID(PyIAdminUploaderObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "657e7708-500d-47ec-8e96-2327083ecdc0");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAdminUploader_GetHR(PyIAdminUploaderObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAdminUploader_GetIgnoreFailures(PyIAdminUploaderObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAdminUploader_SetIgnoreFailures(PyIAdminUploaderObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAdminUploader_SupportsInterface(PyIAdminUploaderObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAdminUploader->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAdminUploaderMethod_AdminUploadFile(PyIAdminUploaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfile = 0;
    PyObject* pyvar_file;
    PyObject* unicodefile = NULL;
    BSTR bsDescription = 0;
    PyObject* pyvar_Description;
    PyObject* unicodeDescription = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IUploadItem* ipppUploadItem = NULL;
    PyObject* py_ppUploadItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_file, &pyvar_Description, &py_pTrackCancel))
      goto iadminuploader_adminuploadfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_file))
        unicodefile = PyUnicode_FromObject(pyvar_file);
    else if (PyUnicode_Check(pyvar_file))
    {
        unicodefile = pyvar_file;
        Py_INCREF(unicodefile);
    }
    else if (pyvar_file != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter file at index 0");
    if (unicodefile)
        bsfile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefile));
    
    if (PyErr_Occurred())
      goto iadminuploader_adminuploadfile_method_cleanup;
    
    if (PyString_Check(pyvar_Description))
        unicodeDescription = PyUnicode_FromObject(pyvar_Description);
    else if (PyUnicode_Check(pyvar_Description))
    {
        unicodeDescription = pyvar_Description;
        Py_INCREF(unicodeDescription);
    }
    else if (pyvar_Description != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Description at index 1");
    if (unicodeDescription)
        bsDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDescription));
    
    if (PyErr_Occurred())
      goto iadminuploader_adminuploadfile_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iadminuploader_adminuploadfile_method_cleanup;
    
    // No setup for ppUploadItem

    // Call method on actual COM interface
    hr = self->m_pIAdminUploader->AdminUploadFile(bsfile, bsDescription, ippTrackCancel, &ipppUploadItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAdminUploader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAdminUploader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAdminUploader.AdminUploadFile() returned %ld", (long)hr);
        goto iadminuploader_adminuploadfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for file
    // No teardown for Description
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppUploadItem);
    if (ipppUploadItem)
    {
        IUnknown* pUnk = NULL;
        ipppUploadItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadItem = IUnknownToPythonIIDObject(pUnk, &IID_IUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadItem)
    {
        if (py_ppUploadItem)
           Py_DECREF(py_ppUploadItem);
        py_ppUploadItem = Py_None;
        Py_INCREF(py_ppUploadItem);
    }
    if (PyErr_Occurred())
      goto iadminuploader_adminuploadfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadItem);
    goto iadminuploader_adminuploadfile_method_cleanup;

    iadminuploader_adminuploadfile_method_cleanup:
    self->m_HR = hr;
    if (bsfile)
        ::SysFreeString(bsfile);
    
    if (bsDescription)
        ::SysFreeString(bsDescription);
    
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppUploadItem);
    if (ipppUploadItem)
      ipppUploadItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAdminUploader.AdminUploadFile");
    return return_tuple;
}


PyMethodDef PyIAdminUploaderMethods[] = {
    {"supports", (PyCFunction)PyIAdminUploader_SupportsInterface, METH_O, ""},
    {"AdminUploadFile", (PyCFunction)IAdminUploaderMethod_AdminUploadFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAdminUploaderGetSet[] = {
  {"_pUnk", (getter)PyIAdminUploader_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAdminUploader", NULL},
  {"_pointer", (getter)PyIAdminUploader_GetPointer, NULL, "Get memory address for IAdminUploader", NULL},
  {"_IID", (getter)PyIAdminUploader_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAdminUploader_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAdminUploader_GetIgnoreFailures, (setter)PyIAdminUploader_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAdminUploaderObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IAdminUploaderObject",                          
                                              /* tp_name */
  sizeof(PyIAdminUploaderObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAdminUploaderObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAdminUploaderMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAdminUploaderGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAdminUploaderObject_new,                      
                                              /* tp_new */
};

// Interface IServiceUploader

typedef struct PyIServiceUploaderObject {
    PyObject_HEAD
    IServiceUploader* m_pIServiceUploader;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIServiceUploaderObject;

static PyObject*
PyIServiceUploaderObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIServiceUploaderObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IServiceUploader* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IServiceUploader, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IServiceUploader with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIServiceUploaderObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IServiceUploader");
            return NULL;
        }
        self->m_pIServiceUploader = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IServiceUploader");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IServiceUploader");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IServiceUploader* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IServiceUploader, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IServiceUploader");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIServiceUploaderObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IServiceUploader");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIServiceUploader = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIServiceUploaderObject_dealloc(PyIServiceUploaderObject* self)
{
    if (self->m_pIServiceUploader)
        self->m_pIServiceUploader->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIServiceUploader_GetpUnk(PyIServiceUploaderObject* self)
{
    if (!self->m_pIServiceUploader)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIServiceUploader->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IServiceUploader to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIServiceUploader_GetPointer(PyIServiceUploaderObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIServiceUploader);
}

static PyObject*
PyIServiceUploader_GetIID(PyIServiceUploaderObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0fb7b5a0-f5c5-412b-aa10-8d34b2d583d9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIServiceUploader_GetHR(PyIServiceUploaderObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIServiceUploader_GetIgnoreFailures(PyIServiceUploaderObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIServiceUploader_SetIgnoreFailures(PyIServiceUploaderObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIServiceUploader_SupportsInterface(PyIServiceUploaderObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIServiceUploader->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IServiceUploaderMethod_ServiceUploadFile(PyIServiceUploaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfile = 0;
    PyObject* pyvar_file;
    PyObject* unicodefile = NULL;
    BSTR bsDescription = 0;
    PyObject* pyvar_Description;
    PyObject* unicodeDescription = NULL;
    IAGSServerObjectName* ippTargetService = NULL;
    PyObject* py_pTargetService;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IUploadItem* ipppUploadItem = NULL;
    PyObject* py_ppUploadItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_file, &pyvar_Description, &py_pTargetService, &py_pTrackCancel))
      goto iserviceuploader_serviceuploadfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_file))
        unicodefile = PyUnicode_FromObject(pyvar_file);
    else if (PyUnicode_Check(pyvar_file))
    {
        unicodefile = pyvar_file;
        Py_INCREF(unicodefile);
    }
    else if (pyvar_file != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter file at index 0");
    if (unicodefile)
        bsfile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefile));
    
    if (PyErr_Occurred())
      goto iserviceuploader_serviceuploadfile_method_cleanup;
    
    if (PyString_Check(pyvar_Description))
        unicodeDescription = PyUnicode_FromObject(pyvar_Description);
    else if (PyUnicode_Check(pyvar_Description))
    {
        unicodeDescription = pyvar_Description;
        Py_INCREF(unicodeDescription);
    }
    else if (pyvar_Description != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Description at index 1");
    if (unicodeDescription)
        bsDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDescription));
    
    if (PyErr_Occurred())
      goto iserviceuploader_serviceuploadfile_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTargetService, &IID_IAGSServerObjectName, (void**)&ippTargetService))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetService (position 2) is not IAGSServerObjectName");
    
    if (PyErr_Occurred())
      goto iserviceuploader_serviceuploadfile_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iserviceuploader_serviceuploadfile_method_cleanup;
    
    // No setup for ppUploadItem

    // Call method on actual COM interface
    hr = self->m_pIServiceUploader->ServiceUploadFile(bsfile, bsDescription, ippTargetService, ippTrackCancel, &ipppUploadItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIServiceUploader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IServiceUploader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IServiceUploader.ServiceUploadFile() returned %ld", (long)hr);
        goto iserviceuploader_serviceuploadfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for file
    // No teardown for Description
    // No teardown for pTargetService
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppUploadItem);
    if (ipppUploadItem)
    {
        IUnknown* pUnk = NULL;
        ipppUploadItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUploadItem = IUnknownToPythonIIDObject(pUnk, &IID_IUploadItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUploadItem)
    {
        if (py_ppUploadItem)
           Py_DECREF(py_ppUploadItem);
        py_ppUploadItem = Py_None;
        Py_INCREF(py_ppUploadItem);
    }
    if (PyErr_Occurred())
      goto iserviceuploader_serviceuploadfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppUploadItem);
    goto iserviceuploader_serviceuploadfile_method_cleanup;

    iserviceuploader_serviceuploadfile_method_cleanup:
    self->m_HR = hr;
    if (bsfile)
        ::SysFreeString(bsfile);
    
    if (bsDescription)
        ::SysFreeString(bsDescription);
    
    if (ippTargetService)
      ippTargetService->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppUploadItem);
    if (ipppUploadItem)
      ipppUploadItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IServiceUploader.ServiceUploadFile");
    return return_tuple;
}


PyMethodDef PyIServiceUploaderMethods[] = {
    {"supports", (PyCFunction)PyIServiceUploader_SupportsInterface, METH_O, ""},
    {"ServiceUploadFile", (PyCFunction)IServiceUploaderMethod_ServiceUploadFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIServiceUploaderGetSet[] = {
  {"_pUnk", (getter)PyIServiceUploader_GetpUnk, NULL, "Get opaque pointer to an Unknown from IServiceUploader", NULL},
  {"_pointer", (getter)PyIServiceUploader_GetPointer, NULL, "Get memory address for IServiceUploader", NULL},
  {"_IID", (getter)PyIServiceUploader_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIServiceUploader_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIServiceUploader_GetIgnoreFailures, (setter)PyIServiceUploader_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIServiceUploaderObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGISClient.IServiceUploaderObject",                          
                                              /* tp_name */
  sizeof(PyIServiceUploaderObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIServiceUploaderObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIServiceUploaderMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIServiceUploaderGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIServiceUploaderObject_new,                      
                                              /* tp_new */
};





static PyObject*
CoCreateAGSServerObjectName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AGSServerObjectName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AGSServerObjectName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("6c22971c-d450-4b4d-9422-ee96a40facc5")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "6c22971c-d450-4b4d-9422-ee96a40facc5");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAGSServerConnection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AGSServerConnection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AGSServerConnection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("b49defd0-85c0-46f4-918b-1fb7e02a8c70")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "b49defd0-85c0-46f4-918b-1fb7e02a8c70");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAGSServerConnectionName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AGSServerConnectionName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AGSServerConnectionName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("cba35c3f-edef-408f-8b51-510784c78eb9")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "cba35c3f-edef-408f-8b51-510784c78eb9");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAGSServerConnectionFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AGSServerConnectionFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AGSServerConnectionFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("7932a86e-f371-4c64-ab84-9e83dda2581b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "7932a86e-f371-4c64-ab84-9e83dda2581b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateIMSServiceName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_IMSServiceName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of IMSServiceName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("630f3de8-e213-4a5e-ac01-2bd5bcd646b6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "630f3de8-e213-4a5e-ac01-2bd5bcd646b6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateIMSWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_IMSWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of IMSWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("bac84d58-fa9d-11d3-9f48-00c04f79927c")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "bac84d58-fa9d-11d3-9f48-00c04f79927c");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateIMSCatalogPathParser(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_IMSCatalogPathParser, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of IMSCatalogPathParser");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("d6ba032f-5391-445a-a012-aba4a0ad5b4e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "d6ba032f-5391-445a-a012-aba4a0ad5b4e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateIMSMetadataServiceName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_IMSMetadataServiceName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of IMSMetadataServiceName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("d2b6fce3-3f56-478b-8125-177b3373a634")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "d2b6fce3-3f56-478b-8125-177b3373a634");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMTSConnectionName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMTSConnectionName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMTSConnectionName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("93b061bb-db92-4e90-9927-48c031b33fe8")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "93b061bb-db92-4e90-9927-48c031b33fe8");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMTSConnection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMTSConnection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMTSConnection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ebf93db1-b6f1-4dfe-94e0-a0d9f2898b83")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ebf93db1-b6f1-4dfe-94e0-a0d9f2898b83");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMTSConnectionFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMTSConnectionFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMTSConnectionFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5dc87020-5300-4b06-b6fb-915cecf9d893")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5dc87020-5300-4b06-b6fb-915cecf9d893");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMTSLayerDescription(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMTSLayerDescription, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMTSLayerDescription");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("6fe7ae5f-3097-44ce-ab5c-f35bd568a58a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "6fe7ae5f-3097-44ce-ab5c-f35bd568a58a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMTSDimension(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMTSDimension, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMTSDimension");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("56122069-7970-4f9f-9e5e-434a5942259a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "56122069-7970-4f9f-9e5e-434a5942259a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMSConnectionName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMSConnectionName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMSConnectionName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("98b0e997-f21d-4195-8e06-f9cd2ad97165")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "98b0e997-f21d-4195-8e06-f9cd2ad97165");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMSConnection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMSConnection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMSConnection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fddb9510-1619-49e9-baa5-9a6620f315ad")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fddb9510-1619-49e9-baa5-9a6620f315ad");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMSServiceExceptionHandler(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMSServiceExceptionHandler, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMSServiceExceptionHandler");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("eb412f19-fb25-44aa-8421-070edd242f3c")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "eb412f19-fb25-44aa-8421-070edd242f3c");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMSConnectionFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMSConnectionFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMSConnectionFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f7c34345-87ce-4ab5-9ca8-2012d7241075")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f7c34345-87ce-4ab5-9ca8-2012d7241075");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWCSConnectionName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WCSConnectionName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WCSConnectionName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("b96cfe9e-44c7-4616-8a2a-f1fba8642af6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "b96cfe9e-44c7-4616-8a2a-f1fba8642af6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWCSConnection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WCSConnection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WCSConnection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a9f6d7d9-f493-4eaf-b0d2-e8f6a3465667")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a9f6d7d9-f493-4eaf-b0d2-e8f6a3465667");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWCSServiceExceptionHandler(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WCSServiceExceptionHandler, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WCSServiceExceptionHandler");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("6c1b586b-6d46-4528-bae6-bf1552817c4a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "6c1b586b-6d46-4528-bae6-bf1552817c4a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWCSConnectionFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WCSConnectionFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WCSConnectionFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ed030e3a-ba11-4047-9b36-0fa11e513dcd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ed030e3a-ba11-4047-9b36-0fa11e513dcd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMTSTileMatrixSetLink(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMTSTileMatrixSetLink, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMTSTileMatrixSetLink");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2c10edfc-4429-44d1-af58-2d9034571f66")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2c10edfc-4429-44d1-af58-2d9034571f66");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMTSTileMatrix(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMTSTileMatrix, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMTSTileMatrix");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("65e7e2d0-28bb-4f81-a572-f4d7bd48bf67")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "65e7e2d0-28bb-4f81-a572-f4d7bd48bf67");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWMTSTileMatrixSet(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WMTSTileMatrixSet, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WMTSTileMatrixSet");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("120ad27e-b63c-4503-a37a-1624b715c421")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "120ad27e-b63c-4503-a37a-1624b715c421");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateUploadItem(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_UploadItem, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of UploadItem");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("912e7fc9-1f8d-490c-b7e8-3403c21545fb")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "912e7fc9-1f8d-490c-b7e8-3403c21545fb");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateUploadsClient(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_UploadsClient, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of UploadsClient");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a6dd18ca-776b-4cbb-b386-f2d5e1e4374d")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a6dd18ca-776b-4cbb-b386-f2d5e1e4374d");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateUploader(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_Uploader, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of Uploader");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("62cc7834-f2b8-4e4b-93cf-fc2d0571811f")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "62cc7834-f2b8-4e4b-93cf-fc2d0571811f");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyMethodDef _esriGISClientMethods[] = {
    {"AGSServerObjectName", (PyCFunction)CoCreateAGSServerObjectName, METH_NOARGS,
     "Create instance of AGSServerObjectName\n"},
    {"AGSServerConnection", (PyCFunction)CoCreateAGSServerConnection, METH_NOARGS,
     "Create instance of AGSServerConnection\n"},
    {"AGSServerConnectionName", (PyCFunction)CoCreateAGSServerConnectionName, METH_NOARGS,
     "Create instance of AGSServerConnectionName\n"},
    {"AGSServerConnectionFactory", (PyCFunction)CoCreateAGSServerConnectionFactory, METH_NOARGS,
     "Create instance of AGSServerConnectionFactory\n"},
    {"IMSServiceName", (PyCFunction)CoCreateIMSServiceName, METH_NOARGS,
     "Create instance of IMSServiceName\n"},
    {"IMSWorkspaceFactory", (PyCFunction)CoCreateIMSWorkspaceFactory, METH_NOARGS,
     "Create instance of IMSWorkspaceFactory\n"},
    {"IMSCatalogPathParser", (PyCFunction)CoCreateIMSCatalogPathParser, METH_NOARGS,
     "Create instance of IMSCatalogPathParser\n"},
    {"IMSMetadataServiceName", (PyCFunction)CoCreateIMSMetadataServiceName, METH_NOARGS,
     "Create instance of IMSMetadataServiceName\n"},
    {"WMTSConnectionName", (PyCFunction)CoCreateWMTSConnectionName, METH_NOARGS,
     "Create instance of WMTSConnectionName\n"},
    {"WMTSConnection", (PyCFunction)CoCreateWMTSConnection, METH_NOARGS,
     "Create instance of WMTSConnection\n"},
    {"WMTSConnectionFactory", (PyCFunction)CoCreateWMTSConnectionFactory, METH_NOARGS,
     "Create instance of WMTSConnectionFactory\n"},
    {"WMTSLayerDescription", (PyCFunction)CoCreateWMTSLayerDescription, METH_NOARGS,
     "Create instance of WMTSLayerDescription\n"},
    {"WMTSDimension", (PyCFunction)CoCreateWMTSDimension, METH_NOARGS,
     "Create instance of WMTSDimension\n"},
    {"WMSConnectionName", (PyCFunction)CoCreateWMSConnectionName, METH_NOARGS,
     "Create instance of WMSConnectionName\n"},
    {"WMSConnection", (PyCFunction)CoCreateWMSConnection, METH_NOARGS,
     "Create instance of WMSConnection\n"},
    {"WMSServiceExceptionHandler", (PyCFunction)CoCreateWMSServiceExceptionHandler, METH_NOARGS,
     "Create instance of WMSServiceExceptionHandler\n"},
    {"WMSConnectionFactory", (PyCFunction)CoCreateWMSConnectionFactory, METH_NOARGS,
     "Create instance of WMSConnectionFactory\n"},
    {"WCSConnectionName", (PyCFunction)CoCreateWCSConnectionName, METH_NOARGS,
     "Create instance of WCSConnectionName\n"},
    {"WCSConnection", (PyCFunction)CoCreateWCSConnection, METH_NOARGS,
     "Create instance of WCSConnection\n"},
    {"WCSServiceExceptionHandler", (PyCFunction)CoCreateWCSServiceExceptionHandler, METH_NOARGS,
     "Create instance of WCSServiceExceptionHandler\n"},
    {"WCSConnectionFactory", (PyCFunction)CoCreateWCSConnectionFactory, METH_NOARGS,
     "Create instance of WCSConnectionFactory\n"},
    {"WMTSTileMatrixSetLink", (PyCFunction)CoCreateWMTSTileMatrixSetLink, METH_NOARGS,
     "Create instance of WMTSTileMatrixSetLink\n"},
    {"WMTSTileMatrix", (PyCFunction)CoCreateWMTSTileMatrix, METH_NOARGS,
     "Create instance of WMTSTileMatrix\n"},
    {"WMTSTileMatrixSet", (PyCFunction)CoCreateWMTSTileMatrixSet, METH_NOARGS,
     "Create instance of WMTSTileMatrixSet\n"},
    {"UploadItem", (PyCFunction)CoCreateUploadItem, METH_NOARGS,
     "Create instance of UploadItem\n"},
    {"UploadsClient", (PyCFunction)CoCreateUploadsClient, METH_NOARGS,
     "Create instance of UploadsClient\n"},
    {"Uploader", (PyCFunction)CoCreateUploader, METH_NOARGS,
     "Create instance of Uploader\n"},
    {NULL, NULL, 0, NULL}
};

extern "C" {

    PyMODINIT_FUNC
    init_esriGISClient(void)
    {
        // Import UUID module and keep a global pointer to the UUID object
        PyObject* uuid_module = PyImport_ImportModuleNoBlock("uuid");
        if (!uuid_module)
        {
            PyErr_SetString(PyExc_ImportError, "Could not import UUID module");
            return;
        }
        if (g_pUUID_type)
            Py_DECREF(g_pUUID_type);
        g_pUUID_type = PyObject_GetAttrString(uuid_module, "UUID");

        // Initialize module, make it show up in the right place
        PyObject* module;
        module = Py_InitModule3("cartocomutils._esriGISClient",
                                 _esriGISClientMethods,
                                "Type library");
        Py_INCREF(module);

        // Add IUnknown base type to parent module so every typelib is using the same
        // Py_Type pointer when typechecking.
        PyObject* parent = PyImport_ImportModuleNoBlock("cartocomutils");
        if (parent)
        {
            if (!PyObject_HasAttrString(parent, "IUnknown"))
            {
                // Bootstrapping
                PyType_Ready(&IUnknownObject_Type);
                PyModule_AddObject(parent, "IUnknown", (PyObject*)(&IUnknownObject_Type));
                // Also probably means we need to coinitialize
                ::CoInitialize(NULL);
            }
            g_pUnk_type = PyObject_GetAttrString(parent, "IUnknown");
            if (!PyObject_HasAttrString(parent, "_IIDMap"))
                PyModule_AddObject(parent, "_IIDMap", PyDict_New());
            if (!PyObject_HasAttrString(parent, "_CLSIDMap"))
                PyModule_AddObject(parent, "_CLSIDMap", PyDict_New());
            g_pIIDMap = PyObject_GetAttrString(parent, "_IIDMap");
            Py_XINCREF(g_pIIDMap);
            // Set global unknown object
            if (g_pUnk_type && g_pIIDMap)
                PyDict_SetItem(g_pIIDMap, PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}"), g_pUnk_type);
            g_pCLSIDMap = PyObject_GetAttrString(parent, "_CLSIDMap");
            Py_XINCREF(g_pCLSIDMap);
            g_pRecordMap = PyObject_GetAttrString(parent, "_RecordMap");
            Py_XINCREF(g_pRecordMap);
            PyErr_Clear();
        }

        // Bulk add all interfaces as objects
        // IAGSServerConnectionName
        PyType_Ready(&PyIAGSServerConnectionNameObject_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnectionNameObject_Type);
        PyModule_AddObject(module, "IAGSServerConnectionName", 
                           (PyObject *)&PyIAGSServerConnectionNameObject_Type);

        // IAGSServerObjectName
        PyType_Ready(&PyIAGSServerObjectNameObject_Type);
        Py_INCREF((PyObject* )&PyIAGSServerObjectNameObject_Type);
        PyModule_AddObject(module, "IAGSServerObjectName", 
                           (PyObject *)&PyIAGSServerObjectNameObject_Type);

        // IAGSEnumServerObjectName
        PyType_Ready(&PyIAGSEnumServerObjectNameObject_Type);
        Py_INCREF((PyObject* )&PyIAGSEnumServerObjectNameObject_Type);
        PyModule_AddObject(module, "IAGSEnumServerObjectName", 
                           (PyObject *)&PyIAGSEnumServerObjectNameObject_Type);

        // IAGSServerConnection
        PyType_Ready(&PyIAGSServerConnectionObject_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnectionObject_Type);
        PyModule_AddObject(module, "IAGSServerConnection", 
                           (PyObject *)&PyIAGSServerConnectionObject_Type);

        // IAGSServerConnection2
        PyType_Ready(&PyIAGSServerConnection2Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnection2Object_Type);
        PyModule_AddObject(module, "IAGSServerConnection2", 
                           (PyObject *)&PyIAGSServerConnection2Object_Type);

        // IAGSServerConnection3
        PyType_Ready(&PyIAGSServerConnection3Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnection3Object_Type);
        PyModule_AddObject(module, "IAGSServerConnection3", 
                           (PyObject *)&PyIAGSServerConnection3Object_Type);

        // IAGSServerConnection4
        PyType_Ready(&PyIAGSServerConnection4Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnection4Object_Type);
        PyModule_AddObject(module, "IAGSServerConnection4", 
                           (PyObject *)&PyIAGSServerConnection4Object_Type);

        // IAGSServerConnectionAdmin
        PyType_Ready(&PyIAGSServerConnectionAdminObject_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnectionAdminObject_Type);
        PyModule_AddObject(module, "IAGSServerConnectionAdmin", 
                           (PyObject *)&PyIAGSServerConnectionAdminObject_Type);

        // IAGSServerConnectionName2
        PyType_Ready(&PyIAGSServerConnectionName2Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnectionName2Object_Type);
        PyModule_AddObject(module, "IAGSServerConnectionName2", 
                           (PyObject *)&PyIAGSServerConnectionName2Object_Type);

        // IAGSServerConnectionName3
        PyType_Ready(&PyIAGSServerConnectionName3Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnectionName3Object_Type);
        PyModule_AddObject(module, "IAGSServerConnectionName3", 
                           (PyObject *)&PyIAGSServerConnectionName3Object_Type);

        // IAGSServerConnectionFactory
        PyType_Ready(&PyIAGSServerConnectionFactoryObject_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnectionFactoryObject_Type);
        PyModule_AddObject(module, "IAGSServerConnectionFactory", 
                           (PyObject *)&PyIAGSServerConnectionFactoryObject_Type);

        // IAGSServerConnectionFactory2
        PyType_Ready(&PyIAGSServerConnectionFactory2Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnectionFactory2Object_Type);
        PyModule_AddObject(module, "IAGSServerConnectionFactory2", 
                           (PyObject *)&PyIAGSServerConnectionFactory2Object_Type);

        // IEnumAGSServerConnectionName
        PyType_Ready(&PyIEnumAGSServerConnectionNameObject_Type);
        Py_INCREF((PyObject* )&PyIEnumAGSServerConnectionNameObject_Type);
        PyModule_AddObject(module, "IEnumAGSServerConnectionName", 
                           (PyObject *)&PyIEnumAGSServerConnectionNameObject_Type);

        // IAGSServerConnectionFactory3
        PyType_Ready(&PyIAGSServerConnectionFactory3Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerConnectionFactory3Object_Type);
        PyModule_AddObject(module, "IAGSServerConnectionFactory3", 
                           (PyObject *)&PyIAGSServerConnectionFactory3Object_Type);

        // ISetDefaultAgsConnectionInfo
        PyType_Ready(&PyISetDefaultAgsConnectionInfoObject_Type);
        Py_INCREF((PyObject* )&PyISetDefaultAgsConnectionInfoObject_Type);
        PyModule_AddObject(module, "ISetDefaultAgsConnectionInfo", 
                           (PyObject *)&PyISetDefaultAgsConnectionInfoObject_Type);

        // IAGSServerObject2
        PyType_Ready(&PyIAGSServerObject2Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerObject2Object_Type);
        PyModule_AddObject(module, "IAGSServerObject2", 
                           (PyObject *)&PyIAGSServerObject2Object_Type);

        // IAGSServerObjectName2
        PyType_Ready(&PyIAGSServerObjectName2Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerObjectName2Object_Type);
        PyModule_AddObject(module, "IAGSServerObjectName2", 
                           (PyObject *)&PyIAGSServerObjectName2Object_Type);

        // IAGSServerObjectName3
        PyType_Ready(&PyIAGSServerObjectName3Object_Type);
        Py_INCREF((PyObject* )&PyIAGSServerObjectName3Object_Type);
        PyModule_AddObject(module, "IAGSServerObjectName3", 
                           (PyObject *)&PyIAGSServerObjectName3Object_Type);

        // IServerObjectDescription
        PyType_Ready(&PyIServerObjectDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIServerObjectDescriptionObject_Type);
        PyModule_AddObject(module, "IServerObjectDescription", 
                           (PyObject *)&PyIServerObjectDescriptionObject_Type);

        // IRESTServerObjectAdmin
        PyType_Ready(&PyIRESTServerObjectAdminObject_Type);
        Py_INCREF((PyObject* )&PyIRESTServerObjectAdminObject_Type);
        PyModule_AddObject(module, "IRESTServerObjectAdmin", 
                           (PyObject *)&PyIRESTServerObjectAdminObject_Type);

        // IIMSWorkspace2
        PyType_Ready(&PyIIMSWorkspace2Object_Type);
        Py_INCREF((PyObject* )&PyIIMSWorkspace2Object_Type);
        PyModule_AddObject(module, "IIMSWorkspace2", 
                           (PyObject *)&PyIIMSWorkspace2Object_Type);

        // IIMSWorkspace
        PyType_Ready(&PyIIMSWorkspaceObject_Type);
        Py_INCREF((PyObject* )&PyIIMSWorkspaceObject_Type);
        PyModule_AddObject(module, "IIMSWorkspace", 
                           (PyObject *)&PyIIMSWorkspaceObject_Type);

        // IIMSFeatureClass
        PyType_Ready(&PyIIMSFeatureClassObject_Type);
        Py_INCREF((PyObject* )&PyIIMSFeatureClassObject_Type);
        PyModule_AddObject(module, "IIMSFeatureClass", 
                           (PyObject *)&PyIIMSFeatureClassObject_Type);

        // IIMSServiceDescription
        PyType_Ready(&PyIIMSServiceDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIIMSServiceDescriptionObject_Type);
        PyModule_AddObject(module, "IIMSServiceDescription", 
                           (PyObject *)&PyIIMSServiceDescriptionObject_Type);

        // IIMSAxlRequest
        PyType_Ready(&PyIIMSAxlRequestObject_Type);
        Py_INCREF((PyObject* )&PyIIMSAxlRequestObject_Type);
        PyModule_AddObject(module, "IIMSAxlRequest", 
                           (PyObject *)&PyIIMSAxlRequestObject_Type);

        // IIMSUserRole
        PyType_Ready(&PyIIMSUserRoleObject_Type);
        Py_INCREF((PyObject* )&PyIIMSUserRoleObject_Type);
        PyModule_AddObject(module, "IIMSUserRole", 
                           (PyObject *)&PyIIMSUserRoleObject_Type);

        // IRemoteMetadataName
        PyType_Ready(&PyIRemoteMetadataNameObject_Type);
        Py_INCREF((PyObject* )&PyIRemoteMetadataNameObject_Type);
        PyModule_AddObject(module, "IRemoteMetadataName", 
                           (PyObject *)&PyIRemoteMetadataNameObject_Type);

        // IRemoteMetadataName2
        PyType_Ready(&PyIRemoteMetadataName2Object_Type);
        Py_INCREF((PyObject* )&PyIRemoteMetadataName2Object_Type);
        PyModule_AddObject(module, "IRemoteMetadataName2", 
                           (PyObject *)&PyIRemoteMetadataName2Object_Type);

        // IIMSMetadataAxlRequest
        PyType_Ready(&PyIIMSMetadataAxlRequestObject_Type);
        Py_INCREF((PyObject* )&PyIIMSMetadataAxlRequestObject_Type);
        PyModule_AddObject(module, "IIMSMetadataAxlRequest", 
                           (PyObject *)&PyIIMSMetadataAxlRequestObject_Type);

        // IWMSLayerStyleDescription
        PyType_Ready(&PyIWMSLayerStyleDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIWMSLayerStyleDescriptionObject_Type);
        PyModule_AddObject(module, "IWMSLayerStyleDescription", 
                           (PyObject *)&PyIWMSLayerStyleDescriptionObject_Type);

        // IWMSLayerDescription
        PyType_Ready(&PyIWMSLayerDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIWMSLayerDescriptionObject_Type);
        PyModule_AddObject(module, "IWMSLayerDescription", 
                           (PyObject *)&PyIWMSLayerDescriptionObject_Type);

        // IWCSConnectionName
        PyType_Ready(&PyIWCSConnectionNameObject_Type);
        Py_INCREF((PyObject* )&PyIWCSConnectionNameObject_Type);
        PyModule_AddObject(module, "IWCSConnectionName", 
                           (PyObject *)&PyIWCSConnectionNameObject_Type);

        // IWCSCoverageName
        PyType_Ready(&PyIWCSCoverageNameObject_Type);
        Py_INCREF((PyObject* )&PyIWCSCoverageNameObject_Type);
        PyModule_AddObject(module, "IWCSCoverageName", 
                           (PyObject *)&PyIWCSCoverageNameObject_Type);

        // IWCSBoundingBoxInfo
        PyType_Ready(&PyIWCSBoundingBoxInfoObject_Type);
        Py_INCREF((PyObject* )&PyIWCSBoundingBoxInfoObject_Type);
        PyModule_AddObject(module, "IWCSBoundingBoxInfo", 
                           (PyObject *)&PyIWCSBoundingBoxInfoObject_Type);

        // IWCSSpatialDomain
        PyType_Ready(&PyIWCSSpatialDomainObject_Type);
        Py_INCREF((PyObject* )&PyIWCSSpatialDomainObject_Type);
        PyModule_AddObject(module, "IWCSSpatialDomain", 
                           (PyObject *)&PyIWCSSpatialDomainObject_Type);

        // IWCSCoverageField
        PyType_Ready(&PyIWCSCoverageFieldObject_Type);
        Py_INCREF((PyObject* )&PyIWCSCoverageFieldObject_Type);
        PyModule_AddObject(module, "IWCSCoverageField", 
                           (PyObject *)&PyIWCSCoverageFieldObject_Type);

        // IWCSRange
        PyType_Ready(&PyIWCSRangeObject_Type);
        Py_INCREF((PyObject* )&PyIWCSRangeObject_Type);
        PyModule_AddObject(module, "IWCSRange", 
                           (PyObject *)&PyIWCSRangeObject_Type);

        // IWCSCoverageDescription
        PyType_Ready(&PyIWCSCoverageDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIWCSCoverageDescriptionObject_Type);
        PyModule_AddObject(module, "IWCSCoverageDescription", 
                           (PyObject *)&PyIWCSCoverageDescriptionObject_Type);

        // IWMTSDimension
        PyType_Ready(&PyIWMTSDimensionObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSDimensionObject_Type);
        PyModule_AddObject(module, "IWMTSDimension", 
                           (PyObject *)&PyIWMTSDimensionObject_Type);

        // IWMTSTileMatrixSetLink
        PyType_Ready(&PyIWMTSTileMatrixSetLinkObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSTileMatrixSetLinkObject_Type);
        PyModule_AddObject(module, "IWMTSTileMatrixSetLink", 
                           (PyObject *)&PyIWMTSTileMatrixSetLinkObject_Type);

        // IWMTSLayerDescription
        PyType_Ready(&PyIWMTSLayerDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSLayerDescriptionObject_Type);
        PyModule_AddObject(module, "IWMTSLayerDescription", 
                           (PyObject *)&PyIWMTSLayerDescriptionObject_Type);

        // IWMTSTileMatrix
        PyType_Ready(&PyIWMTSTileMatrixObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSTileMatrixObject_Type);
        PyModule_AddObject(module, "IWMTSTileMatrix", 
                           (PyObject *)&PyIWMTSTileMatrixObject_Type);

        // IWMTSTileMatrixSet
        PyType_Ready(&PyIWMTSTileMatrixSetObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSTileMatrixSetObject_Type);
        PyModule_AddObject(module, "IWMTSTileMatrixSet", 
                           (PyObject *)&PyIWMTSTileMatrixSetObject_Type);

        // IWMSServiceExceptionHandler
        PyType_Ready(&PyIWMSServiceExceptionHandlerObject_Type);
        Py_INCREF((PyObject* )&PyIWMSServiceExceptionHandlerObject_Type);
        PyModule_AddObject(module, "IWMSServiceExceptionHandler", 
                           (PyObject *)&PyIWMSServiceExceptionHandlerObject_Type);

        // IWMSConnectionName
        PyType_Ready(&PyIWMSConnectionNameObject_Type);
        Py_INCREF((PyObject* )&PyIWMSConnectionNameObject_Type);
        PyModule_AddObject(module, "IWMSConnectionName", 
                           (PyObject *)&PyIWMSConnectionNameObject_Type);

        // IWMSConnection
        PyType_Ready(&PyIWMSConnectionObject_Type);
        Py_INCREF((PyObject* )&PyIWMSConnectionObject_Type);
        PyModule_AddObject(module, "IWMSConnection", 
                           (PyObject *)&PyIWMSConnectionObject_Type);

        // IWMSConnectionFactory
        PyType_Ready(&PyIWMSConnectionFactoryObject_Type);
        Py_INCREF((PyObject* )&PyIWMSConnectionFactoryObject_Type);
        PyModule_AddObject(module, "IWMSConnectionFactory", 
                           (PyObject *)&PyIWMSConnectionFactoryObject_Type);

        // IWMSServiceDescription
        PyType_Ready(&PyIWMSServiceDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIWMSServiceDescriptionObject_Type);
        PyModule_AddObject(module, "IWMSServiceDescription", 
                           (PyObject *)&PyIWMSServiceDescriptionObject_Type);

        // IWMSClientEvents
        PyType_Ready(&PyIWMSClientEventsObject_Type);
        Py_INCREF((PyObject* )&PyIWMSClientEventsObject_Type);
        PyModule_AddObject(module, "IWMSClientEvents", 
                           (PyObject *)&PyIWMSClientEventsObject_Type);

        // IWCSServiceExceptionHandler
        PyType_Ready(&PyIWCSServiceExceptionHandlerObject_Type);
        Py_INCREF((PyObject* )&PyIWCSServiceExceptionHandlerObject_Type);
        PyModule_AddObject(module, "IWCSServiceExceptionHandler", 
                           (PyObject *)&PyIWCSServiceExceptionHandlerObject_Type);

        // IWCSConnection
        PyType_Ready(&PyIWCSConnectionObject_Type);
        Py_INCREF((PyObject* )&PyIWCSConnectionObject_Type);
        PyModule_AddObject(module, "IWCSConnection", 
                           (PyObject *)&PyIWCSConnectionObject_Type);

        // IWCSConnectionFactory
        PyType_Ready(&PyIWCSConnectionFactoryObject_Type);
        Py_INCREF((PyObject* )&PyIWCSConnectionFactoryObject_Type);
        PyModule_AddObject(module, "IWCSConnectionFactory", 
                           (PyObject *)&PyIWCSConnectionFactoryObject_Type);

        // IWCSServiceDescription
        PyType_Ready(&PyIWCSServiceDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIWCSServiceDescriptionObject_Type);
        PyModule_AddObject(module, "IWCSServiceDescription", 
                           (PyObject *)&PyIWCSServiceDescriptionObject_Type);

        // IWCSClientEvents
        PyType_Ready(&PyIWCSClientEventsObject_Type);
        Py_INCREF((PyObject* )&PyIWCSClientEventsObject_Type);
        PyModule_AddObject(module, "IWCSClientEvents", 
                           (PyObject *)&PyIWCSClientEventsObject_Type);

        // IWMTSConnectionName
        PyType_Ready(&PyIWMTSConnectionNameObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSConnectionNameObject_Type);
        PyModule_AddObject(module, "IWMTSConnectionName", 
                           (PyObject *)&PyIWMTSConnectionNameObject_Type);

        // IWMTSConnection
        PyType_Ready(&PyIWMTSConnectionObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSConnectionObject_Type);
        PyModule_AddObject(module, "IWMTSConnection", 
                           (PyObject *)&PyIWMTSConnectionObject_Type);

        // IWMTSConnectionFactory
        PyType_Ready(&PyIWMTSConnectionFactoryObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSConnectionFactoryObject_Type);
        PyModule_AddObject(module, "IWMTSConnectionFactory", 
                           (PyObject *)&PyIWMTSConnectionFactoryObject_Type);

        // IWMTSServiceDescription
        PyType_Ready(&PyIWMTSServiceDescriptionObject_Type);
        Py_INCREF((PyObject* )&PyIWMTSServiceDescriptionObject_Type);
        PyModule_AddObject(module, "IWMTSServiceDescription", 
                           (PyObject *)&PyIWMTSServiceDescriptionObject_Type);

        // IUploadItem
        PyType_Ready(&PyIUploadItemObject_Type);
        Py_INCREF((PyObject* )&PyIUploadItemObject_Type);
        PyModule_AddObject(module, "IUploadItem", 
                           (PyObject *)&PyIUploadItemObject_Type);

        // IUploadsClient
        PyType_Ready(&PyIUploadsClientObject_Type);
        Py_INCREF((PyObject* )&PyIUploadsClientObject_Type);
        PyModule_AddObject(module, "IUploadsClient", 
                           (PyObject *)&PyIUploadsClientObject_Type);

        // IUploader
        PyType_Ready(&PyIUploaderObject_Type);
        Py_INCREF((PyObject* )&PyIUploaderObject_Type);
        PyModule_AddObject(module, "IUploader", 
                           (PyObject *)&PyIUploaderObject_Type);

        // IEnumUploadItem
        PyType_Ready(&PyIEnumUploadItemObject_Type);
        Py_INCREF((PyObject* )&PyIEnumUploadItemObject_Type);
        PyModule_AddObject(module, "IEnumUploadItem", 
                           (PyObject *)&PyIEnumUploadItemObject_Type);

        // IAdminUploadsClient
        PyType_Ready(&PyIAdminUploadsClientObject_Type);
        Py_INCREF((PyObject* )&PyIAdminUploadsClientObject_Type);
        PyModule_AddObject(module, "IAdminUploadsClient", 
                           (PyObject *)&PyIAdminUploadsClientObject_Type);

        // IServiceUploadsClient
        PyType_Ready(&PyIServiceUploadsClientObject_Type);
        Py_INCREF((PyObject* )&PyIServiceUploadsClientObject_Type);
        PyModule_AddObject(module, "IServiceUploadsClient", 
                           (PyObject *)&PyIServiceUploadsClientObject_Type);

        // IAdminUploader
        PyType_Ready(&PyIAdminUploaderObject_Type);
        Py_INCREF((PyObject* )&PyIAdminUploaderObject_Type);
        PyModule_AddObject(module, "IAdminUploader", 
                           (PyObject *)&PyIAdminUploaderObject_Type);

        // IServiceUploader
        PyType_Ready(&PyIServiceUploaderObject_Type);
        Py_INCREF((PyObject* )&PyIServiceUploaderObject_Type);
        PyModule_AddObject(module, "IServiceUploader", 
                           (PyObject *)&PyIServiceUploaderObject_Type);


        // Bulk add all the IID_* CLSID_* from this type lib
        if (g_pUUID_type)
        {
            // guids registration for interfaces
            if (g_pIIDMap)
            {
// Disabled for now, done in the .py file
            }

            // clsids registration for known coclasses
            if (g_pCLSIDMap)
            {
// Disabled for now, done in the .py file
            }
        }
        Py_XDECREF(g_pIIDMap);
        Py_XDECREF(g_pCLSIDMap);
    }

}
