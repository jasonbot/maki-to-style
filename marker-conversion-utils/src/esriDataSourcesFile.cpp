// This source is all automatically generated. Editing it may very
// well be an exercise in futility and frustration.
#include "Python.h"
#include "datetime.h"

// imports
#import "ArcGISVersion.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids, rename("esriProductCode", "esriVersionProductCode"), rename("VersionManager", "ArcGISVersionManager")
#import "esriSystem.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("OLE_COLOR", "OLE_HANDLE", "VARTYPE")
#import "esriSystemUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeometry.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsCore.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsSymbols.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDisplay.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriServer.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriOutput.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabase.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseDistributed.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseExtensions.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabasePS.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGISClient.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesFile.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesGDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesOleDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRaster.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesNetCDF.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRasterUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriCarto.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("UINT_PTR")


// Globals we need to keep around -- a reference to the UUID class for mapping
// GUIDs to Python-usable UUIDs and the IUnknown type we'll be using across the
// board.
static PyObject* g_pUUID_type = NULL;
static PyObject* g_pUnk_type = NULL;
static PyObject* g_pIIDMap = NULL;
static PyObject* g_pCLSIDMap = NULL;
static PyObject* g_pRecordMap = NULL;

// PyObject destructor for PyCObjects that hold IUnknown* in them
static void
destr_unknown(void* pvUnk)
{
    IUnknown* pUnk = (IUnknown*)pvUnk;
    if (pUnk)
        pUnk->Release();
}

// Checker/caster to see if we can get a GUID from a Python object, either
// by  checking if the object is an instance of the uuid.UUID type, or if
// it is a string, coercing it with the constructor and seeing if it accepts
// it.
//
// def GuidFromPyObject(potentialIID, GUID*):
//     if isinstance(potentialIID, basestring):
//         try:
//             potentialIID = uuid.UUID(potentialIID)
//         except:
//             return False
//     if isinstance(potentialIID, uuid.UUID):
//         if (<copy raw bytes of UUID data in object to out GUID*>):
//             return True
//     return False
//
static bool
GuidFromPyObject(PyObject* potentialIID, GUID* pOutGUID)
{
    if (!g_pUUID_type)
        return false;

    // See if we can cast a string into a UUID instance, if that's what we've got.
    if (PyString_Check(potentialIID) || PyUnicode_Check(potentialIID))
    {
        PyObject* piid_object = PyObject_CallFunction(g_pUUID_type, "O", potentialIID);
        bool retval = (piid_object)?GuidFromPyObject(piid_object, pOutGUID): false;
        Py_XDECREF(piid_object);
        if (!piid_object || PyErr_Occurred())
        {
            PyErr_Clear();
            PyObject* unicodearg = NULL;
            if (PyString_Check(potentialIID))
                unicodearg = PyUnicode_FromObject(potentialIID);
            else if (PyUnicode_Check(potentialIID))
            {
                unicodearg = potentialIID;
                Py_INCREF(unicodearg);
            }
            if (unicodearg)
            {
                BSTR classname = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodearg),
                                                     (UINT)PyUnicode_GET_SIZE(unicodearg));
                CLSID clsid;
                if (CLSIDFromProgID(classname, &clsid) == S_OK)
                {
                    retval = true;
                    if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)&clsid, 16))
                        retval = false;
                }
                ::SysFreeString(classname);
            }
            Py_XDECREF(unicodearg);
        }
        return retval;
    }
    else if (PyObject_IsInstance(potentialIID, g_pUUID_type))
    {
        // Fetch raw bytes string -- need to fetch "bytes" on big-endian, 
        // "bytes_le" on little-endian architectures
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )        
            pBytes = PyObject_GetAttrString(potentialIID, "bytes");
        else
            pBytes = PyObject_GetAttrString(potentialIID, "bytes_le");
        if (pBytes)
        {
            bool retval = true;
            // Pointer to raw data
            char* pRawBytes = PyString_AsString(pBytes);
            if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)pRawBytes, 16))
                retval = false;
            Py_XDECREF(pBytes);
            return retval;
        }
        PyErr_Clear();
    }
    return false;
}

static PyObject*
GUIDToPythonUUID(const GUID* UUID)
{
    if (UUID)
    {
        // Lie to Python and tell it that our GUID is a 16-byte string
        PyObject* PyUUIDString = PyString_FromStringAndSize((char *)UUID, sizeof(GUID));
        if (!PyUUIDString)
            return NULL;
        // Args, varargs
        PyObject* PyArgs = PyTuple_New(0);
        PyObject* PyKWArgs = PyDict_New();
        PyObject* RetVal = NULL;
        // Dict with single value: the keyword argument bytes_le.
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )
            PyDict_SetItemString(PyKWArgs, "bytes", PyUUIDString);
        else
            PyDict_SetItemString(PyKWArgs, "bytes_le", PyUUIDString);
        // New UUID with KW
        if (g_pUUID_type)
            RetVal = PyObject_Call(g_pUUID_type, PyArgs, PyKWArgs);
        else
            PyErr_SetString(PyExc_ImportError, "UUID module import failed");

        Py_DECREF(PyUUIDString);
        Py_DECREF(PyArgs);
        Py_DECREF(PyKWArgs);
        return RetVal;
    }
    else
    {
        PyErr_SetString(PyExc_ValueError, "Bad GUID");
        return NULL;
    }
}

static PyObject*
IUnknownToPythonIIDObject(IUnknown* pUnk, const GUID* IID)
{
    PyObject* RetVal = NULL;
    pUnk->AddRef();
    PyObject* PyUnk = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    //return PyUnk;

    PyObject* pCall = NULL;

    PyObject* pGuidObject = GUIDToPythonUUID(IID);
    if (!pGuidObject || !g_pIIDMap)
        return PyUnk;

    if (PyDict_Contains(g_pIIDMap, pGuidObject) == 1)
        pCall = PyDict_GetItem(g_pIIDMap, pGuidObject);
    if (!pCall)
        pCall = g_pUnk_type;
    if (pCall)
        RetVal = PyObject_CallFunction(pCall, "O", PyUnk);

    if (!RetVal)
        RetVal = PyUnk;
    else
        Py_DECREF(PyUnk);

    Py_XDECREF(pGuidObject);
    return RetVal;
}

static PyObject*
DATE_AsPyObject(DATE in_date)
{
  PyDateTime_IMPORT;
  // Round to even number of days
  int days = (int)in_date;
  // Convert what's left (after the decimal) to seconds; 86400 seconds per day.
  int seconds = (int)((in_date - (double)days) * 86400.0);
  if (in_date < 0)
    seconds *= -1;
  // TimeDelta to add to the date representing the start of all Variant VT_DATEs
  PyObject* pDelta = PyDelta_FromDSU(days, seconds, 0);
  // Midnight 30 December 1899
  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  // Do addition of computed delta to 1899-12-30 00:00:00
  PyObject* pRetVal = PyObject_CallMethod(pStartOfVariantTime, "__add__", "O", pDelta);

  Py_XDECREF(pDelta);
  Py_XDECREF(pStartOfVariantTime);

  return pRetVal;
}

static DATE
PyObject_AsDATE(PyObject* in_date)
{
  PyDateTime_IMPORT;
  if (!PyDateTime_Check(in_date))
  {
    PyErr_SetString(PyExc_ValueError, "Cannot convert this Python object to a datetime");
    return (DATE)0.0;
  }

  double out_date;

  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  PyDateTime_Delta* pDelta = (PyDateTime_Delta *)PyObject_CallMethod(in_date, "__sub__", "O", pStartOfVariantTime);
  Py_XDECREF(pStartOfVariantTime);
  
  if (pDelta && PyDelta_Check((PyObject *)pDelta))
  {
    out_date = (double)pDelta->days;
    out_date += (double)(pDelta->seconds) / 86400.0;
  }
  
  Py_XDECREF(pDelta);
  return (DATE)out_date;
}

static bool
PyObject_AsVariant(PyObject* in_object, VARIANT* out_variant)
{
  ::VariantClear(out_variant);
  PyDateTime_IMPORT;

  if (in_object == Py_None)
    return true;
  else if (PyUnicode_Check(in_object))
  {
    out_variant->vt = VT_BSTR;
    BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(in_object), 
                                          (UINT)PyUnicode_GET_SIZE(in_object));
    out_variant->bstrVal = out_string;
    return true;
  }
  else if (PyString_Check(in_object))
  {
    PyObject* pUnicode = PyUnicode_FromObject(in_object);
    if (pUnicode)
    {
      out_variant->vt = VT_BSTR;
      BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(pUnicode), 
                                            (UINT)PyUnicode_GET_SIZE(pUnicode));
      out_variant->bstrVal = out_string;
      Py_DECREF(pUnicode);
      return true;
    }
    return false;
  }
  else if (PyFloat_Check(in_object))
  {
    out_variant->vt = VT_R8;
    out_variant->dblVal = PyFloat_AsDouble(in_object);
    return true;
  }
  else if (PyInt_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyInt_AsLong(in_object);
    return true;
  }
  else if (PyLong_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyLong_AsLongLong(in_object);
    if (PyErr_Occurred())
    {
      PyErr_Clear();
      PyObject* strval = PyObject_Str(in_object);
      if (strval)
      {
        PyObject* unival = PyUnicode_FromObject(strval);
        out_variant->vt = VT_BSTR;
        BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unival), 
                                              (UINT)PyUnicode_GET_SIZE(unival));
        out_variant->bstrVal = out_string;
        Py_DecRef(unival);
        Py_DecRef(strval);
        return true;
      }
      return false;
    }
    else
      return true;
  }
  else if (PyDateTime_Check(in_object))
  {
    out_variant->vt = VT_DATE;
    out_variant->date = PyObject_AsDATE(in_object);

    return true;
  }
  else if (PyObject_HasAttrString(in_object, "_pUnk"))
  {
    PyObject* pUnk = PyObject_GetAttrString(in_object, "_pUnk");
    if (pUnk && PyCObject_Check(pUnk))
    {
      IUnknown* pIUnknown = (IUnknown*)PyCObject_AsVoidPtr(pUnk);
      pIUnknown->AddRef();
      out_variant->vt = VT_UNKNOWN;
      out_variant->punkVal = pIUnknown;
      Py_DecRef(pUnk);
      return true;
    }
    Py_XDECREF(pUnk);
  }
  PyObject* repr = PyObject_Repr(in_object);
  PyErr_Format(PyExc_ValueError, "Can't convert %s to Variant.", repr?PyString_AsString(repr):"<Undef>", NULL);
  Py_XDECREF(repr);
  return false;
}

// Forward decl!
static PyObject* SAFEARRAYToPyObject(SAFEARRAY*, VARTYPE);

static PyObject*
Variant_AsPyObject(VARIANT* in_variant)
{
  if (in_variant->vt == VT_EMPTY)
    Py_RETURN_NONE;
  else if (in_variant->vt  == (VT_BYREF|VT_I1))
    return PyInt_FromLong(*(in_variant->pcVal)); //CHAR                *
  else if (in_variant->vt == (VT_BYREF|VT_UI2))
    return PyInt_FromLong(*(in_variant->puiVal)); //USHORT              *
  else if (in_variant->vt == (VT_BYREF|VT_UI4))
    return PyInt_FromLong(*(in_variant->pulVal)); //ULONG               *
  else if (in_variant->vt == (VT_BYREF|VT_UI8))
    return PyLong_FromUnsignedLongLong(*(in_variant->pullVal)); //ULONGLONG           *
  else if (in_variant->vt == (VT_BYREF|VT_INT))
    return PyInt_FromLong(*(in_variant->pintVal)); //INT                 *
  else if (in_variant->vt == (VT_BYREF|VT_UINT))
    return PyInt_FromLong(*(in_variant->puintVal)); //UINT                *
  else if (in_variant->vt == (VT_BYREF|VT_UI1))
    return PyInt_FromLong(*(in_variant->pbVal)); //BYTE                *
  else if (in_variant->vt == (VT_BYREF|VT_I2))
    return PyInt_FromLong(*(in_variant->piVal)); //SHORT               *
  else if (in_variant->vt == (VT_BYREF|VT_I4))
    return PyInt_FromLong(*(in_variant->plVal)); //LONG                *
  else if (in_variant->vt == (VT_BYREF|VT_I8))
    return PyLong_FromLongLong(*(in_variant->pllVal)); //LONGLONG            *
  else if (in_variant->vt == (VT_BYREF|VT_R4))
    return PyFloat_FromDouble((double)*(in_variant->pfltVal)); //FLOAT               *
  else if (in_variant->vt == (VT_BYREF|VT_R8))
    return PyFloat_FromDouble((double)*(in_variant->pdblVal)); //DOUBLE              *
  else if (in_variant->vt == (VT_BYREF|VT_BOOL))
    if ((*(in_variant->pboolVal)) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;
  else if (in_variant->vt == (VT_BYREF|VT_BSTR))
    return PyUnicode_FromWideChar(*(in_variant->pbstrVal),::SysStringLen(*(in_variant->pbstrVal)));  //BSTR                *
  else if (in_variant->vt == (VT_BYREF|VT_UNKNOWN))
  {
    IUnknown* pUnk = *(in_variant->ppunkVal);
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_DISPATCH))
  {
    IDispatch* pDisp = *(in_variant->ppdispVal);
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_VARIANT))
    return Variant_AsPyObject(in_variant->pvarVal); //VARIANT             *
  else if (in_variant->vt  == VT_I8)
    return PyLong_FromLongLong(in_variant->llVal); //LONGLONG           
  else if (in_variant->vt == VT_I4)
    return PyInt_FromLong(in_variant->lVal); //LONG               
  else if (in_variant->vt == VT_UI1)
    return PyInt_FromLong((unsigned)in_variant->bVal); //BYTE               
  else if (in_variant->vt == VT_I2)
    return PyInt_FromLong(in_variant->iVal); //SHORT              
  else if (in_variant->vt == VT_R4)
    return PyFloat_FromDouble((double)(in_variant->fltVal)); //FLOAT              
  else if (in_variant->vt == VT_R8)
    return PyFloat_FromDouble((double)(in_variant->dblVal)); //DOUBLE             
  else if (in_variant->vt == VT_BOOL)
    if ((in_variant->boolVal) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;              
  else if (in_variant->vt == VT_BSTR)
    return PyUnicode_FromWideChar(in_variant->bstrVal, ::SysStringLen(in_variant->bstrVal)); //BSTR               
  else if (in_variant->vt == VT_UNKNOWN)
  {
    IUnknown* pUnk = in_variant->punkVal;
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_DISPATCH)
  {
    IDispatch* pDisp = in_variant->pdispVal;
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_I1)
    return PyInt_FromLong(in_variant->cVal); //CHAR               
  else if (in_variant->vt == VT_UI2)
    return PyInt_FromLong(in_variant->uiVal); //USHORT             
  else if (in_variant->vt == VT_UI4)
    return PyInt_FromLong(in_variant->ulVal); //ULONG              
  else if (in_variant->vt == VT_UI8)
    return PyLong_FromUnsignedLongLong(in_variant->ullVal); //ULONGLONG          
  else if (in_variant->vt == VT_INT)
    return PyInt_FromLong(in_variant->intVal); //INT                
  else if (in_variant->vt == VT_UINT)
    return PyInt_FromLong(in_variant->uintVal); //UINT               
  else if ((in_variant->vt & VT_DATE) == VT_DATE)
  {
    DATE in_date = (in_variant->vt & VT_BYREF)?(*(in_variant->pdate)):in_variant->date;
    return DATE_AsPyObject(in_date);
  }
  else if (in_variant->vt & VT_ARRAY)
  {
    return SAFEARRAYToPyObject((in_variant->vt & VT_BYREF) ? 
                                        *(in_variant->pparray) : 
                                        in_variant->parray,
                                (in_variant->vt));
  }

  PyErr_SetString(PyExc_ValueError, "Cannot convert this variant to a Python object");
  return NULL;
}

static PyObject*
SAFEARRAYToPyObject(SAFEARRAY* pArray, VARTYPE vt)
{
  if (!pArray)
    Py_RETURN_NONE;
  PyObject* return_array(NULL);
  long entry_count(1);
  for (ssize_t dimension(0); dimension < pArray->cDims; ++dimension)
    entry_count *= (pArray->rgsabound[dimension]).cElements;
  if (pArray->fFeatures & FADF_BSTR)
  {
    return_array = PyList_New(0);
    BSTR* barray = (BSTR*)pArray->pvData;
    for (long string_index = 0; string_index < entry_count; ++string_index)
    {
      PyObject* new_string = PyUnicode_FromWideChar(barray[string_index], ::SysStringLen(barray[string_index]));
      PyList_Append(return_array, new_string);
      Py_DECREF(new_string);
    }
  }
  else if (pArray->fFeatures & FADF_VARIANT)
  {
    return_array = PyList_New(0);
    VARIANT* varray = (VARIANT*)pArray->pvData;
    for (long variant_index(0); variant_index < entry_count; ++variant_index)
    {
      PyObject* new_variant = Variant_AsPyObject(&varray[variant_index]);
      if (new_variant)
      {
        PyList_Append(return_array, new_variant);
        Py_DECREF(new_variant);
      }
      else
      {
        PyErr_Clear();
        PyList_Append(return_array, Py_None);
      }
    }
  }
  else if (pArray->fFeatures & FADF_UNKNOWN)
  {
    return_array = PyList_New(0);
    IUnknown** oarray = (IUnknown**)pArray->pvData;
    for (long object_index(0); object_index < entry_count; ++object_index)
    {
      PyObject* new_object = IUnknownToPythonIIDObject(oarray[object_index], &IID_IUnknown);
      PyList_Append(return_array, new_object);
      Py_DECREF(new_object);
    }
  }
  else if (vt == (VT_UI1 | VT_ARRAY))
  {
    return_array = PyByteArray_FromStringAndSize((char*)(pArray->pvData), entry_count);
  }

  if (!return_array)
  {
    if (PyErr_WarnEx(PyExc_Warning, "conversion for this error type not implemented", -1) != 0)
      return 0;

    return_array = Py_BuildValue("(HHNK)", (unsigned short)vt,
                                           (unsigned short)pArray->fFeatures,
                                           PyByteArray_FromStringAndSize((char*)(pArray->pvData), 
                                                                         sizeof(pArray->pvData)),
                                           (unsigned long long)pArray->pvData);
  }
  return return_array;
}

// Attempt to get an interface pointer from a Python object
static bool
IFaceFromPyObject(PyObject* pIn, const GUID* pOutGuid, void** pOutIFace)
{
    IUnknown* pUnk = NULL;

    if (pIn == Py_None)
    {
        *pOutIFace = NULL;
        return true;
    }
    else if (PyCObject_Check(pIn))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(pIn);
    }
    else
    {
        bool need_decref(false);
        if (PyObject_HasAttrString(pIn, "_arc_object"))
        {
          pIn = PyObject_GetAttrString(pIn, "_arc_object");
          if (pIn)
            need_decref = true;
        }
        PyObject* pObject = PyObject_GetAttrString(pIn, "_pUnk");
        if (!pObject)
            return false;
        if (!PyCObject_Check(pObject))
            return false;
        else
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(pObject);
        if (need_decref)
            Py_DECREF(pIn);
        Py_XDECREF(pObject);
    }
    if (pUnk && SUCCEEDED(pUnk->QueryInterface(*pOutGuid, pOutIFace)))
        return true;

    return false;
}



// Every module implements this IUnknown thing but only one reference to the 
// _Type struct will be used between them, so type checking will still work.
// This has the happy side effect of letting us pick and choose which of the
// OLBs that are offered as wrappers (and just plain remove them) without 
// needing to worry about it. Whichever of the C modules in the suite that gets
// imported first is fully capable and will do its best to bootstrap the system.

typedef struct IUnknownObject {
    PyObject_HEAD
    IUnknown* m_pUnk;
} IUnknownObject;

static PyObject*
IUnknownObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    IUnknownObject* self;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {        
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUnknown with provided CLSID");
            return NULL;
        }
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        pUnk->AddRef();
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUnknown");
            return NULL;
        }
        if (!PyCObject_Check(argument))
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUnknown");
            return NULL;
        }
        else
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
            pUnk->AddRef();
        }
        if (argument)
            Py_DECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    if (!(self = ((IUnknownObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUnknown");
        return NULL;
    }

    self->m_pUnk = pUnk;
    return (PyObject *)self;
}

static void
IUnknownObject_dealloc(IUnknownObject* self)
{
    if (self->m_pUnk)
        self->m_pUnk->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
IUnknown_GetpUnk(IUnknownObject* self)
{
    if (!self->m_pUnk)
        Py_RETURN_NONE;
    self->m_pUnk->AddRef();
    return PyCObject_FromVoidPtr((void*)self->m_pUnk, destr_unknown);
}

static PyObject*
IUnknown_GetPointer(IUnknownObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pUnk);
}

static PyObject*
IUnknown_GetIID(IUnknownObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
IUnknown_SupportsInterface(IUnknownObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pUnk->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}

PyMethodDef IUnknownMethods[] = {
    {"supports", (PyCFunction)IUnknown_SupportsInterface, METH_O, ""},
};

PyGetSetDef IUnknownGetSet[] = {
  {"_IID", (getter)IUnknown_GetIID, NULL, "Get IID for Unknown", NULL},
  {"_pUnk", (getter)IUnknown_GetpUnk, NULL, "Get opaque pointer to Unknown", NULL},
  {"_pointer", (getter)IUnknown_GetPointer, NULL, "Get long pointer to Unknown", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject IUnknownObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "cartocomutils.IUnknown",
                                              /* tp_name */
  sizeof(IUnknownObject),                     /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)IUnknownObject_dealloc,         /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "IUnknown",                                 /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  IUnknownMethods,                            /* tp_methods */
  0,                                          /* tp_members */
  IUnknownGetSet,                             /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  IUnknownObject_new,                         /* tp_new */
};




// Interface IArcInfoItem

typedef struct PyIArcInfoItemObject {
    PyObject_HEAD
    IArcInfoItem* m_pIArcInfoItem;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcInfoItemObject;

static PyObject*
PyIArcInfoItemObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcInfoItemObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcInfoItem* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcInfoItem, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcInfoItem with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcInfoItemObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoItem");
            return NULL;
        }
        self->m_pIArcInfoItem = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcInfoItem");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcInfoItem");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcInfoItem* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcInfoItem, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcInfoItem");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcInfoItemObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoItem");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcInfoItem = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcInfoItemObject_dealloc(PyIArcInfoItemObject* self)
{
    if (self->m_pIArcInfoItem)
        self->m_pIArcInfoItem->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcInfoItem_GetpUnk(PyIArcInfoItemObject* self)
{
    if (!self->m_pIArcInfoItem)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcInfoItem->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcInfoItem to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcInfoItem_GetPointer(PyIArcInfoItemObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcInfoItem);
}

static PyObject*
PyIArcInfoItem_GetIID(PyIArcInfoItemObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b5e470d2-ceab-11d2-b0dc-0000f8780820");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcInfoItem_GetHR(PyIArcInfoItemObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcInfoItem_GetIgnoreFailures(PyIArcInfoItemObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcInfoItem_SetIgnoreFailures(PyIArcInfoItemObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcInfoItem_SupportsInterface(PyIArcInfoItemObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcInfoItemMethod_get_StartPosition(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lStartPosition = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for StartPosition

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_StartPosition(&lStartPosition);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_StartPosition() returned %ld", (long)hr);
        goto iarcinfoitem_get_startposition_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for StartPosition

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lStartPosition);
    goto iarcinfoitem_get_startposition_method_cleanup;

    iarcinfoitem_get_startposition_method_cleanup:
    self->m_HR = hr;
    // No cleanup for StartPosition
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_StartPosition");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_Name(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_Name() returned %ld", (long)hr);
        goto iarcinfoitem_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iarcinfoitem_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iarcinfoitem_get_name_method_cleanup;

    iarcinfoitem_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_Name");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_Width(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_Width(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_Width() returned %ld", (long)hr);
        goto iarcinfoitem_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto iarcinfoitem_get_width_method_cleanup;

    iarcinfoitem_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_Width");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_OutputWidth(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lOutputWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for OutputWidth

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_OutputWidth(&lOutputWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_OutputWidth() returned %ld", (long)hr);
        goto iarcinfoitem_get_outputwidth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OutputWidth

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lOutputWidth);
    goto iarcinfoitem_get_outputwidth_method_cleanup;

    iarcinfoitem_get_outputwidth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OutputWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_OutputWidth");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_Type(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriArcInfoItemType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_Type(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_Type() returned %ld", (long)hr);
        goto iarcinfoitem_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto iarcinfoitem_get_type_method_cleanup;

    iarcinfoitem_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_Type");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_NumberDecimals(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lNumberDecimals = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for NumberDecimals

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_NumberDecimals(&lNumberDecimals);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_NumberDecimals() returned %ld", (long)hr);
        goto iarcinfoitem_get_numberdecimals_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for NumberDecimals

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumberDecimals);
    goto iarcinfoitem_get_numberdecimals_method_cleanup;

    iarcinfoitem_get_numberdecimals_method_cleanup:
    self->m_HR = hr;
    // No cleanup for NumberDecimals
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_NumberDecimals");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_AlternateName(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAlternateName;
    PyObject* pyvar_AlternateName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for AlternateName

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_AlternateName(&bsAlternateName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_AlternateName() returned %ld", (long)hr);
        goto iarcinfoitem_get_alternatename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_AlternateName = PyUnicode_FromWideChar(bsAlternateName,::SysStringLen(bsAlternateName));
    ::SysFreeString(bsAlternateName);
    
    if (PyErr_Occurred())
      goto iarcinfoitem_get_alternatename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_AlternateName);
    goto iarcinfoitem_get_alternatename_method_cleanup;

    iarcinfoitem_get_alternatename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_AlternateName != Py_None)
        Py_XDECREF(pyvar_AlternateName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_AlternateName");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_IsRedefined(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsRedefined = VARIANT_FALSE;
    PyObject* pyvar_IsRedefined = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsRedefined

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_IsRedefined(&b_IsRedefined);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_IsRedefined() returned %ld", (long)hr);
        goto iarcinfoitem_get_isredefined_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsRedefined = ((b_IsRedefined == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iarcinfoitem_get_isredefined_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsRedefined);
    goto iarcinfoitem_get_isredefined_method_cleanup;

    iarcinfoitem_get_isredefined_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsRedefined
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_IsRedefined");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_IsPseudo(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsPseudo = VARIANT_FALSE;
    PyObject* pyvar_IsPseudo = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsPseudo

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_IsPseudo(&b_IsPseudo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_IsPseudo() returned %ld", (long)hr);
        goto iarcinfoitem_get_ispseudo_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsPseudo = ((b_IsPseudo == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iarcinfoitem_get_ispseudo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsPseudo);
    goto iarcinfoitem_get_ispseudo_method_cleanup;

    iarcinfoitem_get_ispseudo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsPseudo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_IsPseudo");
    return return_tuple;
}

static PyObject*
IArcInfoItemMethod_get_IsIndexed(PyIArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsIndexed = VARIANT_FALSE;
    PyObject* pyvar_IsIndexed = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsIndexed

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItem->get_IsIndexed(&b_IsIndexed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItem.get_IsIndexed() returned %ld", (long)hr);
        goto iarcinfoitem_get_isindexed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsIndexed = ((b_IsIndexed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iarcinfoitem_get_isindexed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsIndexed);
    goto iarcinfoitem_get_isindexed_method_cleanup;

    iarcinfoitem_get_isindexed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsIndexed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItem.get_IsIndexed");
    return return_tuple;
}


PyMethodDef PyIArcInfoItemMethods[] = {
    {"supports", (PyCFunction)PyIArcInfoItem_SupportsInterface, METH_O, ""},
    {"get_StartPosition", (PyCFunction)IArcInfoItemMethod_get_StartPosition, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IArcInfoItemMethod_get_Name, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IArcInfoItemMethod_get_Width, METH_VARARGS, ""},
    {"get_OutputWidth", (PyCFunction)IArcInfoItemMethod_get_OutputWidth, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IArcInfoItemMethod_get_Type, METH_VARARGS, ""},
    {"get_NumberDecimals", (PyCFunction)IArcInfoItemMethod_get_NumberDecimals, METH_VARARGS, ""},
    {"get_AlternateName", (PyCFunction)IArcInfoItemMethod_get_AlternateName, METH_VARARGS, ""},
    {"get_IsRedefined", (PyCFunction)IArcInfoItemMethod_get_IsRedefined, METH_VARARGS, ""},
    {"get_IsPseudo", (PyCFunction)IArcInfoItemMethod_get_IsPseudo, METH_VARARGS, ""},
    {"get_IsIndexed", (PyCFunction)IArcInfoItemMethod_get_IsIndexed, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcInfoItemGetSet[] = {
  {"_pUnk", (getter)PyIArcInfoItem_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcInfoItem", NULL},
  {"_pointer", (getter)PyIArcInfoItem_GetPointer, NULL, "Get memory address for IArcInfoItem", NULL},
  {"_IID", (getter)PyIArcInfoItem_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcInfoItem_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcInfoItem_GetIgnoreFailures, (setter)PyIArcInfoItem_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcInfoItemObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IArcInfoItemObject",                          
                                              /* tp_name */
  sizeof(PyIArcInfoItemObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcInfoItemObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcInfoItemMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcInfoItemGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcInfoItemObject_new,                      
                                              /* tp_new */
};

// Interface IArcInfoItemEdit

typedef struct PyIArcInfoItemEditObject {
    PyObject_HEAD
    IArcInfoItemEdit* m_pIArcInfoItemEdit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcInfoItemEditObject;

static PyObject*
PyIArcInfoItemEditObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcInfoItemEditObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcInfoItemEdit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcInfoItemEdit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcInfoItemEdit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcInfoItemEditObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoItemEdit");
            return NULL;
        }
        self->m_pIArcInfoItemEdit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcInfoItemEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcInfoItemEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcInfoItemEdit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcInfoItemEdit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcInfoItemEdit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcInfoItemEditObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoItemEdit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcInfoItemEdit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcInfoItemEditObject_dealloc(PyIArcInfoItemEditObject* self)
{
    if (self->m_pIArcInfoItemEdit)
        self->m_pIArcInfoItemEdit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcInfoItemEdit_GetpUnk(PyIArcInfoItemEditObject* self)
{
    if (!self->m_pIArcInfoItemEdit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcInfoItemEdit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcInfoItemEdit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcInfoItemEdit_GetPointer(PyIArcInfoItemEditObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcInfoItemEdit);
}

static PyObject*
PyIArcInfoItemEdit_GetIID(PyIArcInfoItemEditObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b5e470d3-ceab-11d2-b0dc-0000f8780820");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcInfoItemEdit_GetHR(PyIArcInfoItemEditObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcInfoItemEdit_GetIgnoreFailures(PyIArcInfoItemEditObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcInfoItemEdit_SetIgnoreFailures(PyIArcInfoItemEditObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcInfoItemEdit_SupportsInterface(PyIArcInfoItemEditObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcInfoItemEditMethod_put_StartPosition(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto iarcinfoitemedit_put_startposition_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_StartPosition(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_StartPosition() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_startposition_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_startposition_method_cleanup;

    iarcinfoitemedit_put_startposition_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_StartPosition");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_Name(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bs_arg1 = 0;
    PyObject* pyvar__arg1;
    PyObject* unicode_arg1 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar__arg1))
      goto iarcinfoitemedit_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar__arg1))
        unicode_arg1 = PyUnicode_FromObject(pyvar__arg1);
    else if (PyUnicode_Check(pyvar__arg1))
    {
        unicode_arg1 = pyvar__arg1;
        Py_INCREF(unicode_arg1);
    }
    else if (pyvar__arg1 != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter _arg1 at index 0");
    if (unicode_arg1)
        bs_arg1 = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicode_arg1), 
                                            (UINT)PyUnicode_GET_SIZE(unicode_arg1));
    
    if (PyErr_Occurred())
      goto iarcinfoitemedit_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_Name(bs_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_Name() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_name_method_cleanup;

    iarcinfoitemedit_put_name_method_cleanup:
    self->m_HR = hr;
    if (bs_arg1)
        ::SysFreeString(bs_arg1);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_Name");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_Width(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto iarcinfoitemedit_put_width_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_Width(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_Width() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_width_method_cleanup;

    iarcinfoitemedit_put_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_Width");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_OutputWidth(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto iarcinfoitemedit_put_outputwidth_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_OutputWidth(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_OutputWidth() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_outputwidth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_outputwidth_method_cleanup;

    iarcinfoitemedit_put_outputwidth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_OutputWidth");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_Type(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriArcInfoItemType e_arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&e_arg1))
      goto iarcinfoitemedit_put_type_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_Type(e_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_Type() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_type_method_cleanup;

    iarcinfoitemedit_put_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_Type");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_NumberDecimals(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto iarcinfoitemedit_put_numberdecimals_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_NumberDecimals(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_NumberDecimals() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_numberdecimals_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_numberdecimals_method_cleanup;

    iarcinfoitemedit_put_numberdecimals_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_NumberDecimals");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_AlternateName(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bs_arg1 = 0;
    PyObject* pyvar__arg1;
    PyObject* unicode_arg1 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar__arg1))
      goto iarcinfoitemedit_put_alternatename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar__arg1))
        unicode_arg1 = PyUnicode_FromObject(pyvar__arg1);
    else if (PyUnicode_Check(pyvar__arg1))
    {
        unicode_arg1 = pyvar__arg1;
        Py_INCREF(unicode_arg1);
    }
    else if (pyvar__arg1 != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter _arg1 at index 0");
    if (unicode_arg1)
        bs_arg1 = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicode_arg1), 
                                            (UINT)PyUnicode_GET_SIZE(unicode_arg1));
    
    if (PyErr_Occurred())
      goto iarcinfoitemedit_put_alternatename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_AlternateName(bs_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_AlternateName() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_alternatename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_alternatename_method_cleanup;

    iarcinfoitemedit_put_alternatename_method_cleanup:
    self->m_HR = hr;
    if (bs_arg1)
        ::SysFreeString(bs_arg1);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_AlternateName");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_IsRedefined(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b__arg1 = VARIANT_FALSE;
    PyObject* pyvar__arg1 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar__arg1))
      goto iarcinfoitemedit_put_isredefined_method_cleanup;

    // Set up initial variable values as needed
    b__arg1 = ((PyObject_IsTrue(pyvar__arg1) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iarcinfoitemedit_put_isredefined_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_IsRedefined(b__arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_IsRedefined() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_isredefined_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_isredefined_method_cleanup;

    iarcinfoitemedit_put_isredefined_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_IsRedefined");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_IsPseudo(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b__arg1 = VARIANT_FALSE;
    PyObject* pyvar__arg1 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar__arg1))
      goto iarcinfoitemedit_put_ispseudo_method_cleanup;

    // Set up initial variable values as needed
    b__arg1 = ((PyObject_IsTrue(pyvar__arg1) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iarcinfoitemedit_put_ispseudo_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_IsPseudo(b__arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_IsPseudo() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_ispseudo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_ispseudo_method_cleanup;

    iarcinfoitemedit_put_ispseudo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_IsPseudo");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_put_IsIndexed(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b__arg1 = VARIANT_FALSE;
    PyObject* pyvar__arg1 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar__arg1))
      goto iarcinfoitemedit_put_isindexed_method_cleanup;

    // Set up initial variable values as needed
    b__arg1 = ((PyObject_IsTrue(pyvar__arg1) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iarcinfoitemedit_put_isindexed_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->put_IsIndexed(b__arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.put_IsIndexed() returned %ld", (long)hr);
        goto iarcinfoitemedit_put_isindexed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemedit_put_isindexed_method_cleanup;

    iarcinfoitemedit_put_isindexed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.put_IsIndexed");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_StartPosition(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lStartPosition = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for StartPosition

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_StartPosition(&lStartPosition);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_StartPosition() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_startposition_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for StartPosition

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lStartPosition);
    goto iarcinfoitemedit_get_startposition_method_cleanup;

    iarcinfoitemedit_get_startposition_method_cleanup:
    self->m_HR = hr;
    // No cleanup for StartPosition
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_StartPosition");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_Name(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_Name() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iarcinfoitemedit_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iarcinfoitemedit_get_name_method_cleanup;

    iarcinfoitemedit_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_Name");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_Width(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_Width(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_Width() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto iarcinfoitemedit_get_width_method_cleanup;

    iarcinfoitemedit_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_Width");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_OutputWidth(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lOutputWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for OutputWidth

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_OutputWidth(&lOutputWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_OutputWidth() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_outputwidth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OutputWidth

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lOutputWidth);
    goto iarcinfoitemedit_get_outputwidth_method_cleanup;

    iarcinfoitemedit_get_outputwidth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OutputWidth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_OutputWidth");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_Type(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriArcInfoItemType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_Type(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_Type() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto iarcinfoitemedit_get_type_method_cleanup;

    iarcinfoitemedit_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_Type");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_NumberDecimals(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lNumberDecimals = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for NumberDecimals

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_NumberDecimals(&lNumberDecimals);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_NumberDecimals() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_numberdecimals_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for NumberDecimals

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumberDecimals);
    goto iarcinfoitemedit_get_numberdecimals_method_cleanup;

    iarcinfoitemedit_get_numberdecimals_method_cleanup:
    self->m_HR = hr;
    // No cleanup for NumberDecimals
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_NumberDecimals");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_AlternateName(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAlternateName;
    PyObject* pyvar_AlternateName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for AlternateName

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_AlternateName(&bsAlternateName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_AlternateName() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_alternatename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_AlternateName = PyUnicode_FromWideChar(bsAlternateName,::SysStringLen(bsAlternateName));
    ::SysFreeString(bsAlternateName);
    
    if (PyErr_Occurred())
      goto iarcinfoitemedit_get_alternatename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_AlternateName);
    goto iarcinfoitemedit_get_alternatename_method_cleanup;

    iarcinfoitemedit_get_alternatename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_AlternateName != Py_None)
        Py_XDECREF(pyvar_AlternateName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_AlternateName");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_IsRedefined(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsRedefined = VARIANT_FALSE;
    PyObject* pyvar_IsRedefined = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsRedefined

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_IsRedefined(&b_IsRedefined);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_IsRedefined() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_isredefined_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsRedefined = ((b_IsRedefined == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iarcinfoitemedit_get_isredefined_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsRedefined);
    goto iarcinfoitemedit_get_isredefined_method_cleanup;

    iarcinfoitemedit_get_isredefined_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsRedefined
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_IsRedefined");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_IsPseudo(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsPseudo = VARIANT_FALSE;
    PyObject* pyvar_IsPseudo = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsPseudo

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_IsPseudo(&b_IsPseudo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_IsPseudo() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_ispseudo_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsPseudo = ((b_IsPseudo == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iarcinfoitemedit_get_ispseudo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsPseudo);
    goto iarcinfoitemedit_get_ispseudo_method_cleanup;

    iarcinfoitemedit_get_ispseudo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsPseudo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_IsPseudo");
    return return_tuple;
}

static PyObject*
IArcInfoItemEditMethod_get_IsIndexed(PyIArcInfoItemEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsIndexed = VARIANT_FALSE;
    PyObject* pyvar_IsIndexed = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsIndexed

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemEdit->get_IsIndexed(&b_IsIndexed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemEdit.get_IsIndexed() returned %ld", (long)hr);
        goto iarcinfoitemedit_get_isindexed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsIndexed = ((b_IsIndexed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iarcinfoitemedit_get_isindexed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsIndexed);
    goto iarcinfoitemedit_get_isindexed_method_cleanup;

    iarcinfoitemedit_get_isindexed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsIndexed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemEdit.get_IsIndexed");
    return return_tuple;
}


PyMethodDef PyIArcInfoItemEditMethods[] = {
    {"supports", (PyCFunction)PyIArcInfoItemEdit_SupportsInterface, METH_O, ""},
    {"put_StartPosition", (PyCFunction)IArcInfoItemEditMethod_put_StartPosition, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IArcInfoItemEditMethod_put_Name, METH_VARARGS, ""},
    {"put_Width", (PyCFunction)IArcInfoItemEditMethod_put_Width, METH_VARARGS, ""},
    {"put_OutputWidth", (PyCFunction)IArcInfoItemEditMethod_put_OutputWidth, METH_VARARGS, ""},
    {"put_Type", (PyCFunction)IArcInfoItemEditMethod_put_Type, METH_VARARGS, ""},
    {"put_NumberDecimals", (PyCFunction)IArcInfoItemEditMethod_put_NumberDecimals, METH_VARARGS, ""},
    {"put_AlternateName", (PyCFunction)IArcInfoItemEditMethod_put_AlternateName, METH_VARARGS, ""},
    {"put_IsRedefined", (PyCFunction)IArcInfoItemEditMethod_put_IsRedefined, METH_VARARGS, ""},
    {"put_IsPseudo", (PyCFunction)IArcInfoItemEditMethod_put_IsPseudo, METH_VARARGS, ""},
    {"put_IsIndexed", (PyCFunction)IArcInfoItemEditMethod_put_IsIndexed, METH_VARARGS, ""},
    {"get_StartPosition", (PyCFunction)IArcInfoItemEditMethod_get_StartPosition, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IArcInfoItemEditMethod_get_Name, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IArcInfoItemEditMethod_get_Width, METH_VARARGS, ""},
    {"get_OutputWidth", (PyCFunction)IArcInfoItemEditMethod_get_OutputWidth, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IArcInfoItemEditMethod_get_Type, METH_VARARGS, ""},
    {"get_NumberDecimals", (PyCFunction)IArcInfoItemEditMethod_get_NumberDecimals, METH_VARARGS, ""},
    {"get_AlternateName", (PyCFunction)IArcInfoItemEditMethod_get_AlternateName, METH_VARARGS, ""},
    {"get_IsRedefined", (PyCFunction)IArcInfoItemEditMethod_get_IsRedefined, METH_VARARGS, ""},
    {"get_IsPseudo", (PyCFunction)IArcInfoItemEditMethod_get_IsPseudo, METH_VARARGS, ""},
    {"get_IsIndexed", (PyCFunction)IArcInfoItemEditMethod_get_IsIndexed, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcInfoItemEditGetSet[] = {
  {"_pUnk", (getter)PyIArcInfoItemEdit_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcInfoItemEdit", NULL},
  {"_pointer", (getter)PyIArcInfoItemEdit_GetPointer, NULL, "Get memory address for IArcInfoItemEdit", NULL},
  {"_IID", (getter)PyIArcInfoItemEdit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcInfoItemEdit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcInfoItemEdit_GetIgnoreFailures, (setter)PyIArcInfoItemEdit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcInfoItemEditObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IArcInfoItemEditObject",                          
                                              /* tp_name */
  sizeof(PyIArcInfoItemEditObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcInfoItemEditObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcInfoItemEditMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcInfoItemEditGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcInfoItemEditObject_new,                      
                                              /* tp_new */
};

// Interface IArcInfoItems

typedef struct PyIArcInfoItemsObject {
    PyObject_HEAD
    IArcInfoItems* m_pIArcInfoItems;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcInfoItemsObject;

static PyObject*
PyIArcInfoItemsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcInfoItemsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcInfoItems* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcInfoItems, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcInfoItems with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcInfoItemsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoItems");
            return NULL;
        }
        self->m_pIArcInfoItems = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcInfoItems");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcInfoItems");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcInfoItems* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcInfoItems, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcInfoItems");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcInfoItemsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoItems");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcInfoItems = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcInfoItemsObject_dealloc(PyIArcInfoItemsObject* self)
{
    if (self->m_pIArcInfoItems)
        self->m_pIArcInfoItems->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcInfoItems_GetpUnk(PyIArcInfoItemsObject* self)
{
    if (!self->m_pIArcInfoItems)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcInfoItems->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcInfoItems to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcInfoItems_GetPointer(PyIArcInfoItemsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcInfoItems);
}

static PyObject*
PyIArcInfoItems_GetIID(PyIArcInfoItemsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b5e470d4-ceab-11d2-b0dc-0000f8780820");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcInfoItems_GetHR(PyIArcInfoItemsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcInfoItems_GetIgnoreFailures(PyIArcInfoItemsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcInfoItems_SetIgnoreFailures(PyIArcInfoItemsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcInfoItems_SupportsInterface(PyIArcInfoItemsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcInfoItems->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcInfoItemsMethod_get_ItemCount(PyIArcInfoItemsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnumItems = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for numItems

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItems->get_ItemCount(&lnumItems);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItems->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItems) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItems.get_ItemCount() returned %ld", (long)hr);
        goto iarcinfoitems_get_itemcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for numItems

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lnumItems);
    goto iarcinfoitems_get_itemcount_method_cleanup;

    iarcinfoitems_get_itemcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for numItems
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItems.get_ItemCount");
    return return_tuple;
}

static PyObject*
IArcInfoItemsMethod_get_Item(PyIArcInfoItemsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IArcInfoItem* ipItem = NULL;
    PyObject* py_Item = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iarcinfoitems_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for Item

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItems->get_Item(lindex, &ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItems->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItems) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItems.get_Item() returned %ld", (long)hr);
        goto iarcinfoitems_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_Item);
    if (ipItem)
    {
        IUnknown* pUnk = NULL;
        ipItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Item = IUnknownToPythonIIDObject(pUnk, &IID_IArcInfoItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Item)
    {
        if (py_Item)
           Py_DECREF(py_Item);
        py_Item = Py_None;
        Py_INCREF(py_Item);
    }
    if (PyErr_Occurred())
      goto iarcinfoitems_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Item);
    goto iarcinfoitems_get_item_method_cleanup;

    iarcinfoitems_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_Item);
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItems.get_Item");
    return return_tuple;
}

static PyObject*
IArcInfoItemsMethod_FindItem(PyIArcInfoItemsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iarcinfoitems_finditem_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iarcinfoitems_finditem_method_cleanup;
    
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItems->FindItem(bsName, &lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItems->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItems) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItems.FindItem() returned %ld", (long)hr);
        goto iarcinfoitems_finditem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for index

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lindex);
    goto iarcinfoitems_finditem_method_cleanup;

    iarcinfoitems_finditem_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItems.FindItem");
    return return_tuple;
}


PyMethodDef PyIArcInfoItemsMethods[] = {
    {"supports", (PyCFunction)PyIArcInfoItems_SupportsInterface, METH_O, ""},
    {"get_ItemCount", (PyCFunction)IArcInfoItemsMethod_get_ItemCount, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)IArcInfoItemsMethod_get_Item, METH_VARARGS, ""},
    {"FindItem", (PyCFunction)IArcInfoItemsMethod_FindItem, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcInfoItemsGetSet[] = {
  {"_pUnk", (getter)PyIArcInfoItems_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcInfoItems", NULL},
  {"_pointer", (getter)PyIArcInfoItems_GetPointer, NULL, "Get memory address for IArcInfoItems", NULL},
  {"_IID", (getter)PyIArcInfoItems_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcInfoItems_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcInfoItems_GetIgnoreFailures, (setter)PyIArcInfoItems_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcInfoItemsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IArcInfoItemsObject",                          
                                              /* tp_name */
  sizeof(PyIArcInfoItemsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcInfoItemsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcInfoItemsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcInfoItemsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcInfoItemsObject_new,                      
                                              /* tp_new */
};

// Interface IArcInfoItemsEdit

typedef struct PyIArcInfoItemsEditObject {
    PyObject_HEAD
    IArcInfoItemsEdit* m_pIArcInfoItemsEdit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcInfoItemsEditObject;

static PyObject*
PyIArcInfoItemsEditObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcInfoItemsEditObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcInfoItemsEdit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcInfoItemsEdit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcInfoItemsEdit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcInfoItemsEditObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoItemsEdit");
            return NULL;
        }
        self->m_pIArcInfoItemsEdit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcInfoItemsEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcInfoItemsEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcInfoItemsEdit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcInfoItemsEdit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcInfoItemsEdit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcInfoItemsEditObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoItemsEdit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcInfoItemsEdit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcInfoItemsEditObject_dealloc(PyIArcInfoItemsEditObject* self)
{
    if (self->m_pIArcInfoItemsEdit)
        self->m_pIArcInfoItemsEdit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcInfoItemsEdit_GetpUnk(PyIArcInfoItemsEditObject* self)
{
    if (!self->m_pIArcInfoItemsEdit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcInfoItemsEdit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcInfoItemsEdit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcInfoItemsEdit_GetPointer(PyIArcInfoItemsEditObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcInfoItemsEdit);
}

static PyObject*
PyIArcInfoItemsEdit_GetIID(PyIArcInfoItemsEditObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b5e470d5-ceab-11d2-b0dc-0000f8780820");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcInfoItemsEdit_GetHR(PyIArcInfoItemsEditObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcInfoItemsEdit_GetIgnoreFailures(PyIArcInfoItemsEditObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcInfoItemsEdit_SetIgnoreFailures(PyIArcInfoItemsEditObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcInfoItemsEdit_SupportsInterface(PyIArcInfoItemsEditObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcInfoItemsEditMethod_put_ItemCount(PyIArcInfoItemsEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto iarcinfoitemsedit_put_itemcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemsEdit->put_ItemCount(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemsEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemsEdit.put_ItemCount() returned %ld", (long)hr);
        goto iarcinfoitemsedit_put_itemcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemsedit_put_itemcount_method_cleanup;

    iarcinfoitemsedit_put_itemcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemsEdit.put_ItemCount");
    return return_tuple;
}

static PyObject*
IArcInfoItemsEditMethod_put_Item(PyIArcInfoItemsEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IArcInfoItem* ip_arg2 = NULL;
    PyObject* py__arg2;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lindex, &py__arg2))
      goto iarcinfoitemsedit_put_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py__arg2, &IID_IArcInfoItem, (void**)&ip_arg2))
        PyErr_SetString(PyExc_TypeError, "Argument _arg2 (position 1) is not IArcInfoItem");
    
    if (PyErr_Occurred())
      goto iarcinfoitemsedit_put_item_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemsEdit->put_Item(lindex, ip_arg2);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemsEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemsEdit.put_Item() returned %ld", (long)hr);
        goto iarcinfoitemsedit_put_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for _arg2

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemsedit_put_item_method_cleanup;

    iarcinfoitemsedit_put_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ip_arg2)
      ip_arg2->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemsEdit.put_Item");
    return return_tuple;
}

static PyObject*
IArcInfoItemsEditMethod_AddItem(PyIArcInfoItemsEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArcInfoItem* ipItem = NULL;
    PyObject* py_Item;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Item))
      goto iarcinfoitemsedit_additem_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Item, &IID_IArcInfoItem, (void**)&ipItem))
        PyErr_SetString(PyExc_TypeError, "Argument Item (position 0) is not IArcInfoItem");
    
    if (PyErr_Occurred())
      goto iarcinfoitemsedit_additem_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemsEdit->AddItem(ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemsEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemsEdit.AddItem() returned %ld", (long)hr);
        goto iarcinfoitemsedit_additem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Item

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemsedit_additem_method_cleanup;

    iarcinfoitemsedit_additem_method_cleanup:
    self->m_HR = hr;
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemsEdit.AddItem");
    return return_tuple;
}

static PyObject*
IArcInfoItemsEditMethod_DeleteItem(PyIArcInfoItemsEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArcInfoItem* ipItem = NULL;
    PyObject* py_Item;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Item))
      goto iarcinfoitemsedit_deleteitem_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Item, &IID_IArcInfoItem, (void**)&ipItem))
        PyErr_SetString(PyExc_TypeError, "Argument Item (position 0) is not IArcInfoItem");
    
    if (PyErr_Occurred())
      goto iarcinfoitemsedit_deleteitem_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemsEdit->DeleteItem(ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemsEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemsEdit.DeleteItem() returned %ld", (long)hr);
        goto iarcinfoitemsedit_deleteitem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Item

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfoitemsedit_deleteitem_method_cleanup;

    iarcinfoitemsedit_deleteitem_method_cleanup:
    self->m_HR = hr;
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemsEdit.DeleteItem");
    return return_tuple;
}

static PyObject*
IArcInfoItemsEditMethod_DeleteAllItems(PyIArcInfoItemsEditObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIArcInfoItemsEdit->DeleteAllItems();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemsEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemsEdit.DeleteAllItems() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IArcInfoItemsEditMethod_get_ItemCount(PyIArcInfoItemsEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnumItems = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for numItems

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemsEdit->get_ItemCount(&lnumItems);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemsEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemsEdit.get_ItemCount() returned %ld", (long)hr);
        goto iarcinfoitemsedit_get_itemcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for numItems

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lnumItems);
    goto iarcinfoitemsedit_get_itemcount_method_cleanup;

    iarcinfoitemsedit_get_itemcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for numItems
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemsEdit.get_ItemCount");
    return return_tuple;
}

static PyObject*
IArcInfoItemsEditMethod_get_Item(PyIArcInfoItemsEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IArcInfoItem* ipItem = NULL;
    PyObject* py_Item = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iarcinfoitemsedit_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for Item

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemsEdit->get_Item(lindex, &ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemsEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemsEdit.get_Item() returned %ld", (long)hr);
        goto iarcinfoitemsedit_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_Item);
    if (ipItem)
    {
        IUnknown* pUnk = NULL;
        ipItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Item = IUnknownToPythonIIDObject(pUnk, &IID_IArcInfoItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Item)
    {
        if (py_Item)
           Py_DECREF(py_Item);
        py_Item = Py_None;
        Py_INCREF(py_Item);
    }
    if (PyErr_Occurred())
      goto iarcinfoitemsedit_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Item);
    goto iarcinfoitemsedit_get_item_method_cleanup;

    iarcinfoitemsedit_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_Item);
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemsEdit.get_Item");
    return return_tuple;
}

static PyObject*
IArcInfoItemsEditMethod_FindItem(PyIArcInfoItemsEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iarcinfoitemsedit_finditem_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iarcinfoitemsedit_finditem_method_cleanup;
    
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pIArcInfoItemsEdit->FindItem(bsName, &lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoItemsEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoItemsEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoItemsEdit.FindItem() returned %ld", (long)hr);
        goto iarcinfoitemsedit_finditem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for index

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lindex);
    goto iarcinfoitemsedit_finditem_method_cleanup;

    iarcinfoitemsedit_finditem_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoItemsEdit.FindItem");
    return return_tuple;
}


PyMethodDef PyIArcInfoItemsEditMethods[] = {
    {"supports", (PyCFunction)PyIArcInfoItemsEdit_SupportsInterface, METH_O, ""},
    {"put_ItemCount", (PyCFunction)IArcInfoItemsEditMethod_put_ItemCount, METH_VARARGS, ""},
    {"put_Item", (PyCFunction)IArcInfoItemsEditMethod_put_Item, METH_VARARGS, ""},
    {"AddItem", (PyCFunction)IArcInfoItemsEditMethod_AddItem, METH_VARARGS, ""},
    {"DeleteItem", (PyCFunction)IArcInfoItemsEditMethod_DeleteItem, METH_VARARGS, ""},
    {"DeleteAllItems", (PyCFunction)IArcInfoItemsEditMethod_DeleteAllItems, METH_NOARGS, ""},
    {"get_ItemCount", (PyCFunction)IArcInfoItemsEditMethod_get_ItemCount, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)IArcInfoItemsEditMethod_get_Item, METH_VARARGS, ""},
    {"FindItem", (PyCFunction)IArcInfoItemsEditMethod_FindItem, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcInfoItemsEditGetSet[] = {
  {"_pUnk", (getter)PyIArcInfoItemsEdit_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcInfoItemsEdit", NULL},
  {"_pointer", (getter)PyIArcInfoItemsEdit_GetPointer, NULL, "Get memory address for IArcInfoItemsEdit", NULL},
  {"_IID", (getter)PyIArcInfoItemsEdit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcInfoItemsEdit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcInfoItemsEdit_GetIgnoreFailures, (setter)PyIArcInfoItemsEdit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcInfoItemsEditObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IArcInfoItemsEditObject",                          
                                              /* tp_name */
  sizeof(PyIArcInfoItemsEditObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcInfoItemsEditObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcInfoItemsEditMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcInfoItemsEditGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcInfoItemsEditObject_new,                      
                                              /* tp_new */
};

// Interface IArcInfoTable

typedef struct PyIArcInfoTableObject {
    PyObject_HEAD
    IArcInfoTable* m_pIArcInfoTable;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcInfoTableObject;

static PyObject*
PyIArcInfoTableObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcInfoTableObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcInfoTable* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcInfoTable, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcInfoTable with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcInfoTableObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoTable");
            return NULL;
        }
        self->m_pIArcInfoTable = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcInfoTable");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcInfoTable");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcInfoTable* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcInfoTable, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcInfoTable");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcInfoTableObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoTable");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcInfoTable = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcInfoTableObject_dealloc(PyIArcInfoTableObject* self)
{
    if (self->m_pIArcInfoTable)
        self->m_pIArcInfoTable->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcInfoTable_GetpUnk(PyIArcInfoTableObject* self)
{
    if (!self->m_pIArcInfoTable)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcInfoTable->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcInfoTable to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcInfoTable_GetPointer(PyIArcInfoTableObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcInfoTable);
}

static PyObject*
PyIArcInfoTable_GetIID(PyIArcInfoTableObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d3ec3d31-cffe-11d2-b0dc-0000f8780820");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcInfoTable_GetHR(PyIArcInfoTableObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcInfoTable_GetIgnoreFailures(PyIArcInfoTableObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcInfoTable_SetIgnoreFailures(PyIArcInfoTableObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcInfoTable_SupportsInterface(PyIArcInfoTableObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcInfoTable->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcInfoTableMethod_FindItem(PyIArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long litemIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iarcinfotable_finditem_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iarcinfotable_finditem_method_cleanup;
    
    // No setup for itemIndex

    // Call method on actual COM interface
    hr = self->m_pIArcInfoTable->FindItem(bsName, &litemIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoTable.FindItem() returned %ld", (long)hr);
        goto iarcinfotable_finditem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for itemIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            litemIndex);
    goto iarcinfotable_finditem_method_cleanup;

    iarcinfotable_finditem_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for itemIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoTable.FindItem");
    return return_tuple;
}

static PyObject*
IArcInfoTableMethod_get_ItemSet(PyIArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArcInfoItems* ipItemSet = NULL;
    PyObject* py_ItemSet = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ItemSet

    // Call method on actual COM interface
    hr = self->m_pIArcInfoTable->get_ItemSet(&ipItemSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoTable.get_ItemSet() returned %ld", (long)hr);
        goto iarcinfotable_get_itemset_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ItemSet);
    if (ipItemSet)
    {
        IUnknown* pUnk = NULL;
        ipItemSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ItemSet = IUnknownToPythonIIDObject(pUnk, &IID_IArcInfoItems);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ItemSet)
    {
        if (py_ItemSet)
           Py_DECREF(py_ItemSet);
        py_ItemSet = Py_None;
        Py_INCREF(py_ItemSet);
    }
    if (PyErr_Occurred())
      goto iarcinfotable_get_itemset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ItemSet);
    goto iarcinfotable_get_itemset_method_cleanup;

    iarcinfotable_get_itemset_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ItemSet);
    if (ipItemSet)
      ipItemSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoTable.get_ItemSet");
    return return_tuple;
}

static PyObject*
IArcInfoTableMethod_AddItem(PyIArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArcInfoItem* ipItem = NULL;
    PyObject* py_Item;
    BSTR bsstartItem = 0;
    PyObject* pyvar_startItem;
    PyObject* unicodestartItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_Item, &pyvar_startItem))
      goto iarcinfotable_additem_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Item, &IID_IArcInfoItem, (void**)&ipItem))
        PyErr_SetString(PyExc_TypeError, "Argument Item (position 0) is not IArcInfoItem");
    
    if (PyErr_Occurred())
      goto iarcinfotable_additem_method_cleanup;
    
    if (PyString_Check(pyvar_startItem))
        unicodestartItem = PyUnicode_FromObject(pyvar_startItem);
    else if (PyUnicode_Check(pyvar_startItem))
    {
        unicodestartItem = pyvar_startItem;
        Py_INCREF(unicodestartItem);
    }
    else if (pyvar_startItem != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter startItem at index 1");
    if (unicodestartItem)
        bsstartItem = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodestartItem), 
                                            (UINT)PyUnicode_GET_SIZE(unicodestartItem));
    
    if (PyErr_Occurred())
      goto iarcinfotable_additem_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoTable->AddItem(ipItem, bsstartItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoTable.AddItem() returned %ld", (long)hr);
        goto iarcinfotable_additem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Item
    // No teardown for startItem

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfotable_additem_method_cleanup;

    iarcinfotable_additem_method_cleanup:
    self->m_HR = hr;
    if (ipItem)
      ipItem->Release();
    if (bsstartItem)
        ::SysFreeString(bsstartItem);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoTable.AddItem");
    return return_tuple;
}

static PyObject*
IArcInfoTableMethod_DeleteItem(PyIArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsitemName = 0;
    PyObject* pyvar_itemName;
    PyObject* unicodeitemName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_itemName))
      goto iarcinfotable_deleteitem_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_itemName))
        unicodeitemName = PyUnicode_FromObject(pyvar_itemName);
    else if (PyUnicode_Check(pyvar_itemName))
    {
        unicodeitemName = pyvar_itemName;
        Py_INCREF(unicodeitemName);
    }
    else if (pyvar_itemName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter itemName at index 0");
    if (unicodeitemName)
        bsitemName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeitemName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeitemName));
    
    if (PyErr_Occurred())
      goto iarcinfotable_deleteitem_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoTable->DeleteItem(bsitemName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoTable.DeleteItem() returned %ld", (long)hr);
        goto iarcinfotable_deleteitem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for itemName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfotable_deleteitem_method_cleanup;

    iarcinfotable_deleteitem_method_cleanup:
    self->m_HR = hr;
    if (bsitemName)
        ::SysFreeString(bsitemName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoTable.DeleteItem");
    return return_tuple;
}

static PyObject*
IArcInfoTableMethod_AddIndex(PyIArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsitemName = 0;
    PyObject* pyvar_itemName;
    PyObject* unicodeitemName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_itemName))
      goto iarcinfotable_addindex_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_itemName))
        unicodeitemName = PyUnicode_FromObject(pyvar_itemName);
    else if (PyUnicode_Check(pyvar_itemName))
    {
        unicodeitemName = pyvar_itemName;
        Py_INCREF(unicodeitemName);
    }
    else if (pyvar_itemName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter itemName at index 0");
    if (unicodeitemName)
        bsitemName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeitemName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeitemName));
    
    if (PyErr_Occurred())
      goto iarcinfotable_addindex_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoTable->AddIndex(bsitemName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoTable.AddIndex() returned %ld", (long)hr);
        goto iarcinfotable_addindex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for itemName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfotable_addindex_method_cleanup;

    iarcinfotable_addindex_method_cleanup:
    self->m_HR = hr;
    if (bsitemName)
        ::SysFreeString(bsitemName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoTable.AddIndex");
    return return_tuple;
}

static PyObject*
IArcInfoTableMethod_DeleteIndex(PyIArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsitemName = 0;
    PyObject* pyvar_itemName;
    PyObject* unicodeitemName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_itemName))
      goto iarcinfotable_deleteindex_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_itemName))
        unicodeitemName = PyUnicode_FromObject(pyvar_itemName);
    else if (PyUnicode_Check(pyvar_itemName))
    {
        unicodeitemName = pyvar_itemName;
        Py_INCREF(unicodeitemName);
    }
    else if (pyvar_itemName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter itemName at index 0");
    if (unicodeitemName)
        bsitemName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeitemName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeitemName));
    
    if (PyErr_Occurred())
      goto iarcinfotable_deleteindex_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoTable->DeleteIndex(bsitemName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoTable.DeleteIndex() returned %ld", (long)hr);
        goto iarcinfotable_deleteindex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for itemName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfotable_deleteindex_method_cleanup;

    iarcinfotable_deleteindex_method_cleanup:
    self->m_HR = hr;
    if (bsitemName)
        ::SysFreeString(bsitemName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoTable.DeleteIndex");
    return return_tuple;
}

static PyObject*
IArcInfoTableMethod_AlterItem(PyIArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsitemName = 0;
    PyObject* pyvar_itemName;
    PyObject* unicodeitemName = NULL;
    IArcInfoItem* ipItem = NULL;
    PyObject* py_Item;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_itemName, &py_Item))
      goto iarcinfotable_alteritem_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_itemName))
        unicodeitemName = PyUnicode_FromObject(pyvar_itemName);
    else if (PyUnicode_Check(pyvar_itemName))
    {
        unicodeitemName = pyvar_itemName;
        Py_INCREF(unicodeitemName);
    }
    else if (pyvar_itemName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter itemName at index 0");
    if (unicodeitemName)
        bsitemName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeitemName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeitemName));
    
    if (PyErr_Occurred())
      goto iarcinfotable_alteritem_method_cleanup;
    
    if (!IFaceFromPyObject(py_Item, &IID_IArcInfoItem, (void**)&ipItem))
        PyErr_SetString(PyExc_TypeError, "Argument Item (position 1) is not IArcInfoItem");
    
    if (PyErr_Occurred())
      goto iarcinfotable_alteritem_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoTable->AlterItem(bsitemName, ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoTable.AlterItem() returned %ld", (long)hr);
        goto iarcinfotable_alteritem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for itemName
    // No teardown for Item

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfotable_alteritem_method_cleanup;

    iarcinfotable_alteritem_method_cleanup:
    self->m_HR = hr;
    if (bsitemName)
        ::SysFreeString(bsitemName);
    
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoTable.AlterItem");
    return return_tuple;
}


PyMethodDef PyIArcInfoTableMethods[] = {
    {"supports", (PyCFunction)PyIArcInfoTable_SupportsInterface, METH_O, ""},
    {"FindItem", (PyCFunction)IArcInfoTableMethod_FindItem, METH_VARARGS, ""},
    {"get_ItemSet", (PyCFunction)IArcInfoTableMethod_get_ItemSet, METH_VARARGS, ""},
    {"AddItem", (PyCFunction)IArcInfoTableMethod_AddItem, METH_VARARGS, ""},
    {"DeleteItem", (PyCFunction)IArcInfoTableMethod_DeleteItem, METH_VARARGS, ""},
    {"AddIndex", (PyCFunction)IArcInfoTableMethod_AddIndex, METH_VARARGS, ""},
    {"DeleteIndex", (PyCFunction)IArcInfoTableMethod_DeleteIndex, METH_VARARGS, ""},
    {"AlterItem", (PyCFunction)IArcInfoTableMethod_AlterItem, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcInfoTableGetSet[] = {
  {"_pUnk", (getter)PyIArcInfoTable_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcInfoTable", NULL},
  {"_pointer", (getter)PyIArcInfoTable_GetPointer, NULL, "Get memory address for IArcInfoTable", NULL},
  {"_IID", (getter)PyIArcInfoTable_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcInfoTable_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcInfoTable_GetIgnoreFailures, (setter)PyIArcInfoTable_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcInfoTableObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IArcInfoTableObject",                          
                                              /* tp_name */
  sizeof(PyIArcInfoTableObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcInfoTableObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcInfoTableMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcInfoTableGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcInfoTableObject_new,                      
                                              /* tp_new */
};

// Interface IArcInfoTable2

typedef struct PyIArcInfoTable2Object {
    PyObject_HEAD
    IArcInfoTable2* m_pIArcInfoTable2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcInfoTable2Object;

static PyObject*
PyIArcInfoTable2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcInfoTable2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcInfoTable2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcInfoTable2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcInfoTable2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcInfoTable2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoTable2");
            return NULL;
        }
        self->m_pIArcInfoTable2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcInfoTable2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcInfoTable2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcInfoTable2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcInfoTable2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcInfoTable2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcInfoTable2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoTable2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcInfoTable2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcInfoTable2Object_dealloc(PyIArcInfoTable2Object* self)
{
    if (self->m_pIArcInfoTable2)
        self->m_pIArcInfoTable2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcInfoTable2_GetpUnk(PyIArcInfoTable2Object* self)
{
    if (!self->m_pIArcInfoTable2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcInfoTable2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcInfoTable2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcInfoTable2_GetPointer(PyIArcInfoTable2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcInfoTable2);
}

static PyObject*
PyIArcInfoTable2_GetIID(PyIArcInfoTable2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "99d56004-bb97-4606-a141-6bb061f87940");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcInfoTable2_GetHR(PyIArcInfoTable2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcInfoTable2_GetIgnoreFailures(PyIArcInfoTable2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcInfoTable2_SetIgnoreFailures(PyIArcInfoTable2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcInfoTable2_SupportsInterface(PyIArcInfoTable2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcInfoTable2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcInfoTable2Method_External(PyIArcInfoTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsexternalname = 0;
    PyObject* pyvar_externalname;
    PyObject* unicodeexternalname = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_externalname))
      goto iarcinfotable2_external_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_externalname))
        unicodeexternalname = PyUnicode_FromObject(pyvar_externalname);
    else if (PyUnicode_Check(pyvar_externalname))
    {
        unicodeexternalname = pyvar_externalname;
        Py_INCREF(unicodeexternalname);
    }
    else if (pyvar_externalname != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter externalname at index 0");
    if (unicodeexternalname)
        bsexternalname = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeexternalname), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeexternalname));
    
    if (PyErr_Occurred())
      goto iarcinfotable2_external_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcInfoTable2->External(bsexternalname);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoTable2.External() returned %ld", (long)hr);
        goto iarcinfotable2_external_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for externalname

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarcinfotable2_external_method_cleanup;

    iarcinfotable2_external_method_cleanup:
    self->m_HR = hr;
    if (bsexternalname)
        ::SysFreeString(bsexternalname);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoTable2.External");
    return return_tuple;
}


PyMethodDef PyIArcInfoTable2Methods[] = {
    {"supports", (PyCFunction)PyIArcInfoTable2_SupportsInterface, METH_O, ""},
    {"External", (PyCFunction)IArcInfoTable2Method_External, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcInfoTable2GetSet[] = {
  {"_pUnk", (getter)PyIArcInfoTable2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcInfoTable2", NULL},
  {"_pointer", (getter)PyIArcInfoTable2_GetPointer, NULL, "Get memory address for IArcInfoTable2", NULL},
  {"_IID", (getter)PyIArcInfoTable2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcInfoTable2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcInfoTable2_GetIgnoreFailures, (setter)PyIArcInfoTable2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcInfoTable2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IArcInfoTable2Object",                          
                                              /* tp_name */
  sizeof(PyIArcInfoTable2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcInfoTable2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcInfoTable2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcInfoTable2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcInfoTable2Object_new,                      
                                              /* tp_new */
};

// Interface ICoverageFeatureClass

typedef struct PyICoverageFeatureClassObject {
    PyObject_HEAD
    ICoverageFeatureClass* m_pICoverageFeatureClass;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICoverageFeatureClassObject;

static PyObject*
PyICoverageFeatureClassObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICoverageFeatureClassObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICoverageFeatureClass* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICoverageFeatureClass, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICoverageFeatureClass with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICoverageFeatureClassObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverageFeatureClass");
            return NULL;
        }
        self->m_pICoverageFeatureClass = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICoverageFeatureClass");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICoverageFeatureClass");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICoverageFeatureClass* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICoverageFeatureClass, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICoverageFeatureClass");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICoverageFeatureClassObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverageFeatureClass");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICoverageFeatureClass = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICoverageFeatureClassObject_dealloc(PyICoverageFeatureClassObject* self)
{
    if (self->m_pICoverageFeatureClass)
        self->m_pICoverageFeatureClass->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICoverageFeatureClass_GetpUnk(PyICoverageFeatureClassObject* self)
{
    if (!self->m_pICoverageFeatureClass)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICoverageFeatureClass->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICoverageFeatureClass to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICoverageFeatureClass_GetPointer(PyICoverageFeatureClassObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICoverageFeatureClass);
}

static PyObject*
PyICoverageFeatureClass_GetIID(PyICoverageFeatureClassObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4e471bb1-06fa-11d3-9f31-00c04f79927c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICoverageFeatureClass_GetHR(PyICoverageFeatureClassObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICoverageFeatureClass_GetIgnoreFailures(PyICoverageFeatureClassObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICoverageFeatureClass_SetIgnoreFailures(PyICoverageFeatureClassObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICoverageFeatureClass_SupportsInterface(PyICoverageFeatureClassObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICoverageFeatureClass->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICoverageFeatureClassMethod_get_FeatureClassType(PyICoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FeatureClassType

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClass->get_FeatureClassType(&eFeatureClassType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClass.get_FeatureClassType() returned %ld", (long)hr);
        goto icoveragefeatureclass_get_featureclasstype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eFeatureClassType);
    goto icoveragefeatureclass_get_featureclasstype_method_cleanup;

    icoveragefeatureclass_get_featureclasstype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClass.get_FeatureClassType");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClassMethod_get_Topology(PyICoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureClassTopology eTopology;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Topology

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClass->get_Topology(&eTopology);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClass.get_Topology() returned %ld", (long)hr);
        goto icoveragefeatureclass_get_topology_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Topology

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eTopology);
    goto icoveragefeatureclass_get_topology_method_cleanup;

    icoveragefeatureclass_get_topology_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Topology
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClass.get_Topology");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClassMethod_get_HasFAT(PyICoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HasFAT = VARIANT_FALSE;
    PyObject* pyvar_HasFAT = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HasFAT

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClass->get_HasFAT(&b_HasFAT);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClass.get_HasFAT() returned %ld", (long)hr);
        goto icoveragefeatureclass_get_hasfat_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HasFAT = ((b_HasFAT == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icoveragefeatureclass_get_hasfat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HasFAT);
    goto icoveragefeatureclass_get_hasfat_method_cleanup;

    icoveragefeatureclass_get_hasfat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HasFAT
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClass.get_HasFAT");
    return return_tuple;
}


PyMethodDef PyICoverageFeatureClassMethods[] = {
    {"supports", (PyCFunction)PyICoverageFeatureClass_SupportsInterface, METH_O, ""},
    {"get_FeatureClassType", (PyCFunction)ICoverageFeatureClassMethod_get_FeatureClassType, METH_VARARGS, ""},
    {"get_Topology", (PyCFunction)ICoverageFeatureClassMethod_get_Topology, METH_VARARGS, ""},
    {"get_HasFAT", (PyCFunction)ICoverageFeatureClassMethod_get_HasFAT, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICoverageFeatureClassGetSet[] = {
  {"_pUnk", (getter)PyICoverageFeatureClass_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICoverageFeatureClass", NULL},
  {"_pointer", (getter)PyICoverageFeatureClass_GetPointer, NULL, "Get memory address for ICoverageFeatureClass", NULL},
  {"_IID", (getter)PyICoverageFeatureClass_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICoverageFeatureClass_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICoverageFeatureClass_GetIgnoreFailures, (setter)PyICoverageFeatureClass_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICoverageFeatureClassObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICoverageFeatureClassObject",                          
                                              /* tp_name */
  sizeof(PyICoverageFeatureClassObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICoverageFeatureClassObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICoverageFeatureClassMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICoverageFeatureClassGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICoverageFeatureClassObject_new,                      
                                              /* tp_new */
};

// Interface ICoverageFeatureClass2

typedef struct PyICoverageFeatureClass2Object {
    PyObject_HEAD
    ICoverageFeatureClass2* m_pICoverageFeatureClass2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICoverageFeatureClass2Object;

static PyObject*
PyICoverageFeatureClass2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICoverageFeatureClass2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICoverageFeatureClass2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICoverageFeatureClass2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICoverageFeatureClass2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICoverageFeatureClass2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverageFeatureClass2");
            return NULL;
        }
        self->m_pICoverageFeatureClass2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICoverageFeatureClass2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICoverageFeatureClass2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICoverageFeatureClass2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICoverageFeatureClass2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICoverageFeatureClass2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICoverageFeatureClass2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverageFeatureClass2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICoverageFeatureClass2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICoverageFeatureClass2Object_dealloc(PyICoverageFeatureClass2Object* self)
{
    if (self->m_pICoverageFeatureClass2)
        self->m_pICoverageFeatureClass2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICoverageFeatureClass2_GetpUnk(PyICoverageFeatureClass2Object* self)
{
    if (!self->m_pICoverageFeatureClass2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICoverageFeatureClass2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICoverageFeatureClass2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICoverageFeatureClass2_GetPointer(PyICoverageFeatureClass2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICoverageFeatureClass2);
}

static PyObject*
PyICoverageFeatureClass2_GetIID(PyICoverageFeatureClass2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2da3b82a-b02a-11d4-9f5a-00c04f79927c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICoverageFeatureClass2_GetHR(PyICoverageFeatureClass2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICoverageFeatureClass2_GetIgnoreFailures(PyICoverageFeatureClass2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICoverageFeatureClass2_SetIgnoreFailures(PyICoverageFeatureClass2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICoverageFeatureClass2_SupportsInterface(PyICoverageFeatureClass2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICoverageFeatureClass2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICoverageFeatureClass2Method_Copy(PyICoverageFeatureClass2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscopyName = 0;
    PyObject* pyvar_copyName;
    PyObject* unicodecopyName = NULL;
    IFeatureDataset* ipcopyFeatureDataset = NULL;
    PyObject* py_copyFeatureDataset;
    IFeatureClass* ipcopyFeatureClass = NULL;
    PyObject* py_copyFeatureClass = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_copyName, &py_copyFeatureDataset))
      goto icoveragefeatureclass2_copy_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_copyName))
        unicodecopyName = PyUnicode_FromObject(pyvar_copyName);
    else if (PyUnicode_Check(pyvar_copyName))
    {
        unicodecopyName = pyvar_copyName;
        Py_INCREF(unicodecopyName);
    }
    else if (pyvar_copyName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter copyName at index 0");
    if (unicodecopyName)
        bscopyName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecopyName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecopyName));
    
    if (PyErr_Occurred())
      goto icoveragefeatureclass2_copy_method_cleanup;
    
    if (!IFaceFromPyObject(py_copyFeatureDataset, &IID_IFeatureDataset, (void**)&ipcopyFeatureDataset))
        PyErr_SetString(PyExc_TypeError, "Argument copyFeatureDataset (position 1) is not IFeatureDataset");
    
    if (PyErr_Occurred())
      goto icoveragefeatureclass2_copy_method_cleanup;
    
    // No setup for copyFeatureClass

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClass2->Copy(bscopyName, ipcopyFeatureDataset, &ipcopyFeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClass2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClass2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClass2.Copy() returned %ld", (long)hr);
        goto icoveragefeatureclass2_copy_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for copyName
    // No teardown for copyFeatureDataset
    Py_XDECREF(py_copyFeatureClass);
    if (ipcopyFeatureClass)
    {
        IUnknown* pUnk = NULL;
        ipcopyFeatureClass->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_copyFeatureClass = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_copyFeatureClass)
    {
        if (py_copyFeatureClass)
           Py_DECREF(py_copyFeatureClass);
        py_copyFeatureClass = Py_None;
        Py_INCREF(py_copyFeatureClass);
    }
    if (PyErr_Occurred())
      goto icoveragefeatureclass2_copy_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_copyFeatureClass);
    goto icoveragefeatureclass2_copy_method_cleanup;

    icoveragefeatureclass2_copy_method_cleanup:
    self->m_HR = hr;
    if (bscopyName)
        ::SysFreeString(bscopyName);
    
    if (ipcopyFeatureDataset)
      ipcopyFeatureDataset->Release();
    Py_XDECREF(py_copyFeatureClass);
    if (ipcopyFeatureClass)
      ipcopyFeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClass2.Copy");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClass2Method_get_FeatureClassType(PyICoverageFeatureClass2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FeatureClassType

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClass2->get_FeatureClassType(&eFeatureClassType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClass2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClass2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClass2.get_FeatureClassType() returned %ld", (long)hr);
        goto icoveragefeatureclass2_get_featureclasstype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eFeatureClassType);
    goto icoveragefeatureclass2_get_featureclasstype_method_cleanup;

    icoveragefeatureclass2_get_featureclasstype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClass2.get_FeatureClassType");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClass2Method_get_Topology(PyICoverageFeatureClass2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureClassTopology eTopology;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Topology

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClass2->get_Topology(&eTopology);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClass2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClass2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClass2.get_Topology() returned %ld", (long)hr);
        goto icoveragefeatureclass2_get_topology_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Topology

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eTopology);
    goto icoveragefeatureclass2_get_topology_method_cleanup;

    icoveragefeatureclass2_get_topology_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Topology
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClass2.get_Topology");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClass2Method_get_HasFAT(PyICoverageFeatureClass2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HasFAT = VARIANT_FALSE;
    PyObject* pyvar_HasFAT = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HasFAT

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClass2->get_HasFAT(&b_HasFAT);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClass2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClass2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClass2.get_HasFAT() returned %ld", (long)hr);
        goto icoveragefeatureclass2_get_hasfat_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HasFAT = ((b_HasFAT == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icoveragefeatureclass2_get_hasfat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HasFAT);
    goto icoveragefeatureclass2_get_hasfat_method_cleanup;

    icoveragefeatureclass2_get_hasfat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HasFAT
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClass2.get_HasFAT");
    return return_tuple;
}


PyMethodDef PyICoverageFeatureClass2Methods[] = {
    {"supports", (PyCFunction)PyICoverageFeatureClass2_SupportsInterface, METH_O, ""},
    {"Copy", (PyCFunction)ICoverageFeatureClass2Method_Copy, METH_VARARGS, ""},
    {"get_FeatureClassType", (PyCFunction)ICoverageFeatureClass2Method_get_FeatureClassType, METH_VARARGS, ""},
    {"get_Topology", (PyCFunction)ICoverageFeatureClass2Method_get_Topology, METH_VARARGS, ""},
    {"get_HasFAT", (PyCFunction)ICoverageFeatureClass2Method_get_HasFAT, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICoverageFeatureClass2GetSet[] = {
  {"_pUnk", (getter)PyICoverageFeatureClass2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICoverageFeatureClass2", NULL},
  {"_pointer", (getter)PyICoverageFeatureClass2_GetPointer, NULL, "Get memory address for ICoverageFeatureClass2", NULL},
  {"_IID", (getter)PyICoverageFeatureClass2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICoverageFeatureClass2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICoverageFeatureClass2_GetIgnoreFailures, (setter)PyICoverageFeatureClass2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICoverageFeatureClass2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICoverageFeatureClass2Object",                          
                                              /* tp_name */
  sizeof(PyICoverageFeatureClass2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICoverageFeatureClass2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICoverageFeatureClass2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICoverageFeatureClass2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICoverageFeatureClass2Object_new,                      
                                              /* tp_new */
};

// Interface ICoverage

typedef struct PyICoverageObject {
    PyObject_HEAD
    ICoverage* m_pICoverage;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICoverageObject;

static PyObject*
PyICoverageObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICoverageObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICoverage* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICoverage, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICoverage with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICoverageObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverage");
            return NULL;
        }
        self->m_pICoverage = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICoverage");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICoverage");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICoverage* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICoverage, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICoverage");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICoverageObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverage");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICoverage = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICoverageObject_dealloc(PyICoverageObject* self)
{
    if (self->m_pICoverage)
        self->m_pICoverage->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICoverage_GetpUnk(PyICoverageObject* self)
{
    if (!self->m_pICoverage)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICoverage->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICoverage to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICoverage_GetPointer(PyICoverageObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICoverage);
}

static PyObject*
PyICoverage_GetIID(PyICoverageObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d42131e1-d187-11d2-b0dc-0000f8780820");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICoverage_GetHR(PyICoverageObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICoverage_GetIgnoreFailures(PyICoverageObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICoverage_SetIgnoreFailures(PyICoverageObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICoverage_SupportsInterface(PyICoverageObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICoverage->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICoverageMethod_get_Tolerance(PyICoverageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageToleranceType etoleranceType;
    double dtoleranceValue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&etoleranceType))
      goto icoverage_get_tolerance_method_cleanup;

    // Set up initial variable values as needed
    // No setup for toleranceType
    // No setup for toleranceValue

    // Call method on actual COM interface
    hr = self->m_pICoverage->get_Tolerance(etoleranceType, &dtoleranceValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage.get_Tolerance() returned %ld", (long)hr);
        goto icoverage_get_tolerance_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for toleranceType
    // No teardown for toleranceValue

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dtoleranceValue);
    goto icoverage_get_tolerance_method_cleanup;

    icoverage_get_tolerance_method_cleanup:
    self->m_HR = hr;
    // No cleanup for toleranceType
    // No cleanup for toleranceValue
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage.get_Tolerance");
    return return_tuple;
}

static PyObject*
ICoverageMethod_get_ToleranceStatus(PyICoverageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageToleranceType etoleranceType;
    VARIANT_BOOL b_isVerified = VARIANT_FALSE;
    PyObject* pyvar_isVerified = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&etoleranceType))
      goto icoverage_get_tolerancestatus_method_cleanup;

    // Set up initial variable values as needed
    // No setup for toleranceType
    // No setup for isVerified

    // Call method on actual COM interface
    hr = self->m_pICoverage->get_ToleranceStatus(etoleranceType, &b_isVerified);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage.get_ToleranceStatus() returned %ld", (long)hr);
        goto icoverage_get_tolerancestatus_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for toleranceType
    pyvar_isVerified = ((b_isVerified == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icoverage_get_tolerancestatus_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isVerified);
    goto icoverage_get_tolerancestatus_method_cleanup;

    icoverage_get_tolerancestatus_method_cleanup:
    self->m_HR = hr;
    // No cleanup for toleranceType
    // No cleanup for isVerified
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage.get_ToleranceStatus");
    return return_tuple;
}

static PyObject*
ICoverageMethod_put_Tolerance(PyICoverageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageToleranceType etoleranceType;
    double dtoleranceValue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "id", (int *)&etoleranceType, &dtoleranceValue))
      goto icoverage_put_tolerance_method_cleanup;

    // Set up initial variable values as needed
    // No setup for toleranceType
    // No setup for toleranceValue

    // Call method on actual COM interface
    hr = self->m_pICoverage->put_Tolerance(etoleranceType, dtoleranceValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage.put_Tolerance() returned %ld", (long)hr);
        goto icoverage_put_tolerance_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for toleranceType
    // No teardown for toleranceValue

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoverage_put_tolerance_method_cleanup;

    icoverage_put_tolerance_method_cleanup:
    self->m_HR = hr;
    // No cleanup for toleranceType
    // No cleanup for toleranceValue
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage.put_Tolerance");
    return return_tuple;
}

static PyObject*
ICoverageMethod_Build(PyICoverageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;
    BSTR bssubclassName = 0;
    PyObject* pyvar_subclassName;
    PyObject* unicodesubclassName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eFeatureClassType, &pyvar_subclassName))
      goto icoverage_build_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FeatureClassType
    if (PyString_Check(pyvar_subclassName))
        unicodesubclassName = PyUnicode_FromObject(pyvar_subclassName);
    else if (PyUnicode_Check(pyvar_subclassName))
    {
        unicodesubclassName = pyvar_subclassName;
        Py_INCREF(unicodesubclassName);
    }
    else if (pyvar_subclassName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter subclassName at index 1");
    if (unicodesubclassName)
        bssubclassName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesubclassName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesubclassName));
    
    if (PyErr_Occurred())
      goto icoverage_build_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICoverage->Build(eFeatureClassType, bssubclassName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage.Build() returned %ld", (long)hr);
        goto icoverage_build_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType
    // No teardown for subclassName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoverage_build_method_cleanup;

    icoverage_build_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (bssubclassName)
        ::SysFreeString(bssubclassName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage.Build");
    return return_tuple;
}

static PyObject*
ICoverageMethod_Clean(PyICoverageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double ddangleTolerance = 0;
    double dfuzzyTolerance = 0;
    esriCoverageFeatureClassType eFeatureClassType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ddi", &ddangleTolerance, &dfuzzyTolerance, (int *)&eFeatureClassType))
      goto icoverage_clean_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dangleTolerance
    // No setup for fuzzyTolerance
    // No setup for FeatureClassType

    // Call method on actual COM interface
    hr = self->m_pICoverage->Clean(ddangleTolerance, dfuzzyTolerance, eFeatureClassType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage.Clean() returned %ld", (long)hr);
        goto icoverage_clean_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dangleTolerance
    // No teardown for fuzzyTolerance
    // No teardown for FeatureClassType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoverage_clean_method_cleanup;

    icoverage_clean_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dangleTolerance
    // No cleanup for fuzzyTolerance
    // No cleanup for FeatureClassType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage.Clean");
    return return_tuple;
}

static PyObject*
ICoverageMethod_CreateFeatureClass(PyICoverageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;
    BSTR bssubclassName = 0;
    PyObject* pyvar_subclassName;
    PyObject* unicodesubclassName = NULL;
    IFeatureClass* ipfeatureClass = NULL;
    PyObject* py_featureClass = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eFeatureClassType, &pyvar_subclassName))
      goto icoverage_createfeatureclass_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FeatureClassType
    if (PyString_Check(pyvar_subclassName))
        unicodesubclassName = PyUnicode_FromObject(pyvar_subclassName);
    else if (PyUnicode_Check(pyvar_subclassName))
    {
        unicodesubclassName = pyvar_subclassName;
        Py_INCREF(unicodesubclassName);
    }
    else if (pyvar_subclassName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter subclassName at index 1");
    if (unicodesubclassName)
        bssubclassName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesubclassName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesubclassName));
    
    if (PyErr_Occurred())
      goto icoverage_createfeatureclass_method_cleanup;
    
    // No setup for featureClass

    // Call method on actual COM interface
    hr = self->m_pICoverage->CreateFeatureClass(eFeatureClassType, bssubclassName, &ipfeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage.CreateFeatureClass() returned %ld", (long)hr);
        goto icoverage_createfeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType
    // No teardown for subclassName
    Py_XDECREF(py_featureClass);
    if (ipfeatureClass)
    {
        IUnknown* pUnk = NULL;
        ipfeatureClass->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_featureClass = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_featureClass)
    {
        if (py_featureClass)
           Py_DECREF(py_featureClass);
        py_featureClass = Py_None;
        Py_INCREF(py_featureClass);
    }
    if (PyErr_Occurred())
      goto icoverage_createfeatureclass_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_featureClass);
    goto icoverage_createfeatureclass_method_cleanup;

    icoverage_createfeatureclass_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (bssubclassName)
        ::SysFreeString(bssubclassName);
    
    Py_XDECREF(py_featureClass);
    if (ipfeatureClass)
      ipfeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage.CreateFeatureClass");
    return return_tuple;
}


PyMethodDef PyICoverageMethods[] = {
    {"supports", (PyCFunction)PyICoverage_SupportsInterface, METH_O, ""},
    {"get_Tolerance", (PyCFunction)ICoverageMethod_get_Tolerance, METH_VARARGS, ""},
    {"get_ToleranceStatus", (PyCFunction)ICoverageMethod_get_ToleranceStatus, METH_VARARGS, ""},
    {"put_Tolerance", (PyCFunction)ICoverageMethod_put_Tolerance, METH_VARARGS, ""},
    {"Build", (PyCFunction)ICoverageMethod_Build, METH_VARARGS, ""},
    {"Clean", (PyCFunction)ICoverageMethod_Clean, METH_VARARGS, ""},
    {"CreateFeatureClass", (PyCFunction)ICoverageMethod_CreateFeatureClass, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICoverageGetSet[] = {
  {"_pUnk", (getter)PyICoverage_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICoverage", NULL},
  {"_pointer", (getter)PyICoverage_GetPointer, NULL, "Get memory address for ICoverage", NULL},
  {"_IID", (getter)PyICoverage_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICoverage_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICoverage_GetIgnoreFailures, (setter)PyICoverage_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICoverageObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICoverageObject",                          
                                              /* tp_name */
  sizeof(PyICoverageObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICoverageObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICoverageMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICoverageGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICoverageObject_new,                      
                                              /* tp_new */
};

// Interface ICoverage2

typedef struct PyICoverage2Object {
    PyObject_HEAD
    ICoverage2* m_pICoverage2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICoverage2Object;

static PyObject*
PyICoverage2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICoverage2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICoverage2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICoverage2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICoverage2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICoverage2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverage2");
            return NULL;
        }
        self->m_pICoverage2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICoverage2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICoverage2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICoverage2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICoverage2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICoverage2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICoverage2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverage2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICoverage2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICoverage2Object_dealloc(PyICoverage2Object* self)
{
    if (self->m_pICoverage2)
        self->m_pICoverage2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICoverage2_GetpUnk(PyICoverage2Object* self)
{
    if (!self->m_pICoverage2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICoverage2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICoverage2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICoverage2_GetPointer(PyICoverage2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICoverage2);
}

static PyObject*
PyICoverage2_GetIID(PyICoverage2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d1e706bc-6eee-11d4-9f55-00c04f79927c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICoverage2_GetHR(PyICoverage2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICoverage2_GetIgnoreFailures(PyICoverage2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICoverage2_SetIgnoreFailures(PyICoverage2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICoverage2_SupportsInterface(PyICoverage2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICoverage2Method_put_Extent(PyICoverage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto icoverage2_put_extent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IEnvelope, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto icoverage2_put_extent_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICoverage2->put_Extent(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage2.put_Extent() returned %ld", (long)hr);
        goto icoverage2_put_extent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoverage2_put_extent_method_cleanup;

    icoverage2_put_extent_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage2.put_Extent");
    return return_tuple;
}

static PyObject*
ICoverage2Method_RefreshSpatialProperties(PyICoverage2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICoverage2->RefreshSpatialProperties();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage2.RefreshSpatialProperties() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ICoverage2Method_get_Tolerance(PyICoverage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageToleranceType etoleranceType;
    double dtoleranceValue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&etoleranceType))
      goto icoverage2_get_tolerance_method_cleanup;

    // Set up initial variable values as needed
    // No setup for toleranceType
    // No setup for toleranceValue

    // Call method on actual COM interface
    hr = self->m_pICoverage2->get_Tolerance(etoleranceType, &dtoleranceValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage2.get_Tolerance() returned %ld", (long)hr);
        goto icoverage2_get_tolerance_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for toleranceType
    // No teardown for toleranceValue

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dtoleranceValue);
    goto icoverage2_get_tolerance_method_cleanup;

    icoverage2_get_tolerance_method_cleanup:
    self->m_HR = hr;
    // No cleanup for toleranceType
    // No cleanup for toleranceValue
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage2.get_Tolerance");
    return return_tuple;
}

static PyObject*
ICoverage2Method_get_ToleranceStatus(PyICoverage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageToleranceType etoleranceType;
    VARIANT_BOOL b_isVerified = VARIANT_FALSE;
    PyObject* pyvar_isVerified = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&etoleranceType))
      goto icoverage2_get_tolerancestatus_method_cleanup;

    // Set up initial variable values as needed
    // No setup for toleranceType
    // No setup for isVerified

    // Call method on actual COM interface
    hr = self->m_pICoverage2->get_ToleranceStatus(etoleranceType, &b_isVerified);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage2.get_ToleranceStatus() returned %ld", (long)hr);
        goto icoverage2_get_tolerancestatus_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for toleranceType
    pyvar_isVerified = ((b_isVerified == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icoverage2_get_tolerancestatus_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isVerified);
    goto icoverage2_get_tolerancestatus_method_cleanup;

    icoverage2_get_tolerancestatus_method_cleanup:
    self->m_HR = hr;
    // No cleanup for toleranceType
    // No cleanup for isVerified
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage2.get_ToleranceStatus");
    return return_tuple;
}

static PyObject*
ICoverage2Method_put_Tolerance(PyICoverage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageToleranceType etoleranceType;
    double dtoleranceValue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "id", (int *)&etoleranceType, &dtoleranceValue))
      goto icoverage2_put_tolerance_method_cleanup;

    // Set up initial variable values as needed
    // No setup for toleranceType
    // No setup for toleranceValue

    // Call method on actual COM interface
    hr = self->m_pICoverage2->put_Tolerance(etoleranceType, dtoleranceValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage2.put_Tolerance() returned %ld", (long)hr);
        goto icoverage2_put_tolerance_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for toleranceType
    // No teardown for toleranceValue

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoverage2_put_tolerance_method_cleanup;

    icoverage2_put_tolerance_method_cleanup:
    self->m_HR = hr;
    // No cleanup for toleranceType
    // No cleanup for toleranceValue
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage2.put_Tolerance");
    return return_tuple;
}

static PyObject*
ICoverage2Method_Build(PyICoverage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;
    BSTR bssubclassName = 0;
    PyObject* pyvar_subclassName;
    PyObject* unicodesubclassName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eFeatureClassType, &pyvar_subclassName))
      goto icoverage2_build_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FeatureClassType
    if (PyString_Check(pyvar_subclassName))
        unicodesubclassName = PyUnicode_FromObject(pyvar_subclassName);
    else if (PyUnicode_Check(pyvar_subclassName))
    {
        unicodesubclassName = pyvar_subclassName;
        Py_INCREF(unicodesubclassName);
    }
    else if (pyvar_subclassName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter subclassName at index 1");
    if (unicodesubclassName)
        bssubclassName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesubclassName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesubclassName));
    
    if (PyErr_Occurred())
      goto icoverage2_build_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICoverage2->Build(eFeatureClassType, bssubclassName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage2.Build() returned %ld", (long)hr);
        goto icoverage2_build_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType
    // No teardown for subclassName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoverage2_build_method_cleanup;

    icoverage2_build_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (bssubclassName)
        ::SysFreeString(bssubclassName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage2.Build");
    return return_tuple;
}

static PyObject*
ICoverage2Method_Clean(PyICoverage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double ddangleTolerance = 0;
    double dfuzzyTolerance = 0;
    esriCoverageFeatureClassType eFeatureClassType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ddi", &ddangleTolerance, &dfuzzyTolerance, (int *)&eFeatureClassType))
      goto icoverage2_clean_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dangleTolerance
    // No setup for fuzzyTolerance
    // No setup for FeatureClassType

    // Call method on actual COM interface
    hr = self->m_pICoverage2->Clean(ddangleTolerance, dfuzzyTolerance, eFeatureClassType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage2.Clean() returned %ld", (long)hr);
        goto icoverage2_clean_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dangleTolerance
    // No teardown for fuzzyTolerance
    // No teardown for FeatureClassType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoverage2_clean_method_cleanup;

    icoverage2_clean_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dangleTolerance
    // No cleanup for fuzzyTolerance
    // No cleanup for FeatureClassType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage2.Clean");
    return return_tuple;
}

static PyObject*
ICoverage2Method_CreateFeatureClass(PyICoverage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;
    BSTR bssubclassName = 0;
    PyObject* pyvar_subclassName;
    PyObject* unicodesubclassName = NULL;
    IFeatureClass* ipfeatureClass = NULL;
    PyObject* py_featureClass = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eFeatureClassType, &pyvar_subclassName))
      goto icoverage2_createfeatureclass_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FeatureClassType
    if (PyString_Check(pyvar_subclassName))
        unicodesubclassName = PyUnicode_FromObject(pyvar_subclassName);
    else if (PyUnicode_Check(pyvar_subclassName))
    {
        unicodesubclassName = pyvar_subclassName;
        Py_INCREF(unicodesubclassName);
    }
    else if (pyvar_subclassName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter subclassName at index 1");
    if (unicodesubclassName)
        bssubclassName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesubclassName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesubclassName));
    
    if (PyErr_Occurred())
      goto icoverage2_createfeatureclass_method_cleanup;
    
    // No setup for featureClass

    // Call method on actual COM interface
    hr = self->m_pICoverage2->CreateFeatureClass(eFeatureClassType, bssubclassName, &ipfeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverage2.CreateFeatureClass() returned %ld", (long)hr);
        goto icoverage2_createfeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType
    // No teardown for subclassName
    Py_XDECREF(py_featureClass);
    if (ipfeatureClass)
    {
        IUnknown* pUnk = NULL;
        ipfeatureClass->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_featureClass = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_featureClass)
    {
        if (py_featureClass)
           Py_DECREF(py_featureClass);
        py_featureClass = Py_None;
        Py_INCREF(py_featureClass);
    }
    if (PyErr_Occurred())
      goto icoverage2_createfeatureclass_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_featureClass);
    goto icoverage2_createfeatureclass_method_cleanup;

    icoverage2_createfeatureclass_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (bssubclassName)
        ::SysFreeString(bssubclassName);
    
    Py_XDECREF(py_featureClass);
    if (ipfeatureClass)
      ipfeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverage2.CreateFeatureClass");
    return return_tuple;
}


PyMethodDef PyICoverage2Methods[] = {
    {"supports", (PyCFunction)PyICoverage2_SupportsInterface, METH_O, ""},
    {"put_Extent", (PyCFunction)ICoverage2Method_put_Extent, METH_VARARGS, ""},
    {"RefreshSpatialProperties", (PyCFunction)ICoverage2Method_RefreshSpatialProperties, METH_NOARGS, ""},
    {"get_Tolerance", (PyCFunction)ICoverage2Method_get_Tolerance, METH_VARARGS, ""},
    {"get_ToleranceStatus", (PyCFunction)ICoverage2Method_get_ToleranceStatus, METH_VARARGS, ""},
    {"put_Tolerance", (PyCFunction)ICoverage2Method_put_Tolerance, METH_VARARGS, ""},
    {"Build", (PyCFunction)ICoverage2Method_Build, METH_VARARGS, ""},
    {"Clean", (PyCFunction)ICoverage2Method_Clean, METH_VARARGS, ""},
    {"CreateFeatureClass", (PyCFunction)ICoverage2Method_CreateFeatureClass, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICoverage2GetSet[] = {
  {"_pUnk", (getter)PyICoverage2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICoverage2", NULL},
  {"_pointer", (getter)PyICoverage2_GetPointer, NULL, "Get memory address for ICoverage2", NULL},
  {"_IID", (getter)PyICoverage2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICoverage2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICoverage2_GetIgnoreFailures, (setter)PyICoverage2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICoverage2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICoverage2Object",                          
                                              /* tp_name */
  sizeof(PyICoverage2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICoverage2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICoverage2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICoverage2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICoverage2Object_new,                      
                                              /* tp_new */
};

// Interface IArcInfoWorkspace

typedef struct PyIArcInfoWorkspaceObject {
    PyObject_HEAD
    IArcInfoWorkspace* m_pIArcInfoWorkspace;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcInfoWorkspaceObject;

static PyObject*
PyIArcInfoWorkspaceObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcInfoWorkspaceObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcInfoWorkspace* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcInfoWorkspace, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcInfoWorkspace with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcInfoWorkspaceObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoWorkspace");
            return NULL;
        }
        self->m_pIArcInfoWorkspace = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcInfoWorkspace");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcInfoWorkspace");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcInfoWorkspace* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcInfoWorkspace, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcInfoWorkspace");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcInfoWorkspaceObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoWorkspace");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcInfoWorkspace = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcInfoWorkspaceObject_dealloc(PyIArcInfoWorkspaceObject* self)
{
    if (self->m_pIArcInfoWorkspace)
        self->m_pIArcInfoWorkspace->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcInfoWorkspace_GetpUnk(PyIArcInfoWorkspaceObject* self)
{
    if (!self->m_pIArcInfoWorkspace)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcInfoWorkspace->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcInfoWorkspace to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcInfoWorkspace_GetPointer(PyIArcInfoWorkspaceObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcInfoWorkspace);
}

static PyObject*
PyIArcInfoWorkspace_GetIID(PyIArcInfoWorkspaceObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "730e2ff7-e3b4-11d2-9f30-00c04f79927c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcInfoWorkspace_GetHR(PyIArcInfoWorkspaceObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcInfoWorkspace_GetIgnoreFailures(PyIArcInfoWorkspaceObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcInfoWorkspace_SetIgnoreFailures(PyIArcInfoWorkspaceObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcInfoWorkspace_SupportsInterface(PyIArcInfoWorkspaceObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcInfoWorkspace->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcInfoWorkspaceMethod_CreateCoverage(PyIArcInfoWorkspaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bstemplateCoverage = 0;
    PyObject* pyvar_templateCoverage;
    PyObject* unicodetemplateCoverage = NULL;
    esriCoveragePrecisionType eprecision;
    IFeatureDataset* ipfeatureDataset = NULL;
    PyObject* py_featureDataset = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOi", &pyvar_Name, &pyvar_templateCoverage, (int *)&eprecision))
      goto iarcinfoworkspace_createcoverage_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iarcinfoworkspace_createcoverage_method_cleanup;
    
    if (PyString_Check(pyvar_templateCoverage))
        unicodetemplateCoverage = PyUnicode_FromObject(pyvar_templateCoverage);
    else if (PyUnicode_Check(pyvar_templateCoverage))
    {
        unicodetemplateCoverage = pyvar_templateCoverage;
        Py_INCREF(unicodetemplateCoverage);
    }
    else if (pyvar_templateCoverage != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter templateCoverage at index 1");
    if (unicodetemplateCoverage)
        bstemplateCoverage = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetemplateCoverage), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetemplateCoverage));
    
    if (PyErr_Occurred())
      goto iarcinfoworkspace_createcoverage_method_cleanup;
    
    // No setup for precision
    // No setup for featureDataset

    // Call method on actual COM interface
    hr = self->m_pIArcInfoWorkspace->CreateCoverage(bsName, bstemplateCoverage, eprecision, &ipfeatureDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoWorkspace->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoWorkspace) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoWorkspace.CreateCoverage() returned %ld", (long)hr);
        goto iarcinfoworkspace_createcoverage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for templateCoverage
    // No teardown for precision
    Py_XDECREF(py_featureDataset);
    if (ipfeatureDataset)
    {
        IUnknown* pUnk = NULL;
        ipfeatureDataset->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_featureDataset = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureDataset);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_featureDataset)
    {
        if (py_featureDataset)
           Py_DECREF(py_featureDataset);
        py_featureDataset = Py_None;
        Py_INCREF(py_featureDataset);
    }
    if (PyErr_Occurred())
      goto iarcinfoworkspace_createcoverage_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_featureDataset);
    goto iarcinfoworkspace_createcoverage_method_cleanup;

    iarcinfoworkspace_createcoverage_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bstemplateCoverage)
        ::SysFreeString(bstemplateCoverage);
    
    // No cleanup for precision
    Py_XDECREF(py_featureDataset);
    if (ipfeatureDataset)
      ipfeatureDataset->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoWorkspace.CreateCoverage");
    return return_tuple;
}

static PyObject*
IArcInfoWorkspaceMethod_CreateInfoTable(PyIArcInfoWorkspaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    IArcInfoItems* ipItemSet = NULL;
    PyObject* py_ItemSet;
    ITable* ipTable = NULL;
    PyObject* py_Table = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_Name, &py_ItemSet))
      goto iarcinfoworkspace_createinfotable_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iarcinfoworkspace_createinfotable_method_cleanup;
    
    if (!IFaceFromPyObject(py_ItemSet, &IID_IArcInfoItems, (void**)&ipItemSet))
        PyErr_SetString(PyExc_TypeError, "Argument ItemSet (position 1) is not IArcInfoItems");
    
    if (PyErr_Occurred())
      goto iarcinfoworkspace_createinfotable_method_cleanup;
    
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pIArcInfoWorkspace->CreateInfoTable(bsName, ipItemSet, &ipTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoWorkspace->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoWorkspace) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoWorkspace.CreateInfoTable() returned %ld", (long)hr);
        goto iarcinfoworkspace_createinfotable_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for ItemSet
    Py_XDECREF(py_Table);
    if (ipTable)
    {
        IUnknown* pUnk = NULL;
        ipTable->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Table = IUnknownToPythonIIDObject(pUnk, &IID_ITable);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Table)
    {
        if (py_Table)
           Py_DECREF(py_Table);
        py_Table = Py_None;
        Py_INCREF(py_Table);
    }
    if (PyErr_Occurred())
      goto iarcinfoworkspace_createinfotable_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Table);
    goto iarcinfoworkspace_createinfotable_method_cleanup;

    iarcinfoworkspace_createinfotable_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (ipItemSet)
      ipItemSet->Release();
    Py_XDECREF(py_Table);
    if (ipTable)
      ipTable->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoWorkspace.CreateInfoTable");
    return return_tuple;
}


PyMethodDef PyIArcInfoWorkspaceMethods[] = {
    {"supports", (PyCFunction)PyIArcInfoWorkspace_SupportsInterface, METH_O, ""},
    {"CreateCoverage", (PyCFunction)IArcInfoWorkspaceMethod_CreateCoverage, METH_VARARGS, ""},
    {"CreateInfoTable", (PyCFunction)IArcInfoWorkspaceMethod_CreateInfoTable, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcInfoWorkspaceGetSet[] = {
  {"_pUnk", (getter)PyIArcInfoWorkspace_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcInfoWorkspace", NULL},
  {"_pointer", (getter)PyIArcInfoWorkspace_GetPointer, NULL, "Get memory address for IArcInfoWorkspace", NULL},
  {"_IID", (getter)PyIArcInfoWorkspace_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcInfoWorkspace_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcInfoWorkspace_GetIgnoreFailures, (setter)PyIArcInfoWorkspace_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcInfoWorkspaceObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IArcInfoWorkspaceObject",                          
                                              /* tp_name */
  sizeof(PyIArcInfoWorkspaceObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcInfoWorkspaceObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcInfoWorkspaceMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcInfoWorkspaceGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcInfoWorkspaceObject_new,                      
                                              /* tp_new */
};

// Interface IInfoTableOnlyWorkspaceEdit

typedef struct PyIInfoTableOnlyWorkspaceEditObject {
    PyObject_HEAD
    IInfoTableOnlyWorkspaceEdit* m_pIInfoTableOnlyWorkspaceEdit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIInfoTableOnlyWorkspaceEditObject;

static PyObject*
PyIInfoTableOnlyWorkspaceEditObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIInfoTableOnlyWorkspaceEditObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IInfoTableOnlyWorkspaceEdit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IInfoTableOnlyWorkspaceEdit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IInfoTableOnlyWorkspaceEdit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIInfoTableOnlyWorkspaceEditObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IInfoTableOnlyWorkspaceEdit");
            return NULL;
        }
        self->m_pIInfoTableOnlyWorkspaceEdit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IInfoTableOnlyWorkspaceEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IInfoTableOnlyWorkspaceEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IInfoTableOnlyWorkspaceEdit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IInfoTableOnlyWorkspaceEdit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IInfoTableOnlyWorkspaceEdit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIInfoTableOnlyWorkspaceEditObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IInfoTableOnlyWorkspaceEdit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIInfoTableOnlyWorkspaceEdit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIInfoTableOnlyWorkspaceEditObject_dealloc(PyIInfoTableOnlyWorkspaceEditObject* self)
{
    if (self->m_pIInfoTableOnlyWorkspaceEdit)
        self->m_pIInfoTableOnlyWorkspaceEdit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIInfoTableOnlyWorkspaceEdit_GetpUnk(PyIInfoTableOnlyWorkspaceEditObject* self)
{
    if (!self->m_pIInfoTableOnlyWorkspaceEdit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIInfoTableOnlyWorkspaceEdit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IInfoTableOnlyWorkspaceEdit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIInfoTableOnlyWorkspaceEdit_GetPointer(PyIInfoTableOnlyWorkspaceEditObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIInfoTableOnlyWorkspaceEdit);
}

static PyObject*
PyIInfoTableOnlyWorkspaceEdit_GetIID(PyIInfoTableOnlyWorkspaceEditObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "215b5973-795c-499f-b3ff-798c1cd4dbe6");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIInfoTableOnlyWorkspaceEdit_GetHR(PyIInfoTableOnlyWorkspaceEditObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIInfoTableOnlyWorkspaceEdit_GetIgnoreFailures(PyIInfoTableOnlyWorkspaceEditObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIInfoTableOnlyWorkspaceEdit_SetIgnoreFailures(PyIInfoTableOnlyWorkspaceEditObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIInfoTableOnlyWorkspaceEdit_SupportsInterface(PyIInfoTableOnlyWorkspaceEditObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIInfoTableOnlyWorkspaceEdit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IInfoTableOnlyWorkspaceEditMethod_StartEditingTablesOnly(PyIInfoTableOnlyWorkspaceEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_withUndoRedo = VARIANT_FALSE;
    PyObject* pyvar_withUndoRedo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_withUndoRedo))
      goto iinfotableonlyworkspaceedit_starteditingtablesonly_method_cleanup;

    // Set up initial variable values as needed
    b_withUndoRedo = ((PyObject_IsTrue(pyvar_withUndoRedo) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iinfotableonlyworkspaceedit_starteditingtablesonly_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIInfoTableOnlyWorkspaceEdit->StartEditingTablesOnly(b_withUndoRedo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInfoTableOnlyWorkspaceEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInfoTableOnlyWorkspaceEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInfoTableOnlyWorkspaceEdit.StartEditingTablesOnly() returned %ld", (long)hr);
        goto iinfotableonlyworkspaceedit_starteditingtablesonly_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for withUndoRedo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iinfotableonlyworkspaceedit_starteditingtablesonly_method_cleanup;

    iinfotableonlyworkspaceedit_starteditingtablesonly_method_cleanup:
    self->m_HR = hr;
    // No cleanup for withUndoRedo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInfoTableOnlyWorkspaceEdit.StartEditingTablesOnly");
    return return_tuple;
}


PyMethodDef PyIInfoTableOnlyWorkspaceEditMethods[] = {
    {"supports", (PyCFunction)PyIInfoTableOnlyWorkspaceEdit_SupportsInterface, METH_O, ""},
    {"StartEditingTablesOnly", (PyCFunction)IInfoTableOnlyWorkspaceEditMethod_StartEditingTablesOnly, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIInfoTableOnlyWorkspaceEditGetSet[] = {
  {"_pUnk", (getter)PyIInfoTableOnlyWorkspaceEdit_GetpUnk, NULL, "Get opaque pointer to an Unknown from IInfoTableOnlyWorkspaceEdit", NULL},
  {"_pointer", (getter)PyIInfoTableOnlyWorkspaceEdit_GetPointer, NULL, "Get memory address for IInfoTableOnlyWorkspaceEdit", NULL},
  {"_IID", (getter)PyIInfoTableOnlyWorkspaceEdit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIInfoTableOnlyWorkspaceEdit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIInfoTableOnlyWorkspaceEdit_GetIgnoreFailures, (setter)PyIInfoTableOnlyWorkspaceEdit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIInfoTableOnlyWorkspaceEditObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IInfoTableOnlyWorkspaceEditObject",                          
                                              /* tp_name */
  sizeof(PyIInfoTableOnlyWorkspaceEditObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIInfoTableOnlyWorkspaceEditObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIInfoTableOnlyWorkspaceEditMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIInfoTableOnlyWorkspaceEditGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIInfoTableOnlyWorkspaceEditObject_new,                      
                                              /* tp_new */
};

// Interface ICoverageFeatureClassName

typedef struct PyICoverageFeatureClassNameObject {
    PyObject_HEAD
    ICoverageFeatureClassName* m_pICoverageFeatureClassName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICoverageFeatureClassNameObject;

static PyObject*
PyICoverageFeatureClassNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICoverageFeatureClassNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICoverageFeatureClassName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICoverageFeatureClassName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICoverageFeatureClassName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICoverageFeatureClassNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverageFeatureClassName");
            return NULL;
        }
        self->m_pICoverageFeatureClassName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICoverageFeatureClassName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICoverageFeatureClassName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICoverageFeatureClassName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICoverageFeatureClassName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICoverageFeatureClassName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICoverageFeatureClassNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverageFeatureClassName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICoverageFeatureClassName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICoverageFeatureClassNameObject_dealloc(PyICoverageFeatureClassNameObject* self)
{
    if (self->m_pICoverageFeatureClassName)
        self->m_pICoverageFeatureClassName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICoverageFeatureClassName_GetpUnk(PyICoverageFeatureClassNameObject* self)
{
    if (!self->m_pICoverageFeatureClassName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICoverageFeatureClassName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICoverageFeatureClassName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICoverageFeatureClassName_GetPointer(PyICoverageFeatureClassNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICoverageFeatureClassName);
}

static PyObject*
PyICoverageFeatureClassName_GetIID(PyICoverageFeatureClassNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "de61a107-0e08-11d3-9f31-00c04f79927c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICoverageFeatureClassName_GetHR(PyICoverageFeatureClassNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICoverageFeatureClassName_GetIgnoreFailures(PyICoverageFeatureClassNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICoverageFeatureClassName_SetIgnoreFailures(PyICoverageFeatureClassNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICoverageFeatureClassName_SupportsInterface(PyICoverageFeatureClassNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICoverageFeatureClassName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICoverageFeatureClassNameMethod_get_FeatureClassType(PyICoverageFeatureClassNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FeatureClassType

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClassName->get_FeatureClassType(&eFeatureClassType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClassName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClassName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClassName.get_FeatureClassType() returned %ld", (long)hr);
        goto icoveragefeatureclassname_get_featureclasstype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eFeatureClassType);
    goto icoveragefeatureclassname_get_featureclasstype_method_cleanup;

    icoveragefeatureclassname_get_featureclasstype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClassName.get_FeatureClassType");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClassNameMethod_put_FeatureClassType(PyICoverageFeatureClassNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eFeatureClassType))
      goto icoveragefeatureclassname_put_featureclasstype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FeatureClassType

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClassName->put_FeatureClassType(eFeatureClassType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClassName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClassName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClassName.put_FeatureClassType() returned %ld", (long)hr);
        goto icoveragefeatureclassname_put_featureclasstype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoveragefeatureclassname_put_featureclasstype_method_cleanup;

    icoveragefeatureclassname_put_featureclasstype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClassName.put_FeatureClassType");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClassNameMethod_get_Topology(PyICoverageFeatureClassNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureClassTopology eTopology;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Topology

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClassName->get_Topology(&eTopology);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClassName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClassName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClassName.get_Topology() returned %ld", (long)hr);
        goto icoveragefeatureclassname_get_topology_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Topology

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eTopology);
    goto icoveragefeatureclassname_get_topology_method_cleanup;

    icoveragefeatureclassname_get_topology_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Topology
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClassName.get_Topology");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClassNameMethod_put_Topology(PyICoverageFeatureClassNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureClassTopology eTopology;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eTopology))
      goto icoveragefeatureclassname_put_topology_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Topology

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClassName->put_Topology(eTopology);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClassName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClassName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClassName.put_Topology() returned %ld", (long)hr);
        goto icoveragefeatureclassname_put_topology_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Topology

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoveragefeatureclassname_put_topology_method_cleanup;

    icoveragefeatureclassname_put_topology_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Topology
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClassName.put_Topology");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClassNameMethod_get_HasFAT(PyICoverageFeatureClassNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HasFAT = VARIANT_FALSE;
    PyObject* pyvar_HasFAT = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HasFAT

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClassName->get_HasFAT(&b_HasFAT);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClassName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClassName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClassName.get_HasFAT() returned %ld", (long)hr);
        goto icoveragefeatureclassname_get_hasfat_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HasFAT = ((b_HasFAT == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icoveragefeatureclassname_get_hasfat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HasFAT);
    goto icoveragefeatureclassname_get_hasfat_method_cleanup;

    icoveragefeatureclassname_get_hasfat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HasFAT
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClassName.get_HasFAT");
    return return_tuple;
}

static PyObject*
ICoverageFeatureClassNameMethod_put_HasFAT(PyICoverageFeatureClassNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HasFAT = VARIANT_FALSE;
    PyObject* pyvar_HasFAT = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_HasFAT))
      goto icoveragefeatureclassname_put_hasfat_method_cleanup;

    // Set up initial variable values as needed
    b_HasFAT = ((PyObject_IsTrue(pyvar_HasFAT) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icoveragefeatureclassname_put_hasfat_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICoverageFeatureClassName->put_HasFAT(b_HasFAT);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageFeatureClassName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageFeatureClassName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageFeatureClassName.put_HasFAT() returned %ld", (long)hr);
        goto icoveragefeatureclassname_put_hasfat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HasFAT

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoveragefeatureclassname_put_hasfat_method_cleanup;

    icoveragefeatureclassname_put_hasfat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HasFAT
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageFeatureClassName.put_HasFAT");
    return return_tuple;
}


PyMethodDef PyICoverageFeatureClassNameMethods[] = {
    {"supports", (PyCFunction)PyICoverageFeatureClassName_SupportsInterface, METH_O, ""},
    {"get_FeatureClassType", (PyCFunction)ICoverageFeatureClassNameMethod_get_FeatureClassType, METH_VARARGS, ""},
    {"put_FeatureClassType", (PyCFunction)ICoverageFeatureClassNameMethod_put_FeatureClassType, METH_VARARGS, ""},
    {"get_Topology", (PyCFunction)ICoverageFeatureClassNameMethod_get_Topology, METH_VARARGS, ""},
    {"put_Topology", (PyCFunction)ICoverageFeatureClassNameMethod_put_Topology, METH_VARARGS, ""},
    {"get_HasFAT", (PyCFunction)ICoverageFeatureClassNameMethod_get_HasFAT, METH_VARARGS, ""},
    {"put_HasFAT", (PyCFunction)ICoverageFeatureClassNameMethod_put_HasFAT, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICoverageFeatureClassNameGetSet[] = {
  {"_pUnk", (getter)PyICoverageFeatureClassName_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICoverageFeatureClassName", NULL},
  {"_pointer", (getter)PyICoverageFeatureClassName_GetPointer, NULL, "Get memory address for ICoverageFeatureClassName", NULL},
  {"_IID", (getter)PyICoverageFeatureClassName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICoverageFeatureClassName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICoverageFeatureClassName_GetIgnoreFailures, (setter)PyICoverageFeatureClassName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICoverageFeatureClassNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICoverageFeatureClassNameObject",                          
                                              /* tp_name */
  sizeof(PyICoverageFeatureClassNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICoverageFeatureClassNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICoverageFeatureClassNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICoverageFeatureClassNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICoverageFeatureClassNameObject_new,                      
                                              /* tp_new */
};

// Interface ICoverageName

typedef struct PyICoverageNameObject {
    PyObject_HEAD
    ICoverageName* m_pICoverageName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICoverageNameObject;

static PyObject*
PyICoverageNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICoverageNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICoverageName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICoverageName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICoverageName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICoverageNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverageName");
            return NULL;
        }
        self->m_pICoverageName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICoverageName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICoverageName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICoverageName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICoverageName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICoverageName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICoverageNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoverageName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICoverageName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICoverageNameObject_dealloc(PyICoverageNameObject* self)
{
    if (self->m_pICoverageName)
        self->m_pICoverageName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICoverageName_GetpUnk(PyICoverageNameObject* self)
{
    if (!self->m_pICoverageName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICoverageName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICoverageName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICoverageName_GetPointer(PyICoverageNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICoverageName);
}

static PyObject*
PyICoverageName_GetIID(PyICoverageNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "de61a108-0e08-11d3-9f31-00c04f79927c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICoverageName_GetHR(PyICoverageNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICoverageName_GetIgnoreFailures(PyICoverageNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICoverageName_SetIgnoreFailures(PyICoverageNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICoverageName_SupportsInterface(PyICoverageNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICoverageName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICoverageNameMethod_get_CoverageType(PyICoverageNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageType eCoverageType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CoverageType

    // Call method on actual COM interface
    hr = self->m_pICoverageName->get_CoverageType(&eCoverageType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageName.get_CoverageType() returned %ld", (long)hr);
        goto icoveragename_get_coveragetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for CoverageType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eCoverageType);
    goto icoveragename_get_coveragetype_method_cleanup;

    icoveragename_get_coveragetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for CoverageType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageName.get_CoverageType");
    return return_tuple;
}

static PyObject*
ICoverageNameMethod_put_CoverageType(PyICoverageNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageType eCoverageType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eCoverageType))
      goto icoveragename_put_coveragetype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for CoverageType

    // Call method on actual COM interface
    hr = self->m_pICoverageName->put_CoverageType(eCoverageType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoverageName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoverageName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoverageName.put_CoverageType() returned %ld", (long)hr);
        goto icoveragename_put_coveragetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for CoverageType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icoveragename_put_coveragetype_method_cleanup;

    icoveragename_put_coveragetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for CoverageType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoverageName.put_CoverageType");
    return return_tuple;
}


PyMethodDef PyICoverageNameMethods[] = {
    {"supports", (PyCFunction)PyICoverageName_SupportsInterface, METH_O, ""},
    {"get_CoverageType", (PyCFunction)ICoverageNameMethod_get_CoverageType, METH_VARARGS, ""},
    {"put_CoverageType", (PyCFunction)ICoverageNameMethod_put_CoverageType, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICoverageNameGetSet[] = {
  {"_pUnk", (getter)PyICoverageName_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICoverageName", NULL},
  {"_pointer", (getter)PyICoverageName_GetPointer, NULL, "Get memory address for ICoverageName", NULL},
  {"_IID", (getter)PyICoverageName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICoverageName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICoverageName_GetIgnoreFailures, (setter)PyICoverageName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICoverageNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICoverageNameObject",                          
                                              /* tp_name */
  sizeof(PyICoverageNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICoverageNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICoverageNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICoverageNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICoverageNameObject_new,                      
                                              /* tp_new */
};

// Interface IArcInfoWorkspaceUtil

typedef struct PyIArcInfoWorkspaceUtilObject {
    PyObject_HEAD
    IArcInfoWorkspaceUtil* m_pIArcInfoWorkspaceUtil;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcInfoWorkspaceUtilObject;

static PyObject*
PyIArcInfoWorkspaceUtilObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcInfoWorkspaceUtilObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcInfoWorkspaceUtil* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcInfoWorkspaceUtil, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcInfoWorkspaceUtil with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcInfoWorkspaceUtilObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoWorkspaceUtil");
            return NULL;
        }
        self->m_pIArcInfoWorkspaceUtil = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcInfoWorkspaceUtil");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcInfoWorkspaceUtil");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcInfoWorkspaceUtil* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcInfoWorkspaceUtil, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcInfoWorkspaceUtil");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcInfoWorkspaceUtilObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcInfoWorkspaceUtil");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcInfoWorkspaceUtil = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcInfoWorkspaceUtilObject_dealloc(PyIArcInfoWorkspaceUtilObject* self)
{
    if (self->m_pIArcInfoWorkspaceUtil)
        self->m_pIArcInfoWorkspaceUtil->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcInfoWorkspaceUtil_GetpUnk(PyIArcInfoWorkspaceUtilObject* self)
{
    if (!self->m_pIArcInfoWorkspaceUtil)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcInfoWorkspaceUtil->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcInfoWorkspaceUtil to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcInfoWorkspaceUtil_GetPointer(PyIArcInfoWorkspaceUtilObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcInfoWorkspaceUtil);
}

static PyObject*
PyIArcInfoWorkspaceUtil_GetIID(PyIArcInfoWorkspaceUtilObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a476810a-0c8d-469a-8332-7b3c1cfb8923");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcInfoWorkspaceUtil_GetHR(PyIArcInfoWorkspaceUtilObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcInfoWorkspaceUtil_GetIgnoreFailures(PyIArcInfoWorkspaceUtilObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcInfoWorkspaceUtil_SetIgnoreFailures(PyIArcInfoWorkspaceUtilObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcInfoWorkspaceUtil_SupportsInterface(PyIArcInfoWorkspaceUtilObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcInfoWorkspaceUtil->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcInfoWorkspaceUtilMethod_GetInfoTableName(PyIArcInfoWorkspaceUtilObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsprefix = 0;
    PyObject* pyvar_prefix;
    PyObject* unicodeprefix = NULL;
    BSTR bspTableName;
    PyObject* pyvar_pTableName = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_prefix))
      goto iarcinfoworkspaceutil_getinfotablename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_prefix))
        unicodeprefix = PyUnicode_FromObject(pyvar_prefix);
    else if (PyUnicode_Check(pyvar_prefix))
    {
        unicodeprefix = pyvar_prefix;
        Py_INCREF(unicodeprefix);
    }
    else if (pyvar_prefix != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter prefix at index 0");
    if (unicodeprefix)
        bsprefix = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeprefix), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeprefix));
    
    if (PyErr_Occurred())
      goto iarcinfoworkspaceutil_getinfotablename_method_cleanup;
    
    // No setup for pTableName

    // Call method on actual COM interface
    hr = self->m_pIArcInfoWorkspaceUtil->GetInfoTableName(bsprefix, &bspTableName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcInfoWorkspaceUtil->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcInfoWorkspaceUtil) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcInfoWorkspaceUtil.GetInfoTableName() returned %ld", (long)hr);
        goto iarcinfoworkspaceutil_getinfotablename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for prefix
    pyvar_pTableName = PyUnicode_FromWideChar(bspTableName,::SysStringLen(bspTableName));
    ::SysFreeString(bspTableName);
    
    if (PyErr_Occurred())
      goto iarcinfoworkspaceutil_getinfotablename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pTableName);
    goto iarcinfoworkspaceutil_getinfotablename_method_cleanup;

    iarcinfoworkspaceutil_getinfotablename_method_cleanup:
    self->m_HR = hr;
    if (bsprefix)
        ::SysFreeString(bsprefix);
    
    if (pyvar_pTableName != Py_None)
        Py_XDECREF(pyvar_pTableName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcInfoWorkspaceUtil.GetInfoTableName");
    return return_tuple;
}


PyMethodDef PyIArcInfoWorkspaceUtilMethods[] = {
    {"supports", (PyCFunction)PyIArcInfoWorkspaceUtil_SupportsInterface, METH_O, ""},
    {"GetInfoTableName", (PyCFunction)IArcInfoWorkspaceUtilMethod_GetInfoTableName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcInfoWorkspaceUtilGetSet[] = {
  {"_pUnk", (getter)PyIArcInfoWorkspaceUtil_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcInfoWorkspaceUtil", NULL},
  {"_pointer", (getter)PyIArcInfoWorkspaceUtil_GetPointer, NULL, "Get memory address for IArcInfoWorkspaceUtil", NULL},
  {"_IID", (getter)PyIArcInfoWorkspaceUtil_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcInfoWorkspaceUtil_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcInfoWorkspaceUtil_GetIgnoreFailures, (setter)PyIArcInfoWorkspaceUtil_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcInfoWorkspaceUtilObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IArcInfoWorkspaceUtilObject",                          
                                              /* tp_name */
  sizeof(PyIArcInfoWorkspaceUtilObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcInfoWorkspaceUtilObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcInfoWorkspaceUtilMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcInfoWorkspaceUtilGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcInfoWorkspaceUtilObject_new,                      
                                              /* tp_new */
};

// Interface ICadSettings

typedef struct PyICadSettingsObject {
    PyObject_HEAD
    ICadSettings* m_pICadSettings;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadSettingsObject;

static PyObject*
PyICadSettingsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadSettingsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadSettings* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadSettings, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadSettings with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadSettingsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadSettings");
            return NULL;
        }
        self->m_pICadSettings = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadSettings");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadSettings");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadSettings* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadSettings, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadSettings");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadSettingsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadSettings");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadSettings = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadSettingsObject_dealloc(PyICadSettingsObject* self)
{
    if (self->m_pICadSettings)
        self->m_pICadSettings->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadSettings_GetpUnk(PyICadSettingsObject* self)
{
    if (!self->m_pICadSettings)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadSettings->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadSettings to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadSettings_GetPointer(PyICadSettingsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadSettings);
}

static PyObject*
PyICadSettings_GetIID(PyICadSettingsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "628022fd-e7df-11d4-a2a8-444553547777");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadSettings_GetHR(PyICadSettingsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadSettings_GetIgnoreFailures(PyICadSettingsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadSettings_SetIgnoreFailures(PyICadSettingsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadSettings_SupportsInterface(PyICadSettingsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadSettings->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadSettingsMethod_get_EnableAllDgnFileExtensions(PyICadSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pEnabled = VARIANT_FALSE;
    PyObject* pyvar_pEnabled = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pEnabled

    // Call method on actual COM interface
    hr = self->m_pICadSettings->get_EnableAllDgnFileExtensions(&b_pEnabled);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadSettings.get_EnableAllDgnFileExtensions() returned %ld", (long)hr);
        goto icadsettings_get_enablealldgnfileextensions_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pEnabled = ((b_pEnabled == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icadsettings_get_enablealldgnfileextensions_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pEnabled);
    goto icadsettings_get_enablealldgnfileextensions_method_cleanup;

    icadsettings_get_enablealldgnfileextensions_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pEnabled
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadSettings.get_EnableAllDgnFileExtensions");
    return return_tuple;
}

static PyObject*
ICadSettingsMethod_put_EnableAllDgnFileExtensions(PyICadSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pEnabled = VARIANT_FALSE;
    PyObject* pyvar_pEnabled = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pEnabled))
      goto icadsettings_put_enablealldgnfileextensions_method_cleanup;

    // Set up initial variable values as needed
    b_pEnabled = ((PyObject_IsTrue(pyvar_pEnabled) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadsettings_put_enablealldgnfileextensions_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadSettings->put_EnableAllDgnFileExtensions(b_pEnabled);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadSettings.put_EnableAllDgnFileExtensions() returned %ld", (long)hr);
        goto icadsettings_put_enablealldgnfileextensions_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pEnabled

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadsettings_put_enablealldgnfileextensions_method_cleanup;

    icadsettings_put_enablealldgnfileextensions_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pEnabled
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadSettings.put_EnableAllDgnFileExtensions");
    return return_tuple;
}


PyMethodDef PyICadSettingsMethods[] = {
    {"supports", (PyCFunction)PyICadSettings_SupportsInterface, METH_O, ""},
    {"get_EnableAllDgnFileExtensions", (PyCFunction)ICadSettingsMethod_get_EnableAllDgnFileExtensions, METH_VARARGS, ""},
    {"put_EnableAllDgnFileExtensions", (PyCFunction)ICadSettingsMethod_put_EnableAllDgnFileExtensions, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadSettingsGetSet[] = {
  {"_pUnk", (getter)PyICadSettings_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadSettings", NULL},
  {"_pointer", (getter)PyICadSettings_GetPointer, NULL, "Get memory address for ICadSettings", NULL},
  {"_IID", (getter)PyICadSettings_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadSettings_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadSettings_GetIgnoreFailures, (setter)PyICadSettings_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadSettingsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICadSettingsObject",                          
                                              /* tp_name */
  sizeof(PyICadSettingsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadSettingsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadSettingsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadSettingsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadSettingsObject_new,                      
                                              /* tp_new */
};

// Interface ICadDrawingLayers

typedef struct PyICadDrawingLayersObject {
    PyObject_HEAD
    ICadDrawingLayers* m_pICadDrawingLayers;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadDrawingLayersObject;

static PyObject*
PyICadDrawingLayersObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadDrawingLayersObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadDrawingLayers* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadDrawingLayers, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadDrawingLayers with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadDrawingLayersObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadDrawingLayers");
            return NULL;
        }
        self->m_pICadDrawingLayers = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadDrawingLayers");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadDrawingLayers");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadDrawingLayers* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadDrawingLayers, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadDrawingLayers");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadDrawingLayersObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadDrawingLayers");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadDrawingLayers = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadDrawingLayersObject_dealloc(PyICadDrawingLayersObject* self)
{
    if (self->m_pICadDrawingLayers)
        self->m_pICadDrawingLayers->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadDrawingLayers_GetpUnk(PyICadDrawingLayersObject* self)
{
    if (!self->m_pICadDrawingLayers)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadDrawingLayers->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadDrawingLayers to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadDrawingLayers_GetPointer(PyICadDrawingLayersObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadDrawingLayers);
}

static PyObject*
PyICadDrawingLayers_GetIID(PyICadDrawingLayersObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e37f71aa-bfb1-11d2-9b20-00c04fa33299");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadDrawingLayers_GetHR(PyICadDrawingLayersObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadDrawingLayers_GetIgnoreFailures(PyICadDrawingLayersObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadDrawingLayers_SetIgnoreFailures(PyICadDrawingLayersObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadDrawingLayers_SupportsInterface(PyICadDrawingLayersObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadDrawingLayers->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadDrawingLayersMethod_get_DrawingLayerCount(PyICadDrawingLayersObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pICadDrawingLayers->get_DrawingLayerCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingLayers->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingLayers) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingLayers.get_DrawingLayerCount() returned %ld", (long)hr);
        goto icaddrawinglayers_get_drawinglayercount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto icaddrawinglayers_get_drawinglayercount_method_cleanup;

    icaddrawinglayers_get_drawinglayercount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingLayers.get_DrawingLayerCount");
    return return_tuple;
}

static PyObject*
ICadDrawingLayersMethod_get_DrawingLayerName(PyICadDrawingLayersObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bsFilePath;
    PyObject* pyvar_FilePath = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto icaddrawinglayers_get_drawinglayername_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for FilePath

    // Call method on actual COM interface
    hr = self->m_pICadDrawingLayers->get_DrawingLayerName(lindex, &bsFilePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingLayers->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingLayers) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingLayers.get_DrawingLayerName() returned %ld", (long)hr);
        goto icaddrawinglayers_get_drawinglayername_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_FilePath = PyUnicode_FromWideChar(bsFilePath,::SysStringLen(bsFilePath));
    ::SysFreeString(bsFilePath);
    
    if (PyErr_Occurred())
      goto icaddrawinglayers_get_drawinglayername_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_FilePath);
    goto icaddrawinglayers_get_drawinglayername_method_cleanup;

    icaddrawinglayers_get_drawinglayername_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (pyvar_FilePath != Py_None)
        Py_XDECREF(pyvar_FilePath);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingLayers.get_DrawingLayerName");
    return return_tuple;
}

static PyObject*
ICadDrawingLayersMethod_get_DrawingLayerVisible(PyICadDrawingLayersObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    VARIANT_BOOL b_visible = VARIANT_FALSE;
    PyObject* pyvar_visible = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto icaddrawinglayers_get_drawinglayervisible_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for visible

    // Call method on actual COM interface
    hr = self->m_pICadDrawingLayers->get_DrawingLayerVisible(lindex, &b_visible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingLayers->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingLayers) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingLayers.get_DrawingLayerVisible() returned %ld", (long)hr);
        goto icaddrawinglayers_get_drawinglayervisible_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_visible = ((b_visible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icaddrawinglayers_get_drawinglayervisible_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_visible);
    goto icaddrawinglayers_get_drawinglayervisible_method_cleanup;

    icaddrawinglayers_get_drawinglayervisible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for visible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingLayers.get_DrawingLayerVisible");
    return return_tuple;
}

static PyObject*
ICadDrawingLayersMethod_put_DrawingLayerVisible(PyICadDrawingLayersObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    VARIANT_BOOL b_visible = VARIANT_FALSE;
    PyObject* pyvar_visible = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lindex, &pyvar_visible))
      goto icaddrawinglayers_put_drawinglayervisible_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    b_visible = ((PyObject_IsTrue(pyvar_visible) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icaddrawinglayers_put_drawinglayervisible_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadDrawingLayers->put_DrawingLayerVisible(lindex, b_visible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingLayers->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingLayers) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingLayers.put_DrawingLayerVisible() returned %ld", (long)hr);
        goto icaddrawinglayers_put_drawinglayervisible_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for visible

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icaddrawinglayers_put_drawinglayervisible_method_cleanup;

    icaddrawinglayers_put_drawinglayervisible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for visible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingLayers.put_DrawingLayerVisible");
    return return_tuple;
}

static PyObject*
ICadDrawingLayersMethod_get_OriginalDrawingLayerVisible(PyICadDrawingLayersObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    VARIANT_BOOL b_visible = VARIANT_FALSE;
    PyObject* pyvar_visible = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto icaddrawinglayers_get_originaldrawinglayervisible_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for visible

    // Call method on actual COM interface
    hr = self->m_pICadDrawingLayers->get_OriginalDrawingLayerVisible(lindex, &b_visible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingLayers->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingLayers) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingLayers.get_OriginalDrawingLayerVisible() returned %ld", (long)hr);
        goto icaddrawinglayers_get_originaldrawinglayervisible_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_visible = ((b_visible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icaddrawinglayers_get_originaldrawinglayervisible_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_visible);
    goto icaddrawinglayers_get_originaldrawinglayervisible_method_cleanup;

    icaddrawinglayers_get_originaldrawinglayervisible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for visible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingLayers.get_OriginalDrawingLayerVisible");
    return return_tuple;
}


PyMethodDef PyICadDrawingLayersMethods[] = {
    {"supports", (PyCFunction)PyICadDrawingLayers_SupportsInterface, METH_O, ""},
    {"get_DrawingLayerCount", (PyCFunction)ICadDrawingLayersMethod_get_DrawingLayerCount, METH_VARARGS, ""},
    {"get_DrawingLayerName", (PyCFunction)ICadDrawingLayersMethod_get_DrawingLayerName, METH_VARARGS, ""},
    {"get_DrawingLayerVisible", (PyCFunction)ICadDrawingLayersMethod_get_DrawingLayerVisible, METH_VARARGS, ""},
    {"put_DrawingLayerVisible", (PyCFunction)ICadDrawingLayersMethod_put_DrawingLayerVisible, METH_VARARGS, ""},
    {"get_OriginalDrawingLayerVisible", (PyCFunction)ICadDrawingLayersMethod_get_OriginalDrawingLayerVisible, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadDrawingLayersGetSet[] = {
  {"_pUnk", (getter)PyICadDrawingLayers_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadDrawingLayers", NULL},
  {"_pointer", (getter)PyICadDrawingLayers_GetPointer, NULL, "Get memory address for ICadDrawingLayers", NULL},
  {"_IID", (getter)PyICadDrawingLayers_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadDrawingLayers_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadDrawingLayers_GetIgnoreFailures, (setter)PyICadDrawingLayers_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadDrawingLayersObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICadDrawingLayersObject",                          
                                              /* tp_name */
  sizeof(PyICadDrawingLayersObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadDrawingLayersObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadDrawingLayersMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadDrawingLayersGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadDrawingLayersObject_new,                      
                                              /* tp_new */
};

// Interface ICadTransformations

typedef struct PyICadTransformationsObject {
    PyObject_HEAD
    ICadTransformations* m_pICadTransformations;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadTransformationsObject;

static PyObject*
PyICadTransformationsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadTransformationsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadTransformations* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadTransformations, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadTransformations with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadTransformationsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadTransformations");
            return NULL;
        }
        self->m_pICadTransformations = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadTransformations");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadTransformations");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadTransformations* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadTransformations, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadTransformations");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadTransformationsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadTransformations");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadTransformations = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadTransformationsObject_dealloc(PyICadTransformationsObject* self)
{
    if (self->m_pICadTransformations)
        self->m_pICadTransformations->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadTransformations_GetpUnk(PyICadTransformationsObject* self)
{
    if (!self->m_pICadTransformations)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadTransformations->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadTransformations to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadTransformations_GetPointer(PyICadTransformationsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadTransformations);
}

static PyObject*
PyICadTransformations_GetIID(PyICadTransformationsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e37f71ab-bfb1-11d2-9b20-00c04fa33299");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadTransformations_GetHR(PyICadTransformationsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadTransformations_GetIgnoreFailures(PyICadTransformationsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadTransformations_SetIgnoreFailures(PyICadTransformationsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadTransformations_SupportsInterface(PyICadTransformationsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadTransformationsMethod_get_EnableTransformations(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_enabled = VARIANT_FALSE;
    PyObject* pyvar_enabled = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for enabled

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->get_EnableTransformations(&b_enabled);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.get_EnableTransformations() returned %ld", (long)hr);
        goto icadtransformations_get_enabletransformations_method_cleanup;
    }

    // Set up return values as needed
    pyvar_enabled = ((b_enabled == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icadtransformations_get_enabletransformations_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_enabled);
    goto icadtransformations_get_enabletransformations_method_cleanup;

    icadtransformations_get_enabletransformations_method_cleanup:
    self->m_HR = hr;
    // No cleanup for enabled
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.get_EnableTransformations");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_put_EnableTransformations(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_enabled = VARIANT_FALSE;
    PyObject* pyvar_enabled = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_enabled))
      goto icadtransformations_put_enabletransformations_method_cleanup;

    // Set up initial variable values as needed
    b_enabled = ((PyObject_IsTrue(pyvar_enabled) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadtransformations_put_enabletransformations_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->put_EnableTransformations(b_enabled);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.put_EnableTransformations() returned %ld", (long)hr);
        goto icadtransformations_put_enabletransformations_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for enabled

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadtransformations_put_enabletransformations_method_cleanup;

    icadtransformations_put_enabletransformations_method_cleanup:
    self->m_HR = hr;
    // No cleanup for enabled
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.put_EnableTransformations");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_get_WorldFileName(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFilePath;
    PyObject* pyvar_FilePath = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FilePath

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->get_WorldFileName(&bsFilePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.get_WorldFileName() returned %ld", (long)hr);
        goto icadtransformations_get_worldfilename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_FilePath = PyUnicode_FromWideChar(bsFilePath,::SysStringLen(bsFilePath));
    ::SysFreeString(bsFilePath);
    
    if (PyErr_Occurred())
      goto icadtransformations_get_worldfilename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_FilePath);
    goto icadtransformations_get_worldfilename_method_cleanup;

    icadtransformations_get_worldfilename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_FilePath != Py_None)
        Py_XDECREF(pyvar_FilePath);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.get_WorldFileName");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_put_WorldFileName(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFilePath = 0;
    PyObject* pyvar_FilePath;
    PyObject* unicodeFilePath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FilePath))
      goto icadtransformations_put_worldfilename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FilePath))
        unicodeFilePath = PyUnicode_FromObject(pyvar_FilePath);
    else if (PyUnicode_Check(pyvar_FilePath))
    {
        unicodeFilePath = pyvar_FilePath;
        Py_INCREF(unicodeFilePath);
    }
    else if (pyvar_FilePath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FilePath at index 0");
    if (unicodeFilePath)
        bsFilePath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFilePath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFilePath));
    
    if (PyErr_Occurred())
      goto icadtransformations_put_worldfilename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->put_WorldFileName(bsFilePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.put_WorldFileName() returned %ld", (long)hr);
        goto icadtransformations_put_worldfilename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FilePath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadtransformations_put_worldfilename_method_cleanup;

    icadtransformations_put_worldfilename_method_cleanup:
    self->m_HR = hr;
    if (bsFilePath)
        ::SysFreeString(bsFilePath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.put_WorldFileName");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_get_TransformMode(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadTransform emode;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for mode

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->get_TransformMode(&emode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.get_TransformMode() returned %ld", (long)hr);
        goto icadtransformations_get_transformmode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for mode

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)emode);
    goto icadtransformations_get_transformmode_method_cleanup;

    icadtransformations_get_transformmode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for mode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.get_TransformMode");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_put_TransformMode(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadTransform emode;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&emode))
      goto icadtransformations_put_transformmode_method_cleanup;

    // Set up initial variable values as needed
    // No setup for mode

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->put_TransformMode(emode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.put_TransformMode() returned %ld", (long)hr);
        goto icadtransformations_put_transformmode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for mode

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadtransformations_put_transformmode_method_cleanup;

    icadtransformations_put_transformmode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for mode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.put_TransformMode");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_GetFromToTransform(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    WKSPoint sfromPoint1;
    PyObject* py_fromPoint1 = NULL;
    WKSPoint sfromPoint2;
    PyObject* py_fromPoint2 = NULL;
    WKSPoint stoPoint1;
    PyObject* py_toPoint1 = NULL;
    WKSPoint stoPoint2;
    PyObject* py_toPoint2 = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for fromPoint1
    // No setup for fromPoint2
    // No setup for toPoint1
    // No setup for toPoint2

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->GetFromToTransform(&sfromPoint1, &sfromPoint2, &stoPoint1, &stoPoint2);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.GetFromToTransform() returned %ld", (long)hr);
        goto icadtransformations_getfromtotransform_method_cleanup;
    }

    // Set up return values as needed
    py_fromPoint1 = PyByteArray_FromStringAndSize((char*)&sfromPoint1, sizeof(WKSPoint));
    PyObject* RecordWrapfromPoint1 = NULL;
    if (g_pRecordMap && (RecordWrapfromPoint1 = PyDict_GetItemString(g_pRecordMap, "WKSPoint")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrapfromPoint1, py_fromPoint1, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_fromPoint1);
            py_fromPoint1 = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrapfromPoint1)
        PyErr_Clear();
    Py_XDECREF(RecordWrapfromPoint1);
    
    if (PyErr_Occurred())
      goto icadtransformations_getfromtotransform_method_cleanup;
    
    py_fromPoint2 = PyByteArray_FromStringAndSize((char*)&sfromPoint2, sizeof(WKSPoint));
    PyObject* RecordWrapfromPoint2 = NULL;
    if (g_pRecordMap && (RecordWrapfromPoint2 = PyDict_GetItemString(g_pRecordMap, "WKSPoint")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrapfromPoint2, py_fromPoint2, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_fromPoint2);
            py_fromPoint2 = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrapfromPoint2)
        PyErr_Clear();
    Py_XDECREF(RecordWrapfromPoint2);
    
    if (PyErr_Occurred())
      goto icadtransformations_getfromtotransform_method_cleanup;
    
    py_toPoint1 = PyByteArray_FromStringAndSize((char*)&stoPoint1, sizeof(WKSPoint));
    PyObject* RecordWraptoPoint1 = NULL;
    if (g_pRecordMap && (RecordWraptoPoint1 = PyDict_GetItemString(g_pRecordMap, "WKSPoint")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWraptoPoint1, py_toPoint1, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_toPoint1);
            py_toPoint1 = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWraptoPoint1)
        PyErr_Clear();
    Py_XDECREF(RecordWraptoPoint1);
    
    if (PyErr_Occurred())
      goto icadtransformations_getfromtotransform_method_cleanup;
    
    py_toPoint2 = PyByteArray_FromStringAndSize((char*)&stoPoint2, sizeof(WKSPoint));
    PyObject* RecordWraptoPoint2 = NULL;
    if (g_pRecordMap && (RecordWraptoPoint2 = PyDict_GetItemString(g_pRecordMap, "WKSPoint")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWraptoPoint2, py_toPoint2, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_toPoint2);
            py_toPoint2 = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWraptoPoint2)
        PyErr_Clear();
    Py_XDECREF(RecordWraptoPoint2);
    
    if (PyErr_Occurred())
      goto icadtransformations_getfromtotransform_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOOO",
                                            py_fromPoint1, py_fromPoint2, py_toPoint1, py_toPoint2);
    goto icadtransformations_getfromtotransform_method_cleanup;

    icadtransformations_getfromtotransform_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_fromPoint1);
    Py_XDECREF(py_fromPoint2);
    Py_XDECREF(py_toPoint1);
    Py_XDECREF(py_toPoint2);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.GetFromToTransform");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_SetFromToTransform(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    WKSPoint* sfromPoint1 = 0;
    PyObject* py_fromPoint1 = NULL;
    WKSPoint* sfromPoint2 = 0;
    PyObject* py_fromPoint2 = NULL;
    WKSPoint* stoPoint1 = 0;
    PyObject* py_toPoint1 = NULL;
    WKSPoint* stoPoint2 = 0;
    PyObject* py_toPoint2 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_fromPoint1, &py_fromPoint2, &py_toPoint1, &py_toPoint2))
      goto icadtransformations_setfromtotransform_method_cleanup;

    // Set up initial variable values as needed
    if (PyByteArray_Check(py_fromPoint1))
        Py_INCREF(py_fromPoint1);
    else
        py_fromPoint1 = PyObject_GetAttrString(py_fromPoint1, "_bytes");
    if (!py_fromPoint1 || !PyByteArray_Check(py_fromPoint1) || PyByteArray_Size(py_fromPoint1) < sizeof(WKSPoint))
        PyErr_SetString(PyExc_ValueError, "Not a usable WKSPoint");
    else
        sfromPoint1 = (WKSPoint*)PyByteArray_AsString(py_fromPoint1);
    
    if (PyErr_Occurred())
      goto icadtransformations_setfromtotransform_method_cleanup;
    
    if (PyByteArray_Check(py_fromPoint2))
        Py_INCREF(py_fromPoint2);
    else
        py_fromPoint2 = PyObject_GetAttrString(py_fromPoint2, "_bytes");
    if (!py_fromPoint2 || !PyByteArray_Check(py_fromPoint2) || PyByteArray_Size(py_fromPoint2) < sizeof(WKSPoint))
        PyErr_SetString(PyExc_ValueError, "Not a usable WKSPoint");
    else
        sfromPoint2 = (WKSPoint*)PyByteArray_AsString(py_fromPoint2);
    
    if (PyErr_Occurred())
      goto icadtransformations_setfromtotransform_method_cleanup;
    
    if (PyByteArray_Check(py_toPoint1))
        Py_INCREF(py_toPoint1);
    else
        py_toPoint1 = PyObject_GetAttrString(py_toPoint1, "_bytes");
    if (!py_toPoint1 || !PyByteArray_Check(py_toPoint1) || PyByteArray_Size(py_toPoint1) < sizeof(WKSPoint))
        PyErr_SetString(PyExc_ValueError, "Not a usable WKSPoint");
    else
        stoPoint1 = (WKSPoint*)PyByteArray_AsString(py_toPoint1);
    
    if (PyErr_Occurred())
      goto icadtransformations_setfromtotransform_method_cleanup;
    
    if (PyByteArray_Check(py_toPoint2))
        Py_INCREF(py_toPoint2);
    else
        py_toPoint2 = PyObject_GetAttrString(py_toPoint2, "_bytes");
    if (!py_toPoint2 || !PyByteArray_Check(py_toPoint2) || PyByteArray_Size(py_toPoint2) < sizeof(WKSPoint))
        PyErr_SetString(PyExc_ValueError, "Not a usable WKSPoint");
    else
        stoPoint2 = (WKSPoint*)PyByteArray_AsString(py_toPoint2);
    
    if (PyErr_Occurred())
      goto icadtransformations_setfromtotransform_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->SetFromToTransform(sfromPoint1, sfromPoint2, stoPoint1, stoPoint2);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.SetFromToTransform() returned %ld", (long)hr);
        goto icadtransformations_setfromtotransform_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fromPoint1
    // No teardown for fromPoint2
    // No teardown for toPoint1
    // No teardown for toPoint2

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadtransformations_setfromtotransform_method_cleanup;

    icadtransformations_setfromtotransform_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_fromPoint1);
    Py_XDECREF(py_fromPoint2);
    Py_XDECREF(py_toPoint1);
    Py_XDECREF(py_toPoint2);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.SetFromToTransform");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_GetTransformation(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    WKSPoint sfrom;
    PyObject* py_from = NULL;
    WKSPoint sto;
    PyObject* py_to = NULL;
    double dangle = 0;
    double dscale = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for from
    // No setup for to
    // No setup for angle
    // No setup for scale

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->GetTransformation(&sfrom, &sto, &dangle, &dscale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.GetTransformation() returned %ld", (long)hr);
        goto icadtransformations_gettransformation_method_cleanup;
    }

    // Set up return values as needed
    py_from = PyByteArray_FromStringAndSize((char*)&sfrom, sizeof(WKSPoint));
    PyObject* RecordWrapfrom = NULL;
    if (g_pRecordMap && (RecordWrapfrom = PyDict_GetItemString(g_pRecordMap, "WKSPoint")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrapfrom, py_from, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_from);
            py_from = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrapfrom)
        PyErr_Clear();
    Py_XDECREF(RecordWrapfrom);
    
    if (PyErr_Occurred())
      goto icadtransformations_gettransformation_method_cleanup;
    
    py_to = PyByteArray_FromStringAndSize((char*)&sto, sizeof(WKSPoint));
    PyObject* RecordWrapto = NULL;
    if (g_pRecordMap && (RecordWrapto = PyDict_GetItemString(g_pRecordMap, "WKSPoint")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrapto, py_to, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_to);
            py_to = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrapto)
        PyErr_Clear();
    Py_XDECREF(RecordWrapto);
    
    if (PyErr_Occurred())
      goto icadtransformations_gettransformation_method_cleanup;
    
    // No teardown for angle
    // No teardown for scale

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOdd",
                                            py_from, py_to, dangle, dscale);
    goto icadtransformations_gettransformation_method_cleanup;

    icadtransformations_gettransformation_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_from);
    Py_XDECREF(py_to);
    // No cleanup for angle
    // No cleanup for scale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.GetTransformation");
    return return_tuple;
}

static PyObject*
ICadTransformationsMethod_SetTransformation(PyICadTransformationsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    WKSPoint* sfrom = 0;
    PyObject* py_from = NULL;
    WKSPoint* sto = 0;
    PyObject* py_to = NULL;
    double dangle = 0;
    double dscale = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdd", &py_from, &py_to, &dangle, &dscale))
      goto icadtransformations_settransformation_method_cleanup;

    // Set up initial variable values as needed
    if (PyByteArray_Check(py_from))
        Py_INCREF(py_from);
    else
        py_from = PyObject_GetAttrString(py_from, "_bytes");
    if (!py_from || !PyByteArray_Check(py_from) || PyByteArray_Size(py_from) < sizeof(WKSPoint))
        PyErr_SetString(PyExc_ValueError, "Not a usable WKSPoint");
    else
        sfrom = (WKSPoint*)PyByteArray_AsString(py_from);
    
    if (PyErr_Occurred())
      goto icadtransformations_settransformation_method_cleanup;
    
    if (PyByteArray_Check(py_to))
        Py_INCREF(py_to);
    else
        py_to = PyObject_GetAttrString(py_to, "_bytes");
    if (!py_to || !PyByteArray_Check(py_to) || PyByteArray_Size(py_to) < sizeof(WKSPoint))
        PyErr_SetString(PyExc_ValueError, "Not a usable WKSPoint");
    else
        sto = (WKSPoint*)PyByteArray_AsString(py_to);
    
    if (PyErr_Occurred())
      goto icadtransformations_settransformation_method_cleanup;
    
    // No setup for angle
    // No setup for scale

    // Call method on actual COM interface
    hr = self->m_pICadTransformations->SetTransformation(sfrom, sto, dangle, dscale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadTransformations->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadTransformations) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadTransformations.SetTransformation() returned %ld", (long)hr);
        goto icadtransformations_settransformation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for from
    // No teardown for to
    // No teardown for angle
    // No teardown for scale

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadtransformations_settransformation_method_cleanup;

    icadtransformations_settransformation_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_from);
    Py_XDECREF(py_to);
    // No cleanup for angle
    // No cleanup for scale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadTransformations.SetTransformation");
    return return_tuple;
}


PyMethodDef PyICadTransformationsMethods[] = {
    {"supports", (PyCFunction)PyICadTransformations_SupportsInterface, METH_O, ""},
    {"get_EnableTransformations", (PyCFunction)ICadTransformationsMethod_get_EnableTransformations, METH_VARARGS, ""},
    {"put_EnableTransformations", (PyCFunction)ICadTransformationsMethod_put_EnableTransformations, METH_VARARGS, ""},
    {"get_WorldFileName", (PyCFunction)ICadTransformationsMethod_get_WorldFileName, METH_VARARGS, ""},
    {"put_WorldFileName", (PyCFunction)ICadTransformationsMethod_put_WorldFileName, METH_VARARGS, ""},
    {"get_TransformMode", (PyCFunction)ICadTransformationsMethod_get_TransformMode, METH_VARARGS, ""},
    {"put_TransformMode", (PyCFunction)ICadTransformationsMethod_put_TransformMode, METH_VARARGS, ""},
    {"GetFromToTransform", (PyCFunction)ICadTransformationsMethod_GetFromToTransform, METH_VARARGS, ""},
    {"SetFromToTransform", (PyCFunction)ICadTransformationsMethod_SetFromToTransform, METH_VARARGS, ""},
    {"GetTransformation", (PyCFunction)ICadTransformationsMethod_GetTransformation, METH_VARARGS, ""},
    {"SetTransformation", (PyCFunction)ICadTransformationsMethod_SetTransformation, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadTransformationsGetSet[] = {
  {"_pUnk", (getter)PyICadTransformations_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadTransformations", NULL},
  {"_pointer", (getter)PyICadTransformations_GetPointer, NULL, "Get memory address for ICadTransformations", NULL},
  {"_IID", (getter)PyICadTransformations_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadTransformations_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadTransformations_GetIgnoreFailures, (setter)PyICadTransformations_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadTransformationsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICadTransformationsObject",                          
                                              /* tp_name */
  sizeof(PyICadTransformationsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadTransformationsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadTransformationsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadTransformationsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadTransformationsObject_new,                      
                                              /* tp_new */
};

// Interface ICadDrawingDataset

typedef struct PyICadDrawingDatasetObject {
    PyObject_HEAD
    ICadDrawingDataset* m_pICadDrawingDataset;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadDrawingDatasetObject;

static PyObject*
PyICadDrawingDatasetObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadDrawingDatasetObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadDrawingDataset* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadDrawingDataset, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadDrawingDataset with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadDrawingDatasetObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadDrawingDataset");
            return NULL;
        }
        self->m_pICadDrawingDataset = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadDrawingDataset");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadDrawingDataset");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadDrawingDataset* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadDrawingDataset, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadDrawingDataset");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadDrawingDatasetObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadDrawingDataset");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadDrawingDataset = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadDrawingDatasetObject_dealloc(PyICadDrawingDatasetObject* self)
{
    if (self->m_pICadDrawingDataset)
        self->m_pICadDrawingDataset->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadDrawingDataset_GetpUnk(PyICadDrawingDatasetObject* self)
{
    if (!self->m_pICadDrawingDataset)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadDrawingDataset->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadDrawingDataset to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadDrawingDataset_GetPointer(PyICadDrawingDatasetObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadDrawingDataset);
}

static PyObject*
PyICadDrawingDataset_GetIID(PyICadDrawingDatasetObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6c1d6540-4930-11d3-9b39-00c04fa33299");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadDrawingDataset_GetHR(PyICadDrawingDatasetObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadDrawingDataset_GetIgnoreFailures(PyICadDrawingDatasetObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadDrawingDataset_SetIgnoreFailures(PyICadDrawingDatasetObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadDrawingDataset_SupportsInterface(PyICadDrawingDatasetObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadDrawingDataset->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadDrawingDatasetMethod_get_FilePath(PyICadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFilePath;
    PyObject* pyvar_FilePath = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FilePath

    // Call method on actual COM interface
    hr = self->m_pICadDrawingDataset->get_FilePath(&bsFilePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingDataset.get_FilePath() returned %ld", (long)hr);
        goto icaddrawingdataset_get_filepath_method_cleanup;
    }

    // Set up return values as needed
    pyvar_FilePath = PyUnicode_FromWideChar(bsFilePath,::SysStringLen(bsFilePath));
    ::SysFreeString(bsFilePath);
    
    if (PyErr_Occurred())
      goto icaddrawingdataset_get_filepath_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_FilePath);
    goto icaddrawingdataset_get_filepath_method_cleanup;

    icaddrawingdataset_get_filepath_method_cleanup:
    self->m_HR = hr;
    if (pyvar_FilePath != Py_None)
        Py_XDECREF(pyvar_FilePath);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingDataset.get_FilePath");
    return return_tuple;
}

static PyObject*
ICadDrawingDatasetMethod_get_Is2d(PyICadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Is2d = VARIANT_FALSE;
    PyObject* pyvar_Is2d = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Is2d

    // Call method on actual COM interface
    hr = self->m_pICadDrawingDataset->get_Is2d(&b_Is2d);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingDataset.get_Is2d() returned %ld", (long)hr);
        goto icaddrawingdataset_get_is2d_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Is2d = ((b_Is2d == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icaddrawingdataset_get_is2d_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Is2d);
    goto icaddrawingdataset_get_is2d_method_cleanup;

    icaddrawingdataset_get_is2d_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Is2d
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingDataset.get_Is2d");
    return return_tuple;
}

static PyObject*
ICadDrawingDatasetMethod_get_Is3d(PyICadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Is3d = VARIANT_FALSE;
    PyObject* pyvar_Is3d = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Is3d

    // Call method on actual COM interface
    hr = self->m_pICadDrawingDataset->get_Is3d(&b_Is3d);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingDataset.get_Is3d() returned %ld", (long)hr);
        goto icaddrawingdataset_get_is3d_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Is3d = ((b_Is3d == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icaddrawingdataset_get_is3d_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Is3d);
    goto icaddrawingdataset_get_is3d_method_cleanup;

    icaddrawingdataset_get_is3d_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Is3d
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingDataset.get_Is3d");
    return return_tuple;
}

static PyObject*
ICadDrawingDatasetMethod_get_IsAutoCad(PyICadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsAutoCad = VARIANT_FALSE;
    PyObject* pyvar_IsAutoCad = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsAutoCad

    // Call method on actual COM interface
    hr = self->m_pICadDrawingDataset->get_IsAutoCad(&b_IsAutoCad);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingDataset.get_IsAutoCad() returned %ld", (long)hr);
        goto icaddrawingdataset_get_isautocad_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsAutoCad = ((b_IsAutoCad == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icaddrawingdataset_get_isautocad_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsAutoCad);
    goto icaddrawingdataset_get_isautocad_method_cleanup;

    icaddrawingdataset_get_isautocad_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsAutoCad
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingDataset.get_IsAutoCad");
    return return_tuple;
}

static PyObject*
ICadDrawingDatasetMethod_get_IsDgn(PyICadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsDgn = VARIANT_FALSE;
    PyObject* pyvar_IsDgn = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsDgn

    // Call method on actual COM interface
    hr = self->m_pICadDrawingDataset->get_IsDgn(&b_IsDgn);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingDataset.get_IsDgn() returned %ld", (long)hr);
        goto icaddrawingdataset_get_isdgn_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsDgn = ((b_IsDgn == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icaddrawingdataset_get_isdgn_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsDgn);
    goto icaddrawingdataset_get_isdgn_method_cleanup;

    icaddrawingdataset_get_isdgn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsDgn
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingDataset.get_IsDgn");
    return return_tuple;
}

static PyObject*
ICadDrawingDatasetMethod_get_Exists(PyICadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Exists = VARIANT_FALSE;
    PyObject* pyvar_Exists = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Exists

    // Call method on actual COM interface
    hr = self->m_pICadDrawingDataset->get_Exists(&b_Exists);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingDataset.get_Exists() returned %ld", (long)hr);
        goto icaddrawingdataset_get_exists_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Exists = ((b_Exists == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icaddrawingdataset_get_exists_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Exists);
    goto icaddrawingdataset_get_exists_method_cleanup;

    icaddrawingdataset_get_exists_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Exists
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingDataset.get_Exists");
    return return_tuple;
}


PyMethodDef PyICadDrawingDatasetMethods[] = {
    {"supports", (PyCFunction)PyICadDrawingDataset_SupportsInterface, METH_O, ""},
    {"get_FilePath", (PyCFunction)ICadDrawingDatasetMethod_get_FilePath, METH_VARARGS, ""},
    {"get_Is2d", (PyCFunction)ICadDrawingDatasetMethod_get_Is2d, METH_VARARGS, ""},
    {"get_Is3d", (PyCFunction)ICadDrawingDatasetMethod_get_Is3d, METH_VARARGS, ""},
    {"get_IsAutoCad", (PyCFunction)ICadDrawingDatasetMethod_get_IsAutoCad, METH_VARARGS, ""},
    {"get_IsDgn", (PyCFunction)ICadDrawingDatasetMethod_get_IsDgn, METH_VARARGS, ""},
    {"get_Exists", (PyCFunction)ICadDrawingDatasetMethod_get_Exists, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadDrawingDatasetGetSet[] = {
  {"_pUnk", (getter)PyICadDrawingDataset_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadDrawingDataset", NULL},
  {"_pointer", (getter)PyICadDrawingDataset_GetPointer, NULL, "Get memory address for ICadDrawingDataset", NULL},
  {"_IID", (getter)PyICadDrawingDataset_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadDrawingDataset_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadDrawingDataset_GetIgnoreFailures, (setter)PyICadDrawingDataset_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadDrawingDatasetObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICadDrawingDatasetObject",                          
                                              /* tp_name */
  sizeof(PyICadDrawingDatasetObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadDrawingDatasetObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadDrawingDatasetMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadDrawingDatasetGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadDrawingDatasetObject_new,                      
                                              /* tp_new */
};

// Interface ICadDrawingWorkspace

typedef struct PyICadDrawingWorkspaceObject {
    PyObject_HEAD
    ICadDrawingWorkspace* m_pICadDrawingWorkspace;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadDrawingWorkspaceObject;

static PyObject*
PyICadDrawingWorkspaceObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadDrawingWorkspaceObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadDrawingWorkspace* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadDrawingWorkspace, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadDrawingWorkspace with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadDrawingWorkspaceObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadDrawingWorkspace");
            return NULL;
        }
        self->m_pICadDrawingWorkspace = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadDrawingWorkspace");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadDrawingWorkspace");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadDrawingWorkspace* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadDrawingWorkspace, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadDrawingWorkspace");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadDrawingWorkspaceObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadDrawingWorkspace");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadDrawingWorkspace = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadDrawingWorkspaceObject_dealloc(PyICadDrawingWorkspaceObject* self)
{
    if (self->m_pICadDrawingWorkspace)
        self->m_pICadDrawingWorkspace->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadDrawingWorkspace_GetpUnk(PyICadDrawingWorkspaceObject* self)
{
    if (!self->m_pICadDrawingWorkspace)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadDrawingWorkspace->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadDrawingWorkspace to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadDrawingWorkspace_GetPointer(PyICadDrawingWorkspaceObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadDrawingWorkspace);
}

static PyObject*
PyICadDrawingWorkspace_GetIID(PyICadDrawingWorkspaceObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "76b47b11-ac32-11d4-a226-444553547777");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadDrawingWorkspace_GetHR(PyICadDrawingWorkspaceObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadDrawingWorkspace_GetIgnoreFailures(PyICadDrawingWorkspaceObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadDrawingWorkspace_SetIgnoreFailures(PyICadDrawingWorkspaceObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadDrawingWorkspace_SupportsInterface(PyICadDrawingWorkspaceObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadDrawingWorkspace->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadDrawingWorkspaceMethod_OpenCadDrawingDataset(PyICadDrawingWorkspaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    ICadDrawingDataset* ipdataset = NULL;
    PyObject* py_dataset = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto icaddrawingworkspace_opencaddrawingdataset_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icaddrawingworkspace_opencaddrawingdataset_method_cleanup;
    
    // No setup for dataset

    // Call method on actual COM interface
    hr = self->m_pICadDrawingWorkspace->OpenCadDrawingDataset(bsName, &ipdataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadDrawingWorkspace->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadDrawingWorkspace) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadDrawingWorkspace.OpenCadDrawingDataset() returned %ld", (long)hr);
        goto icaddrawingworkspace_opencaddrawingdataset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    Py_XDECREF(py_dataset);
    if (ipdataset)
    {
        IUnknown* pUnk = NULL;
        ipdataset->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_dataset = IUnknownToPythonIIDObject(pUnk, &IID_ICadDrawingDataset);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_dataset)
    {
        if (py_dataset)
           Py_DECREF(py_dataset);
        py_dataset = Py_None;
        Py_INCREF(py_dataset);
    }
    if (PyErr_Occurred())
      goto icaddrawingworkspace_opencaddrawingdataset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_dataset);
    goto icaddrawingworkspace_opencaddrawingdataset_method_cleanup;

    icaddrawingworkspace_opencaddrawingdataset_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    Py_XDECREF(py_dataset);
    if (ipdataset)
      ipdataset->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadDrawingWorkspace.OpenCadDrawingDataset");
    return return_tuple;
}


PyMethodDef PyICadDrawingWorkspaceMethods[] = {
    {"supports", (PyCFunction)PyICadDrawingWorkspace_SupportsInterface, METH_O, ""},
    {"OpenCadDrawingDataset", (PyCFunction)ICadDrawingWorkspaceMethod_OpenCadDrawingDataset, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadDrawingWorkspaceGetSet[] = {
  {"_pUnk", (getter)PyICadDrawingWorkspace_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadDrawingWorkspace", NULL},
  {"_pointer", (getter)PyICadDrawingWorkspace_GetPointer, NULL, "Get memory address for ICadDrawingWorkspace", NULL},
  {"_IID", (getter)PyICadDrawingWorkspace_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadDrawingWorkspace_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadDrawingWorkspace_GetIgnoreFailures, (setter)PyICadDrawingWorkspace_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadDrawingWorkspaceObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ICadDrawingWorkspaceObject",                          
                                              /* tp_name */
  sizeof(PyICadDrawingWorkspaceObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadDrawingWorkspaceObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadDrawingWorkspaceMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadDrawingWorkspaceGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadDrawingWorkspaceObject_new,                      
                                              /* tp_new */
};

// Interface ISdcExporter

typedef struct PyISdcExporterObject {
    PyObject_HEAD
    ISdcExporter* m_pISdcExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISdcExporterObject;

static PyObject*
PyISdcExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISdcExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISdcExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISdcExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISdcExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISdcExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISdcExporter");
            return NULL;
        }
        self->m_pISdcExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISdcExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISdcExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISdcExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISdcExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISdcExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISdcExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISdcExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISdcExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISdcExporterObject_dealloc(PyISdcExporterObject* self)
{
    if (self->m_pISdcExporter)
        self->m_pISdcExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISdcExporter_GetpUnk(PyISdcExporterObject* self)
{
    if (!self->m_pISdcExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISdcExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISdcExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISdcExporter_GetPointer(PyISdcExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISdcExporter);
}

static PyObject*
PyISdcExporter_GetIID(PyISdcExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "989b9737-fecf-467d-8544-d3b3ee30e60c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISdcExporter_GetHR(PyISdcExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISdcExporter_GetIgnoreFailures(PyISdcExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISdcExporter_SetIgnoreFailures(PyISdcExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISdcExporter_SupportsInterface(PyISdcExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISdcExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISdcExporterMethod_Export(PyISdcExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICursor* ipcursor = NULL;
    PyObject* py_cursor;
    BSTR bsoutputRootname = 0;
    PyObject* pyvar_outputRootname;
    PyObject* unicodeoutputRootname = NULL;
    PyObject* py_Key = NULL;
    GUID gKey;
    ITrackCancel* iptrackCancel = NULL;
    PyObject* py_trackCancel;
    IDataset* ipsdcDataset = NULL;
    PyObject* py_sdcDataset = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_cursor, &pyvar_outputRootname, &py_Key, &py_trackCancel))
      goto isdcexporter_export_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_cursor, &IID_ICursor, (void**)&ipcursor))
        PyErr_SetString(PyExc_TypeError, "Argument cursor (position 0) is not ICursor");
    
    if (PyErr_Occurred())
      goto isdcexporter_export_method_cleanup;
    
    if (PyString_Check(pyvar_outputRootname))
        unicodeoutputRootname = PyUnicode_FromObject(pyvar_outputRootname);
    else if (PyUnicode_Check(pyvar_outputRootname))
    {
        unicodeoutputRootname = pyvar_outputRootname;
        Py_INCREF(unicodeoutputRootname);
    }
    else if (pyvar_outputRootname != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter outputRootname at index 1");
    if (unicodeoutputRootname)
        bsoutputRootname = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeoutputRootname), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeoutputRootname));
    
    if (PyErr_Occurred())
      goto isdcexporter_export_method_cleanup;
    
    if (!GuidFromPyObject(py_Key, &gKey))
        PyErr_SetString(PyExc_TypeError, "Argument Key (position 2) is not UUID");
    
    if (PyErr_Occurred())
      goto isdcexporter_export_method_cleanup;
    
    if (!IFaceFromPyObject(py_trackCancel, &IID_ITrackCancel, (void**)&iptrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument trackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto isdcexporter_export_method_cleanup;
    
    // No setup for sdcDataset

    // Call method on actual COM interface
    hr = self->m_pISdcExporter->Export(ipcursor, bsoutputRootname, &gKey, iptrackCancel, &ipsdcDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISdcExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISdcExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISdcExporter.Export() returned %ld", (long)hr);
        goto isdcexporter_export_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for cursor
    // No teardown for outputRootname
    // No teardown for Key
    // No teardown for trackCancel
    Py_XDECREF(py_sdcDataset);
    if (ipsdcDataset)
    {
        IUnknown* pUnk = NULL;
        ipsdcDataset->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_sdcDataset = IUnknownToPythonIIDObject(pUnk, &IID_IDataset);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_sdcDataset)
    {
        if (py_sdcDataset)
           Py_DECREF(py_sdcDataset);
        py_sdcDataset = Py_None;
        Py_INCREF(py_sdcDataset);
    }
    if (PyErr_Occurred())
      goto isdcexporter_export_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_sdcDataset);
    goto isdcexporter_export_method_cleanup;

    isdcexporter_export_method_cleanup:
    self->m_HR = hr;
    if (ipcursor)
      ipcursor->Release();
    if (bsoutputRootname)
        ::SysFreeString(bsoutputRootname);
    
    // No cleanup for Key
    if (iptrackCancel)
      iptrackCancel->Release();
    Py_XDECREF(py_sdcDataset);
    if (ipsdcDataset)
      ipsdcDataset->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISdcExporter.Export");
    return return_tuple;
}


PyMethodDef PyISdcExporterMethods[] = {
    {"supports", (PyCFunction)PyISdcExporter_SupportsInterface, METH_O, ""},
    {"Export", (PyCFunction)ISdcExporterMethod_Export, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISdcExporterGetSet[] = {
  {"_pUnk", (getter)PyISdcExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISdcExporter", NULL},
  {"_pointer", (getter)PyISdcExporter_GetPointer, NULL, "Get memory address for ISdcExporter", NULL},
  {"_IID", (getter)PyISdcExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISdcExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISdcExporter_GetIgnoreFailures, (setter)PyISdcExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISdcExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISdcExporterObject",                          
                                              /* tp_name */
  sizeof(PyISdcExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISdcExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISdcExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISdcExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISdcExporterObject_new,                      
                                              /* tp_new */
};

// Interface ISMRouterPoint

typedef struct PyISMRouterPointObject {
    PyObject_HEAD
    ISMRouterPoint* m_pISMRouterPoint;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRouterPointObject;

static PyObject*
PyISMRouterPointObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRouterPointObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRouterPoint* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRouterPoint, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRouterPoint with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRouterPointObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterPoint");
            return NULL;
        }
        self->m_pISMRouterPoint = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRouterPoint");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRouterPoint");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRouterPoint* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRouterPoint, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRouterPoint");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRouterPointObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterPoint");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRouterPoint = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRouterPointObject_dealloc(PyISMRouterPointObject* self)
{
    if (self->m_pISMRouterPoint)
        self->m_pISMRouterPoint->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRouterPoint_GetpUnk(PyISMRouterPointObject* self)
{
    if (!self->m_pISMRouterPoint)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRouterPoint->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRouterPoint to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRouterPoint_GetPointer(PyISMRouterPointObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRouterPoint);
}

static PyObject*
PyISMRouterPoint_GetIID(PyISMRouterPointObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b65fed-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRouterPoint_GetHR(PyISMRouterPointObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRouterPoint_GetIgnoreFailures(PyISMRouterPointObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRouterPoint_SetIgnoreFailures(PyISMRouterPointObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRouterPoint_SupportsInterface(PyISMRouterPointObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRouterPoint->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRouterPointMethod_get_X(PyISMRouterPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterPoint->get_X(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterPoint.get_X() returned %ld", (long)hr);
        goto ismrouterpoint_get_x_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismrouterpoint_get_x_method_cleanup;

    ismrouterpoint_get_x_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterPoint.get_X");
    return return_tuple;
}

static PyObject*
ISMRouterPointMethod_put_X(PyISMRouterPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto ismrouterpoint_put_x_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterPoint->put_X(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterPoint.put_X() returned %ld", (long)hr);
        goto ismrouterpoint_put_x_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrouterpoint_put_x_method_cleanup;

    ismrouterpoint_put_x_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterPoint.put_X");
    return return_tuple;
}

static PyObject*
ISMRouterPointMethod_get_Y(PyISMRouterPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterPoint->get_Y(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterPoint.get_Y() returned %ld", (long)hr);
        goto ismrouterpoint_get_y_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismrouterpoint_get_y_method_cleanup;

    ismrouterpoint_get_y_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterPoint.get_Y");
    return return_tuple;
}

static PyObject*
ISMRouterPointMethod_put_Y(PyISMRouterPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto ismrouterpoint_put_y_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterPoint->put_Y(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterPoint.put_Y() returned %ld", (long)hr);
        goto ismrouterpoint_put_y_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrouterpoint_put_y_method_cleanup;

    ismrouterpoint_put_y_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterPoint.put_Y");
    return return_tuple;
}


PyMethodDef PyISMRouterPointMethods[] = {
    {"supports", (PyCFunction)PyISMRouterPoint_SupportsInterface, METH_O, ""},
    {"get_X", (PyCFunction)ISMRouterPointMethod_get_X, METH_VARARGS, ""},
    {"put_X", (PyCFunction)ISMRouterPointMethod_put_X, METH_VARARGS, ""},
    {"get_Y", (PyCFunction)ISMRouterPointMethod_get_Y, METH_VARARGS, ""},
    {"put_Y", (PyCFunction)ISMRouterPointMethod_put_Y, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRouterPointGetSet[] = {
  {"_pUnk", (getter)PyISMRouterPoint_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRouterPoint", NULL},
  {"_pointer", (getter)PyISMRouterPoint_GetPointer, NULL, "Get memory address for ISMRouterPoint", NULL},
  {"_IID", (getter)PyISMRouterPoint_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRouterPoint_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRouterPoint_GetIgnoreFailures, (setter)PyISMRouterPoint_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRouterPointObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRouterPointObject",                          
                                              /* tp_name */
  sizeof(PyISMRouterPointObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRouterPointObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRouterPointMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRouterPointGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRouterPointObject_new,                      
                                              /* tp_new */
};

// Interface ISMRouterEnvelope

typedef struct PyISMRouterEnvelopeObject {
    PyObject_HEAD
    ISMRouterEnvelope* m_pISMRouterEnvelope;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRouterEnvelopeObject;

static PyObject*
PyISMRouterEnvelopeObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRouterEnvelopeObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRouterEnvelope* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRouterEnvelope, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRouterEnvelope with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRouterEnvelopeObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterEnvelope");
            return NULL;
        }
        self->m_pISMRouterEnvelope = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRouterEnvelope");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRouterEnvelope");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRouterEnvelope* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRouterEnvelope, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRouterEnvelope");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRouterEnvelopeObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterEnvelope");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRouterEnvelope = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRouterEnvelopeObject_dealloc(PyISMRouterEnvelopeObject* self)
{
    if (self->m_pISMRouterEnvelope)
        self->m_pISMRouterEnvelope->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRouterEnvelope_GetpUnk(PyISMRouterEnvelopeObject* self)
{
    if (!self->m_pISMRouterEnvelope)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRouterEnvelope->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRouterEnvelope to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRouterEnvelope_GetPointer(PyISMRouterEnvelopeObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRouterEnvelope);
}

static PyObject*
PyISMRouterEnvelope_GetIID(PyISMRouterEnvelopeObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b65ff0-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRouterEnvelope_GetHR(PyISMRouterEnvelopeObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRouterEnvelope_GetIgnoreFailures(PyISMRouterEnvelopeObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRouterEnvelope_SetIgnoreFailures(PyISMRouterEnvelopeObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRouterEnvelope_SupportsInterface(PyISMRouterEnvelopeObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRouterEnvelopeMethod_get_Top(PyISMRouterEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterEnvelope->get_Top(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterEnvelope.get_Top() returned %ld", (long)hr);
        goto ismrouterenvelope_get_top_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismrouterenvelope_get_top_method_cleanup;

    ismrouterenvelope_get_top_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterEnvelope.get_Top");
    return return_tuple;
}

static PyObject*
ISMRouterEnvelopeMethod_put_Top(PyISMRouterEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto ismrouterenvelope_put_top_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterEnvelope->put_Top(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterEnvelope.put_Top() returned %ld", (long)hr);
        goto ismrouterenvelope_put_top_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrouterenvelope_put_top_method_cleanup;

    ismrouterenvelope_put_top_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterEnvelope.put_Top");
    return return_tuple;
}

static PyObject*
ISMRouterEnvelopeMethod_get_Bottom(PyISMRouterEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterEnvelope->get_Bottom(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterEnvelope.get_Bottom() returned %ld", (long)hr);
        goto ismrouterenvelope_get_bottom_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismrouterenvelope_get_bottom_method_cleanup;

    ismrouterenvelope_get_bottom_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterEnvelope.get_Bottom");
    return return_tuple;
}

static PyObject*
ISMRouterEnvelopeMethod_put_Bottom(PyISMRouterEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto ismrouterenvelope_put_bottom_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterEnvelope->put_Bottom(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterEnvelope.put_Bottom() returned %ld", (long)hr);
        goto ismrouterenvelope_put_bottom_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrouterenvelope_put_bottom_method_cleanup;

    ismrouterenvelope_put_bottom_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterEnvelope.put_Bottom");
    return return_tuple;
}

static PyObject*
ISMRouterEnvelopeMethod_get_Left(PyISMRouterEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterEnvelope->get_Left(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterEnvelope.get_Left() returned %ld", (long)hr);
        goto ismrouterenvelope_get_left_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismrouterenvelope_get_left_method_cleanup;

    ismrouterenvelope_get_left_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterEnvelope.get_Left");
    return return_tuple;
}

static PyObject*
ISMRouterEnvelopeMethod_put_Left(PyISMRouterEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto ismrouterenvelope_put_left_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterEnvelope->put_Left(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterEnvelope.put_Left() returned %ld", (long)hr);
        goto ismrouterenvelope_put_left_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrouterenvelope_put_left_method_cleanup;

    ismrouterenvelope_put_left_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterEnvelope.put_Left");
    return return_tuple;
}

static PyObject*
ISMRouterEnvelopeMethod_get_Right(PyISMRouterEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterEnvelope->get_Right(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterEnvelope.get_Right() returned %ld", (long)hr);
        goto ismrouterenvelope_get_right_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismrouterenvelope_get_right_method_cleanup;

    ismrouterenvelope_get_right_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterEnvelope.get_Right");
    return return_tuple;
}

static PyObject*
ISMRouterEnvelopeMethod_put_Right(PyISMRouterEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto ismrouterenvelope_put_right_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterEnvelope->put_Right(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterEnvelope.put_Right() returned %ld", (long)hr);
        goto ismrouterenvelope_put_right_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrouterenvelope_put_right_method_cleanup;

    ismrouterenvelope_put_right_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterEnvelope.put_Right");
    return return_tuple;
}


PyMethodDef PyISMRouterEnvelopeMethods[] = {
    {"supports", (PyCFunction)PyISMRouterEnvelope_SupportsInterface, METH_O, ""},
    {"get_Top", (PyCFunction)ISMRouterEnvelopeMethod_get_Top, METH_VARARGS, ""},
    {"put_Top", (PyCFunction)ISMRouterEnvelopeMethod_put_Top, METH_VARARGS, ""},
    {"get_Bottom", (PyCFunction)ISMRouterEnvelopeMethod_get_Bottom, METH_VARARGS, ""},
    {"put_Bottom", (PyCFunction)ISMRouterEnvelopeMethod_put_Bottom, METH_VARARGS, ""},
    {"get_Left", (PyCFunction)ISMRouterEnvelopeMethod_get_Left, METH_VARARGS, ""},
    {"put_Left", (PyCFunction)ISMRouterEnvelopeMethod_put_Left, METH_VARARGS, ""},
    {"get_Right", (PyCFunction)ISMRouterEnvelopeMethod_get_Right, METH_VARARGS, ""},
    {"put_Right", (PyCFunction)ISMRouterEnvelopeMethod_put_Right, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRouterEnvelopeGetSet[] = {
  {"_pUnk", (getter)PyISMRouterEnvelope_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRouterEnvelope", NULL},
  {"_pointer", (getter)PyISMRouterEnvelope_GetPointer, NULL, "Get memory address for ISMRouterEnvelope", NULL},
  {"_IID", (getter)PyISMRouterEnvelope_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRouterEnvelope_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRouterEnvelope_GetIgnoreFailures, (setter)PyISMRouterEnvelope_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRouterEnvelopeObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRouterEnvelopeObject",                          
                                              /* tp_name */
  sizeof(PyISMRouterEnvelopeObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRouterEnvelopeObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRouterEnvelopeMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRouterEnvelopeGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRouterEnvelopeObject_new,                      
                                              /* tp_new */
};

// Interface ISMPointsCollection

typedef struct PyISMPointsCollectionObject {
    PyObject_HEAD
    ISMPointsCollection* m_pISMPointsCollection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMPointsCollectionObject;

static PyObject*
PyISMPointsCollectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMPointsCollectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMPointsCollection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMPointsCollection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMPointsCollection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMPointsCollectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMPointsCollection");
            return NULL;
        }
        self->m_pISMPointsCollection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMPointsCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMPointsCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMPointsCollection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMPointsCollection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMPointsCollection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMPointsCollectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMPointsCollection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMPointsCollection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMPointsCollectionObject_dealloc(PyISMPointsCollectionObject* self)
{
    if (self->m_pISMPointsCollection)
        self->m_pISMPointsCollection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMPointsCollection_GetpUnk(PyISMPointsCollectionObject* self)
{
    if (!self->m_pISMPointsCollection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMPointsCollection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMPointsCollection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMPointsCollection_GetPointer(PyISMPointsCollectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMPointsCollection);
}

static PyObject*
PyISMPointsCollection_GetIID(PyISMPointsCollectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b65ff3-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMPointsCollection_GetHR(PyISMPointsCollectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMPointsCollection_GetIgnoreFailures(PyISMPointsCollectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMPointsCollection_SetIgnoreFailures(PyISMPointsCollectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMPointsCollection_SupportsInterface(PyISMPointsCollectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMPointsCollection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMPointsCollectionMethod_get_Count(PyISMPointsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMPointsCollection->get_Count(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMPointsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMPointsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMPointsCollection.get_Count() returned %ld", (long)hr);
        goto ismpointscollection_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismpointscollection_get_count_method_cleanup;

    ismpointscollection_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMPointsCollection.get_Count");
    return return_tuple;
}

static PyObject*
ISMPointsCollectionMethod_get_Item(PyISMPointsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;
    ISMRouterPoint* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPosition))
      goto ismpointscollection_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMPointsCollection->get_Item(lPosition, &ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMPointsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMPointsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMPointsCollection.get_Item() returned %ld", (long)hr);
        goto ismpointscollection_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMRouterPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismpointscollection_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismpointscollection_get_item_method_cleanup;

    ismpointscollection_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMPointsCollection.get_Item");
    return return_tuple;
}

static PyObject*
ISMPointsCollectionMethod_Add(PyISMPointsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippItem = NULL;
    PyObject* py_pItem;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pItem))
      goto ismpointscollection_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pItem, &IID_ISMRouterPoint, (void**)&ippItem))
        PyErr_SetString(PyExc_TypeError, "Argument pItem (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismpointscollection_add_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMPointsCollection->Add(ippItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMPointsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMPointsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMPointsCollection.Add() returned %ld", (long)hr);
        goto ismpointscollection_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pItem

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismpointscollection_add_method_cleanup;

    ismpointscollection_add_method_cleanup:
    self->m_HR = hr;
    if (ippItem)
      ippItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMPointsCollection.Add");
    return return_tuple;
}

static PyObject*
ISMPointsCollectionMethod_Insert(PyISMPointsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;
    ISMRouterPoint* ippItem = NULL;
    PyObject* py_pItem;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lPosition, &py_pItem))
      goto ismpointscollection_insert_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position
    if (!IFaceFromPyObject(py_pItem, &IID_ISMRouterPoint, (void**)&ippItem))
        PyErr_SetString(PyExc_TypeError, "Argument pItem (position 1) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismpointscollection_insert_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMPointsCollection->Insert(lPosition, ippItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMPointsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMPointsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMPointsCollection.Insert() returned %ld", (long)hr);
        goto ismpointscollection_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position
    // No teardown for pItem

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismpointscollection_insert_method_cleanup;

    ismpointscollection_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    if (ippItem)
      ippItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMPointsCollection.Insert");
    return return_tuple;
}

static PyObject*
ISMPointsCollectionMethod_Remove(PyISMPointsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPosition))
      goto ismpointscollection_remove_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position

    // Call method on actual COM interface
    hr = self->m_pISMPointsCollection->Remove(lPosition);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMPointsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMPointsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMPointsCollection.Remove() returned %ld", (long)hr);
        goto ismpointscollection_remove_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismpointscollection_remove_method_cleanup;

    ismpointscollection_remove_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMPointsCollection.Remove");
    return return_tuple;
}

static PyObject*
ISMPointsCollectionMethod_Clear(PyISMPointsCollectionObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pISMPointsCollection->Clear();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMPointsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMPointsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMPointsCollection.Clear() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyISMPointsCollectionMethods[] = {
    {"supports", (PyCFunction)PyISMPointsCollection_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)ISMPointsCollectionMethod_get_Count, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)ISMPointsCollectionMethod_get_Item, METH_VARARGS, ""},
    {"Add", (PyCFunction)ISMPointsCollectionMethod_Add, METH_VARARGS, ""},
    {"Insert", (PyCFunction)ISMPointsCollectionMethod_Insert, METH_VARARGS, ""},
    {"Remove", (PyCFunction)ISMPointsCollectionMethod_Remove, METH_VARARGS, ""},
    {"Clear", (PyCFunction)ISMPointsCollectionMethod_Clear, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMPointsCollectionGetSet[] = {
  {"_pUnk", (getter)PyISMPointsCollection_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMPointsCollection", NULL},
  {"_pointer", (getter)PyISMPointsCollection_GetPointer, NULL, "Get memory address for ISMPointsCollection", NULL},
  {"_IID", (getter)PyISMPointsCollection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMPointsCollection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMPointsCollection_GetIgnoreFailures, (setter)PyISMPointsCollection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMPointsCollectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMPointsCollectionObject",                          
                                              /* tp_name */
  sizeof(PyISMPointsCollectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMPointsCollectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMPointsCollectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMPointsCollectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMPointsCollectionObject_new,                      
                                              /* tp_new */
};

// Interface ISMNetAttribute

typedef struct PyISMNetAttributeObject {
    PyObject_HEAD
    ISMNetAttribute* m_pISMNetAttribute;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMNetAttributeObject;

static PyObject*
PyISMNetAttributeObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMNetAttributeObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMNetAttribute* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMNetAttribute, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMNetAttribute with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMNetAttributeObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetAttribute");
            return NULL;
        }
        self->m_pISMNetAttribute = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMNetAttribute");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMNetAttribute");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMNetAttribute* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMNetAttribute, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMNetAttribute");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMNetAttributeObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetAttribute");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMNetAttribute = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMNetAttributeObject_dealloc(PyISMNetAttributeObject* self)
{
    if (self->m_pISMNetAttribute)
        self->m_pISMNetAttribute->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMNetAttribute_GetpUnk(PyISMNetAttributeObject* self)
{
    if (!self->m_pISMNetAttribute)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMNetAttribute->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMNetAttribute to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMNetAttribute_GetPointer(PyISMNetAttributeObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMNetAttribute);
}

static PyObject*
PyISMNetAttribute_GetIID(PyISMNetAttributeObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b65ff6-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMNetAttribute_GetHR(PyISMNetAttributeObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMNetAttribute_GetIgnoreFailures(PyISMNetAttributeObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMNetAttribute_SetIgnoreFailures(PyISMNetAttributeObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMNetAttribute_SupportsInterface(PyISMNetAttributeObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMNetAttribute->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMNetAttributeMethod_get_Name(PyISMNetAttributeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetAttribute->get_Name(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetAttribute->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetAttribute) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetAttribute.get_Name() returned %ld", (long)hr);
        goto ismnetattribute_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismnetattribute_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismnetattribute_get_name_method_cleanup;

    ismnetattribute_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetAttribute.get_Name");
    return return_tuple;
}

static PyObject*
ISMNetAttributeMethod_get_Type(PyISMNetAttributeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMNetAttributeType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetAttribute->get_Type(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetAttribute->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetAttribute) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetAttribute.get_Type() returned %ld", (long)hr);
        goto ismnetattribute_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismnetattribute_get_type_method_cleanup;

    ismnetattribute_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetAttribute.get_Type");
    return return_tuple;
}


PyMethodDef PyISMNetAttributeMethods[] = {
    {"supports", (PyCFunction)PyISMNetAttribute_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)ISMNetAttributeMethod_get_Name, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)ISMNetAttributeMethod_get_Type, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMNetAttributeGetSet[] = {
  {"_pUnk", (getter)PyISMNetAttribute_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMNetAttribute", NULL},
  {"_pointer", (getter)PyISMNetAttribute_GetPointer, NULL, "Get memory address for ISMNetAttribute", NULL},
  {"_IID", (getter)PyISMNetAttribute_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMNetAttribute_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMNetAttribute_GetIgnoreFailures, (setter)PyISMNetAttribute_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMNetAttributeObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMNetAttributeObject",                          
                                              /* tp_name */
  sizeof(PyISMNetAttributeObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMNetAttributeObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMNetAttributeMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMNetAttributeGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMNetAttributeObject_new,                      
                                              /* tp_new */
};

// Interface ISMNetAttribute2

typedef struct PyISMNetAttribute2Object {
    PyObject_HEAD
    ISMNetAttribute2* m_pISMNetAttribute2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMNetAttribute2Object;

static PyObject*
PyISMNetAttribute2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMNetAttribute2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMNetAttribute2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMNetAttribute2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMNetAttribute2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMNetAttribute2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetAttribute2");
            return NULL;
        }
        self->m_pISMNetAttribute2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMNetAttribute2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMNetAttribute2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMNetAttribute2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMNetAttribute2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMNetAttribute2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMNetAttribute2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetAttribute2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMNetAttribute2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMNetAttribute2Object_dealloc(PyISMNetAttribute2Object* self)
{
    if (self->m_pISMNetAttribute2)
        self->m_pISMNetAttribute2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMNetAttribute2_GetpUnk(PyISMNetAttribute2Object* self)
{
    if (!self->m_pISMNetAttribute2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMNetAttribute2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMNetAttribute2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMNetAttribute2_GetPointer(PyISMNetAttribute2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMNetAttribute2);
}

static PyObject*
PyISMNetAttribute2_GetIID(PyISMNetAttribute2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b1a5376c-dfdf-48dd-a472-076808c0c73e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMNetAttribute2_GetHR(PyISMNetAttribute2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMNetAttribute2_GetIgnoreFailures(PyISMNetAttribute2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMNetAttribute2_SetIgnoreFailures(PyISMNetAttribute2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMNetAttribute2_SupportsInterface(PyISMNetAttribute2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMNetAttribute2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMNetAttribute2Method_get_UsageType(PyISMNetAttribute2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMNetAttributeUsageType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetAttribute2->get_UsageType(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetAttribute2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetAttribute2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetAttribute2.get_UsageType() returned %ld", (long)hr);
        goto ismnetattribute2_get_usagetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismnetattribute2_get_usagetype_method_cleanup;

    ismnetattribute2_get_usagetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetAttribute2.get_UsageType");
    return return_tuple;
}

static PyObject*
ISMNetAttribute2Method_get_Name(PyISMNetAttribute2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetAttribute2->get_Name(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetAttribute2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetAttribute2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetAttribute2.get_Name() returned %ld", (long)hr);
        goto ismnetattribute2_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismnetattribute2_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismnetattribute2_get_name_method_cleanup;

    ismnetattribute2_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetAttribute2.get_Name");
    return return_tuple;
}

static PyObject*
ISMNetAttribute2Method_get_Type(PyISMNetAttribute2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMNetAttributeType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetAttribute2->get_Type(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetAttribute2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetAttribute2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetAttribute2.get_Type() returned %ld", (long)hr);
        goto ismnetattribute2_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismnetattribute2_get_type_method_cleanup;

    ismnetattribute2_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetAttribute2.get_Type");
    return return_tuple;
}


PyMethodDef PyISMNetAttribute2Methods[] = {
    {"supports", (PyCFunction)PyISMNetAttribute2_SupportsInterface, METH_O, ""},
    {"get_UsageType", (PyCFunction)ISMNetAttribute2Method_get_UsageType, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ISMNetAttribute2Method_get_Name, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)ISMNetAttribute2Method_get_Type, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMNetAttribute2GetSet[] = {
  {"_pUnk", (getter)PyISMNetAttribute2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMNetAttribute2", NULL},
  {"_pointer", (getter)PyISMNetAttribute2_GetPointer, NULL, "Get memory address for ISMNetAttribute2", NULL},
  {"_IID", (getter)PyISMNetAttribute2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMNetAttribute2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMNetAttribute2_GetIgnoreFailures, (setter)PyISMNetAttribute2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMNetAttribute2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMNetAttribute2Object",                          
                                              /* tp_name */
  sizeof(PyISMNetAttribute2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMNetAttribute2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMNetAttribute2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMNetAttribute2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMNetAttribute2Object_new,                      
                                              /* tp_new */
};

// Interface ISMNetAttributesCollection

typedef struct PyISMNetAttributesCollectionObject {
    PyObject_HEAD
    ISMNetAttributesCollection* m_pISMNetAttributesCollection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMNetAttributesCollectionObject;

static PyObject*
PyISMNetAttributesCollectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMNetAttributesCollectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMNetAttributesCollection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMNetAttributesCollection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMNetAttributesCollection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMNetAttributesCollectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetAttributesCollection");
            return NULL;
        }
        self->m_pISMNetAttributesCollection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMNetAttributesCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMNetAttributesCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMNetAttributesCollection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMNetAttributesCollection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMNetAttributesCollection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMNetAttributesCollectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetAttributesCollection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMNetAttributesCollection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMNetAttributesCollectionObject_dealloc(PyISMNetAttributesCollectionObject* self)
{
    if (self->m_pISMNetAttributesCollection)
        self->m_pISMNetAttributesCollection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMNetAttributesCollection_GetpUnk(PyISMNetAttributesCollectionObject* self)
{
    if (!self->m_pISMNetAttributesCollection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMNetAttributesCollection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMNetAttributesCollection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMNetAttributesCollection_GetPointer(PyISMNetAttributesCollectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMNetAttributesCollection);
}

static PyObject*
PyISMNetAttributesCollection_GetIID(PyISMNetAttributesCollectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b65ff9-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMNetAttributesCollection_GetHR(PyISMNetAttributesCollectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMNetAttributesCollection_GetIgnoreFailures(PyISMNetAttributesCollectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMNetAttributesCollection_SetIgnoreFailures(PyISMNetAttributesCollectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMNetAttributesCollection_SupportsInterface(PyISMNetAttributesCollectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMNetAttributesCollection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMNetAttributesCollectionMethod_get_Count(PyISMNetAttributesCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetAttributesCollection->get_Count(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetAttributesCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetAttributesCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetAttributesCollection.get_Count() returned %ld", (long)hr);
        goto ismnetattributescollection_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismnetattributescollection_get_count_method_cleanup;

    ismnetattributescollection_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetAttributesCollection.get_Count");
    return return_tuple;
}

static PyObject*
ISMNetAttributesCollectionMethod_get_Item(PyISMNetAttributesCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;
    ISMNetAttribute* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPosition))
      goto ismnetattributescollection_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetAttributesCollection->get_Item(lPosition, &ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetAttributesCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetAttributesCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetAttributesCollection.get_Item() returned %ld", (long)hr);
        goto ismnetattributescollection_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMNetAttribute);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismnetattributescollection_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismnetattributescollection_get_item_method_cleanup;

    ismnetattributescollection_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetAttributesCollection.get_Item");
    return return_tuple;
}


PyMethodDef PyISMNetAttributesCollectionMethods[] = {
    {"supports", (PyCFunction)PyISMNetAttributesCollection_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)ISMNetAttributesCollectionMethod_get_Count, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)ISMNetAttributesCollectionMethod_get_Item, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMNetAttributesCollectionGetSet[] = {
  {"_pUnk", (getter)PyISMNetAttributesCollection_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMNetAttributesCollection", NULL},
  {"_pointer", (getter)PyISMNetAttributesCollection_GetPointer, NULL, "Get memory address for ISMNetAttributesCollection", NULL},
  {"_IID", (getter)PyISMNetAttributesCollection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMNetAttributesCollection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMNetAttributesCollection_GetIgnoreFailures, (setter)PyISMNetAttributesCollection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMNetAttributesCollectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMNetAttributesCollectionObject",                          
                                              /* tp_name */
  sizeof(PyISMNetAttributesCollectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMNetAttributesCollectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMNetAttributesCollectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMNetAttributesCollectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMNetAttributesCollectionObject_new,                      
                                              /* tp_new */
};

// Interface ISMNetBarrier

typedef struct PyISMNetBarrierObject {
    PyObject_HEAD
    ISMNetBarrier* m_pISMNetBarrier;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMNetBarrierObject;

static PyObject*
PyISMNetBarrierObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMNetBarrierObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMNetBarrier* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMNetBarrier, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMNetBarrier with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMNetBarrierObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetBarrier");
            return NULL;
        }
        self->m_pISMNetBarrier = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMNetBarrier");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMNetBarrier");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMNetBarrier* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMNetBarrier, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMNetBarrier");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMNetBarrierObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetBarrier");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMNetBarrier = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMNetBarrierObject_dealloc(PyISMNetBarrierObject* self)
{
    if (self->m_pISMNetBarrier)
        self->m_pISMNetBarrier->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMNetBarrier_GetpUnk(PyISMNetBarrierObject* self)
{
    if (!self->m_pISMNetBarrier)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMNetBarrier->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMNetBarrier to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMNetBarrier_GetPointer(PyISMNetBarrierObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMNetBarrier);
}

static PyObject*
PyISMNetBarrier_GetIID(PyISMNetBarrierObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b65ffc-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMNetBarrier_GetHR(PyISMNetBarrierObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMNetBarrier_GetIgnoreFailures(PyISMNetBarrierObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMNetBarrier_SetIgnoreFailures(PyISMNetBarrierObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMNetBarrier_SupportsInterface(PyISMNetBarrierObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMNetBarrier->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMNetBarrierMethod_get_BarrierID(PyISMNetBarrierObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetBarrier->get_BarrierID(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetBarrier->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetBarrier) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetBarrier.get_BarrierID() returned %ld", (long)hr);
        goto ismnetbarrier_get_barrierid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismnetbarrier_get_barrierid_method_cleanup;

    ismnetbarrier_get_barrierid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetBarrier.get_BarrierID");
    return return_tuple;
}

static PyObject*
ISMNetBarrierMethod_put_BarrierID(PyISMNetBarrierObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpVal))
      goto ismnetbarrier_put_barrierid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetBarrier->put_BarrierID(lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetBarrier->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetBarrier) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetBarrier.put_BarrierID() returned %ld", (long)hr);
        goto ismnetbarrier_put_barrierid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismnetbarrier_put_barrierid_method_cleanup;

    ismnetbarrier_put_barrierid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetBarrier.put_BarrierID");
    return return_tuple;
}

static PyObject*
ISMNetBarrierMethod_get_Point(PyISMNetBarrierObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMNetBarrier->get_Point(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetBarrier->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetBarrier) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetBarrier.get_Point() returned %ld", (long)hr);
        goto ismnetbarrier_get_point_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMRouterPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismnetbarrier_get_point_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismnetbarrier_get_point_method_cleanup;

    ismnetbarrier_get_point_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetBarrier.get_Point");
    return return_tuple;
}

static PyObject*
ISMNetBarrierMethod_put_Point(PyISMNetBarrierObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippVal = NULL;
    PyObject* py_pVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto ismnetbarrier_put_point_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pVal, &IID_ISMRouterPoint, (void**)&ippVal))
        PyErr_SetString(PyExc_TypeError, "Argument pVal (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismnetbarrier_put_point_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMNetBarrier->put_Point(ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetBarrier->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetBarrier) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetBarrier.put_Point() returned %ld", (long)hr);
        goto ismnetbarrier_put_point_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismnetbarrier_put_point_method_cleanup;

    ismnetbarrier_put_point_method_cleanup:
    self->m_HR = hr;
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetBarrier.put_Point");
    return return_tuple;
}


PyMethodDef PyISMNetBarrierMethods[] = {
    {"supports", (PyCFunction)PyISMNetBarrier_SupportsInterface, METH_O, ""},
    {"get_BarrierID", (PyCFunction)ISMNetBarrierMethod_get_BarrierID, METH_VARARGS, ""},
    {"put_BarrierID", (PyCFunction)ISMNetBarrierMethod_put_BarrierID, METH_VARARGS, ""},
    {"get_Point", (PyCFunction)ISMNetBarrierMethod_get_Point, METH_VARARGS, ""},
    {"put_Point", (PyCFunction)ISMNetBarrierMethod_put_Point, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMNetBarrierGetSet[] = {
  {"_pUnk", (getter)PyISMNetBarrier_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMNetBarrier", NULL},
  {"_pointer", (getter)PyISMNetBarrier_GetPointer, NULL, "Get memory address for ISMNetBarrier", NULL},
  {"_IID", (getter)PyISMNetBarrier_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMNetBarrier_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMNetBarrier_GetIgnoreFailures, (setter)PyISMNetBarrier_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMNetBarrierObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMNetBarrierObject",                          
                                              /* tp_name */
  sizeof(PyISMNetBarrierObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMNetBarrierObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMNetBarrierMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMNetBarrierGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMNetBarrierObject_new,                      
                                              /* tp_new */
};

// Interface ISMNetBarriersCollection

typedef struct PyISMNetBarriersCollectionObject {
    PyObject_HEAD
    ISMNetBarriersCollection* m_pISMNetBarriersCollection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMNetBarriersCollectionObject;

static PyObject*
PyISMNetBarriersCollectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMNetBarriersCollectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMNetBarriersCollection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMNetBarriersCollection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMNetBarriersCollection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMNetBarriersCollectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetBarriersCollection");
            return NULL;
        }
        self->m_pISMNetBarriersCollection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMNetBarriersCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMNetBarriersCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMNetBarriersCollection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMNetBarriersCollection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMNetBarriersCollection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMNetBarriersCollectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetBarriersCollection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMNetBarriersCollection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMNetBarriersCollectionObject_dealloc(PyISMNetBarriersCollectionObject* self)
{
    if (self->m_pISMNetBarriersCollection)
        self->m_pISMNetBarriersCollection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMNetBarriersCollection_GetpUnk(PyISMNetBarriersCollectionObject* self)
{
    if (!self->m_pISMNetBarriersCollection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMNetBarriersCollection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMNetBarriersCollection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMNetBarriersCollection_GetPointer(PyISMNetBarriersCollectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMNetBarriersCollection);
}

static PyObject*
PyISMNetBarriersCollection_GetIID(PyISMNetBarriersCollectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b65fff-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMNetBarriersCollection_GetHR(PyISMNetBarriersCollectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMNetBarriersCollection_GetIgnoreFailures(PyISMNetBarriersCollectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMNetBarriersCollection_SetIgnoreFailures(PyISMNetBarriersCollectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMNetBarriersCollection_SupportsInterface(PyISMNetBarriersCollectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMNetBarriersCollection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMNetBarriersCollectionMethod_Add(PyISMNetBarriersCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMNetBarrier* ippItem = NULL;
    PyObject* py_pItem;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pItem))
      goto ismnetbarrierscollection_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pItem, &IID_ISMNetBarrier, (void**)&ippItem))
        PyErr_SetString(PyExc_TypeError, "Argument pItem (position 0) is not ISMNetBarrier");
    
    if (PyErr_Occurred())
      goto ismnetbarrierscollection_add_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMNetBarriersCollection->Add(ippItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetBarriersCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetBarriersCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetBarriersCollection.Add() returned %ld", (long)hr);
        goto ismnetbarrierscollection_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pItem

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismnetbarrierscollection_add_method_cleanup;

    ismnetbarrierscollection_add_method_cleanup:
    self->m_HR = hr;
    if (ippItem)
      ippItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetBarriersCollection.Add");
    return return_tuple;
}

static PyObject*
ISMNetBarriersCollectionMethod_Remove(PyISMNetBarriersCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long llID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &llID))
      goto ismnetbarrierscollection_remove_method_cleanup;

    // Set up initial variable values as needed
    // No setup for lID

    // Call method on actual COM interface
    hr = self->m_pISMNetBarriersCollection->Remove(llID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetBarriersCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetBarriersCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetBarriersCollection.Remove() returned %ld", (long)hr);
        goto ismnetbarrierscollection_remove_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismnetbarrierscollection_remove_method_cleanup;

    ismnetbarrierscollection_remove_method_cleanup:
    self->m_HR = hr;
    // No cleanup for lID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetBarriersCollection.Remove");
    return return_tuple;
}

static PyObject*
ISMNetBarriersCollectionMethod_Clear(PyISMNetBarriersCollectionObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pISMNetBarriersCollection->Clear();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetBarriersCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetBarriersCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetBarriersCollection.Clear() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyISMNetBarriersCollectionMethods[] = {
    {"supports", (PyCFunction)PyISMNetBarriersCollection_SupportsInterface, METH_O, ""},
    {"Add", (PyCFunction)ISMNetBarriersCollectionMethod_Add, METH_VARARGS, ""},
    {"Remove", (PyCFunction)ISMNetBarriersCollectionMethod_Remove, METH_VARARGS, ""},
    {"Clear", (PyCFunction)ISMNetBarriersCollectionMethod_Clear, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMNetBarriersCollectionGetSet[] = {
  {"_pUnk", (getter)PyISMNetBarriersCollection_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMNetBarriersCollection", NULL},
  {"_pointer", (getter)PyISMNetBarriersCollection_GetPointer, NULL, "Get memory address for ISMNetBarriersCollection", NULL},
  {"_IID", (getter)PyISMNetBarriersCollection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMNetBarriersCollection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMNetBarriersCollection_GetIgnoreFailures, (setter)PyISMNetBarriersCollection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMNetBarriersCollectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMNetBarriersCollectionObject",                          
                                              /* tp_name */
  sizeof(PyISMNetBarriersCollectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMNetBarriersCollectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMNetBarriersCollectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMNetBarriersCollectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMNetBarriersCollectionObject_new,                      
                                              /* tp_new */
};

// Interface ISMRoadPreferences

typedef struct PyISMRoadPreferencesObject {
    PyObject_HEAD
    ISMRoadPreferences* m_pISMRoadPreferences;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRoadPreferencesObject;

static PyObject*
PyISMRoadPreferencesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRoadPreferencesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRoadPreferences* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRoadPreferences, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRoadPreferences with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRoadPreferencesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRoadPreferences");
            return NULL;
        }
        self->m_pISMRoadPreferences = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRoadPreferences");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRoadPreferences");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRoadPreferences* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRoadPreferences, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRoadPreferences");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRoadPreferencesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRoadPreferences");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRoadPreferences = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRoadPreferencesObject_dealloc(PyISMRoadPreferencesObject* self)
{
    if (self->m_pISMRoadPreferences)
        self->m_pISMRoadPreferences->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRoadPreferences_GetpUnk(PyISMRoadPreferencesObject* self)
{
    if (!self->m_pISMRoadPreferences)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRoadPreferences->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRoadPreferences to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRoadPreferences_GetPointer(PyISMRoadPreferencesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRoadPreferences);
}

static PyObject*
PyISMRoadPreferences_GetIID(PyISMRoadPreferencesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b66002-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRoadPreferences_GetHR(PyISMRoadPreferencesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRoadPreferences_GetIgnoreFailures(PyISMRoadPreferencesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRoadPreferences_SetIgnoreFailures(PyISMRoadPreferencesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRoadPreferences_SupportsInterface(PyISMRoadPreferencesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRoadPreferences->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRoadPreferencesMethod_get_Item(PyISMRoadPreferencesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMRoadType eRoadType;
    short spVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eRoadType))
      goto ismroadpreferences_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for RoadType
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRoadPreferences->get_Item(eRoadType, &spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRoadPreferences->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRoadPreferences) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRoadPreferences.get_Item() returned %ld", (long)hr);
        goto ismroadpreferences_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for RoadType
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spVal);
    goto ismroadpreferences_get_item_method_cleanup;

    ismroadpreferences_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for RoadType
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRoadPreferences.get_Item");
    return return_tuple;
}

static PyObject*
ISMRoadPreferencesMethod_put_Item(PyISMRoadPreferencesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMRoadType eRoadType;
    short spVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ih", (int *)&eRoadType, &spVal))
      goto ismroadpreferences_put_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for RoadType
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRoadPreferences->put_Item(eRoadType, spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRoadPreferences->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRoadPreferences) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRoadPreferences.put_Item() returned %ld", (long)hr);
        goto ismroadpreferences_put_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for RoadType
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismroadpreferences_put_item_method_cleanup;

    ismroadpreferences_put_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for RoadType
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRoadPreferences.put_Item");
    return return_tuple;
}


PyMethodDef PyISMRoadPreferencesMethods[] = {
    {"supports", (PyCFunction)PyISMRoadPreferences_SupportsInterface, METH_O, ""},
    {"get_Item", (PyCFunction)ISMRoadPreferencesMethod_get_Item, METH_VARARGS, ""},
    {"put_Item", (PyCFunction)ISMRoadPreferencesMethod_put_Item, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRoadPreferencesGetSet[] = {
  {"_pUnk", (getter)PyISMRoadPreferences_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRoadPreferences", NULL},
  {"_pointer", (getter)PyISMRoadPreferences_GetPointer, NULL, "Get memory address for ISMRoadPreferences", NULL},
  {"_IID", (getter)PyISMRoadPreferences_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRoadPreferences_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRoadPreferences_GetIgnoreFailures, (setter)PyISMRoadPreferences_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRoadPreferencesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRoadPreferencesObject",                          
                                              /* tp_name */
  sizeof(PyISMRoadPreferencesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRoadPreferencesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRoadPreferencesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRoadPreferencesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRoadPreferencesObject_new,                      
                                              /* tp_new */
};

// Interface ISMSpeedGroup

typedef struct PyISMSpeedGroupObject {
    PyObject_HEAD
    ISMSpeedGroup* m_pISMSpeedGroup;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMSpeedGroupObject;

static PyObject*
PyISMSpeedGroupObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMSpeedGroupObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMSpeedGroup* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMSpeedGroup, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMSpeedGroup with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMSpeedGroupObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMSpeedGroup");
            return NULL;
        }
        self->m_pISMSpeedGroup = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMSpeedGroup");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMSpeedGroup");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMSpeedGroup* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMSpeedGroup, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMSpeedGroup");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMSpeedGroupObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMSpeedGroup");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMSpeedGroup = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMSpeedGroupObject_dealloc(PyISMSpeedGroupObject* self)
{
    if (self->m_pISMSpeedGroup)
        self->m_pISMSpeedGroup->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMSpeedGroup_GetpUnk(PyISMSpeedGroupObject* self)
{
    if (!self->m_pISMSpeedGroup)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMSpeedGroup->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMSpeedGroup to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMSpeedGroup_GetPointer(PyISMSpeedGroupObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMSpeedGroup);
}

static PyObject*
PyISMSpeedGroup_GetIID(PyISMSpeedGroupObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b66005-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMSpeedGroup_GetHR(PyISMSpeedGroupObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMSpeedGroup_GetIgnoreFailures(PyISMSpeedGroupObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMSpeedGroup_SetIgnoreFailures(PyISMSpeedGroupObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMSpeedGroup_SupportsInterface(PyISMSpeedGroupObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMSpeedGroup->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMSpeedGroupMethod_get_Speed(PyISMSpeedGroupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    float dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroup->get_Speed(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroup.get_Speed() returned %ld", (long)hr);
        goto ismspeedgroup_get_speed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("f",
                                            dpVal);
    goto ismspeedgroup_get_speed_method_cleanup;

    ismspeedgroup_get_speed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroup.get_Speed");
    return return_tuple;
}

static PyObject*
ISMSpeedGroupMethod_put_Speed(PyISMSpeedGroupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    float dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "f", &dpVal))
      goto ismspeedgroup_put_speed_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroup->put_Speed(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroup.put_Speed() returned %ld", (long)hr);
        goto ismspeedgroup_put_speed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismspeedgroup_put_speed_method_cleanup;

    ismspeedgroup_put_speed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroup.put_Speed");
    return return_tuple;
}

static PyObject*
ISMSpeedGroupMethod_get_Description(PyISMSpeedGroupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroup->get_Description(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroup.get_Description() returned %ld", (long)hr);
        goto ismspeedgroup_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismspeedgroup_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismspeedgroup_get_description_method_cleanup;

    ismspeedgroup_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroup.get_Description");
    return return_tuple;
}


PyMethodDef PyISMSpeedGroupMethods[] = {
    {"supports", (PyCFunction)PyISMSpeedGroup_SupportsInterface, METH_O, ""},
    {"get_Speed", (PyCFunction)ISMSpeedGroupMethod_get_Speed, METH_VARARGS, ""},
    {"put_Speed", (PyCFunction)ISMSpeedGroupMethod_put_Speed, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)ISMSpeedGroupMethod_get_Description, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMSpeedGroupGetSet[] = {
  {"_pUnk", (getter)PyISMSpeedGroup_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMSpeedGroup", NULL},
  {"_pointer", (getter)PyISMSpeedGroup_GetPointer, NULL, "Get memory address for ISMSpeedGroup", NULL},
  {"_IID", (getter)PyISMSpeedGroup_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMSpeedGroup_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMSpeedGroup_GetIgnoreFailures, (setter)PyISMSpeedGroup_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMSpeedGroupObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMSpeedGroupObject",                          
                                              /* tp_name */
  sizeof(PyISMSpeedGroupObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMSpeedGroupObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMSpeedGroupMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMSpeedGroupGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMSpeedGroupObject_new,                      
                                              /* tp_new */
};

// Interface ISMSpeedGroup2

typedef struct PyISMSpeedGroup2Object {
    PyObject_HEAD
    ISMSpeedGroup2* m_pISMSpeedGroup2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMSpeedGroup2Object;

static PyObject*
PyISMSpeedGroup2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMSpeedGroup2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMSpeedGroup2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMSpeedGroup2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMSpeedGroup2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMSpeedGroup2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMSpeedGroup2");
            return NULL;
        }
        self->m_pISMSpeedGroup2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMSpeedGroup2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMSpeedGroup2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMSpeedGroup2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMSpeedGroup2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMSpeedGroup2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMSpeedGroup2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMSpeedGroup2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMSpeedGroup2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMSpeedGroup2Object_dealloc(PyISMSpeedGroup2Object* self)
{
    if (self->m_pISMSpeedGroup2)
        self->m_pISMSpeedGroup2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMSpeedGroup2_GetpUnk(PyISMSpeedGroup2Object* self)
{
    if (!self->m_pISMSpeedGroup2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMSpeedGroup2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMSpeedGroup2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMSpeedGroup2_GetPointer(PyISMSpeedGroup2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMSpeedGroup2);
}

static PyObject*
PyISMSpeedGroup2_GetIID(PyISMSpeedGroup2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1e436c24-cf57-4aca-bbd3-ffddb1151fa7");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMSpeedGroup2_GetHR(PyISMSpeedGroup2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMSpeedGroup2_GetIgnoreFailures(PyISMSpeedGroup2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMSpeedGroup2_SetIgnoreFailures(PyISMSpeedGroup2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMSpeedGroup2_SupportsInterface(PyISMSpeedGroup2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMSpeedGroup2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMSpeedGroup2Method_get_QueryString(PyISMSpeedGroup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroup2->get_QueryString(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroup2.get_QueryString() returned %ld", (long)hr);
        goto ismspeedgroup2_get_querystring_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismspeedgroup2_get_querystring_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismspeedgroup2_get_querystring_method_cleanup;

    ismspeedgroup2_get_querystring_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroup2.get_QueryString");
    return return_tuple;
}

static PyObject*
ISMSpeedGroup2Method_get_Speed(PyISMSpeedGroup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    float dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroup2->get_Speed(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroup2.get_Speed() returned %ld", (long)hr);
        goto ismspeedgroup2_get_speed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("f",
                                            dpVal);
    goto ismspeedgroup2_get_speed_method_cleanup;

    ismspeedgroup2_get_speed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroup2.get_Speed");
    return return_tuple;
}

static PyObject*
ISMSpeedGroup2Method_put_Speed(PyISMSpeedGroup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    float dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "f", &dpVal))
      goto ismspeedgroup2_put_speed_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroup2->put_Speed(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroup2.put_Speed() returned %ld", (long)hr);
        goto ismspeedgroup2_put_speed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismspeedgroup2_put_speed_method_cleanup;

    ismspeedgroup2_put_speed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroup2.put_Speed");
    return return_tuple;
}

static PyObject*
ISMSpeedGroup2Method_get_Description(PyISMSpeedGroup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroup2->get_Description(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroup2.get_Description() returned %ld", (long)hr);
        goto ismspeedgroup2_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismspeedgroup2_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismspeedgroup2_get_description_method_cleanup;

    ismspeedgroup2_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroup2.get_Description");
    return return_tuple;
}


PyMethodDef PyISMSpeedGroup2Methods[] = {
    {"supports", (PyCFunction)PyISMSpeedGroup2_SupportsInterface, METH_O, ""},
    {"get_QueryString", (PyCFunction)ISMSpeedGroup2Method_get_QueryString, METH_VARARGS, ""},
    {"get_Speed", (PyCFunction)ISMSpeedGroup2Method_get_Speed, METH_VARARGS, ""},
    {"put_Speed", (PyCFunction)ISMSpeedGroup2Method_put_Speed, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)ISMSpeedGroup2Method_get_Description, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMSpeedGroup2GetSet[] = {
  {"_pUnk", (getter)PyISMSpeedGroup2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMSpeedGroup2", NULL},
  {"_pointer", (getter)PyISMSpeedGroup2_GetPointer, NULL, "Get memory address for ISMSpeedGroup2", NULL},
  {"_IID", (getter)PyISMSpeedGroup2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMSpeedGroup2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMSpeedGroup2_GetIgnoreFailures, (setter)PyISMSpeedGroup2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMSpeedGroup2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMSpeedGroup2Object",                          
                                              /* tp_name */
  sizeof(PyISMSpeedGroup2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMSpeedGroup2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMSpeedGroup2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMSpeedGroup2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMSpeedGroup2Object_new,                      
                                              /* tp_new */
};

// Interface ISMSpeedGroups

typedef struct PyISMSpeedGroupsObject {
    PyObject_HEAD
    ISMSpeedGroups* m_pISMSpeedGroups;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMSpeedGroupsObject;

static PyObject*
PyISMSpeedGroupsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMSpeedGroupsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMSpeedGroups* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMSpeedGroups, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMSpeedGroups with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMSpeedGroupsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMSpeedGroups");
            return NULL;
        }
        self->m_pISMSpeedGroups = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMSpeedGroups");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMSpeedGroups");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMSpeedGroups* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMSpeedGroups, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMSpeedGroups");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMSpeedGroupsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMSpeedGroups");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMSpeedGroups = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMSpeedGroupsObject_dealloc(PyISMSpeedGroupsObject* self)
{
    if (self->m_pISMSpeedGroups)
        self->m_pISMSpeedGroups->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMSpeedGroups_GetpUnk(PyISMSpeedGroupsObject* self)
{
    if (!self->m_pISMSpeedGroups)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMSpeedGroups->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMSpeedGroups to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMSpeedGroups_GetPointer(PyISMSpeedGroupsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMSpeedGroups);
}

static PyObject*
PyISMSpeedGroups_GetIID(PyISMSpeedGroupsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b66008-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMSpeedGroups_GetHR(PyISMSpeedGroupsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMSpeedGroups_GetIgnoreFailures(PyISMSpeedGroupsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMSpeedGroups_SetIgnoreFailures(PyISMSpeedGroupsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMSpeedGroups_SupportsInterface(PyISMSpeedGroupsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMSpeedGroups->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMSpeedGroupsMethod_get_Count(PyISMSpeedGroupsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroups->get_Count(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroups->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroups) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroups.get_Count() returned %ld", (long)hr);
        goto ismspeedgroups_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismspeedgroups_get_count_method_cleanup;

    ismspeedgroups_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroups.get_Count");
    return return_tuple;
}

static PyObject*
ISMSpeedGroupsMethod_get_Item(PyISMSpeedGroupsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;
    ISMSpeedGroup* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPosition))
      goto ismspeedgroups_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMSpeedGroups->get_Item(lPosition, &ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMSpeedGroups->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMSpeedGroups) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMSpeedGroups.get_Item() returned %ld", (long)hr);
        goto ismspeedgroups_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMSpeedGroup);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismspeedgroups_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismspeedgroups_get_item_method_cleanup;

    ismspeedgroups_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMSpeedGroups.get_Item");
    return return_tuple;
}


PyMethodDef PyISMSpeedGroupsMethods[] = {
    {"supports", (PyCFunction)PyISMSpeedGroups_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)ISMSpeedGroupsMethod_get_Count, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)ISMSpeedGroupsMethod_get_Item, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMSpeedGroupsGetSet[] = {
  {"_pUnk", (getter)PyISMSpeedGroups_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMSpeedGroups", NULL},
  {"_pointer", (getter)PyISMSpeedGroups_GetPointer, NULL, "Get memory address for ISMSpeedGroups", NULL},
  {"_IID", (getter)PyISMSpeedGroups_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMSpeedGroups_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMSpeedGroups_GetIgnoreFailures, (setter)PyISMSpeedGroups_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMSpeedGroupsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMSpeedGroupsObject",                          
                                              /* tp_name */
  sizeof(PyISMSpeedGroupsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMSpeedGroupsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMSpeedGroupsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMSpeedGroupsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMSpeedGroupsObject_new,                      
                                              /* tp_new */
};

// Interface ISMTripPlanSettings

typedef struct PyISMTripPlanSettingsObject {
    PyObject_HEAD
    ISMTripPlanSettings* m_pISMTripPlanSettings;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMTripPlanSettingsObject;

static PyObject*
PyISMTripPlanSettingsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMTripPlanSettingsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMTripPlanSettings* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMTripPlanSettings, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMTripPlanSettings with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMTripPlanSettingsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMTripPlanSettings");
            return NULL;
        }
        self->m_pISMTripPlanSettings = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMTripPlanSettings");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMTripPlanSettings");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMTripPlanSettings* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMTripPlanSettings, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMTripPlanSettings");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMTripPlanSettingsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMTripPlanSettings");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMTripPlanSettings = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMTripPlanSettingsObject_dealloc(PyISMTripPlanSettingsObject* self)
{
    if (self->m_pISMTripPlanSettings)
        self->m_pISMTripPlanSettings->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMTripPlanSettings_GetpUnk(PyISMTripPlanSettingsObject* self)
{
    if (!self->m_pISMTripPlanSettings)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMTripPlanSettings->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMTripPlanSettings to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMTripPlanSettings_GetPointer(PyISMTripPlanSettingsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMTripPlanSettings);
}

static PyObject*
PyISMTripPlanSettings_GetIID(PyISMTripPlanSettingsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b6600b-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMTripPlanSettings_GetHR(PyISMTripPlanSettingsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMTripPlanSettings_GetIgnoreFailures(PyISMTripPlanSettingsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMTripPlanSettings_SetIgnoreFailures(PyISMTripPlanSettingsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMTripPlanSettings_SupportsInterface(PyISMTripPlanSettingsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMTripPlanSettingsMethod_get_TripPlanningEnable(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->get_TripPlanningEnable(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.get_TripPlanningEnable() returned %ld", (long)hr);
        goto ismtripplansettings_get_tripplanningenable_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ismtripplansettings_get_tripplanningenable_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismtripplansettings_get_tripplanningenable_method_cleanup;

    ismtripplansettings_get_tripplanningenable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.get_TripPlanningEnable");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_put_TripPlanningEnable(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto ismtripplansettings_put_tripplanningenable_method_cleanup;

    // Set up initial variable values as needed
    b_pVal = ((PyObject_IsTrue(pyvar_pVal) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ismtripplansettings_put_tripplanningenable_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->put_TripPlanningEnable(b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.put_TripPlanningEnable() returned %ld", (long)hr);
        goto ismtripplansettings_put_tripplanningenable_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismtripplansettings_put_tripplanningenable_method_cleanup;

    ismtripplansettings_put_tripplanningenable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.put_TripPlanningEnable");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_get_TripStart(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpVal;
    PyObject* py_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->get_TripStart(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.get_TripStart() returned %ld", (long)hr);
        goto ismtripplansettings_get_tripstart_method_cleanup;
    }

    // Set up return values as needed
    py_pVal = DATE_AsPyObject(dpVal);
    if (PyErr_Occurred())
      goto ismtripplansettings_get_tripstart_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismtripplansettings_get_tripstart_method_cleanup;

    ismtripplansettings_get_tripstart_method_cleanup:
    self->m_HR = hr;
    if (py_pVal && (py_pVal != Py_None))
      Py_XDECREF(py_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.get_TripStart");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_put_TripStart(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpVal;
    PyObject* py_pVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto ismtripplansettings_put_tripstart_method_cleanup;

    // Set up initial variable values as needed
    dpVal = PyObject_AsDATE(py_pVal);
    
    if (PyErr_Occurred())
      goto ismtripplansettings_put_tripstart_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->put_TripStart(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.put_TripStart() returned %ld", (long)hr);
        goto ismtripplansettings_put_tripstart_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismtripplansettings_put_tripstart_method_cleanup;

    ismtripplansettings_put_tripstart_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.put_TripStart");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_get_DayDriveStart(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpVal;
    PyObject* py_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->get_DayDriveStart(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.get_DayDriveStart() returned %ld", (long)hr);
        goto ismtripplansettings_get_daydrivestart_method_cleanup;
    }

    // Set up return values as needed
    py_pVal = DATE_AsPyObject(dpVal);
    if (PyErr_Occurred())
      goto ismtripplansettings_get_daydrivestart_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismtripplansettings_get_daydrivestart_method_cleanup;

    ismtripplansettings_get_daydrivestart_method_cleanup:
    self->m_HR = hr;
    if (py_pVal && (py_pVal != Py_None))
      Py_XDECREF(py_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.get_DayDriveStart");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_put_DayDriveStart(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpVal;
    PyObject* py_pVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto ismtripplansettings_put_daydrivestart_method_cleanup;

    // Set up initial variable values as needed
    dpVal = PyObject_AsDATE(py_pVal);
    
    if (PyErr_Occurred())
      goto ismtripplansettings_put_daydrivestart_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->put_DayDriveStart(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.put_DayDriveStart() returned %ld", (long)hr);
        goto ismtripplansettings_put_daydrivestart_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismtripplansettings_put_daydrivestart_method_cleanup;

    ismtripplansettings_put_daydrivestart_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.put_DayDriveStart");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_get_DayDriveEnd(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpVal;
    PyObject* py_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->get_DayDriveEnd(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.get_DayDriveEnd() returned %ld", (long)hr);
        goto ismtripplansettings_get_daydriveend_method_cleanup;
    }

    // Set up return values as needed
    py_pVal = DATE_AsPyObject(dpVal);
    if (PyErr_Occurred())
      goto ismtripplansettings_get_daydriveend_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismtripplansettings_get_daydriveend_method_cleanup;

    ismtripplansettings_get_daydriveend_method_cleanup:
    self->m_HR = hr;
    if (py_pVal && (py_pVal != Py_None))
      Py_XDECREF(py_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.get_DayDriveEnd");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_put_DayDriveEnd(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpVal;
    PyObject* py_pVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto ismtripplansettings_put_daydriveend_method_cleanup;

    // Set up initial variable values as needed
    dpVal = PyObject_AsDATE(py_pVal);
    
    if (PyErr_Occurred())
      goto ismtripplansettings_put_daydriveend_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->put_DayDriveEnd(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.put_DayDriveEnd() returned %ld", (long)hr);
        goto ismtripplansettings_put_daydriveend_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismtripplansettings_put_daydriveend_method_cleanup;

    ismtripplansettings_put_daydriveend_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.put_DayDriveEnd");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_get_DriveFlexibility(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->get_DriveFlexibility(&spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.get_DriveFlexibility() returned %ld", (long)hr);
        goto ismtripplansettings_get_driveflexibility_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spVal);
    goto ismtripplansettings_get_driveflexibility_method_cleanup;

    ismtripplansettings_get_driveflexibility_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.get_DriveFlexibility");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_put_DriveFlexibility(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spVal))
      goto ismtripplansettings_put_driveflexibility_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->put_DriveFlexibility(spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.put_DriveFlexibility() returned %ld", (long)hr);
        goto ismtripplansettings_put_driveflexibility_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismtripplansettings_put_driveflexibility_method_cleanup;

    ismtripplansettings_put_driveflexibility_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.put_DriveFlexibility");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_get_RestBreaksEnable(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->get_RestBreaksEnable(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.get_RestBreaksEnable() returned %ld", (long)hr);
        goto ismtripplansettings_get_restbreaksenable_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ismtripplansettings_get_restbreaksenable_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismtripplansettings_get_restbreaksenable_method_cleanup;

    ismtripplansettings_get_restbreaksenable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.get_RestBreaksEnable");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_put_RestBreaksEnable(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto ismtripplansettings_put_restbreaksenable_method_cleanup;

    // Set up initial variable values as needed
    b_pVal = ((PyObject_IsTrue(pyvar_pVal) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ismtripplansettings_put_restbreaksenable_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->put_RestBreaksEnable(b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.put_RestBreaksEnable() returned %ld", (long)hr);
        goto ismtripplansettings_put_restbreaksenable_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismtripplansettings_put_restbreaksenable_method_cleanup;

    ismtripplansettings_put_restbreaksenable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.put_RestBreaksEnable");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_get_RestDuration(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->get_RestDuration(&spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.get_RestDuration() returned %ld", (long)hr);
        goto ismtripplansettings_get_restduration_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spVal);
    goto ismtripplansettings_get_restduration_method_cleanup;

    ismtripplansettings_get_restduration_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.get_RestDuration");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_put_RestDuration(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spVal))
      goto ismtripplansettings_put_restduration_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->put_RestDuration(spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.put_RestDuration() returned %ld", (long)hr);
        goto ismtripplansettings_put_restduration_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismtripplansettings_put_restduration_method_cleanup;

    ismtripplansettings_put_restduration_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.put_RestDuration");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_get_DriveBetweenRest(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->get_DriveBetweenRest(&spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.get_DriveBetweenRest() returned %ld", (long)hr);
        goto ismtripplansettings_get_drivebetweenrest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spVal);
    goto ismtripplansettings_get_drivebetweenrest_method_cleanup;

    ismtripplansettings_get_drivebetweenrest_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.get_DriveBetweenRest");
    return return_tuple;
}

static PyObject*
ISMTripPlanSettingsMethod_put_DriveBetweenRest(PyISMTripPlanSettingsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spVal))
      goto ismtripplansettings_put_drivebetweenrest_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMTripPlanSettings->put_DriveBetweenRest(spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMTripPlanSettings->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMTripPlanSettings) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMTripPlanSettings.put_DriveBetweenRest() returned %ld", (long)hr);
        goto ismtripplansettings_put_drivebetweenrest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismtripplansettings_put_drivebetweenrest_method_cleanup;

    ismtripplansettings_put_drivebetweenrest_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMTripPlanSettings.put_DriveBetweenRest");
    return return_tuple;
}


PyMethodDef PyISMTripPlanSettingsMethods[] = {
    {"supports", (PyCFunction)PyISMTripPlanSettings_SupportsInterface, METH_O, ""},
    {"get_TripPlanningEnable", (PyCFunction)ISMTripPlanSettingsMethod_get_TripPlanningEnable, METH_VARARGS, ""},
    {"put_TripPlanningEnable", (PyCFunction)ISMTripPlanSettingsMethod_put_TripPlanningEnable, METH_VARARGS, ""},
    {"get_TripStart", (PyCFunction)ISMTripPlanSettingsMethod_get_TripStart, METH_VARARGS, ""},
    {"put_TripStart", (PyCFunction)ISMTripPlanSettingsMethod_put_TripStart, METH_VARARGS, ""},
    {"get_DayDriveStart", (PyCFunction)ISMTripPlanSettingsMethod_get_DayDriveStart, METH_VARARGS, ""},
    {"put_DayDriveStart", (PyCFunction)ISMTripPlanSettingsMethod_put_DayDriveStart, METH_VARARGS, ""},
    {"get_DayDriveEnd", (PyCFunction)ISMTripPlanSettingsMethod_get_DayDriveEnd, METH_VARARGS, ""},
    {"put_DayDriveEnd", (PyCFunction)ISMTripPlanSettingsMethod_put_DayDriveEnd, METH_VARARGS, ""},
    {"get_DriveFlexibility", (PyCFunction)ISMTripPlanSettingsMethod_get_DriveFlexibility, METH_VARARGS, ""},
    {"put_DriveFlexibility", (PyCFunction)ISMTripPlanSettingsMethod_put_DriveFlexibility, METH_VARARGS, ""},
    {"get_RestBreaksEnable", (PyCFunction)ISMTripPlanSettingsMethod_get_RestBreaksEnable, METH_VARARGS, ""},
    {"put_RestBreaksEnable", (PyCFunction)ISMTripPlanSettingsMethod_put_RestBreaksEnable, METH_VARARGS, ""},
    {"get_RestDuration", (PyCFunction)ISMTripPlanSettingsMethod_get_RestDuration, METH_VARARGS, ""},
    {"put_RestDuration", (PyCFunction)ISMTripPlanSettingsMethod_put_RestDuration, METH_VARARGS, ""},
    {"get_DriveBetweenRest", (PyCFunction)ISMTripPlanSettingsMethod_get_DriveBetweenRest, METH_VARARGS, ""},
    {"put_DriveBetweenRest", (PyCFunction)ISMTripPlanSettingsMethod_put_DriveBetweenRest, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMTripPlanSettingsGetSet[] = {
  {"_pUnk", (getter)PyISMTripPlanSettings_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMTripPlanSettings", NULL},
  {"_pointer", (getter)PyISMTripPlanSettings_GetPointer, NULL, "Get memory address for ISMTripPlanSettings", NULL},
  {"_IID", (getter)PyISMTripPlanSettings_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMTripPlanSettings_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMTripPlanSettings_GetIgnoreFailures, (setter)PyISMTripPlanSettings_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMTripPlanSettingsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMTripPlanSettingsObject",                          
                                              /* tp_name */
  sizeof(PyISMTripPlanSettingsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMTripPlanSettingsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMTripPlanSettingsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMTripPlanSettingsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMTripPlanSettingsObject_new,                      
                                              /* tp_new */
};

// Interface ISMFlag

typedef struct PyISMFlagObject {
    PyObject_HEAD
    ISMFlag* m_pISMFlag;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMFlagObject;

static PyObject*
PyISMFlagObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMFlagObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMFlag* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMFlag, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMFlag with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMFlagObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMFlag");
            return NULL;
        }
        self->m_pISMFlag = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMFlag");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMFlag");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMFlag* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMFlag, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMFlag");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMFlagObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMFlag");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMFlag = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMFlagObject_dealloc(PyISMFlagObject* self)
{
    if (self->m_pISMFlag)
        self->m_pISMFlag->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMFlag_GetpUnk(PyISMFlagObject* self)
{
    if (!self->m_pISMFlag)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMFlag->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMFlag to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMFlag_GetPointer(PyISMFlagObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMFlag);
}

static PyObject*
PyISMFlag_GetIID(PyISMFlagObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b66011-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMFlag_GetHR(PyISMFlagObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMFlag_GetIgnoreFailures(PyISMFlagObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMFlag_SetIgnoreFailures(PyISMFlagObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMFlag_SupportsInterface(PyISMFlagObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMFlagMethod_get_ObjectID(PyISMFlagObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlag->get_ObjectID(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlag) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlag.get_ObjectID() returned %ld", (long)hr);
        goto ismflag_get_objectid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismflag_get_objectid_method_cleanup;

    ismflag_get_objectid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlag.get_ObjectID");
    return return_tuple;
}

static PyObject*
ISMFlagMethod_put_ObjectID(PyISMFlagObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpVal))
      goto ismflag_put_objectid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlag->put_ObjectID(lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlag) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlag.put_ObjectID() returned %ld", (long)hr);
        goto ismflag_put_objectid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismflag_put_objectid_method_cleanup;

    ismflag_put_objectid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlag.put_ObjectID");
    return return_tuple;
}

static PyObject*
ISMFlagMethod_get_PercentAlong(PyISMFlagObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    float dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlag->get_PercentAlong(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlag) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlag.get_PercentAlong() returned %ld", (long)hr);
        goto ismflag_get_percentalong_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("f",
                                            dpVal);
    goto ismflag_get_percentalong_method_cleanup;

    ismflag_get_percentalong_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlag.get_PercentAlong");
    return return_tuple;
}

static PyObject*
ISMFlagMethod_put_PercentAlong(PyISMFlagObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    float dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "f", &dpVal))
      goto ismflag_put_percentalong_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlag->put_PercentAlong(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlag) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlag.put_PercentAlong() returned %ld", (long)hr);
        goto ismflag_put_percentalong_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismflag_put_percentalong_method_cleanup;

    ismflag_put_percentalong_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlag.put_PercentAlong");
    return return_tuple;
}

static PyObject*
ISMFlagMethod_get_Side(PyISMFlagObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMStreetSideType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlag->get_Side(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlag) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlag.get_Side() returned %ld", (long)hr);
        goto ismflag_get_side_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismflag_get_side_method_cleanup;

    ismflag_get_side_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlag.get_Side");
    return return_tuple;
}

static PyObject*
ISMFlagMethod_put_Side(PyISMFlagObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMStreetSideType epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto ismflag_put_side_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlag->put_Side(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlag) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlag.put_Side() returned %ld", (long)hr);
        goto ismflag_put_side_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismflag_put_side_method_cleanup;

    ismflag_put_side_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlag.put_Side");
    return return_tuple;
}

static PyObject*
ISMFlagMethod_get_StreetPoint(PyISMFlagObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlag->get_StreetPoint(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlag) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlag.get_StreetPoint() returned %ld", (long)hr);
        goto ismflag_get_streetpoint_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMRouterPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismflag_get_streetpoint_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismflag_get_streetpoint_method_cleanup;

    ismflag_get_streetpoint_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlag.get_StreetPoint");
    return return_tuple;
}

static PyObject*
ISMFlagMethod_put_StreetPoint(PyISMFlagObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippVal = NULL;
    PyObject* py_pVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto ismflag_put_streetpoint_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pVal, &IID_ISMRouterPoint, (void**)&ippVal))
        PyErr_SetString(PyExc_TypeError, "Argument pVal (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismflag_put_streetpoint_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMFlag->put_StreetPoint(ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlag->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlag) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlag.put_StreetPoint() returned %ld", (long)hr);
        goto ismflag_put_streetpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismflag_put_streetpoint_method_cleanup;

    ismflag_put_streetpoint_method_cleanup:
    self->m_HR = hr;
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlag.put_StreetPoint");
    return return_tuple;
}


PyMethodDef PyISMFlagMethods[] = {
    {"supports", (PyCFunction)PyISMFlag_SupportsInterface, METH_O, ""},
    {"get_ObjectID", (PyCFunction)ISMFlagMethod_get_ObjectID, METH_VARARGS, ""},
    {"put_ObjectID", (PyCFunction)ISMFlagMethod_put_ObjectID, METH_VARARGS, ""},
    {"get_PercentAlong", (PyCFunction)ISMFlagMethod_get_PercentAlong, METH_VARARGS, ""},
    {"put_PercentAlong", (PyCFunction)ISMFlagMethod_put_PercentAlong, METH_VARARGS, ""},
    {"get_Side", (PyCFunction)ISMFlagMethod_get_Side, METH_VARARGS, ""},
    {"put_Side", (PyCFunction)ISMFlagMethod_put_Side, METH_VARARGS, ""},
    {"get_StreetPoint", (PyCFunction)ISMFlagMethod_get_StreetPoint, METH_VARARGS, ""},
    {"put_StreetPoint", (PyCFunction)ISMFlagMethod_put_StreetPoint, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMFlagGetSet[] = {
  {"_pUnk", (getter)PyISMFlag_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMFlag", NULL},
  {"_pointer", (getter)PyISMFlag_GetPointer, NULL, "Get memory address for ISMFlag", NULL},
  {"_IID", (getter)PyISMFlag_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMFlag_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMFlag_GetIgnoreFailures, (setter)PyISMFlag_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMFlagObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMFlagObject",                          
                                              /* tp_name */
  sizeof(PyISMFlagObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMFlagObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMFlagMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMFlagGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMFlagObject_new,                      
                                              /* tp_new */
};

// Interface ISMFlagCreator

typedef struct PyISMFlagCreatorObject {
    PyObject_HEAD
    ISMFlagCreator* m_pISMFlagCreator;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMFlagCreatorObject;

static PyObject*
PyISMFlagCreatorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMFlagCreatorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMFlagCreator* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMFlagCreator, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMFlagCreator with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMFlagCreatorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMFlagCreator");
            return NULL;
        }
        self->m_pISMFlagCreator = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMFlagCreator");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMFlagCreator");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMFlagCreator* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMFlagCreator, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMFlagCreator");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMFlagCreatorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMFlagCreator");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMFlagCreator = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMFlagCreatorObject_dealloc(PyISMFlagCreatorObject* self)
{
    if (self->m_pISMFlagCreator)
        self->m_pISMFlagCreator->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMFlagCreator_GetpUnk(PyISMFlagCreatorObject* self)
{
    if (!self->m_pISMFlagCreator)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMFlagCreator->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMFlagCreator to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMFlagCreator_GetPointer(PyISMFlagCreatorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMFlagCreator);
}

static PyObject*
PyISMFlagCreator_GetIID(PyISMFlagCreatorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8a4bb863-0c3f-4897-aa09-1479a4b76a6f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMFlagCreator_GetHR(PyISMFlagCreatorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMFlagCreator_GetIgnoreFailures(PyISMFlagCreatorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMFlagCreator_SetIgnoreFailures(PyISMFlagCreatorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMFlagCreator_SupportsInterface(PyISMFlagCreatorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMFlagCreator->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMFlagCreatorMethod_CreateFlag(PyISMFlagCreatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippPoint = NULL;
    PyObject* py_pPoint;
    ISMFlag* ippIFlag = NULL;
    PyObject* py_pIFlag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pPoint))
      goto ismflagcreator_createflag_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPoint, &IID_ISMRouterPoint, (void**)&ippPoint))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismflagcreator_createflag_method_cleanup;
    
    // No setup for pIFlag

    // Call method on actual COM interface
    hr = self->m_pISMFlagCreator->CreateFlag(ippPoint, &ippIFlag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlagCreator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlagCreator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlagCreator.CreateFlag() returned %ld", (long)hr);
        goto ismflagcreator_createflag_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPoint
    Py_XDECREF(py_pIFlag);
    if (ippIFlag)
    {
        IUnknown* pUnk = NULL;
        ippIFlag->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pIFlag = IUnknownToPythonIIDObject(pUnk, &IID_ISMFlag);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pIFlag)
    {
        if (py_pIFlag)
           Py_DECREF(py_pIFlag);
        py_pIFlag = Py_None;
        Py_INCREF(py_pIFlag);
    }
    if (PyErr_Occurred())
      goto ismflagcreator_createflag_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pIFlag);
    goto ismflagcreator_createflag_method_cleanup;

    ismflagcreator_createflag_method_cleanup:
    self->m_HR = hr;
    if (ippPoint)
      ippPoint->Release();
    Py_XDECREF(py_pIFlag);
    if (ippIFlag)
      ippIFlag->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlagCreator.CreateFlag");
    return return_tuple;
}

static PyObject*
ISMFlagCreatorMethod_CreateFlagDirection(PyISMFlagCreatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippPoint = NULL;
    PyObject* py_pPoint;
    double ddOrientation = 0;
    double ddTolerance = 0;
    double dpdAdjustedOrientation = 0;
    ISMFlag* ipppFlag = NULL;
    PyObject* py_ppFlag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Odd", &py_pPoint, &ddOrientation, &ddTolerance))
      goto ismflagcreator_createflagdirection_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPoint, &IID_ISMRouterPoint, (void**)&ippPoint))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismflagcreator_createflagdirection_method_cleanup;
    
    // No setup for dOrientation
    // No setup for dTolerance
    // No setup for pdAdjustedOrientation
    // No setup for ppFlag

    // Call method on actual COM interface
    hr = self->m_pISMFlagCreator->CreateFlagDirection(ippPoint, ddOrientation, ddTolerance, &dpdAdjustedOrientation, &ipppFlag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlagCreator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlagCreator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlagCreator.CreateFlagDirection() returned %ld", (long)hr);
        goto ismflagcreator_createflagdirection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPoint
    // No teardown for dOrientation
    // No teardown for dTolerance
    // No teardown for pdAdjustedOrientation
    Py_XDECREF(py_ppFlag);
    if (ipppFlag)
    {
        IUnknown* pUnk = NULL;
        ipppFlag->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFlag = IUnknownToPythonIIDObject(pUnk, &IID_ISMFlag);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFlag)
    {
        if (py_ppFlag)
           Py_DECREF(py_ppFlag);
        py_ppFlag = Py_None;
        Py_INCREF(py_ppFlag);
    }
    if (PyErr_Occurred())
      goto ismflagcreator_createflagdirection_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("dO",
                                            dpdAdjustedOrientation, py_ppFlag);
    goto ismflagcreator_createflagdirection_method_cleanup;

    ismflagcreator_createflagdirection_method_cleanup:
    self->m_HR = hr;
    if (ippPoint)
      ippPoint->Release();
    // No cleanup for dOrientation
    // No cleanup for dTolerance
    // No cleanup for pdAdjustedOrientation
    Py_XDECREF(py_ppFlag);
    if (ipppFlag)
      ipppFlag->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlagCreator.CreateFlagDirection");
    return return_tuple;
}

static PyObject*
ISMFlagCreatorMethod_CreateFlagDirectionAdv(PyISMFlagCreatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippPoint = NULL;
    PyObject* py_pPoint;
    double ddOrientation = 0;
    double ddTolerance = 0;
    double ddSpeed = 0;
    double ddLatency = 0;
    double dpdAdjustedOrientation = 0;
    ISMFlag* ipppFlag = NULL;
    PyObject* py_ppFlag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Odddd", &py_pPoint, &ddOrientation, &ddTolerance, &ddSpeed, &ddLatency))
      goto ismflagcreator_createflagdirectionadv_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPoint, &IID_ISMRouterPoint, (void**)&ippPoint))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismflagcreator_createflagdirectionadv_method_cleanup;
    
    // No setup for dOrientation
    // No setup for dTolerance
    // No setup for dSpeed
    // No setup for dLatency
    // No setup for pdAdjustedOrientation
    // No setup for ppFlag

    // Call method on actual COM interface
    hr = self->m_pISMFlagCreator->CreateFlagDirectionAdv(ippPoint, ddOrientation, ddTolerance, ddSpeed, ddLatency, &dpdAdjustedOrientation, &ipppFlag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlagCreator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlagCreator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlagCreator.CreateFlagDirectionAdv() returned %ld", (long)hr);
        goto ismflagcreator_createflagdirectionadv_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPoint
    // No teardown for dOrientation
    // No teardown for dTolerance
    // No teardown for dSpeed
    // No teardown for dLatency
    // No teardown for pdAdjustedOrientation
    Py_XDECREF(py_ppFlag);
    if (ipppFlag)
    {
        IUnknown* pUnk = NULL;
        ipppFlag->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFlag = IUnknownToPythonIIDObject(pUnk, &IID_ISMFlag);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFlag)
    {
        if (py_ppFlag)
           Py_DECREF(py_ppFlag);
        py_ppFlag = Py_None;
        Py_INCREF(py_ppFlag);
    }
    if (PyErr_Occurred())
      goto ismflagcreator_createflagdirectionadv_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("dO",
                                            dpdAdjustedOrientation, py_ppFlag);
    goto ismflagcreator_createflagdirectionadv_method_cleanup;

    ismflagcreator_createflagdirectionadv_method_cleanup:
    self->m_HR = hr;
    if (ippPoint)
      ippPoint->Release();
    // No cleanup for dOrientation
    // No cleanup for dTolerance
    // No cleanup for dSpeed
    // No cleanup for dLatency
    // No cleanup for pdAdjustedOrientation
    Py_XDECREF(py_ppFlag);
    if (ipppFlag)
      ipppFlag->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlagCreator.CreateFlagDirectionAdv");
    return return_tuple;
}


PyMethodDef PyISMFlagCreatorMethods[] = {
    {"supports", (PyCFunction)PyISMFlagCreator_SupportsInterface, METH_O, ""},
    {"CreateFlag", (PyCFunction)ISMFlagCreatorMethod_CreateFlag, METH_VARARGS, ""},
    {"CreateFlagDirection", (PyCFunction)ISMFlagCreatorMethod_CreateFlagDirection, METH_VARARGS, ""},
    {"CreateFlagDirectionAdv", (PyCFunction)ISMFlagCreatorMethod_CreateFlagDirectionAdv, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMFlagCreatorGetSet[] = {
  {"_pUnk", (getter)PyISMFlagCreator_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMFlagCreator", NULL},
  {"_pointer", (getter)PyISMFlagCreator_GetPointer, NULL, "Get memory address for ISMFlagCreator", NULL},
  {"_IID", (getter)PyISMFlagCreator_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMFlagCreator_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMFlagCreator_GetIgnoreFailures, (setter)PyISMFlagCreator_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMFlagCreatorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMFlagCreatorObject",                          
                                              /* tp_name */
  sizeof(PyISMFlagCreatorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMFlagCreatorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMFlagCreatorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMFlagCreatorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMFlagCreatorObject_new,                      
                                              /* tp_new */
};

// Interface ISMFlagCreator2

typedef struct PyISMFlagCreator2Object {
    PyObject_HEAD
    ISMFlagCreator2* m_pISMFlagCreator2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMFlagCreator2Object;

static PyObject*
PyISMFlagCreator2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMFlagCreator2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMFlagCreator2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMFlagCreator2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMFlagCreator2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMFlagCreator2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMFlagCreator2");
            return NULL;
        }
        self->m_pISMFlagCreator2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMFlagCreator2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMFlagCreator2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMFlagCreator2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMFlagCreator2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMFlagCreator2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMFlagCreator2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMFlagCreator2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMFlagCreator2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMFlagCreator2Object_dealloc(PyISMFlagCreator2Object* self)
{
    if (self->m_pISMFlagCreator2)
        self->m_pISMFlagCreator2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMFlagCreator2_GetpUnk(PyISMFlagCreator2Object* self)
{
    if (!self->m_pISMFlagCreator2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMFlagCreator2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMFlagCreator2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMFlagCreator2_GetPointer(PyISMFlagCreator2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMFlagCreator2);
}

static PyObject*
PyISMFlagCreator2_GetIID(PyISMFlagCreator2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0e8f6257-745f-4de3-b651-6ecf14728c5c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMFlagCreator2_GetHR(PyISMFlagCreator2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMFlagCreator2_GetIgnoreFailures(PyISMFlagCreator2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMFlagCreator2_SetIgnoreFailures(PyISMFlagCreator2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMFlagCreator2_SupportsInterface(PyISMFlagCreator2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMFlagCreator2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMFlagCreator2Method_get_SearchTolerance(PyISMFlagCreator2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlagCreator2->get_SearchTolerance(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlagCreator2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlagCreator2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlagCreator2.get_SearchTolerance() returned %ld", (long)hr);
        goto ismflagcreator2_get_searchtolerance_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismflagcreator2_get_searchtolerance_method_cleanup;

    ismflagcreator2_get_searchtolerance_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlagCreator2.get_SearchTolerance");
    return return_tuple;
}

static PyObject*
ISMFlagCreator2Method_put_SearchTolerance(PyISMFlagCreator2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto ismflagcreator2_put_searchtolerance_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMFlagCreator2->put_SearchTolerance(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlagCreator2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlagCreator2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlagCreator2.put_SearchTolerance() returned %ld", (long)hr);
        goto ismflagcreator2_put_searchtolerance_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismflagcreator2_put_searchtolerance_method_cleanup;

    ismflagcreator2_put_searchtolerance_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlagCreator2.put_SearchTolerance");
    return return_tuple;
}

static PyObject*
ISMFlagCreator2Method_CreateFlag(PyISMFlagCreator2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippPoint = NULL;
    PyObject* py_pPoint;
    ISMFlag* ippIFlag = NULL;
    PyObject* py_pIFlag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pPoint))
      goto ismflagcreator2_createflag_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPoint, &IID_ISMRouterPoint, (void**)&ippPoint))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismflagcreator2_createflag_method_cleanup;
    
    // No setup for pIFlag

    // Call method on actual COM interface
    hr = self->m_pISMFlagCreator2->CreateFlag(ippPoint, &ippIFlag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlagCreator2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlagCreator2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlagCreator2.CreateFlag() returned %ld", (long)hr);
        goto ismflagcreator2_createflag_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPoint
    Py_XDECREF(py_pIFlag);
    if (ippIFlag)
    {
        IUnknown* pUnk = NULL;
        ippIFlag->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pIFlag = IUnknownToPythonIIDObject(pUnk, &IID_ISMFlag);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pIFlag)
    {
        if (py_pIFlag)
           Py_DECREF(py_pIFlag);
        py_pIFlag = Py_None;
        Py_INCREF(py_pIFlag);
    }
    if (PyErr_Occurred())
      goto ismflagcreator2_createflag_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pIFlag);
    goto ismflagcreator2_createflag_method_cleanup;

    ismflagcreator2_createflag_method_cleanup:
    self->m_HR = hr;
    if (ippPoint)
      ippPoint->Release();
    Py_XDECREF(py_pIFlag);
    if (ippIFlag)
      ippIFlag->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlagCreator2.CreateFlag");
    return return_tuple;
}

static PyObject*
ISMFlagCreator2Method_CreateFlagDirection(PyISMFlagCreator2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippPoint = NULL;
    PyObject* py_pPoint;
    double ddOrientation = 0;
    double ddTolerance = 0;
    double dpdAdjustedOrientation = 0;
    ISMFlag* ipppFlag = NULL;
    PyObject* py_ppFlag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Odd", &py_pPoint, &ddOrientation, &ddTolerance))
      goto ismflagcreator2_createflagdirection_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPoint, &IID_ISMRouterPoint, (void**)&ippPoint))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismflagcreator2_createflagdirection_method_cleanup;
    
    // No setup for dOrientation
    // No setup for dTolerance
    // No setup for pdAdjustedOrientation
    // No setup for ppFlag

    // Call method on actual COM interface
    hr = self->m_pISMFlagCreator2->CreateFlagDirection(ippPoint, ddOrientation, ddTolerance, &dpdAdjustedOrientation, &ipppFlag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlagCreator2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlagCreator2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlagCreator2.CreateFlagDirection() returned %ld", (long)hr);
        goto ismflagcreator2_createflagdirection_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPoint
    // No teardown for dOrientation
    // No teardown for dTolerance
    // No teardown for pdAdjustedOrientation
    Py_XDECREF(py_ppFlag);
    if (ipppFlag)
    {
        IUnknown* pUnk = NULL;
        ipppFlag->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFlag = IUnknownToPythonIIDObject(pUnk, &IID_ISMFlag);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFlag)
    {
        if (py_ppFlag)
           Py_DECREF(py_ppFlag);
        py_ppFlag = Py_None;
        Py_INCREF(py_ppFlag);
    }
    if (PyErr_Occurred())
      goto ismflagcreator2_createflagdirection_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("dO",
                                            dpdAdjustedOrientation, py_ppFlag);
    goto ismflagcreator2_createflagdirection_method_cleanup;

    ismflagcreator2_createflagdirection_method_cleanup:
    self->m_HR = hr;
    if (ippPoint)
      ippPoint->Release();
    // No cleanup for dOrientation
    // No cleanup for dTolerance
    // No cleanup for pdAdjustedOrientation
    Py_XDECREF(py_ppFlag);
    if (ipppFlag)
      ipppFlag->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlagCreator2.CreateFlagDirection");
    return return_tuple;
}

static PyObject*
ISMFlagCreator2Method_CreateFlagDirectionAdv(PyISMFlagCreator2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterPoint* ippPoint = NULL;
    PyObject* py_pPoint;
    double ddOrientation = 0;
    double ddTolerance = 0;
    double ddSpeed = 0;
    double ddLatency = 0;
    double dpdAdjustedOrientation = 0;
    ISMFlag* ipppFlag = NULL;
    PyObject* py_ppFlag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Odddd", &py_pPoint, &ddOrientation, &ddTolerance, &ddSpeed, &ddLatency))
      goto ismflagcreator2_createflagdirectionadv_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPoint, &IID_ISMRouterPoint, (void**)&ippPoint))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint (position 0) is not ISMRouterPoint");
    
    if (PyErr_Occurred())
      goto ismflagcreator2_createflagdirectionadv_method_cleanup;
    
    // No setup for dOrientation
    // No setup for dTolerance
    // No setup for dSpeed
    // No setup for dLatency
    // No setup for pdAdjustedOrientation
    // No setup for ppFlag

    // Call method on actual COM interface
    hr = self->m_pISMFlagCreator2->CreateFlagDirectionAdv(ippPoint, ddOrientation, ddTolerance, ddSpeed, ddLatency, &dpdAdjustedOrientation, &ipppFlag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMFlagCreator2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMFlagCreator2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMFlagCreator2.CreateFlagDirectionAdv() returned %ld", (long)hr);
        goto ismflagcreator2_createflagdirectionadv_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPoint
    // No teardown for dOrientation
    // No teardown for dTolerance
    // No teardown for dSpeed
    // No teardown for dLatency
    // No teardown for pdAdjustedOrientation
    Py_XDECREF(py_ppFlag);
    if (ipppFlag)
    {
        IUnknown* pUnk = NULL;
        ipppFlag->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFlag = IUnknownToPythonIIDObject(pUnk, &IID_ISMFlag);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFlag)
    {
        if (py_ppFlag)
           Py_DECREF(py_ppFlag);
        py_ppFlag = Py_None;
        Py_INCREF(py_ppFlag);
    }
    if (PyErr_Occurred())
      goto ismflagcreator2_createflagdirectionadv_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("dO",
                                            dpdAdjustedOrientation, py_ppFlag);
    goto ismflagcreator2_createflagdirectionadv_method_cleanup;

    ismflagcreator2_createflagdirectionadv_method_cleanup:
    self->m_HR = hr;
    if (ippPoint)
      ippPoint->Release();
    // No cleanup for dOrientation
    // No cleanup for dTolerance
    // No cleanup for dSpeed
    // No cleanup for dLatency
    // No cleanup for pdAdjustedOrientation
    Py_XDECREF(py_ppFlag);
    if (ipppFlag)
      ipppFlag->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMFlagCreator2.CreateFlagDirectionAdv");
    return return_tuple;
}


PyMethodDef PyISMFlagCreator2Methods[] = {
    {"supports", (PyCFunction)PyISMFlagCreator2_SupportsInterface, METH_O, ""},
    {"get_SearchTolerance", (PyCFunction)ISMFlagCreator2Method_get_SearchTolerance, METH_VARARGS, ""},
    {"put_SearchTolerance", (PyCFunction)ISMFlagCreator2Method_put_SearchTolerance, METH_VARARGS, ""},
    {"CreateFlag", (PyCFunction)ISMFlagCreator2Method_CreateFlag, METH_VARARGS, ""},
    {"CreateFlagDirection", (PyCFunction)ISMFlagCreator2Method_CreateFlagDirection, METH_VARARGS, ""},
    {"CreateFlagDirectionAdv", (PyCFunction)ISMFlagCreator2Method_CreateFlagDirectionAdv, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMFlagCreator2GetSet[] = {
  {"_pUnk", (getter)PyISMFlagCreator2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMFlagCreator2", NULL},
  {"_pointer", (getter)PyISMFlagCreator2_GetPointer, NULL, "Get memory address for ISMFlagCreator2", NULL},
  {"_IID", (getter)PyISMFlagCreator2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMFlagCreator2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMFlagCreator2_GetIgnoreFailures, (setter)PyISMFlagCreator2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMFlagCreator2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMFlagCreator2Object",                          
                                              /* tp_name */
  sizeof(PyISMFlagCreator2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMFlagCreator2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMFlagCreator2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMFlagCreator2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMFlagCreator2Object_new,                      
                                              /* tp_new */
};

// Interface ISMStop

typedef struct PyISMStopObject {
    PyObject_HEAD
    ISMStop* m_pISMStop;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMStopObject;

static PyObject*
PyISMStopObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMStopObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMStop* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMStop, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMStop with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMStopObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMStop");
            return NULL;
        }
        self->m_pISMStop = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMStop");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMStop");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMStop* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMStop, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMStop");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMStopObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMStop");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMStop = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMStopObject_dealloc(PyISMStopObject* self)
{
    if (self->m_pISMStop)
        self->m_pISMStop->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMStop_GetpUnk(PyISMStopObject* self)
{
    if (!self->m_pISMStop)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMStop->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMStop to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMStop_GetPointer(PyISMStopObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMStop);
}

static PyObject*
PyISMStop_GetIID(PyISMStopObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b66014-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMStop_GetHR(PyISMStopObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMStop_GetIgnoreFailures(PyISMStopObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMStop_SetIgnoreFailures(PyISMStopObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMStop_SupportsInterface(PyISMStopObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMStopMethod_get_StopID(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMStop->get_StopID(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.get_StopID() returned %ld", (long)hr);
        goto ismstop_get_stopid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismstop_get_stopid_method_cleanup;

    ismstop_get_stopid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.get_StopID");
    return return_tuple;
}

static PyObject*
ISMStopMethod_put_StopID(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpVal))
      goto ismstop_put_stopid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMStop->put_StopID(lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.put_StopID() returned %ld", (long)hr);
        goto ismstop_put_stopid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstop_put_stopid_method_cleanup;

    ismstop_put_stopid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.put_StopID");
    return return_tuple;
}

static PyObject*
ISMStopMethod_get_Description(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMStop->get_Description(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.get_Description() returned %ld", (long)hr);
        goto ismstop_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismstop_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismstop_get_description_method_cleanup;

    ismstop_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.get_Description");
    return return_tuple;
}

static PyObject*
ISMStopMethod_put_Description(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto ismstop_put_description_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto ismstop_put_description_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMStop->put_Description(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.put_Description() returned %ld", (long)hr);
        goto ismstop_put_description_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstop_put_description_method_cleanup;

    ismstop_put_description_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.put_Description");
    return return_tuple;
}

static PyObject*
ISMStopMethod_get_Flag(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMFlag* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMStop->get_Flag(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.get_Flag() returned %ld", (long)hr);
        goto ismstop_get_flag_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMFlag);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismstop_get_flag_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismstop_get_flag_method_cleanup;

    ismstop_get_flag_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.get_Flag");
    return return_tuple;
}

static PyObject*
ISMStopMethod_put_Flag(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMFlag* ippVal = NULL;
    PyObject* py_pVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto ismstop_put_flag_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pVal, &IID_ISMFlag, (void**)&ippVal))
        PyErr_SetString(PyExc_TypeError, "Argument pVal (position 0) is not ISMFlag");
    
    if (PyErr_Occurred())
      goto ismstop_put_flag_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMStop->put_Flag(ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.put_Flag() returned %ld", (long)hr);
        goto ismstop_put_flag_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstop_put_flag_method_cleanup;

    ismstop_put_flag_method_cleanup:
    self->m_HR = hr;
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.put_Flag");
    return return_tuple;
}

static PyObject*
ISMStopMethod_get_Duration(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMStop->get_Duration(&spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.get_Duration() returned %ld", (long)hr);
        goto ismstop_get_duration_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spVal);
    goto ismstop_get_duration_method_cleanup;

    ismstop_get_duration_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.get_Duration");
    return return_tuple;
}

static PyObject*
ISMStopMethod_put_Duration(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spVal))
      goto ismstop_put_duration_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMStop->put_Duration(spVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.put_Duration() returned %ld", (long)hr);
        goto ismstop_put_duration_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstop_put_duration_method_cleanup;

    ismstop_put_duration_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.put_Duration");
    return return_tuple;
}

static PyObject*
ISMStopMethod_get_MinDistanceToTurn(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpdDist = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pdDist

    // Call method on actual COM interface
    hr = self->m_pISMStop->get_MinDistanceToTurn(&dpdDist);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.get_MinDistanceToTurn() returned %ld", (long)hr);
        goto ismstop_get_mindistancetoturn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pdDist

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpdDist);
    goto ismstop_get_mindistancetoturn_method_cleanup;

    ismstop_get_mindistancetoturn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pdDist
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.get_MinDistanceToTurn");
    return return_tuple;
}

static PyObject*
ISMStopMethod_put_MinDistanceToTurn(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpdDist = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpdDist))
      goto ismstop_put_mindistancetoturn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pdDist

    // Call method on actual COM interface
    hr = self->m_pISMStop->put_MinDistanceToTurn(dpdDist);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.put_MinDistanceToTurn() returned %ld", (long)hr);
        goto ismstop_put_mindistancetoturn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pdDist

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstop_put_mindistancetoturn_method_cleanup;

    ismstop_put_mindistancetoturn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pdDist
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.put_MinDistanceToTurn");
    return return_tuple;
}

static PyObject*
ISMStopMethod_get_EnforceSideOfStreet(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbESS = VARIANT_FALSE;
    PyObject* pyvar_pbESS = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbESS

    // Call method on actual COM interface
    hr = self->m_pISMStop->get_EnforceSideOfStreet(&b_pbESS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.get_EnforceSideOfStreet() returned %ld", (long)hr);
        goto ismstop_get_enforcesideofstreet_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbESS = ((b_pbESS == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ismstop_get_enforcesideofstreet_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbESS);
    goto ismstop_get_enforcesideofstreet_method_cleanup;

    ismstop_get_enforcesideofstreet_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbESS
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.get_EnforceSideOfStreet");
    return return_tuple;
}

static PyObject*
ISMStopMethod_put_EnforceSideOfStreet(PyISMStopObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbESS = VARIANT_FALSE;
    PyObject* pyvar_pbESS = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbESS))
      goto ismstop_put_enforcesideofstreet_method_cleanup;

    // Set up initial variable values as needed
    b_pbESS = ((PyObject_IsTrue(pyvar_pbESS) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ismstop_put_enforcesideofstreet_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMStop->put_EnforceSideOfStreet(b_pbESS);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStop->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStop) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStop.put_EnforceSideOfStreet() returned %ld", (long)hr);
        goto ismstop_put_enforcesideofstreet_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbESS

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstop_put_enforcesideofstreet_method_cleanup;

    ismstop_put_enforcesideofstreet_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbESS
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStop.put_EnforceSideOfStreet");
    return return_tuple;
}


PyMethodDef PyISMStopMethods[] = {
    {"supports", (PyCFunction)PyISMStop_SupportsInterface, METH_O, ""},
    {"get_StopID", (PyCFunction)ISMStopMethod_get_StopID, METH_VARARGS, ""},
    {"put_StopID", (PyCFunction)ISMStopMethod_put_StopID, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)ISMStopMethod_get_Description, METH_VARARGS, ""},
    {"put_Description", (PyCFunction)ISMStopMethod_put_Description, METH_VARARGS, ""},
    {"get_Flag", (PyCFunction)ISMStopMethod_get_Flag, METH_VARARGS, ""},
    {"put_Flag", (PyCFunction)ISMStopMethod_put_Flag, METH_VARARGS, ""},
    {"get_Duration", (PyCFunction)ISMStopMethod_get_Duration, METH_VARARGS, ""},
    {"put_Duration", (PyCFunction)ISMStopMethod_put_Duration, METH_VARARGS, ""},
    {"get_MinDistanceToTurn", (PyCFunction)ISMStopMethod_get_MinDistanceToTurn, METH_VARARGS, ""},
    {"put_MinDistanceToTurn", (PyCFunction)ISMStopMethod_put_MinDistanceToTurn, METH_VARARGS, ""},
    {"get_EnforceSideOfStreet", (PyCFunction)ISMStopMethod_get_EnforceSideOfStreet, METH_VARARGS, ""},
    {"put_EnforceSideOfStreet", (PyCFunction)ISMStopMethod_put_EnforceSideOfStreet, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMStopGetSet[] = {
  {"_pUnk", (getter)PyISMStop_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMStop", NULL},
  {"_pointer", (getter)PyISMStop_GetPointer, NULL, "Get memory address for ISMStop", NULL},
  {"_IID", (getter)PyISMStop_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMStop_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMStop_GetIgnoreFailures, (setter)PyISMStop_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMStopObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMStopObject",                          
                                              /* tp_name */
  sizeof(PyISMStopObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMStopObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMStopMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMStopGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMStopObject_new,                      
                                              /* tp_new */
};

// Interface ISMStopsCollection

typedef struct PyISMStopsCollectionObject {
    PyObject_HEAD
    ISMStopsCollection* m_pISMStopsCollection;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMStopsCollectionObject;

static PyObject*
PyISMStopsCollectionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMStopsCollectionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMStopsCollection* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMStopsCollection, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMStopsCollection with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMStopsCollectionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMStopsCollection");
            return NULL;
        }
        self->m_pISMStopsCollection = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMStopsCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMStopsCollection");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMStopsCollection* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMStopsCollection, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMStopsCollection");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMStopsCollectionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMStopsCollection");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMStopsCollection = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMStopsCollectionObject_dealloc(PyISMStopsCollectionObject* self)
{
    if (self->m_pISMStopsCollection)
        self->m_pISMStopsCollection->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMStopsCollection_GetpUnk(PyISMStopsCollectionObject* self)
{
    if (!self->m_pISMStopsCollection)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMStopsCollection->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMStopsCollection to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMStopsCollection_GetPointer(PyISMStopsCollectionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMStopsCollection);
}

static PyObject*
PyISMStopsCollection_GetIID(PyISMStopsCollectionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b66017-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMStopsCollection_GetHR(PyISMStopsCollectionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMStopsCollection_GetIgnoreFailures(PyISMStopsCollectionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMStopsCollection_SetIgnoreFailures(PyISMStopsCollectionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMStopsCollection_SupportsInterface(PyISMStopsCollectionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMStopsCollection->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMStopsCollectionMethod_get_Count(PyISMStopsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMStopsCollection->get_Count(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStopsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStopsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStopsCollection.get_Count() returned %ld", (long)hr);
        goto ismstopscollection_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismstopscollection_get_count_method_cleanup;

    ismstopscollection_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStopsCollection.get_Count");
    return return_tuple;
}

static PyObject*
ISMStopsCollectionMethod_get_Item(PyISMStopsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;
    ISMStop* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPosition))
      goto ismstopscollection_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMStopsCollection->get_Item(lPosition, &ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStopsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStopsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStopsCollection.get_Item() returned %ld", (long)hr);
        goto ismstopscollection_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMStop);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismstopscollection_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismstopscollection_get_item_method_cleanup;

    ismstopscollection_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStopsCollection.get_Item");
    return return_tuple;
}

static PyObject*
ISMStopsCollectionMethod_Add(PyISMStopsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMStop* ippItem = NULL;
    PyObject* py_pItem;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pItem))
      goto ismstopscollection_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pItem, &IID_ISMStop, (void**)&ippItem))
        PyErr_SetString(PyExc_TypeError, "Argument pItem (position 0) is not ISMStop");
    
    if (PyErr_Occurred())
      goto ismstopscollection_add_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMStopsCollection->Add(ippItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStopsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStopsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStopsCollection.Add() returned %ld", (long)hr);
        goto ismstopscollection_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pItem

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstopscollection_add_method_cleanup;

    ismstopscollection_add_method_cleanup:
    self->m_HR = hr;
    if (ippItem)
      ippItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStopsCollection.Add");
    return return_tuple;
}

static PyObject*
ISMStopsCollectionMethod_Insert(PyISMStopsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;
    ISMStop* ippItem = NULL;
    PyObject* py_pItem;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lPosition, &py_pItem))
      goto ismstopscollection_insert_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position
    if (!IFaceFromPyObject(py_pItem, &IID_ISMStop, (void**)&ippItem))
        PyErr_SetString(PyExc_TypeError, "Argument pItem (position 1) is not ISMStop");
    
    if (PyErr_Occurred())
      goto ismstopscollection_insert_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMStopsCollection->Insert(lPosition, ippItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStopsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStopsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStopsCollection.Insert() returned %ld", (long)hr);
        goto ismstopscollection_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position
    // No teardown for pItem

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstopscollection_insert_method_cleanup;

    ismstopscollection_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    if (ippItem)
      ippItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStopsCollection.Insert");
    return return_tuple;
}

static PyObject*
ISMStopsCollectionMethod_Remove(PyISMStopsCollectionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPosition))
      goto ismstopscollection_remove_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position

    // Call method on actual COM interface
    hr = self->m_pISMStopsCollection->Remove(lPosition);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStopsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStopsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStopsCollection.Remove() returned %ld", (long)hr);
        goto ismstopscollection_remove_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismstopscollection_remove_method_cleanup;

    ismstopscollection_remove_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMStopsCollection.Remove");
    return return_tuple;
}

static PyObject*
ISMStopsCollectionMethod_Clear(PyISMStopsCollectionObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pISMStopsCollection->Clear();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMStopsCollection->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMStopsCollection) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMStopsCollection.Clear() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyISMStopsCollectionMethods[] = {
    {"supports", (PyCFunction)PyISMStopsCollection_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)ISMStopsCollectionMethod_get_Count, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)ISMStopsCollectionMethod_get_Item, METH_VARARGS, ""},
    {"Add", (PyCFunction)ISMStopsCollectionMethod_Add, METH_VARARGS, ""},
    {"Insert", (PyCFunction)ISMStopsCollectionMethod_Insert, METH_VARARGS, ""},
    {"Remove", (PyCFunction)ISMStopsCollectionMethod_Remove, METH_VARARGS, ""},
    {"Clear", (PyCFunction)ISMStopsCollectionMethod_Clear, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMStopsCollectionGetSet[] = {
  {"_pUnk", (getter)PyISMStopsCollection_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMStopsCollection", NULL},
  {"_pointer", (getter)PyISMStopsCollection_GetPointer, NULL, "Get memory address for ISMStopsCollection", NULL},
  {"_IID", (getter)PyISMStopsCollection_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMStopsCollection_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMStopsCollection_GetIgnoreFailures, (setter)PyISMStopsCollection_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMStopsCollectionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMStopsCollectionObject",                          
                                              /* tp_name */
  sizeof(PyISMStopsCollectionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMStopsCollectionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMStopsCollectionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMStopsCollectionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMStopsCollectionObject_new,                      
                                              /* tp_new */
};

// Interface ISMDirItem

typedef struct PyISMDirItemObject {
    PyObject_HEAD
    ISMDirItem* m_pISMDirItem;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMDirItemObject;

static PyObject*
PyISMDirItemObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMDirItemObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMDirItem* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMDirItem, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMDirItem with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMDirItemObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMDirItem");
            return NULL;
        }
        self->m_pISMDirItem = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMDirItem");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMDirItem");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMDirItem* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMDirItem, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMDirItem");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMDirItemObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMDirItem");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMDirItem = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMDirItemObject_dealloc(PyISMDirItemObject* self)
{
    if (self->m_pISMDirItem)
        self->m_pISMDirItem->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMDirItem_GetpUnk(PyISMDirItemObject* self)
{
    if (!self->m_pISMDirItem)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMDirItem->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMDirItem to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMDirItem_GetPointer(PyISMDirItemObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMDirItem);
}

static PyObject*
PyISMDirItem_GetIID(PyISMDirItemObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b6601a-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMDirItem_GetHR(PyISMDirItemObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMDirItem_GetIgnoreFailures(PyISMDirItemObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMDirItem_SetIgnoreFailures(PyISMDirItemObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMDirItem_SupportsInterface(PyISMDirItemObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMDirItemMethod_get_Text(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_Text(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_Text() returned %ld", (long)hr);
        goto ismdiritem_get_text_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismdiritem_get_text_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismdiritem_get_text_method_cleanup;

    ismdiritem_get_text_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_Text");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_Length(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_Length(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_Length() returned %ld", (long)hr);
        goto ismdiritem_get_length_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismdiritem_get_length_method_cleanup;

    ismdiritem_get_length_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_Length");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_Time(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_Time(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_Time() returned %ld", (long)hr);
        goto ismdiritem_get_time_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismdiritem_get_time_method_cleanup;

    ismdiritem_get_time_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_Time");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_DriveText(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_DriveText(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_DriveText() returned %ld", (long)hr);
        goto ismdiritem_get_drivetext_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismdiritem_get_drivetext_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismdiritem_get_drivetext_method_cleanup;

    ismdiritem_get_drivetext_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_DriveText");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_ItemType(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMDirItemType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_ItemType(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_ItemType() returned %ld", (long)hr);
        goto ismdiritem_get_itemtype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismdiritem_get_itemtype_method_cleanup;

    ismdiritem_get_itemtype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_ItemType");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_RoutePart(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_RoutePart(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_RoutePart() returned %ld", (long)hr);
        goto ismdiritem_get_routepart_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismdiritem_get_routepart_method_cleanup;

    ismdiritem_get_routepart_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_RoutePart");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_Shape(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMPointsCollection* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_Shape(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_Shape() returned %ld", (long)hr);
        goto ismdiritem_get_shape_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMPointsCollection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismdiritem_get_shape_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismdiritem_get_shape_method_cleanup;

    ismdiritem_get_shape_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_Shape");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_BoundBox(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterEnvelope* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_BoundBox(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_BoundBox() returned %ld", (long)hr);
        goto ismdiritem_get_boundbox_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMRouterEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismdiritem_get_boundbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismdiritem_get_boundbox_method_cleanup;

    ismdiritem_get_boundbox_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_BoundBox");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_StreetName(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrStreetName;
    PyObject* pyvar_pbstrStreetName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbstrStreetName

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_StreetName(&bspbstrStreetName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_StreetName() returned %ld", (long)hr);
        goto ismdiritem_get_streetname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbstrStreetName = PyUnicode_FromWideChar(bspbstrStreetName,::SysStringLen(bspbstrStreetName));
    ::SysFreeString(bspbstrStreetName);
    
    if (PyErr_Occurred())
      goto ismdiritem_get_streetname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbstrStreetName);
    goto ismdiritem_get_streetname_method_cleanup;

    ismdiritem_get_streetname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pbstrStreetName != Py_None)
        Py_XDECREF(pyvar_pbstrStreetName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_StreetName");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_TurnAngle(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpdAngle = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pdAngle

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_TurnAngle(&dpdAngle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_TurnAngle() returned %ld", (long)hr);
        goto ismdiritem_get_turnangle_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pdAngle

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpdAngle);
    goto ismdiritem_get_turnangle_method_cleanup;

    ismdiritem_get_turnangle_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pdAngle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_TurnAngle");
    return return_tuple;
}

static PyObject*
ISMDirItemMethod_get_Azimuth(PyISMDirItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMAzimuthType epAzimuth;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pAzimuth

    // Call method on actual COM interface
    hr = self->m_pISMDirItem->get_Azimuth(&epAzimuth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirItem.get_Azimuth() returned %ld", (long)hr);
        goto ismdiritem_get_azimuth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAzimuth

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epAzimuth);
    goto ismdiritem_get_azimuth_method_cleanup;

    ismdiritem_get_azimuth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAzimuth
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirItem.get_Azimuth");
    return return_tuple;
}


PyMethodDef PyISMDirItemMethods[] = {
    {"supports", (PyCFunction)PyISMDirItem_SupportsInterface, METH_O, ""},
    {"get_Text", (PyCFunction)ISMDirItemMethod_get_Text, METH_VARARGS, ""},
    {"get_Length", (PyCFunction)ISMDirItemMethod_get_Length, METH_VARARGS, ""},
    {"get_Time", (PyCFunction)ISMDirItemMethod_get_Time, METH_VARARGS, ""},
    {"get_DriveText", (PyCFunction)ISMDirItemMethod_get_DriveText, METH_VARARGS, ""},
    {"get_ItemType", (PyCFunction)ISMDirItemMethod_get_ItemType, METH_VARARGS, ""},
    {"get_RoutePart", (PyCFunction)ISMDirItemMethod_get_RoutePart, METH_VARARGS, ""},
    {"get_Shape", (PyCFunction)ISMDirItemMethod_get_Shape, METH_VARARGS, ""},
    {"get_BoundBox", (PyCFunction)ISMDirItemMethod_get_BoundBox, METH_VARARGS, ""},
    {"get_StreetName", (PyCFunction)ISMDirItemMethod_get_StreetName, METH_VARARGS, ""},
    {"get_TurnAngle", (PyCFunction)ISMDirItemMethod_get_TurnAngle, METH_VARARGS, ""},
    {"get_Azimuth", (PyCFunction)ISMDirItemMethod_get_Azimuth, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMDirItemGetSet[] = {
  {"_pUnk", (getter)PyISMDirItem_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMDirItem", NULL},
  {"_pointer", (getter)PyISMDirItem_GetPointer, NULL, "Get memory address for ISMDirItem", NULL},
  {"_IID", (getter)PyISMDirItem_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMDirItem_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMDirItem_GetIgnoreFailures, (setter)PyISMDirItem_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMDirItemObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMDirItemObject",                          
                                              /* tp_name */
  sizeof(PyISMDirItemObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMDirItemObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMDirItemMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMDirItemGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMDirItemObject_new,                      
                                              /* tp_new */
};

// Interface ISMDirections

typedef struct PyISMDirectionsObject {
    PyObject_HEAD
    ISMDirections* m_pISMDirections;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMDirectionsObject;

static PyObject*
PyISMDirectionsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMDirectionsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMDirections* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMDirections, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMDirections with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMDirectionsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMDirections");
            return NULL;
        }
        self->m_pISMDirections = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMDirections");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMDirections");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMDirections* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMDirections, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMDirections");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMDirectionsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMDirections");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMDirections = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMDirectionsObject_dealloc(PyISMDirectionsObject* self)
{
    if (self->m_pISMDirections)
        self->m_pISMDirections->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMDirections_GetpUnk(PyISMDirectionsObject* self)
{
    if (!self->m_pISMDirections)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMDirections->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMDirections to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMDirections_GetPointer(PyISMDirectionsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMDirections);
}

static PyObject*
PyISMDirections_GetIID(PyISMDirectionsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b6601d-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMDirections_GetHR(PyISMDirectionsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMDirections_GetIgnoreFailures(PyISMDirectionsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMDirections_SetIgnoreFailures(PyISMDirectionsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMDirections_SupportsInterface(PyISMDirectionsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMDirections->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMDirectionsMethod_get_TotalLength(PyISMDirectionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirections->get_TotalLength(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirections->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirections) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirections.get_TotalLength() returned %ld", (long)hr);
        goto ismdirections_get_totallength_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto ismdirections_get_totallength_method_cleanup;

    ismdirections_get_totallength_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirections.get_TotalLength");
    return return_tuple;
}

static PyObject*
ISMDirectionsMethod_get_TotalTime(PyISMDirectionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpVal;
    PyObject* py_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirections->get_TotalTime(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirections->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirections) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirections.get_TotalTime() returned %ld", (long)hr);
        goto ismdirections_get_totaltime_method_cleanup;
    }

    // Set up return values as needed
    py_pVal = DATE_AsPyObject(dpVal);
    if (PyErr_Occurred())
      goto ismdirections_get_totaltime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismdirections_get_totaltime_method_cleanup;

    ismdirections_get_totaltime_method_cleanup:
    self->m_HR = hr;
    if (py_pVal && (py_pVal != Py_None))
      Py_XDECREF(py_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirections.get_TotalTime");
    return return_tuple;
}

static PyObject*
ISMDirectionsMethod_get_TotalDrivingTime(PyISMDirectionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    DATE dpVal;
    PyObject* py_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirections->get_TotalDrivingTime(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirections->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirections) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirections.get_TotalDrivingTime() returned %ld", (long)hr);
        goto ismdirections_get_totaldrivingtime_method_cleanup;
    }

    // Set up return values as needed
    py_pVal = DATE_AsPyObject(dpVal);
    if (PyErr_Occurred())
      goto ismdirections_get_totaldrivingtime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismdirections_get_totaldrivingtime_method_cleanup;

    ismdirections_get_totaldrivingtime_method_cleanup:
    self->m_HR = hr;
    if (py_pVal && (py_pVal != Py_None))
      Py_XDECREF(py_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirections.get_TotalDrivingTime");
    return return_tuple;
}

static PyObject*
ISMDirectionsMethod_get_TotalsText(PyISMDirectionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirections->get_TotalsText(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirections->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirections) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirections.get_TotalsText() returned %ld", (long)hr);
        goto ismdirections_get_totalstext_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismdirections_get_totalstext_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismdirections_get_totalstext_method_cleanup;

    ismdirections_get_totalstext_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirections.get_TotalsText");
    return return_tuple;
}

static PyObject*
ISMDirectionsMethod_get_BoundBox(PyISMDirectionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRouterEnvelope* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirections->get_BoundBox(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirections->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirections) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirections.get_BoundBox() returned %ld", (long)hr);
        goto ismdirections_get_boundbox_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMRouterEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismdirections_get_boundbox_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismdirections_get_boundbox_method_cleanup;

    ismdirections_get_boundbox_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirections.get_BoundBox");
    return return_tuple;
}

static PyObject*
ISMDirectionsMethod_get_Count(PyISMDirectionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirections->get_Count(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirections->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirections) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirections.get_Count() returned %ld", (long)hr);
        goto ismdirections_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismdirections_get_count_method_cleanup;

    ismdirections_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirections.get_Count");
    return return_tuple;
}

static PyObject*
ISMDirectionsMethod_get_Item(PyISMDirectionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;
    ISMDirItem* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPosition))
      goto ismdirections_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMDirections->get_Item(lPosition, &ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMDirections->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMDirections) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMDirections.get_Item() returned %ld", (long)hr);
        goto ismdirections_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMDirItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismdirections_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismdirections_get_item_method_cleanup;

    ismdirections_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMDirections.get_Item");
    return return_tuple;
}


PyMethodDef PyISMDirectionsMethods[] = {
    {"supports", (PyCFunction)PyISMDirections_SupportsInterface, METH_O, ""},
    {"get_TotalLength", (PyCFunction)ISMDirectionsMethod_get_TotalLength, METH_VARARGS, ""},
    {"get_TotalTime", (PyCFunction)ISMDirectionsMethod_get_TotalTime, METH_VARARGS, ""},
    {"get_TotalDrivingTime", (PyCFunction)ISMDirectionsMethod_get_TotalDrivingTime, METH_VARARGS, ""},
    {"get_TotalsText", (PyCFunction)ISMDirectionsMethod_get_TotalsText, METH_VARARGS, ""},
    {"get_BoundBox", (PyCFunction)ISMDirectionsMethod_get_BoundBox, METH_VARARGS, ""},
    {"get_Count", (PyCFunction)ISMDirectionsMethod_get_Count, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)ISMDirectionsMethod_get_Item, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMDirectionsGetSet[] = {
  {"_pUnk", (getter)PyISMDirections_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMDirections", NULL},
  {"_pointer", (getter)PyISMDirections_GetPointer, NULL, "Get memory address for ISMDirections", NULL},
  {"_IID", (getter)PyISMDirections_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMDirections_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMDirections_GetIgnoreFailures, (setter)PyISMDirections_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMDirectionsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMDirectionsObject",                          
                                              /* tp_name */
  sizeof(PyISMDirectionsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMDirectionsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMDirectionsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMDirectionsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMDirectionsObject_new,                      
                                              /* tp_new */
};

// Interface ISMBreakTracker

typedef struct PyISMBreakTrackerObject {
    PyObject_HEAD
    ISMBreakTracker* m_pISMBreakTracker;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMBreakTrackerObject;

static PyObject*
PyISMBreakTrackerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMBreakTrackerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMBreakTracker* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMBreakTracker, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMBreakTracker with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMBreakTrackerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMBreakTracker");
            return NULL;
        }
        self->m_pISMBreakTracker = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMBreakTracker");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMBreakTracker");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMBreakTracker* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMBreakTracker, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMBreakTracker");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMBreakTrackerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMBreakTracker");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMBreakTracker = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMBreakTrackerObject_dealloc(PyISMBreakTrackerObject* self)
{
    if (self->m_pISMBreakTracker)
        self->m_pISMBreakTracker->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMBreakTracker_GetpUnk(PyISMBreakTrackerObject* self)
{
    if (!self->m_pISMBreakTracker)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMBreakTracker->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMBreakTracker to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMBreakTracker_GetPointer(PyISMBreakTrackerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMBreakTracker);
}

static PyObject*
PyISMBreakTracker_GetIID(PyISMBreakTrackerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "122fc3ae-a421-4922-9459-dff9d3631333");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMBreakTracker_GetHR(PyISMBreakTrackerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMBreakTracker_GetIgnoreFailures(PyISMBreakTrackerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMBreakTracker_SetIgnoreFailures(PyISMBreakTrackerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMBreakTracker_SupportsInterface(PyISMBreakTrackerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMBreakTracker->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMBreakTrackerMethod_Continue(PyISMBreakTrackerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bKeepGoing = VARIANT_FALSE;
    PyObject* pyvar_bKeepGoing = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bKeepGoing

    // Call method on actual COM interface
    hr = self->m_pISMBreakTracker->Continue(&b_bKeepGoing);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMBreakTracker->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMBreakTracker) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMBreakTracker.Continue() returned %ld", (long)hr);
        goto ismbreaktracker_continue_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bKeepGoing = ((b_bKeepGoing == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ismbreaktracker_continue_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bKeepGoing);
    goto ismbreaktracker_continue_method_cleanup;

    ismbreaktracker_continue_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bKeepGoing
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMBreakTracker.Continue");
    return return_tuple;
}


PyMethodDef PyISMBreakTrackerMethods[] = {
    {"supports", (PyCFunction)PyISMBreakTracker_SupportsInterface, METH_O, ""},
    {"Continue", (PyCFunction)ISMBreakTrackerMethod_Continue, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMBreakTrackerGetSet[] = {
  {"_pUnk", (getter)PyISMBreakTracker_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMBreakTracker", NULL},
  {"_pointer", (getter)PyISMBreakTracker_GetPointer, NULL, "Get memory address for ISMBreakTracker", NULL},
  {"_IID", (getter)PyISMBreakTracker_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMBreakTracker_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMBreakTracker_GetIgnoreFailures, (setter)PyISMBreakTracker_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMBreakTrackerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMBreakTrackerObject",                          
                                              /* tp_name */
  sizeof(PyISMBreakTrackerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMBreakTrackerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMBreakTrackerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMBreakTrackerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMBreakTrackerObject_new,                      
                                              /* tp_new */
};

// Interface ISMNetAttributesAccess

typedef struct PyISMNetAttributesAccessObject {
    PyObject_HEAD
    ISMNetAttributesAccess* m_pISMNetAttributesAccess;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMNetAttributesAccessObject;

static PyObject*
PyISMNetAttributesAccessObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMNetAttributesAccessObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMNetAttributesAccess* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMNetAttributesAccess, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMNetAttributesAccess with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMNetAttributesAccessObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetAttributesAccess");
            return NULL;
        }
        self->m_pISMNetAttributesAccess = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMNetAttributesAccess");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMNetAttributesAccess");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMNetAttributesAccess* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMNetAttributesAccess, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMNetAttributesAccess");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMNetAttributesAccessObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMNetAttributesAccess");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMNetAttributesAccess = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMNetAttributesAccessObject_dealloc(PyISMNetAttributesAccessObject* self)
{
    if (self->m_pISMNetAttributesAccess)
        self->m_pISMNetAttributesAccess->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMNetAttributesAccess_GetpUnk(PyISMNetAttributesAccessObject* self)
{
    if (!self->m_pISMNetAttributesAccess)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMNetAttributesAccess->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMNetAttributesAccess to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMNetAttributesAccess_GetPointer(PyISMNetAttributesAccessObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMNetAttributesAccess);
}

static PyObject*
PyISMNetAttributesAccess_GetIID(PyISMNetAttributesAccessObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "198dc955-519b-41ec-af33-1090d356c674");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMNetAttributesAccess_GetHR(PyISMNetAttributesAccessObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMNetAttributesAccess_GetIgnoreFailures(PyISMNetAttributesAccessObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMNetAttributesAccess_SetIgnoreFailures(PyISMNetAttributesAccessObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMNetAttributesAccess_SupportsInterface(PyISMNetAttributesAccessObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMNetAttributesAccess->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMNetAttributesAccessMethod_GetNetAttributeValue(PyISMNetAttributesAccessObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsbstrAttrName = 0;
    PyObject* pyvar_bstrAttrName;
    PyObject* unicodebstrAttrName = NULL;
    long llObjectID = 0;
    VARIANT vpvtVal;
    ::VariantInit(&vpvtVal);
    PyObject* pyvar_pvtVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Ol", &pyvar_bstrAttrName, &llObjectID))
      goto ismnetattributesaccess_getnetattributevalue_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_bstrAttrName))
        unicodebstrAttrName = PyUnicode_FromObject(pyvar_bstrAttrName);
    else if (PyUnicode_Check(pyvar_bstrAttrName))
    {
        unicodebstrAttrName = pyvar_bstrAttrName;
        Py_INCREF(unicodebstrAttrName);
    }
    else if (pyvar_bstrAttrName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter bstrAttrName at index 0");
    if (unicodebstrAttrName)
        bsbstrAttrName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodebstrAttrName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodebstrAttrName));
    
    if (PyErr_Occurred())
      goto ismnetattributesaccess_getnetattributevalue_method_cleanup;
    
    // No setup for lObjectID
    // No setup for pvtVal

    // Call method on actual COM interface
    hr = self->m_pISMNetAttributesAccess->GetNetAttributeValue(bsbstrAttrName, llObjectID, &vpvtVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMNetAttributesAccess->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMNetAttributesAccess) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMNetAttributesAccess.GetNetAttributeValue() returned %ld", (long)hr);
        goto ismnetattributesaccess_getnetattributevalue_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bstrAttrName
    // No teardown for lObjectID
    pyvar_pvtVal = Variant_AsPyObject(&vpvtVal);
    if (PyErr_Occurred())
      goto ismnetattributesaccess_getnetattributevalue_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pvtVal);
    goto ismnetattributesaccess_getnetattributevalue_method_cleanup;

    ismnetattributesaccess_getnetattributevalue_method_cleanup:
    self->m_HR = hr;
    if (bsbstrAttrName)
        ::SysFreeString(bsbstrAttrName);
    
    // No cleanup for lObjectID
    ::VariantClear(&vpvtVal);
    Py_XDECREF(pyvar_pvtVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMNetAttributesAccess.GetNetAttributeValue");
    return return_tuple;
}


PyMethodDef PyISMNetAttributesAccessMethods[] = {
    {"supports", (PyCFunction)PyISMNetAttributesAccess_SupportsInterface, METH_O, ""},
    {"GetNetAttributeValue", (PyCFunction)ISMNetAttributesAccessMethod_GetNetAttributeValue, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMNetAttributesAccessGetSet[] = {
  {"_pUnk", (getter)PyISMNetAttributesAccess_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMNetAttributesAccess", NULL},
  {"_pointer", (getter)PyISMNetAttributesAccess_GetPointer, NULL, "Get memory address for ISMNetAttributesAccess", NULL},
  {"_IID", (getter)PyISMNetAttributesAccess_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMNetAttributesAccess_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMNetAttributesAccess_GetIgnoreFailures, (setter)PyISMNetAttributesAccess_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMNetAttributesAccessObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMNetAttributesAccessObject",                          
                                              /* tp_name */
  sizeof(PyISMNetAttributesAccessObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMNetAttributesAccessObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMNetAttributesAccessMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMNetAttributesAccessGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMNetAttributesAccessObject_new,                      
                                              /* tp_new */
};

// Interface ISMRouter

typedef struct PyISMRouterObject {
    PyObject_HEAD
    ISMRouter* m_pISMRouter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRouterObject;

static PyObject*
PyISMRouterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRouterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRouter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRouter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRouter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRouterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouter");
            return NULL;
        }
        self->m_pISMRouter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRouter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRouter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRouter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRouter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRouter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRouterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRouter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRouterObject_dealloc(PyISMRouterObject* self)
{
    if (self->m_pISMRouter)
        self->m_pISMRouter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRouter_GetpUnk(PyISMRouterObject* self)
{
    if (!self->m_pISMRouter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRouter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRouter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRouter_GetPointer(PyISMRouterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRouter);
}

static PyObject*
PyISMRouter_GetIID(PyISMRouterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b66020-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRouter_GetHR(PyISMRouterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRouter_GetIgnoreFailures(PyISMRouterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRouter_SetIgnoreFailures(PyISMRouterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRouter_SupportsInterface(PyISMRouterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRouterMethod_get_Barriers(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMNetBarriersCollection* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_Barriers(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_Barriers() returned %ld", (long)hr);
        goto ismrouter_get_barriers_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMNetBarriersCollection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismrouter_get_barriers_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismrouter_get_barriers_method_cleanup;

    ismrouter_get_barriers_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_Barriers");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_get_NetAttributes(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMNetAttributesCollection* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_NetAttributes(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_NetAttributes() returned %ld", (long)hr);
        goto ismrouter_get_netattributes_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMNetAttributesCollection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismrouter_get_netattributes_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismrouter_get_netattributes_method_cleanup;

    ismrouter_get_netattributes_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_NetAttributes");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_get_Preferences(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRoadPreferences* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_Preferences(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_Preferences() returned %ld", (long)hr);
        goto ismrouter_get_preferences_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMRoadPreferences);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismrouter_get_preferences_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismrouter_get_preferences_method_cleanup;

    ismrouter_get_preferences_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_Preferences");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_get_SpeedGroups(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMSpeedGroups* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_SpeedGroups(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_SpeedGroups() returned %ld", (long)hr);
        goto ismrouter_get_speedgroups_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMSpeedGroups);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismrouter_get_speedgroups_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismrouter_get_speedgroups_method_cleanup;

    ismrouter_get_speedgroups_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_SpeedGroups");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_get_TripPlanSettings(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMTripPlanSettings* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_TripPlanSettings(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_TripPlanSettings() returned %ld", (long)hr);
        goto ismrouter_get_tripplansettings_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMTripPlanSettings);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismrouter_get_tripplansettings_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismrouter_get_tripplansettings_method_cleanup;

    ismrouter_get_tripplansettings_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_TripPlanSettings");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_get_NetAttributeName(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_NetAttributeName(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_NetAttributeName() returned %ld", (long)hr);
        goto ismrouter_get_netattributename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismrouter_get_netattributename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismrouter_get_netattributename_method_cleanup;

    ismrouter_get_netattributename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_NetAttributeName");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_put_NetAttributeName(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto ismrouter_put_netattributename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto ismrouter_put_netattributename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMRouter->put_NetAttributeName(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.put_NetAttributeName() returned %ld", (long)hr);
        goto ismrouter_put_netattributename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrouter_put_netattributename_method_cleanup;

    ismrouter_put_netattributename_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.put_NetAttributeName");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_ReorderStops(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMStopsCollection* ippISrcStops = NULL;
    PyObject* py_pISrcStops;
    ISMStopsCollection* ippIResStops = NULL;
    PyObject* py_pIResStops = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pISrcStops))
      goto ismrouter_reorderstops_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pISrcStops, &IID_ISMStopsCollection, (void**)&ippISrcStops))
        PyErr_SetString(PyExc_TypeError, "Argument pISrcStops (position 0) is not ISMStopsCollection");
    
    if (PyErr_Occurred())
      goto ismrouter_reorderstops_method_cleanup;
    
    // No setup for pIResStops

    // Call method on actual COM interface
    hr = self->m_pISMRouter->ReorderStops(ippISrcStops, &ippIResStops);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.ReorderStops() returned %ld", (long)hr);
        goto ismrouter_reorderstops_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pISrcStops
    Py_XDECREF(py_pIResStops);
    if (ippIResStops)
    {
        IUnknown* pUnk = NULL;
        ippIResStops->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pIResStops = IUnknownToPythonIIDObject(pUnk, &IID_ISMStopsCollection);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pIResStops)
    {
        if (py_pIResStops)
           Py_DECREF(py_pIResStops);
        py_pIResStops = Py_None;
        Py_INCREF(py_pIResStops);
    }
    if (PyErr_Occurred())
      goto ismrouter_reorderstops_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pIResStops);
    goto ismrouter_reorderstops_method_cleanup;

    ismrouter_reorderstops_method_cleanup:
    self->m_HR = hr;
    if (ippISrcStops)
      ippISrcStops->Release();
    Py_XDECREF(py_pIResStops);
    if (ippIResStops)
      ippIResStops->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.ReorderStops");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_Solve(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMStopsCollection* ippIStops = NULL;
    PyObject* py_pIStops;
    ISMBreakTracker* ippITracker = NULL;
    PyObject* py_pITracker;
    ISMDirections* ippIDirections = NULL;
    PyObject* py_pIDirections = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pIStops, &py_pITracker))
      goto ismrouter_solve_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pIStops, &IID_ISMStopsCollection, (void**)&ippIStops))
        PyErr_SetString(PyExc_TypeError, "Argument pIStops (position 0) is not ISMStopsCollection");
    
    if (PyErr_Occurred())
      goto ismrouter_solve_method_cleanup;
    
    if (!IFaceFromPyObject(py_pITracker, &IID_ISMBreakTracker, (void**)&ippITracker))
        PyErr_SetString(PyExc_TypeError, "Argument pITracker (position 1) is not ISMBreakTracker");
    
    if (PyErr_Occurred())
      goto ismrouter_solve_method_cleanup;
    
    // No setup for pIDirections

    // Call method on actual COM interface
    hr = self->m_pISMRouter->Solve(ippIStops, ippITracker, &ippIDirections);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.Solve() returned %ld", (long)hr);
        goto ismrouter_solve_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIStops
    // No teardown for pITracker
    Py_XDECREF(py_pIDirections);
    if (ippIDirections)
    {
        IUnknown* pUnk = NULL;
        ippIDirections->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pIDirections = IUnknownToPythonIIDObject(pUnk, &IID_ISMDirections);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pIDirections)
    {
        if (py_pIDirections)
           Py_DECREF(py_pIDirections);
        py_pIDirections = Py_None;
        Py_INCREF(py_pIDirections);
    }
    if (PyErr_Occurred())
      goto ismrouter_solve_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pIDirections);
    goto ismrouter_solve_method_cleanup;

    ismrouter_solve_method_cleanup:
    self->m_HR = hr;
    if (ippIStops)
      ippIStops->Release();
    if (ippITracker)
      ippITracker->Release();
    Py_XDECREF(py_pIDirections);
    if (ippIDirections)
      ippIDirections->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.Solve");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_get_NetAttributesAccess(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMNetAttributesAccess* ipppNetAttrAccess = NULL;
    PyObject* py_ppNetAttrAccess = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppNetAttrAccess

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_NetAttributesAccess(&ipppNetAttrAccess);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_NetAttributesAccess() returned %ld", (long)hr);
        goto ismrouter_get_netattributesaccess_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppNetAttrAccess);
    if (ipppNetAttrAccess)
    {
        IUnknown* pUnk = NULL;
        ipppNetAttrAccess->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppNetAttrAccess = IUnknownToPythonIIDObject(pUnk, &IID_ISMNetAttributesAccess);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppNetAttrAccess)
    {
        if (py_ppNetAttrAccess)
           Py_DECREF(py_ppNetAttrAccess);
        py_ppNetAttrAccess = Py_None;
        Py_INCREF(py_ppNetAttrAccess);
    }
    if (PyErr_Occurred())
      goto ismrouter_get_netattributesaccess_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppNetAttrAccess);
    goto ismrouter_get_netattributesaccess_method_cleanup;

    ismrouter_get_netattributesaccess_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppNetAttrAccess);
    if (ipppNetAttrAccess)
      ipppNetAttrAccess->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_NetAttributesAccess");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_get_ProjectionString(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_ProjectionString(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_ProjectionString() returned %ld", (long)hr);
        goto ismrouter_get_projectionstring_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismrouter_get_projectionstring_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismrouter_get_projectionstring_method_cleanup;

    ismrouter_get_projectionstring_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_ProjectionString");
    return return_tuple;
}

static PyObject*
ISMRouterMethod_get_FlagCreator(PyISMRouterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMFlagCreator* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouter->get_FlagCreator(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouter.get_FlagCreator() returned %ld", (long)hr);
        goto ismrouter_get_flagcreator_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMFlagCreator);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismrouter_get_flagcreator_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismrouter_get_flagcreator_method_cleanup;

    ismrouter_get_flagcreator_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouter.get_FlagCreator");
    return return_tuple;
}


PyMethodDef PyISMRouterMethods[] = {
    {"supports", (PyCFunction)PyISMRouter_SupportsInterface, METH_O, ""},
    {"get_Barriers", (PyCFunction)ISMRouterMethod_get_Barriers, METH_VARARGS, ""},
    {"get_NetAttributes", (PyCFunction)ISMRouterMethod_get_NetAttributes, METH_VARARGS, ""},
    {"get_Preferences", (PyCFunction)ISMRouterMethod_get_Preferences, METH_VARARGS, ""},
    {"get_SpeedGroups", (PyCFunction)ISMRouterMethod_get_SpeedGroups, METH_VARARGS, ""},
    {"get_TripPlanSettings", (PyCFunction)ISMRouterMethod_get_TripPlanSettings, METH_VARARGS, ""},
    {"get_NetAttributeName", (PyCFunction)ISMRouterMethod_get_NetAttributeName, METH_VARARGS, ""},
    {"put_NetAttributeName", (PyCFunction)ISMRouterMethod_put_NetAttributeName, METH_VARARGS, ""},
    {"ReorderStops", (PyCFunction)ISMRouterMethod_ReorderStops, METH_VARARGS, ""},
    {"Solve", (PyCFunction)ISMRouterMethod_Solve, METH_VARARGS, ""},
    {"get_NetAttributesAccess", (PyCFunction)ISMRouterMethod_get_NetAttributesAccess, METH_VARARGS, ""},
    {"get_ProjectionString", (PyCFunction)ISMRouterMethod_get_ProjectionString, METH_VARARGS, ""},
    {"get_FlagCreator", (PyCFunction)ISMRouterMethod_get_FlagCreator, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRouterGetSet[] = {
  {"_pUnk", (getter)PyISMRouter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRouter", NULL},
  {"_pointer", (getter)PyISMRouter_GetPointer, NULL, "Get memory address for ISMRouter", NULL},
  {"_IID", (getter)PyISMRouter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRouter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRouter_GetIgnoreFailures, (setter)PyISMRouter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRouterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRouterObject",                          
                                              /* tp_name */
  sizeof(PyISMRouterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRouterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRouterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRouterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRouterObject_new,                      
                                              /* tp_new */
};

// Interface ISMRouterFactory

typedef struct PyISMRouterFactoryObject {
    PyObject_HEAD
    ISMRouterFactory* m_pISMRouterFactory;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRouterFactoryObject;

static PyObject*
PyISMRouterFactoryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRouterFactoryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRouterFactory* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRouterFactory, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRouterFactory with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRouterFactoryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterFactory");
            return NULL;
        }
        self->m_pISMRouterFactory = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRouterFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRouterFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRouterFactory* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRouterFactory, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRouterFactory");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRouterFactoryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterFactory");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRouterFactory = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRouterFactoryObject_dealloc(PyISMRouterFactoryObject* self)
{
    if (self->m_pISMRouterFactory)
        self->m_pISMRouterFactory->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRouterFactory_GetpUnk(PyISMRouterFactoryObject* self)
{
    if (!self->m_pISMRouterFactory)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRouterFactory->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRouterFactory to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRouterFactory_GetPointer(PyISMRouterFactoryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRouterFactory);
}

static PyObject*
PyISMRouterFactory_GetIID(PyISMRouterFactoryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b66023-5850-11d7-b321-008048db11de");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRouterFactory_GetHR(PyISMRouterFactoryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRouterFactory_GetIgnoreFailures(PyISMRouterFactoryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRouterFactory_SetIgnoreFailures(PyISMRouterFactoryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRouterFactory_SupportsInterface(PyISMRouterFactoryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRouterFactory->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRouterFactoryMethod_CreateRouter(PyISMRouterFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsRoutingFilePath = 0;
    PyObject* pyvar_RoutingFilePath;
    PyObject* unicodeRoutingFilePath = NULL;
    ISMRouter* ippIRouter = NULL;
    PyObject* py_pIRouter = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_RoutingFilePath))
      goto ismrouterfactory_createrouter_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_RoutingFilePath))
        unicodeRoutingFilePath = PyUnicode_FromObject(pyvar_RoutingFilePath);
    else if (PyUnicode_Check(pyvar_RoutingFilePath))
    {
        unicodeRoutingFilePath = pyvar_RoutingFilePath;
        Py_INCREF(unicodeRoutingFilePath);
    }
    else if (pyvar_RoutingFilePath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter RoutingFilePath at index 0");
    if (unicodeRoutingFilePath)
        bsRoutingFilePath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeRoutingFilePath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeRoutingFilePath));
    
    if (PyErr_Occurred())
      goto ismrouterfactory_createrouter_method_cleanup;
    
    // No setup for pIRouter

    // Call method on actual COM interface
    hr = self->m_pISMRouterFactory->CreateRouter(bsRoutingFilePath, &ippIRouter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterFactory.CreateRouter() returned %ld", (long)hr);
        goto ismrouterfactory_createrouter_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for RoutingFilePath
    Py_XDECREF(py_pIRouter);
    if (ippIRouter)
    {
        IUnknown* pUnk = NULL;
        ippIRouter->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pIRouter = IUnknownToPythonIIDObject(pUnk, &IID_ISMRouter);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pIRouter)
    {
        if (py_pIRouter)
           Py_DECREF(py_pIRouter);
        py_pIRouter = Py_None;
        Py_INCREF(py_pIRouter);
    }
    if (PyErr_Occurred())
      goto ismrouterfactory_createrouter_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pIRouter);
    goto ismrouterfactory_createrouter_method_cleanup;

    ismrouterfactory_createrouter_method_cleanup:
    self->m_HR = hr;
    if (bsRoutingFilePath)
        ::SysFreeString(bsRoutingFilePath);
    
    Py_XDECREF(py_pIRouter);
    if (ippIRouter)
      ippIRouter->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterFactory.CreateRouter");
    return return_tuple;
}

static PyObject*
ISMRouterFactoryMethod_CreateRouterCfg(PyISMRouterFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsRoutingFilePath = 0;
    PyObject* pyvar_RoutingFilePath;
    PyObject* unicodeRoutingFilePath = NULL;
    BSTR bsConfigPath = 0;
    PyObject* pyvar_ConfigPath;
    PyObject* unicodeConfigPath = NULL;
    ISMRouter* ippIRouter = NULL;
    PyObject* py_pIRouter = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_RoutingFilePath, &pyvar_ConfigPath))
      goto ismrouterfactory_createroutercfg_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_RoutingFilePath))
        unicodeRoutingFilePath = PyUnicode_FromObject(pyvar_RoutingFilePath);
    else if (PyUnicode_Check(pyvar_RoutingFilePath))
    {
        unicodeRoutingFilePath = pyvar_RoutingFilePath;
        Py_INCREF(unicodeRoutingFilePath);
    }
    else if (pyvar_RoutingFilePath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter RoutingFilePath at index 0");
    if (unicodeRoutingFilePath)
        bsRoutingFilePath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeRoutingFilePath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeRoutingFilePath));
    
    if (PyErr_Occurred())
      goto ismrouterfactory_createroutercfg_method_cleanup;
    
    if (PyString_Check(pyvar_ConfigPath))
        unicodeConfigPath = PyUnicode_FromObject(pyvar_ConfigPath);
    else if (PyUnicode_Check(pyvar_ConfigPath))
    {
        unicodeConfigPath = pyvar_ConfigPath;
        Py_INCREF(unicodeConfigPath);
    }
    else if (pyvar_ConfigPath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ConfigPath at index 1");
    if (unicodeConfigPath)
        bsConfigPath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeConfigPath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeConfigPath));
    
    if (PyErr_Occurred())
      goto ismrouterfactory_createroutercfg_method_cleanup;
    
    // No setup for pIRouter

    // Call method on actual COM interface
    hr = self->m_pISMRouterFactory->CreateRouterCfg(bsRoutingFilePath, bsConfigPath, &ippIRouter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterFactory.CreateRouterCfg() returned %ld", (long)hr);
        goto ismrouterfactory_createroutercfg_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for RoutingFilePath
    // No teardown for ConfigPath
    Py_XDECREF(py_pIRouter);
    if (ippIRouter)
    {
        IUnknown* pUnk = NULL;
        ippIRouter->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pIRouter = IUnknownToPythonIIDObject(pUnk, &IID_ISMRouter);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pIRouter)
    {
        if (py_pIRouter)
           Py_DECREF(py_pIRouter);
        py_pIRouter = Py_None;
        Py_INCREF(py_pIRouter);
    }
    if (PyErr_Occurred())
      goto ismrouterfactory_createroutercfg_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pIRouter);
    goto ismrouterfactory_createroutercfg_method_cleanup;

    ismrouterfactory_createroutercfg_method_cleanup:
    self->m_HR = hr;
    if (bsRoutingFilePath)
        ::SysFreeString(bsRoutingFilePath);
    
    if (bsConfigPath)
        ::SysFreeString(bsConfigPath);
    
    Py_XDECREF(py_pIRouter);
    if (ippIRouter)
      ippIRouter->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterFactory.CreateRouterCfg");
    return return_tuple;
}


PyMethodDef PyISMRouterFactoryMethods[] = {
    {"supports", (PyCFunction)PyISMRouterFactory_SupportsInterface, METH_O, ""},
    {"CreateRouter", (PyCFunction)ISMRouterFactoryMethod_CreateRouter, METH_VARARGS, ""},
    {"CreateRouterCfg", (PyCFunction)ISMRouterFactoryMethod_CreateRouterCfg, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRouterFactoryGetSet[] = {
  {"_pUnk", (getter)PyISMRouterFactory_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRouterFactory", NULL},
  {"_pointer", (getter)PyISMRouterFactory_GetPointer, NULL, "Get memory address for ISMRouterFactory", NULL},
  {"_IID", (getter)PyISMRouterFactory_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRouterFactory_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRouterFactory_GetIgnoreFailures, (setter)PyISMRouterFactory_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRouterFactoryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRouterFactoryObject",                          
                                              /* tp_name */
  sizeof(PyISMRouterFactoryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRouterFactoryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRouterFactoryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRouterFactoryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRouterFactoryObject_new,                      
                                              /* tp_new */
};

// Interface ISMRoutingMetaData

typedef struct PyISMRoutingMetaDataObject {
    PyObject_HEAD
    ISMRoutingMetaData* m_pISMRoutingMetaData;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRoutingMetaDataObject;

static PyObject*
PyISMRoutingMetaDataObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRoutingMetaDataObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRoutingMetaData* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRoutingMetaData, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRoutingMetaData with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRoutingMetaDataObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRoutingMetaData");
            return NULL;
        }
        self->m_pISMRoutingMetaData = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRoutingMetaData");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRoutingMetaData");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRoutingMetaData* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRoutingMetaData, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRoutingMetaData");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRoutingMetaDataObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRoutingMetaData");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRoutingMetaData = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRoutingMetaDataObject_dealloc(PyISMRoutingMetaDataObject* self)
{
    if (self->m_pISMRoutingMetaData)
        self->m_pISMRoutingMetaData->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRoutingMetaData_GetpUnk(PyISMRoutingMetaDataObject* self)
{
    if (!self->m_pISMRoutingMetaData)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRoutingMetaData->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRoutingMetaData to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRoutingMetaData_GetPointer(PyISMRoutingMetaDataObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRoutingMetaData);
}

static PyObject*
PyISMRoutingMetaData_GetIID(PyISMRoutingMetaDataObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c8128b1a-23c3-4e21-93eb-50739b68f17a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRoutingMetaData_GetHR(PyISMRoutingMetaDataObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRoutingMetaData_GetIgnoreFailures(PyISMRoutingMetaDataObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRoutingMetaData_SetIgnoreFailures(PyISMRoutingMetaDataObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRoutingMetaData_SupportsInterface(PyISMRoutingMetaDataObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRoutingMetaData->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRoutingMetaDataMethod_get_Vendor(PyISMRoutingMetaDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRoutingMetaData->get_Vendor(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRoutingMetaData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRoutingMetaData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRoutingMetaData.get_Vendor() returned %ld", (long)hr);
        goto ismroutingmetadata_get_vendor_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismroutingmetadata_get_vendor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismroutingmetadata_get_vendor_method_cleanup;

    ismroutingmetadata_get_vendor_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRoutingMetaData.get_Vendor");
    return return_tuple;
}

static PyObject*
ISMRoutingMetaDataMethod_get_ProductName(PyISMRoutingMetaDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRoutingMetaData->get_ProductName(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRoutingMetaData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRoutingMetaData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRoutingMetaData.get_ProductName() returned %ld", (long)hr);
        goto ismroutingmetadata_get_productname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismroutingmetadata_get_productname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismroutingmetadata_get_productname_method_cleanup;

    ismroutingmetadata_get_productname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRoutingMetaData.get_ProductName");
    return return_tuple;
}

static PyObject*
ISMRoutingMetaDataMethod_get_ProductVersion(PyISMRoutingMetaDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRoutingMetaData->get_ProductVersion(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRoutingMetaData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRoutingMetaData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRoutingMetaData.get_ProductVersion() returned %ld", (long)hr);
        goto ismroutingmetadata_get_productversion_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismroutingmetadata_get_productversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismroutingmetadata_get_productversion_method_cleanup;

    ismroutingmetadata_get_productversion_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRoutingMetaData.get_ProductVersion");
    return return_tuple;
}

static PyObject*
ISMRoutingMetaDataMethod_get_Geography(PyISMRoutingMetaDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRoutingMetaData->get_Geography(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRoutingMetaData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRoutingMetaData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRoutingMetaData.get_Geography() returned %ld", (long)hr);
        goto ismroutingmetadata_get_geography_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismroutingmetadata_get_geography_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismroutingmetadata_get_geography_method_cleanup;

    ismroutingmetadata_get_geography_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRoutingMetaData.get_Geography");
    return return_tuple;
}

static PyObject*
ISMRoutingMetaDataMethod_get_Description(PyISMRoutingMetaDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRoutingMetaData->get_Description(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRoutingMetaData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRoutingMetaData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRoutingMetaData.get_Description() returned %ld", (long)hr);
        goto ismroutingmetadata_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismroutingmetadata_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismroutingmetadata_get_description_method_cleanup;

    ismroutingmetadata_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRoutingMetaData.get_Description");
    return return_tuple;
}

static PyObject*
ISMRoutingMetaDataMethod_get_Time(PyISMRoutingMetaDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRoutingMetaData->get_Time(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRoutingMetaData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRoutingMetaData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRoutingMetaData.get_Time() returned %ld", (long)hr);
        goto ismroutingmetadata_get_time_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto ismroutingmetadata_get_time_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto ismroutingmetadata_get_time_method_cleanup;

    ismroutingmetadata_get_time_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRoutingMetaData.get_Time");
    return return_tuple;
}


PyMethodDef PyISMRoutingMetaDataMethods[] = {
    {"supports", (PyCFunction)PyISMRoutingMetaData_SupportsInterface, METH_O, ""},
    {"get_Vendor", (PyCFunction)ISMRoutingMetaDataMethod_get_Vendor, METH_VARARGS, ""},
    {"get_ProductName", (PyCFunction)ISMRoutingMetaDataMethod_get_ProductName, METH_VARARGS, ""},
    {"get_ProductVersion", (PyCFunction)ISMRoutingMetaDataMethod_get_ProductVersion, METH_VARARGS, ""},
    {"get_Geography", (PyCFunction)ISMRoutingMetaDataMethod_get_Geography, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)ISMRoutingMetaDataMethod_get_Description, METH_VARARGS, ""},
    {"get_Time", (PyCFunction)ISMRoutingMetaDataMethod_get_Time, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRoutingMetaDataGetSet[] = {
  {"_pUnk", (getter)PyISMRoutingMetaData_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRoutingMetaData", NULL},
  {"_pointer", (getter)PyISMRoutingMetaData_GetPointer, NULL, "Get memory address for ISMRoutingMetaData", NULL},
  {"_IID", (getter)PyISMRoutingMetaData_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRoutingMetaData_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRoutingMetaData_GetIgnoreFailures, (setter)PyISMRoutingMetaData_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRoutingMetaDataObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRoutingMetaDataObject",                          
                                              /* tp_name */
  sizeof(PyISMRoutingMetaDataObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRoutingMetaDataObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRoutingMetaDataMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRoutingMetaDataGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRoutingMetaDataObject_new,                      
                                              /* tp_new */
};

// Interface ISMRestriction

typedef struct PyISMRestrictionObject {
    PyObject_HEAD
    ISMRestriction* m_pISMRestriction;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRestrictionObject;

static PyObject*
PyISMRestrictionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRestrictionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRestriction* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRestriction, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRestriction with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRestrictionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRestriction");
            return NULL;
        }
        self->m_pISMRestriction = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRestriction");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRestriction");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRestriction* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRestriction, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRestriction");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRestrictionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRestriction");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRestriction = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRestrictionObject_dealloc(PyISMRestrictionObject* self)
{
    if (self->m_pISMRestriction)
        self->m_pISMRestriction->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRestriction_GetpUnk(PyISMRestrictionObject* self)
{
    if (!self->m_pISMRestriction)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRestriction->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRestriction to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRestriction_GetPointer(PyISMRestrictionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRestriction);
}

static PyObject*
PyISMRestriction_GetIID(PyISMRestrictionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3df8d708-18e9-4d3c-bc69-54190a3577d8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRestriction_GetHR(PyISMRestrictionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRestriction_GetIgnoreFailures(PyISMRestrictionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRestriction_SetIgnoreFailures(PyISMRestrictionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRestriction_SupportsInterface(PyISMRestrictionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRestriction->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRestrictionMethod_get_Attribute(PyISMRestrictionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMNetAttribute* ippAttr = NULL;
    PyObject* py_pAttr = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pAttr

    // Call method on actual COM interface
    hr = self->m_pISMRestriction->get_Attribute(&ippAttr);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRestriction->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRestriction) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRestriction.get_Attribute() returned %ld", (long)hr);
        goto ismrestriction_get_attribute_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pAttr);
    if (ippAttr)
    {
        IUnknown* pUnk = NULL;
        ippAttr->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pAttr = IUnknownToPythonIIDObject(pUnk, &IID_ISMNetAttribute);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pAttr)
    {
        if (py_pAttr)
           Py_DECREF(py_pAttr);
        py_pAttr = Py_None;
        Py_INCREF(py_pAttr);
    }
    if (PyErr_Occurred())
      goto ismrestriction_get_attribute_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pAttr);
    goto ismrestriction_get_attribute_method_cleanup;

    ismrestriction_get_attribute_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pAttr);
    if (ippAttr)
      ippAttr->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRestriction.get_Attribute");
    return return_tuple;
}

static PyObject*
ISMRestrictionMethod_putref_Attribute(PyISMRestrictionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMNetAttribute* ippAttr = NULL;
    PyObject* py_pAttr;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pAttr))
      goto ismrestriction_putref_attribute_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAttr, &IID_ISMNetAttribute, (void**)&ippAttr))
        PyErr_SetString(PyExc_TypeError, "Argument pAttr (position 0) is not ISMNetAttribute");
    
    if (PyErr_Occurred())
      goto ismrestriction_putref_attribute_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMRestriction->putref_Attribute(ippAttr);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRestriction->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRestriction) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRestriction.putref_Attribute() returned %ld", (long)hr);
        goto ismrestriction_putref_attribute_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAttr

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrestriction_putref_attribute_method_cleanup;

    ismrestriction_putref_attribute_method_cleanup:
    self->m_HR = hr;
    if (ippAttr)
      ippAttr->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRestriction.putref_Attribute");
    return return_tuple;
}

static PyObject*
ISMRestrictionMethod_get_Type(PyISMRestrictionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMRestrictionType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRestriction->get_Type(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRestriction->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRestriction) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRestriction.get_Type() returned %ld", (long)hr);
        goto ismrestriction_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismrestriction_get_type_method_cleanup;

    ismrestriction_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRestriction.get_Type");
    return return_tuple;
}

static PyObject*
ISMRestrictionMethod_put_Type(PyISMRestrictionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMRestrictionType epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto ismrestriction_put_type_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRestriction->put_Type(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRestriction->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRestriction) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRestriction.put_Type() returned %ld", (long)hr);
        goto ismrestriction_put_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrestriction_put_type_method_cleanup;

    ismrestriction_put_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRestriction.put_Type");
    return return_tuple;
}

static PyObject*
ISMRestrictionMethod_get_Param(PyISMRestrictionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvParam;
    ::VariantInit(&vpvParam);
    PyObject* pyvar_pvParam = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pvParam

    // Call method on actual COM interface
    hr = self->m_pISMRestriction->get_Param(&vpvParam);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRestriction->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRestriction) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRestriction.get_Param() returned %ld", (long)hr);
        goto ismrestriction_get_param_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pvParam = Variant_AsPyObject(&vpvParam);
    if (PyErr_Occurred())
      goto ismrestriction_get_param_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pvParam);
    goto ismrestriction_get_param_method_cleanup;

    ismrestriction_get_param_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvParam);
    Py_XDECREF(pyvar_pvParam);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRestriction.get_Param");
    return return_tuple;
}

static PyObject*
ISMRestrictionMethod_put_Param(PyISMRestrictionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvParam;
    ::VariantInit(&vpvParam);
    PyObject* pyvar_pvParam = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pvParam))
      goto ismrestriction_put_param_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pvParam, &vpvParam);
    
    if (PyErr_Occurred())
      goto ismrestriction_put_param_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMRestriction->put_Param(vpvParam);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRestriction->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRestriction) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRestriction.put_Param() returned %ld", (long)hr);
        goto ismrestriction_put_param_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pvParam

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismrestriction_put_param_method_cleanup;

    ismrestriction_put_param_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvParam);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRestriction.put_Param");
    return return_tuple;
}


PyMethodDef PyISMRestrictionMethods[] = {
    {"supports", (PyCFunction)PyISMRestriction_SupportsInterface, METH_O, ""},
    {"get_Attribute", (PyCFunction)ISMRestrictionMethod_get_Attribute, METH_VARARGS, ""},
    {"putref_Attribute", (PyCFunction)ISMRestrictionMethod_putref_Attribute, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)ISMRestrictionMethod_get_Type, METH_VARARGS, ""},
    {"put_Type", (PyCFunction)ISMRestrictionMethod_put_Type, METH_VARARGS, ""},
    {"get_Param", (PyCFunction)ISMRestrictionMethod_get_Param, METH_VARARGS, ""},
    {"put_Param", (PyCFunction)ISMRestrictionMethod_put_Param, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRestrictionGetSet[] = {
  {"_pUnk", (getter)PyISMRestriction_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRestriction", NULL},
  {"_pointer", (getter)PyISMRestriction_GetPointer, NULL, "Get memory address for ISMRestriction", NULL},
  {"_IID", (getter)PyISMRestriction_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRestriction_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRestriction_GetIgnoreFailures, (setter)PyISMRestriction_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRestrictionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRestrictionObject",                          
                                              /* tp_name */
  sizeof(PyISMRestrictionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRestrictionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRestrictionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRestrictionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRestrictionObject_new,                      
                                              /* tp_new */
};

// Interface ISMRouterSetup

typedef struct PyISMRouterSetupObject {
    PyObject_HEAD
    ISMRouterSetup* m_pISMRouterSetup;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRouterSetupObject;

static PyObject*
PyISMRouterSetupObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRouterSetupObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRouterSetup* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRouterSetup, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRouterSetup with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRouterSetupObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterSetup");
            return NULL;
        }
        self->m_pISMRouterSetup = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRouterSetup");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRouterSetup");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRouterSetup* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRouterSetup, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRouterSetup");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRouterSetupObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterSetup");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRouterSetup = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRouterSetupObject_dealloc(PyISMRouterSetupObject* self)
{
    if (self->m_pISMRouterSetup)
        self->m_pISMRouterSetup->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRouterSetup_GetpUnk(PyISMRouterSetupObject* self)
{
    if (!self->m_pISMRouterSetup)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRouterSetup->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRouterSetup to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRouterSetup_GetPointer(PyISMRouterSetupObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRouterSetup);
}

static PyObject*
PyISMRouterSetup_GetIID(PyISMRouterSetupObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a386707f-fb42-4d0e-af12-3c1feb26f771");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRouterSetup_GetHR(PyISMRouterSetupObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRouterSetup_GetIgnoreFailures(PyISMRouterSetupObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRouterSetup_SetIgnoreFailures(PyISMRouterSetupObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRouterSetup_SupportsInterface(PyISMRouterSetupObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRouterSetup->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRouterSetupMethod_SetRestriction(PyISMRouterSetupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRestriction* ippRestriction = NULL;
    PyObject* py_pRestriction;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pRestriction))
      goto ismroutersetup_setrestriction_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pRestriction, &IID_ISMRestriction, (void**)&ippRestriction))
        PyErr_SetString(PyExc_TypeError, "Argument pRestriction (position 0) is not ISMRestriction");
    
    if (PyErr_Occurred())
      goto ismroutersetup_setrestriction_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup->SetRestriction(ippRestriction);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup.SetRestriction() returned %ld", (long)hr);
        goto ismroutersetup_setrestriction_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRestriction

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismroutersetup_setrestriction_method_cleanup;

    ismroutersetup_setrestriction_method_cleanup:
    self->m_HR = hr;
    if (ippRestriction)
      ippRestriction->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup.SetRestriction");
    return return_tuple;
}

static PyObject*
ISMRouterSetupMethod_ClearAllRestrictions(PyISMRouterSetupObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pISMRouterSetup->ClearAllRestrictions();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup.ClearAllRestrictions() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ISMRouterSetupMethod_get_BacktrackPolicy(PyISMRouterSetupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMBacktrackPolicy epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup->get_BacktrackPolicy(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup.get_BacktrackPolicy() returned %ld", (long)hr);
        goto ismroutersetup_get_backtrackpolicy_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismroutersetup_get_backtrackpolicy_method_cleanup;

    ismroutersetup_get_backtrackpolicy_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup.get_BacktrackPolicy");
    return return_tuple;
}

static PyObject*
ISMRouterSetupMethod_put_BacktrackPolicy(PyISMRouterSetupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMBacktrackPolicy epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto ismroutersetup_put_backtrackpolicy_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup->put_BacktrackPolicy(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup.put_BacktrackPolicy() returned %ld", (long)hr);
        goto ismroutersetup_put_backtrackpolicy_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismroutersetup_put_backtrackpolicy_method_cleanup;

    ismroutersetup_put_backtrackpolicy_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup.put_BacktrackPolicy");
    return return_tuple;
}

static PyObject*
ISMRouterSetupMethod_get_DirectionsLengthUnits(PyISMRouterSetupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMDirectionsLengthUnits epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup->get_DirectionsLengthUnits(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup.get_DirectionsLengthUnits() returned %ld", (long)hr);
        goto ismroutersetup_get_directionslengthunits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismroutersetup_get_directionslengthunits_method_cleanup;

    ismroutersetup_get_directionslengthunits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup.get_DirectionsLengthUnits");
    return return_tuple;
}

static PyObject*
ISMRouterSetupMethod_put_DirectionsLengthUnits(PyISMRouterSetupObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMDirectionsLengthUnits epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto ismroutersetup_put_directionslengthunits_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup->put_DirectionsLengthUnits(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup.put_DirectionsLengthUnits() returned %ld", (long)hr);
        goto ismroutersetup_put_directionslengthunits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismroutersetup_put_directionslengthunits_method_cleanup;

    ismroutersetup_put_directionslengthunits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup.put_DirectionsLengthUnits");
    return return_tuple;
}


PyMethodDef PyISMRouterSetupMethods[] = {
    {"supports", (PyCFunction)PyISMRouterSetup_SupportsInterface, METH_O, ""},
    {"SetRestriction", (PyCFunction)ISMRouterSetupMethod_SetRestriction, METH_VARARGS, ""},
    {"ClearAllRestrictions", (PyCFunction)ISMRouterSetupMethod_ClearAllRestrictions, METH_NOARGS, ""},
    {"get_BacktrackPolicy", (PyCFunction)ISMRouterSetupMethod_get_BacktrackPolicy, METH_VARARGS, ""},
    {"put_BacktrackPolicy", (PyCFunction)ISMRouterSetupMethod_put_BacktrackPolicy, METH_VARARGS, ""},
    {"get_DirectionsLengthUnits", (PyCFunction)ISMRouterSetupMethod_get_DirectionsLengthUnits, METH_VARARGS, ""},
    {"put_DirectionsLengthUnits", (PyCFunction)ISMRouterSetupMethod_put_DirectionsLengthUnits, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRouterSetupGetSet[] = {
  {"_pUnk", (getter)PyISMRouterSetup_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRouterSetup", NULL},
  {"_pointer", (getter)PyISMRouterSetup_GetPointer, NULL, "Get memory address for ISMRouterSetup", NULL},
  {"_IID", (getter)PyISMRouterSetup_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRouterSetup_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRouterSetup_GetIgnoreFailures, (setter)PyISMRouterSetup_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRouterSetupObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRouterSetupObject",                          
                                              /* tp_name */
  sizeof(PyISMRouterSetupObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRouterSetupObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRouterSetupMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRouterSetupGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRouterSetupObject_new,                      
                                              /* tp_new */
};

// Interface ISMRouterSetup2

typedef struct PyISMRouterSetup2Object {
    PyObject_HEAD
    ISMRouterSetup2* m_pISMRouterSetup2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISMRouterSetup2Object;

static PyObject*
PyISMRouterSetup2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISMRouterSetup2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISMRouterSetup2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISMRouterSetup2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISMRouterSetup2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISMRouterSetup2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterSetup2");
            return NULL;
        }
        self->m_pISMRouterSetup2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISMRouterSetup2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISMRouterSetup2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISMRouterSetup2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISMRouterSetup2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISMRouterSetup2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISMRouterSetup2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISMRouterSetup2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISMRouterSetup2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISMRouterSetup2Object_dealloc(PyISMRouterSetup2Object* self)
{
    if (self->m_pISMRouterSetup2)
        self->m_pISMRouterSetup2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISMRouterSetup2_GetpUnk(PyISMRouterSetup2Object* self)
{
    if (!self->m_pISMRouterSetup2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISMRouterSetup2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISMRouterSetup2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISMRouterSetup2_GetPointer(PyISMRouterSetup2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISMRouterSetup2);
}

static PyObject*
PyISMRouterSetup2_GetIID(PyISMRouterSetup2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "06efa9d2-490c-4325-bf15-3f73f4492f34");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISMRouterSetup2_GetHR(PyISMRouterSetup2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISMRouterSetup2_GetIgnoreFailures(PyISMRouterSetup2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISMRouterSetup2_SetIgnoreFailures(PyISMRouterSetup2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISMRouterSetup2_SupportsInterface(PyISMRouterSetup2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISMRouterSetup2Method_get_RestrictionCount(PyISMRouterSetup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup2->get_RestrictionCount(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.get_RestrictionCount() returned %ld", (long)hr);
        goto ismroutersetup2_get_restrictioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto ismroutersetup2_get_restrictioncount_method_cleanup;

    ismroutersetup2_get_restrictioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup2.get_RestrictionCount");
    return return_tuple;
}

static PyObject*
ISMRouterSetup2Method_get_Restriction(PyISMRouterSetup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ISMRestriction* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ismroutersetup2_get_restriction_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup2->get_Restriction(lindex, &ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.get_Restriction() returned %ld", (long)hr);
        goto ismroutersetup2_get_restriction_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ISMRestriction);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto ismroutersetup2_get_restriction_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto ismroutersetup2_get_restriction_method_cleanup;

    ismroutersetup2_get_restriction_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup2.get_Restriction");
    return return_tuple;
}

static PyObject*
ISMRouterSetup2Method_ClearRestriction(PyISMRouterSetup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ismroutersetup2_clearrestriction_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup2->ClearRestriction(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.ClearRestriction() returned %ld", (long)hr);
        goto ismroutersetup2_clearrestriction_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismroutersetup2_clearrestriction_method_cleanup;

    ismroutersetup2_clearrestriction_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup2.ClearRestriction");
    return return_tuple;
}

static PyObject*
ISMRouterSetup2Method_SetRestriction(PyISMRouterSetup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISMRestriction* ippRestriction = NULL;
    PyObject* py_pRestriction;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pRestriction))
      goto ismroutersetup2_setrestriction_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pRestriction, &IID_ISMRestriction, (void**)&ippRestriction))
        PyErr_SetString(PyExc_TypeError, "Argument pRestriction (position 0) is not ISMRestriction");
    
    if (PyErr_Occurred())
      goto ismroutersetup2_setrestriction_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup2->SetRestriction(ippRestriction);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.SetRestriction() returned %ld", (long)hr);
        goto ismroutersetup2_setrestriction_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRestriction

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismroutersetup2_setrestriction_method_cleanup;

    ismroutersetup2_setrestriction_method_cleanup:
    self->m_HR = hr;
    if (ippRestriction)
      ippRestriction->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup2.SetRestriction");
    return return_tuple;
}

static PyObject*
ISMRouterSetup2Method_ClearAllRestrictions(PyISMRouterSetup2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pISMRouterSetup2->ClearAllRestrictions();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.ClearAllRestrictions() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ISMRouterSetup2Method_get_BacktrackPolicy(PyISMRouterSetup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMBacktrackPolicy epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup2->get_BacktrackPolicy(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.get_BacktrackPolicy() returned %ld", (long)hr);
        goto ismroutersetup2_get_backtrackpolicy_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismroutersetup2_get_backtrackpolicy_method_cleanup;

    ismroutersetup2_get_backtrackpolicy_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup2.get_BacktrackPolicy");
    return return_tuple;
}

static PyObject*
ISMRouterSetup2Method_put_BacktrackPolicy(PyISMRouterSetup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMBacktrackPolicy epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto ismroutersetup2_put_backtrackpolicy_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup2->put_BacktrackPolicy(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.put_BacktrackPolicy() returned %ld", (long)hr);
        goto ismroutersetup2_put_backtrackpolicy_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismroutersetup2_put_backtrackpolicy_method_cleanup;

    ismroutersetup2_put_backtrackpolicy_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup2.put_BacktrackPolicy");
    return return_tuple;
}

static PyObject*
ISMRouterSetup2Method_get_DirectionsLengthUnits(PyISMRouterSetup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMDirectionsLengthUnits epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup2->get_DirectionsLengthUnits(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.get_DirectionsLengthUnits() returned %ld", (long)hr);
        goto ismroutersetup2_get_directionslengthunits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto ismroutersetup2_get_directionslengthunits_method_cleanup;

    ismroutersetup2_get_directionslengthunits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup2.get_DirectionsLengthUnits");
    return return_tuple;
}

static PyObject*
ISMRouterSetup2Method_put_DirectionsLengthUnits(PyISMRouterSetup2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSMDirectionsLengthUnits epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto ismroutersetup2_put_directionslengthunits_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pISMRouterSetup2->put_DirectionsLengthUnits(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISMRouterSetup2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISMRouterSetup2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISMRouterSetup2.put_DirectionsLengthUnits() returned %ld", (long)hr);
        goto ismroutersetup2_put_directionslengthunits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ismroutersetup2_put_directionslengthunits_method_cleanup;

    ismroutersetup2_put_directionslengthunits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISMRouterSetup2.put_DirectionsLengthUnits");
    return return_tuple;
}


PyMethodDef PyISMRouterSetup2Methods[] = {
    {"supports", (PyCFunction)PyISMRouterSetup2_SupportsInterface, METH_O, ""},
    {"get_RestrictionCount", (PyCFunction)ISMRouterSetup2Method_get_RestrictionCount, METH_VARARGS, ""},
    {"get_Restriction", (PyCFunction)ISMRouterSetup2Method_get_Restriction, METH_VARARGS, ""},
    {"ClearRestriction", (PyCFunction)ISMRouterSetup2Method_ClearRestriction, METH_VARARGS, ""},
    {"SetRestriction", (PyCFunction)ISMRouterSetup2Method_SetRestriction, METH_VARARGS, ""},
    {"ClearAllRestrictions", (PyCFunction)ISMRouterSetup2Method_ClearAllRestrictions, METH_NOARGS, ""},
    {"get_BacktrackPolicy", (PyCFunction)ISMRouterSetup2Method_get_BacktrackPolicy, METH_VARARGS, ""},
    {"put_BacktrackPolicy", (PyCFunction)ISMRouterSetup2Method_put_BacktrackPolicy, METH_VARARGS, ""},
    {"get_DirectionsLengthUnits", (PyCFunction)ISMRouterSetup2Method_get_DirectionsLengthUnits, METH_VARARGS, ""},
    {"put_DirectionsLengthUnits", (PyCFunction)ISMRouterSetup2Method_put_DirectionsLengthUnits, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISMRouterSetup2GetSet[] = {
  {"_pUnk", (getter)PyISMRouterSetup2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISMRouterSetup2", NULL},
  {"_pointer", (getter)PyISMRouterSetup2_GetPointer, NULL, "Get memory address for ISMRouterSetup2", NULL},
  {"_IID", (getter)PyISMRouterSetup2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISMRouterSetup2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISMRouterSetup2_GetIgnoreFailures, (setter)PyISMRouterSetup2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISMRouterSetup2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.ISMRouterSetup2Object",                          
                                              /* tp_name */
  sizeof(PyISMRouterSetup2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISMRouterSetup2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISMRouterSetup2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISMRouterSetup2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISMRouterSetup2Object_new,                      
                                              /* tp_new */
};

// Interface IUsageModeOption

typedef struct PyIUsageModeOptionObject {
    PyObject_HEAD
    IUsageModeOption* m_pIUsageModeOption;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIUsageModeOptionObject;

static PyObject*
PyIUsageModeOptionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIUsageModeOptionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IUsageModeOption* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUsageModeOption, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUsageModeOption with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIUsageModeOptionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IUsageModeOption");
            return NULL;
        }
        self->m_pIUsageModeOption = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUsageModeOption");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUsageModeOption");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IUsageModeOption* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IUsageModeOption, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IUsageModeOption");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIUsageModeOptionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUsageModeOption");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIUsageModeOption = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIUsageModeOptionObject_dealloc(PyIUsageModeOptionObject* self)
{
    if (self->m_pIUsageModeOption)
        self->m_pIUsageModeOption->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIUsageModeOption_GetpUnk(PyIUsageModeOptionObject* self)
{
    if (!self->m_pIUsageModeOption)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIUsageModeOption->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IUsageModeOption to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIUsageModeOption_GetPointer(PyIUsageModeOptionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIUsageModeOption);
}

static PyObject*
PyIUsageModeOption_GetIID(PyIUsageModeOptionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c1d85fc8-f132-4187-b897-623c647c9213");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIUsageModeOption_GetHR(PyIUsageModeOptionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIUsageModeOption_GetIgnoreFailures(PyIUsageModeOptionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIUsageModeOption_SetIgnoreFailures(PyIUsageModeOptionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIUsageModeOption_SupportsInterface(PyIUsageModeOptionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIUsageModeOption->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IUsageModeOptionMethod_get_Name(PyIUsageModeOptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspsName;
    PyObject* pyvar_psName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for psName

    // Call method on actual COM interface
    hr = self->m_pIUsageModeOption->get_Name(&bspsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUsageModeOption->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUsageModeOption) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUsageModeOption.get_Name() returned %ld", (long)hr);
        goto iusagemodeoption_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_psName = PyUnicode_FromWideChar(bspsName,::SysStringLen(bspsName));
    ::SysFreeString(bspsName);
    
    if (PyErr_Occurred())
      goto iusagemodeoption_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_psName);
    goto iusagemodeoption_get_name_method_cleanup;

    iusagemodeoption_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_psName != Py_None)
        Py_XDECREF(pyvar_psName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUsageModeOption.get_Name");
    return return_tuple;
}

static PyObject*
IUsageModeOptionMethod_get_Value(PyIUsageModeOptionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspsValue;
    PyObject* pyvar_psValue = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for psValue

    // Call method on actual COM interface
    hr = self->m_pIUsageModeOption->get_Value(&bspsValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUsageModeOption->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUsageModeOption) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUsageModeOption.get_Value() returned %ld", (long)hr);
        goto iusagemodeoption_get_value_method_cleanup;
    }

    // Set up return values as needed
    pyvar_psValue = PyUnicode_FromWideChar(bspsValue,::SysStringLen(bspsValue));
    ::SysFreeString(bspsValue);
    
    if (PyErr_Occurred())
      goto iusagemodeoption_get_value_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_psValue);
    goto iusagemodeoption_get_value_method_cleanup;

    iusagemodeoption_get_value_method_cleanup:
    self->m_HR = hr;
    if (pyvar_psValue != Py_None)
        Py_XDECREF(pyvar_psValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUsageModeOption.get_Value");
    return return_tuple;
}


PyMethodDef PyIUsageModeOptionMethods[] = {
    {"supports", (PyCFunction)PyIUsageModeOption_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IUsageModeOptionMethod_get_Name, METH_VARARGS, ""},
    {"get_Value", (PyCFunction)IUsageModeOptionMethod_get_Value, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIUsageModeOptionGetSet[] = {
  {"_pUnk", (getter)PyIUsageModeOption_GetpUnk, NULL, "Get opaque pointer to an Unknown from IUsageModeOption", NULL},
  {"_pointer", (getter)PyIUsageModeOption_GetPointer, NULL, "Get memory address for IUsageModeOption", NULL},
  {"_IID", (getter)PyIUsageModeOption_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIUsageModeOption_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIUsageModeOption_GetIgnoreFailures, (setter)PyIUsageModeOption_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIUsageModeOptionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IUsageModeOptionObject",                          
                                              /* tp_name */
  sizeof(PyIUsageModeOptionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIUsageModeOptionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIUsageModeOptionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIUsageModeOptionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIUsageModeOptionObject_new,                      
                                              /* tp_new */
};

// Interface IUsageModeInfo

typedef struct PyIUsageModeInfoObject {
    PyObject_HEAD
    IUsageModeInfo* m_pIUsageModeInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIUsageModeInfoObject;

static PyObject*
PyIUsageModeInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIUsageModeInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IUsageModeInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUsageModeInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUsageModeInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIUsageModeInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IUsageModeInfo");
            return NULL;
        }
        self->m_pIUsageModeInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUsageModeInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUsageModeInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IUsageModeInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IUsageModeInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IUsageModeInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIUsageModeInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUsageModeInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIUsageModeInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIUsageModeInfoObject_dealloc(PyIUsageModeInfoObject* self)
{
    if (self->m_pIUsageModeInfo)
        self->m_pIUsageModeInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIUsageModeInfo_GetpUnk(PyIUsageModeInfoObject* self)
{
    if (!self->m_pIUsageModeInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIUsageModeInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IUsageModeInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIUsageModeInfo_GetPointer(PyIUsageModeInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIUsageModeInfo);
}

static PyObject*
PyIUsageModeInfo_GetIID(PyIUsageModeInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "07713846-9da7-45f8-886f-3eb2f0a30187");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIUsageModeInfo_GetHR(PyIUsageModeInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIUsageModeInfo_GetIgnoreFailures(PyIUsageModeInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIUsageModeInfo_SetIgnoreFailures(PyIUsageModeInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIUsageModeInfo_SupportsInterface(PyIUsageModeInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIUsageModeInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IUsageModeInfoMethod_get_Name(PyIUsageModeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspsName;
    PyObject* pyvar_psName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for psName

    // Call method on actual COM interface
    hr = self->m_pIUsageModeInfo->get_Name(&bspsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUsageModeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUsageModeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUsageModeInfo.get_Name() returned %ld", (long)hr);
        goto iusagemodeinfo_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_psName = PyUnicode_FromWideChar(bspsName,::SysStringLen(bspsName));
    ::SysFreeString(bspsName);
    
    if (PyErr_Occurred())
      goto iusagemodeinfo_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_psName);
    goto iusagemodeinfo_get_name_method_cleanup;

    iusagemodeinfo_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_psName != Py_None)
        Py_XDECREF(pyvar_psName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUsageModeInfo.get_Name");
    return return_tuple;
}

static PyObject*
IUsageModeInfoMethod_get_OptionCount(PyIUsageModeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpnCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pnCount

    // Call method on actual COM interface
    hr = self->m_pIUsageModeInfo->get_OptionCount(&lpnCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUsageModeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUsageModeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUsageModeInfo.get_OptionCount() returned %ld", (long)hr);
        goto iusagemodeinfo_get_optioncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pnCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpnCount);
    goto iusagemodeinfo_get_optioncount_method_cleanup;

    iusagemodeinfo_get_optioncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pnCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUsageModeInfo.get_OptionCount");
    return return_tuple;
}

static PyObject*
IUsageModeInfoMethod_get_Option(PyIUsageModeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIndex = 0;
    IUsageModeOption* ippOption = NULL;
    PyObject* py_pOption = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIndex))
      goto iusagemodeinfo_get_option_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex
    // No setup for pOption

    // Call method on actual COM interface
    hr = self->m_pIUsageModeInfo->get_Option(lnIndex, &ippOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIUsageModeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IUsageModeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IUsageModeInfo.get_Option() returned %ld", (long)hr);
        goto iusagemodeinfo_get_option_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex
    Py_XDECREF(py_pOption);
    if (ippOption)
    {
        IUnknown* pUnk = NULL;
        ippOption->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pOption = IUnknownToPythonIIDObject(pUnk, &IID_IUsageModeOption);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pOption)
    {
        if (py_pOption)
           Py_DECREF(py_pOption);
        py_pOption = Py_None;
        Py_INCREF(py_pOption);
    }
    if (PyErr_Occurred())
      goto iusagemodeinfo_get_option_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pOption);
    goto iusagemodeinfo_get_option_method_cleanup;

    iusagemodeinfo_get_option_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    Py_XDECREF(py_pOption);
    if (ippOption)
      ippOption->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IUsageModeInfo.get_Option");
    return return_tuple;
}


PyMethodDef PyIUsageModeInfoMethods[] = {
    {"supports", (PyCFunction)PyIUsageModeInfo_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IUsageModeInfoMethod_get_Name, METH_VARARGS, ""},
    {"get_OptionCount", (PyCFunction)IUsageModeInfoMethod_get_OptionCount, METH_VARARGS, ""},
    {"get_Option", (PyCFunction)IUsageModeInfoMethod_get_Option, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIUsageModeInfoGetSet[] = {
  {"_pUnk", (getter)PyIUsageModeInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from IUsageModeInfo", NULL},
  {"_pointer", (getter)PyIUsageModeInfo_GetPointer, NULL, "Get memory address for IUsageModeInfo", NULL},
  {"_IID", (getter)PyIUsageModeInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIUsageModeInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIUsageModeInfo_GetIgnoreFailures, (setter)PyIUsageModeInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIUsageModeInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IUsageModeInfoObject",                          
                                              /* tp_name */
  sizeof(PyIUsageModeInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIUsageModeInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIUsageModeInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIUsageModeInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIUsageModeInfoObject_new,                      
                                              /* tp_new */
};

// Interface IMetaInfo

typedef struct PyIMetaInfoObject {
    PyObject_HEAD
    IMetaInfo* m_pIMetaInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIMetaInfoObject;

static PyObject*
PyIMetaInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIMetaInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IMetaInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IMetaInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IMetaInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIMetaInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IMetaInfo");
            return NULL;
        }
        self->m_pIMetaInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IMetaInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IMetaInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IMetaInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IMetaInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IMetaInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIMetaInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IMetaInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIMetaInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIMetaInfoObject_dealloc(PyIMetaInfoObject* self)
{
    if (self->m_pIMetaInfo)
        self->m_pIMetaInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIMetaInfo_GetpUnk(PyIMetaInfoObject* self)
{
    if (!self->m_pIMetaInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIMetaInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IMetaInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIMetaInfo_GetPointer(PyIMetaInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIMetaInfo);
}

static PyObject*
PyIMetaInfo_GetIID(PyIMetaInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0db7a450-5fed-441b-bb3a-db6e24d6cda3");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIMetaInfo_GetHR(PyIMetaInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIMetaInfo_GetIgnoreFailures(PyIMetaInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIMetaInfo_SetIgnoreFailures(PyIMetaInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIMetaInfo_SupportsInterface(PyIMetaInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIMetaInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IMetaInfoMethod_get_Name(PyIMetaInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspsName;
    PyObject* pyvar_psName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for psName

    // Call method on actual COM interface
    hr = self->m_pIMetaInfo->get_Name(&bspsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMetaInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMetaInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMetaInfo.get_Name() returned %ld", (long)hr);
        goto imetainfo_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_psName = PyUnicode_FromWideChar(bspsName,::SysStringLen(bspsName));
    ::SysFreeString(bspsName);
    
    if (PyErr_Occurred())
      goto imetainfo_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_psName);
    goto imetainfo_get_name_method_cleanup;

    imetainfo_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_psName != Py_None)
        Py_XDECREF(pyvar_psName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IMetaInfo.get_Name");
    return return_tuple;
}

static PyObject*
IMetaInfoMethod_get_Value(PyIMetaInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspsValue;
    PyObject* pyvar_psValue = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for psValue

    // Call method on actual COM interface
    hr = self->m_pIMetaInfo->get_Value(&bspsValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMetaInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMetaInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMetaInfo.get_Value() returned %ld", (long)hr);
        goto imetainfo_get_value_method_cleanup;
    }

    // Set up return values as needed
    pyvar_psValue = PyUnicode_FromWideChar(bspsValue,::SysStringLen(bspsValue));
    ::SysFreeString(bspsValue);
    
    if (PyErr_Occurred())
      goto imetainfo_get_value_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_psValue);
    goto imetainfo_get_value_method_cleanup;

    imetainfo_get_value_method_cleanup:
    self->m_HR = hr;
    if (pyvar_psValue != Py_None)
        Py_XDECREF(pyvar_psValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IMetaInfo.get_Value");
    return return_tuple;
}


PyMethodDef PyIMetaInfoMethods[] = {
    {"supports", (PyCFunction)PyIMetaInfo_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IMetaInfoMethod_get_Name, METH_VARARGS, ""},
    {"get_Value", (PyCFunction)IMetaInfoMethod_get_Value, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIMetaInfoGetSet[] = {
  {"_pUnk", (getter)PyIMetaInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from IMetaInfo", NULL},
  {"_pointer", (getter)PyIMetaInfo_GetPointer, NULL, "Get memory address for IMetaInfo", NULL},
  {"_IID", (getter)PyIMetaInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIMetaInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIMetaInfo_GetIgnoreFailures, (setter)PyIMetaInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIMetaInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IMetaInfoObject",                          
                                              /* tp_name */
  sizeof(PyIMetaInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIMetaInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIMetaInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIMetaInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIMetaInfoObject_new,                      
                                              /* tp_new */
};

// Interface IDataLicenseInfo

typedef struct PyIDataLicenseInfoObject {
    PyObject_HEAD
    IDataLicenseInfo* m_pIDataLicenseInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataLicenseInfoObject;

static PyObject*
PyIDataLicenseInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataLicenseInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataLicenseInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataLicenseInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataLicenseInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataLicenseInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataLicenseInfo");
            return NULL;
        }
        self->m_pIDataLicenseInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataLicenseInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataLicenseInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataLicenseInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataLicenseInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataLicenseInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataLicenseInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataLicenseInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataLicenseInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataLicenseInfoObject_dealloc(PyIDataLicenseInfoObject* self)
{
    if (self->m_pIDataLicenseInfo)
        self->m_pIDataLicenseInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataLicenseInfo_GetpUnk(PyIDataLicenseInfoObject* self)
{
    if (!self->m_pIDataLicenseInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataLicenseInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataLicenseInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataLicenseInfo_GetPointer(PyIDataLicenseInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataLicenseInfo);
}

static PyObject*
PyIDataLicenseInfo_GetIID(PyIDataLicenseInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "37474491-1c04-4669-99b5-825cf67294c5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataLicenseInfo_GetHR(PyIDataLicenseInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataLicenseInfo_GetIgnoreFailures(PyIDataLicenseInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataLicenseInfo_SetIgnoreFailures(PyIDataLicenseInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataLicenseInfo_SupportsInterface(PyIDataLicenseInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataLicenseInfoMethod_get_DataProductName(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_DataProductName(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_DataProductName() returned %ld", (long)hr);
        goto idatalicenseinfo_get_dataproductname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_dataproductname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatalicenseinfo_get_dataproductname_method_cleanup;

    idatalicenseinfo_get_dataproductname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_DataProductName");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_ApplicationsCount(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_ApplicationsCount(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_ApplicationsCount() returned %ld", (long)hr);
        goto idatalicenseinfo_get_applicationscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto idatalicenseinfo_get_applicationscount_method_cleanup;

    idatalicenseinfo_get_applicationscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_ApplicationsCount");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_ApplicationName(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIdx = 0;
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIdx))
      goto idatalicenseinfo_get_applicationname_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIdx
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_ApplicationName(lnIdx, &bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_ApplicationName() returned %ld", (long)hr);
        goto idatalicenseinfo_get_applicationname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIdx
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_applicationname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatalicenseinfo_get_applicationname_method_cleanup;

    idatalicenseinfo_get_applicationname_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIdx
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_ApplicationName");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_AttrCroupsCount(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_AttrCroupsCount(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_AttrCroupsCount() returned %ld", (long)hr);
        goto idatalicenseinfo_get_attrcroupscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto idatalicenseinfo_get_attrcroupscount_method_cleanup;

    idatalicenseinfo_get_attrcroupscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_AttrCroupsCount");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_AttrGroupName(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIdx = 0;
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIdx))
      goto idatalicenseinfo_get_attrgroupname_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIdx
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_AttrGroupName(lnIdx, &bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_AttrGroupName() returned %ld", (long)hr);
        goto idatalicenseinfo_get_attrgroupname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIdx
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_attrgroupname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatalicenseinfo_get_attrgroupname_method_cleanup;

    idatalicenseinfo_get_attrgroupname_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIdx
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_AttrGroupName");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_GeographiesCount(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_GeographiesCount(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_GeographiesCount() returned %ld", (long)hr);
        goto idatalicenseinfo_get_geographiescount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto idatalicenseinfo_get_geographiescount_method_cleanup;

    idatalicenseinfo_get_geographiescount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_GeographiesCount");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_GeographyName(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIdx = 0;
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIdx))
      goto idatalicenseinfo_get_geographyname_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIdx
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_GeographyName(lnIdx, &bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_GeographyName() returned %ld", (long)hr);
        goto idatalicenseinfo_get_geographyname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIdx
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_geographyname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatalicenseinfo_get_geographyname_method_cleanup;

    idatalicenseinfo_get_geographyname_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIdx
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_GeographyName");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_MetaCount(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_MetaCount(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_MetaCount() returned %ld", (long)hr);
        goto idatalicenseinfo_get_metacount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto idatalicenseinfo_get_metacount_method_cleanup;

    idatalicenseinfo_get_metacount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_MetaCount");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_MetaInfo(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIdx = 0;
    IMetaInfo* ipppMeta = NULL;
    PyObject* py_ppMeta = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIdx))
      goto idatalicenseinfo_get_metainfo_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIdx
    // No setup for ppMeta

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_MetaInfo(lnIdx, &ipppMeta);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_MetaInfo() returned %ld", (long)hr);
        goto idatalicenseinfo_get_metainfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIdx
    Py_XDECREF(py_ppMeta);
    if (ipppMeta)
    {
        IUnknown* pUnk = NULL;
        ipppMeta->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppMeta = IUnknownToPythonIIDObject(pUnk, &IID_IMetaInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppMeta)
    {
        if (py_ppMeta)
           Py_DECREF(py_ppMeta);
        py_ppMeta = Py_None;
        Py_INCREF(py_ppMeta);
    }
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_metainfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppMeta);
    goto idatalicenseinfo_get_metainfo_method_cleanup;

    idatalicenseinfo_get_metainfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIdx
    Py_XDECREF(py_ppMeta);
    if (ipppMeta)
      ipppMeta->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_MetaInfo");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_LayerCroupsCount(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_LayerCroupsCount(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_LayerCroupsCount() returned %ld", (long)hr);
        goto idatalicenseinfo_get_layercroupscount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto idatalicenseinfo_get_layercroupscount_method_cleanup;

    idatalicenseinfo_get_layercroupscount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_LayerCroupsCount");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_LayerGroupName(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIdx = 0;
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIdx))
      goto idatalicenseinfo_get_layergroupname_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIdx
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_LayerGroupName(lnIdx, &bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_LayerGroupName() returned %ld", (long)hr);
        goto idatalicenseinfo_get_layergroupname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIdx
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_layergroupname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatalicenseinfo_get_layergroupname_method_cleanup;

    idatalicenseinfo_get_layergroupname_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIdx
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_LayerGroupName");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_LicenseID(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    GUID gpVal;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_LicenseID(&gpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_LicenseID() returned %ld", (long)hr);
        goto idatalicenseinfo_get_licenseid_method_cleanup;
    }

    // Set up return values as needed
    py_pVal = GUIDToPythonUUID((const GUID*)&gpVal);
    
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_licenseid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto idatalicenseinfo_get_licenseid_method_cleanup;

    idatalicenseinfo_get_licenseid_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_LicenseID");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_Expiration(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvtDate;
    ::VariantInit(&vpvtDate);
    PyObject* pyvar_pvtDate = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pvtDate

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_Expiration(&vpvtDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_Expiration() returned %ld", (long)hr);
        goto idatalicenseinfo_get_expiration_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pvtDate = Variant_AsPyObject(&vpvtDate);
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_expiration_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pvtDate);
    goto idatalicenseinfo_get_expiration_method_cleanup;

    idatalicenseinfo_get_expiration_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvtDate);
    Py_XDECREF(pyvar_pvtDate);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_Expiration");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_LicenseType(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDataLicenseType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_LicenseType(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_LicenseType() returned %ld", (long)hr);
        goto idatalicenseinfo_get_licensetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto idatalicenseinfo_get_licensetype_method_cleanup;

    idatalicenseinfo_get_licensetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_LicenseType");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_MaxConnections(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_MaxConnections(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_MaxConnections() returned %ld", (long)hr);
        goto idatalicenseinfo_get_maxconnections_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto idatalicenseinfo_get_maxconnections_method_cleanup;

    idatalicenseinfo_get_maxconnections_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_MaxConnections");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_AvailableConnections(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_AvailableConnections(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_AvailableConnections() returned %ld", (long)hr);
        goto idatalicenseinfo_get_availableconnections_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto idatalicenseinfo_get_availableconnections_method_cleanup;

    idatalicenseinfo_get_availableconnections_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_AvailableConnections");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_UsageModeCount(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpnCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pnCount

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_UsageModeCount(&lpnCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_UsageModeCount() returned %ld", (long)hr);
        goto idatalicenseinfo_get_usagemodecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pnCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpnCount);
    goto idatalicenseinfo_get_usagemodecount_method_cleanup;

    idatalicenseinfo_get_usagemodecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pnCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_UsageModeCount");
    return return_tuple;
}

static PyObject*
IDataLicenseInfoMethod_get_UsageMode(PyIDataLicenseInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIndex = 0;
    IUsageModeInfo* ippInfo = NULL;
    PyObject* py_pInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIndex))
      goto idatalicenseinfo_get_usagemode_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex
    // No setup for pInfo

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseInfo->get_UsageMode(lnIndex, &ippInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseInfo.get_UsageMode() returned %ld", (long)hr);
        goto idatalicenseinfo_get_usagemode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex
    Py_XDECREF(py_pInfo);
    if (ippInfo)
    {
        IUnknown* pUnk = NULL;
        ippInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pInfo = IUnknownToPythonIIDObject(pUnk, &IID_IUsageModeInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pInfo)
    {
        if (py_pInfo)
           Py_DECREF(py_pInfo);
        py_pInfo = Py_None;
        Py_INCREF(py_pInfo);
    }
    if (PyErr_Occurred())
      goto idatalicenseinfo_get_usagemode_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pInfo);
    goto idatalicenseinfo_get_usagemode_method_cleanup;

    idatalicenseinfo_get_usagemode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    Py_XDECREF(py_pInfo);
    if (ippInfo)
      ippInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseInfo.get_UsageMode");
    return return_tuple;
}


PyMethodDef PyIDataLicenseInfoMethods[] = {
    {"supports", (PyCFunction)PyIDataLicenseInfo_SupportsInterface, METH_O, ""},
    {"get_DataProductName", (PyCFunction)IDataLicenseInfoMethod_get_DataProductName, METH_VARARGS, ""},
    {"get_ApplicationsCount", (PyCFunction)IDataLicenseInfoMethod_get_ApplicationsCount, METH_VARARGS, ""},
    {"get_ApplicationName", (PyCFunction)IDataLicenseInfoMethod_get_ApplicationName, METH_VARARGS, ""},
    {"get_AttrCroupsCount", (PyCFunction)IDataLicenseInfoMethod_get_AttrCroupsCount, METH_VARARGS, ""},
    {"get_AttrGroupName", (PyCFunction)IDataLicenseInfoMethod_get_AttrGroupName, METH_VARARGS, ""},
    {"get_GeographiesCount", (PyCFunction)IDataLicenseInfoMethod_get_GeographiesCount, METH_VARARGS, ""},
    {"get_GeographyName", (PyCFunction)IDataLicenseInfoMethod_get_GeographyName, METH_VARARGS, ""},
    {"get_MetaCount", (PyCFunction)IDataLicenseInfoMethod_get_MetaCount, METH_VARARGS, ""},
    {"get_MetaInfo", (PyCFunction)IDataLicenseInfoMethod_get_MetaInfo, METH_VARARGS, ""},
    {"get_LayerCroupsCount", (PyCFunction)IDataLicenseInfoMethod_get_LayerCroupsCount, METH_VARARGS, ""},
    {"get_LayerGroupName", (PyCFunction)IDataLicenseInfoMethod_get_LayerGroupName, METH_VARARGS, ""},
    {"get_LicenseID", (PyCFunction)IDataLicenseInfoMethod_get_LicenseID, METH_VARARGS, ""},
    {"get_Expiration", (PyCFunction)IDataLicenseInfoMethod_get_Expiration, METH_VARARGS, ""},
    {"get_LicenseType", (PyCFunction)IDataLicenseInfoMethod_get_LicenseType, METH_VARARGS, ""},
    {"get_MaxConnections", (PyCFunction)IDataLicenseInfoMethod_get_MaxConnections, METH_VARARGS, ""},
    {"get_AvailableConnections", (PyCFunction)IDataLicenseInfoMethod_get_AvailableConnections, METH_VARARGS, ""},
    {"get_UsageModeCount", (PyCFunction)IDataLicenseInfoMethod_get_UsageModeCount, METH_VARARGS, ""},
    {"get_UsageMode", (PyCFunction)IDataLicenseInfoMethod_get_UsageMode, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataLicenseInfoGetSet[] = {
  {"_pUnk", (getter)PyIDataLicenseInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataLicenseInfo", NULL},
  {"_pointer", (getter)PyIDataLicenseInfo_GetPointer, NULL, "Get memory address for IDataLicenseInfo", NULL},
  {"_IID", (getter)PyIDataLicenseInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataLicenseInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataLicenseInfo_GetIgnoreFailures, (setter)PyIDataLicenseInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataLicenseInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDataLicenseInfoObject",                          
                                              /* tp_name */
  sizeof(PyIDataLicenseInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataLicenseInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataLicenseInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataLicenseInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataLicenseInfoObject_new,                      
                                              /* tp_new */
};

// Interface IDataLicenseManager

typedef struct PyIDataLicenseManagerObject {
    PyObject_HEAD
    IDataLicenseManager* m_pIDataLicenseManager;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataLicenseManagerObject;

static PyObject*
PyIDataLicenseManagerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataLicenseManagerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataLicenseManager* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataLicenseManager, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataLicenseManager with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataLicenseManagerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataLicenseManager");
            return NULL;
        }
        self->m_pIDataLicenseManager = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataLicenseManager");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataLicenseManager");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataLicenseManager* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataLicenseManager, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataLicenseManager");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataLicenseManagerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataLicenseManager");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataLicenseManager = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataLicenseManagerObject_dealloc(PyIDataLicenseManagerObject* self)
{
    if (self->m_pIDataLicenseManager)
        self->m_pIDataLicenseManager->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataLicenseManager_GetpUnk(PyIDataLicenseManagerObject* self)
{
    if (!self->m_pIDataLicenseManager)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataLicenseManager->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataLicenseManager to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataLicenseManager_GetPointer(PyIDataLicenseManagerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataLicenseManager);
}

static PyObject*
PyIDataLicenseManager_GetIID(PyIDataLicenseManagerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2d5b7a40-f25b-4490-b36c-edd367df33d0");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataLicenseManager_GetHR(PyIDataLicenseManagerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataLicenseManager_GetIgnoreFailures(PyIDataLicenseManagerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataLicenseManager_SetIgnoreFailures(PyIDataLicenseManagerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataLicenseManager_SupportsInterface(PyIDataLicenseManagerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataLicenseManager->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataLicenseManagerMethod_get_Count(PyIDataLicenseManagerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseManager->get_Count(&lpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseManager->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseManager) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseManager.get_Count() returned %ld", (long)hr);
        goto idatalicensemanager_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpVal);
    goto idatalicensemanager_get_count_method_cleanup;

    idatalicensemanager_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseManager.get_Count");
    return return_tuple;
}

static PyObject*
IDataLicenseManagerMethod_GetLicenseInfo(PyIDataLicenseManagerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIdx = 0;
    IDataLicenseInfo* ippLicInfo = NULL;
    PyObject* py_pLicInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIdx))
      goto idatalicensemanager_getlicenseinfo_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIdx
    // No setup for pLicInfo

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseManager->GetLicenseInfo(lnIdx, &ippLicInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseManager->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseManager) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseManager.GetLicenseInfo() returned %ld", (long)hr);
        goto idatalicensemanager_getlicenseinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIdx
    Py_XDECREF(py_pLicInfo);
    if (ippLicInfo)
    {
        IUnknown* pUnk = NULL;
        ippLicInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pLicInfo = IUnknownToPythonIIDObject(pUnk, &IID_IDataLicenseInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pLicInfo)
    {
        if (py_pLicInfo)
           Py_DECREF(py_pLicInfo);
        py_pLicInfo = Py_None;
        Py_INCREF(py_pLicInfo);
    }
    if (PyErr_Occurred())
      goto idatalicensemanager_getlicenseinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pLicInfo);
    goto idatalicensemanager_getlicenseinfo_method_cleanup;

    idatalicensemanager_getlicenseinfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIdx
    Py_XDECREF(py_pLicInfo);
    if (ippLicInfo)
      ippLicInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseManager.GetLicenseInfo");
    return return_tuple;
}

static PyObject*
IDataLicenseManagerMethod_AddLicenseFromFile(PyIDataLicenseManagerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsbstrLicenseFileName = 0;
    PyObject* pyvar_bstrLicenseFileName;
    PyObject* unicodebstrLicenseFileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bstrLicenseFileName))
      goto idatalicensemanager_addlicensefromfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_bstrLicenseFileName))
        unicodebstrLicenseFileName = PyUnicode_FromObject(pyvar_bstrLicenseFileName);
    else if (PyUnicode_Check(pyvar_bstrLicenseFileName))
    {
        unicodebstrLicenseFileName = pyvar_bstrLicenseFileName;
        Py_INCREF(unicodebstrLicenseFileName);
    }
    else if (pyvar_bstrLicenseFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter bstrLicenseFileName at index 0");
    if (unicodebstrLicenseFileName)
        bsbstrLicenseFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodebstrLicenseFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodebstrLicenseFileName));
    
    if (PyErr_Occurred())
      goto idatalicensemanager_addlicensefromfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseManager->AddLicenseFromFile(bsbstrLicenseFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseManager->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseManager) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseManager.AddLicenseFromFile() returned %ld", (long)hr);
        goto idatalicensemanager_addlicensefromfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bstrLicenseFileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatalicensemanager_addlicensefromfile_method_cleanup;

    idatalicensemanager_addlicensefromfile_method_cleanup:
    self->m_HR = hr;
    if (bsbstrLicenseFileName)
        ::SysFreeString(bsbstrLicenseFileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseManager.AddLicenseFromFile");
    return return_tuple;
}

static PyObject*
IDataLicenseManagerMethod_RemoveLicense(PyIDataLicenseManagerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnIdx = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnIdx))
      goto idatalicensemanager_removelicense_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIdx

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseManager->RemoveLicense(lnIdx);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseManager->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseManager) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseManager.RemoveLicense() returned %ld", (long)hr);
        goto idatalicensemanager_removelicense_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIdx

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatalicensemanager_removelicense_method_cleanup;

    idatalicensemanager_removelicense_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIdx
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseManager.RemoveLicense");
    return return_tuple;
}

static PyObject*
IDataLicenseManagerMethod_GetLicenseInfoFromFile(PyIDataLicenseManagerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsbstrLicenseFileName = 0;
    PyObject* pyvar_bstrLicenseFileName;
    PyObject* unicodebstrLicenseFileName = NULL;
    IDataLicenseInfo* ippLicInfo = NULL;
    PyObject* py_pLicInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bstrLicenseFileName))
      goto idatalicensemanager_getlicenseinfofromfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_bstrLicenseFileName))
        unicodebstrLicenseFileName = PyUnicode_FromObject(pyvar_bstrLicenseFileName);
    else if (PyUnicode_Check(pyvar_bstrLicenseFileName))
    {
        unicodebstrLicenseFileName = pyvar_bstrLicenseFileName;
        Py_INCREF(unicodebstrLicenseFileName);
    }
    else if (pyvar_bstrLicenseFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter bstrLicenseFileName at index 0");
    if (unicodebstrLicenseFileName)
        bsbstrLicenseFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodebstrLicenseFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodebstrLicenseFileName));
    
    if (PyErr_Occurred())
      goto idatalicensemanager_getlicenseinfofromfile_method_cleanup;
    
    // No setup for pLicInfo

    // Call method on actual COM interface
    hr = self->m_pIDataLicenseManager->GetLicenseInfoFromFile(bsbstrLicenseFileName, &ippLicInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataLicenseManager->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataLicenseManager) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataLicenseManager.GetLicenseInfoFromFile() returned %ld", (long)hr);
        goto idatalicensemanager_getlicenseinfofromfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bstrLicenseFileName
    Py_XDECREF(py_pLicInfo);
    if (ippLicInfo)
    {
        IUnknown* pUnk = NULL;
        ippLicInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pLicInfo = IUnknownToPythonIIDObject(pUnk, &IID_IDataLicenseInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pLicInfo)
    {
        if (py_pLicInfo)
           Py_DECREF(py_pLicInfo);
        py_pLicInfo = Py_None;
        Py_INCREF(py_pLicInfo);
    }
    if (PyErr_Occurred())
      goto idatalicensemanager_getlicenseinfofromfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pLicInfo);
    goto idatalicensemanager_getlicenseinfofromfile_method_cleanup;

    idatalicensemanager_getlicenseinfofromfile_method_cleanup:
    self->m_HR = hr;
    if (bsbstrLicenseFileName)
        ::SysFreeString(bsbstrLicenseFileName);
    
    Py_XDECREF(py_pLicInfo);
    if (ippLicInfo)
      ippLicInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataLicenseManager.GetLicenseInfoFromFile");
    return return_tuple;
}


PyMethodDef PyIDataLicenseManagerMethods[] = {
    {"supports", (PyCFunction)PyIDataLicenseManager_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)IDataLicenseManagerMethod_get_Count, METH_VARARGS, ""},
    {"GetLicenseInfo", (PyCFunction)IDataLicenseManagerMethod_GetLicenseInfo, METH_VARARGS, ""},
    {"AddLicenseFromFile", (PyCFunction)IDataLicenseManagerMethod_AddLicenseFromFile, METH_VARARGS, ""},
    {"RemoveLicense", (PyCFunction)IDataLicenseManagerMethod_RemoveLicense, METH_VARARGS, ""},
    {"GetLicenseInfoFromFile", (PyCFunction)IDataLicenseManagerMethod_GetLicenseInfoFromFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataLicenseManagerGetSet[] = {
  {"_pUnk", (getter)PyIDataLicenseManager_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataLicenseManager", NULL},
  {"_pointer", (getter)PyIDataLicenseManager_GetPointer, NULL, "Get memory address for IDataLicenseManager", NULL},
  {"_IID", (getter)PyIDataLicenseManager_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataLicenseManager_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataLicenseManager_GetIgnoreFailures, (setter)PyIDataLicenseManager_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataLicenseManagerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDataLicenseManagerObject",                          
                                              /* tp_name */
  sizeof(PyIDataLicenseManagerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataLicenseManagerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataLicenseManagerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataLicenseManagerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataLicenseManagerObject_new,                      
                                              /* tp_new */
};

// Interface IDECadDrawingDataset

typedef struct PyIDECadDrawingDatasetObject {
    PyObject_HEAD
    IDECadDrawingDataset* m_pIDECadDrawingDataset;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDECadDrawingDatasetObject;

static PyObject*
PyIDECadDrawingDatasetObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDECadDrawingDatasetObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDECadDrawingDataset* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDECadDrawingDataset, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDECadDrawingDataset with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDECadDrawingDatasetObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECadDrawingDataset");
            return NULL;
        }
        self->m_pIDECadDrawingDataset = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDECadDrawingDataset");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDECadDrawingDataset");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDECadDrawingDataset* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDECadDrawingDataset, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDECadDrawingDataset");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDECadDrawingDatasetObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECadDrawingDataset");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDECadDrawingDataset = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDECadDrawingDatasetObject_dealloc(PyIDECadDrawingDatasetObject* self)
{
    if (self->m_pIDECadDrawingDataset)
        self->m_pIDECadDrawingDataset->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDECadDrawingDataset_GetpUnk(PyIDECadDrawingDatasetObject* self)
{
    if (!self->m_pIDECadDrawingDataset)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDECadDrawingDataset->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDECadDrawingDataset to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDECadDrawingDataset_GetPointer(PyIDECadDrawingDatasetObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDECadDrawingDataset);
}

static PyObject*
PyIDECadDrawingDataset_GetIID(PyIDECadDrawingDatasetObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6ec9d0c5-c3c5-4a2c-b9b3-5959209f427c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDECadDrawingDataset_GetHR(PyIDECadDrawingDatasetObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDECadDrawingDataset_GetIgnoreFailures(PyIDECadDrawingDatasetObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDECadDrawingDataset_SetIgnoreFailures(PyIDECadDrawingDatasetObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDECadDrawingDataset_SupportsInterface(PyIDECadDrawingDatasetObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDECadDrawingDatasetMethod_get_Is2d(PyIDECadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Is2d = VARIANT_FALSE;
    PyObject* pyvar_Is2d = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Is2d

    // Call method on actual COM interface
    hr = self->m_pIDECadDrawingDataset->get_Is2d(&b_Is2d);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadDrawingDataset.get_Is2d() returned %ld", (long)hr);
        goto idecaddrawingdataset_get_is2d_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Is2d = ((b_Is2d == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecaddrawingdataset_get_is2d_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Is2d);
    goto idecaddrawingdataset_get_is2d_method_cleanup;

    idecaddrawingdataset_get_is2d_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Is2d
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadDrawingDataset.get_Is2d");
    return return_tuple;
}

static PyObject*
IDECadDrawingDatasetMethod_put_Is2d(PyIDECadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Is2d = VARIANT_FALSE;
    PyObject* pyvar_Is2d = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Is2d))
      goto idecaddrawingdataset_put_is2d_method_cleanup;

    // Set up initial variable values as needed
    b_Is2d = ((PyObject_IsTrue(pyvar_Is2d) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecaddrawingdataset_put_is2d_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadDrawingDataset->put_Is2d(b_Is2d);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadDrawingDataset.put_Is2d() returned %ld", (long)hr);
        goto idecaddrawingdataset_put_is2d_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Is2d

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecaddrawingdataset_put_is2d_method_cleanup;

    idecaddrawingdataset_put_is2d_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Is2d
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadDrawingDataset.put_Is2d");
    return return_tuple;
}

static PyObject*
IDECadDrawingDatasetMethod_get_Is3d(PyIDECadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Is3d = VARIANT_FALSE;
    PyObject* pyvar_Is3d = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Is3d

    // Call method on actual COM interface
    hr = self->m_pIDECadDrawingDataset->get_Is3d(&b_Is3d);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadDrawingDataset.get_Is3d() returned %ld", (long)hr);
        goto idecaddrawingdataset_get_is3d_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Is3d = ((b_Is3d == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecaddrawingdataset_get_is3d_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Is3d);
    goto idecaddrawingdataset_get_is3d_method_cleanup;

    idecaddrawingdataset_get_is3d_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Is3d
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadDrawingDataset.get_Is3d");
    return return_tuple;
}

static PyObject*
IDECadDrawingDatasetMethod_put_Is3d(PyIDECadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Is3d = VARIANT_FALSE;
    PyObject* pyvar_Is3d = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Is3d))
      goto idecaddrawingdataset_put_is3d_method_cleanup;

    // Set up initial variable values as needed
    b_Is3d = ((PyObject_IsTrue(pyvar_Is3d) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecaddrawingdataset_put_is3d_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadDrawingDataset->put_Is3d(b_Is3d);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadDrawingDataset.put_Is3d() returned %ld", (long)hr);
        goto idecaddrawingdataset_put_is3d_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Is3d

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecaddrawingdataset_put_is3d_method_cleanup;

    idecaddrawingdataset_put_is3d_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Is3d
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadDrawingDataset.put_Is3d");
    return return_tuple;
}

static PyObject*
IDECadDrawingDatasetMethod_get_IsAutoCad(PyIDECadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsAutoCad = VARIANT_FALSE;
    PyObject* pyvar_IsAutoCad = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsAutoCad

    // Call method on actual COM interface
    hr = self->m_pIDECadDrawingDataset->get_IsAutoCad(&b_IsAutoCad);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadDrawingDataset.get_IsAutoCad() returned %ld", (long)hr);
        goto idecaddrawingdataset_get_isautocad_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsAutoCad = ((b_IsAutoCad == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecaddrawingdataset_get_isautocad_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsAutoCad);
    goto idecaddrawingdataset_get_isautocad_method_cleanup;

    idecaddrawingdataset_get_isautocad_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsAutoCad
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadDrawingDataset.get_IsAutoCad");
    return return_tuple;
}

static PyObject*
IDECadDrawingDatasetMethod_put_IsAutoCad(PyIDECadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsAutoCad = VARIANT_FALSE;
    PyObject* pyvar_IsAutoCad = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_IsAutoCad))
      goto idecaddrawingdataset_put_isautocad_method_cleanup;

    // Set up initial variable values as needed
    b_IsAutoCad = ((PyObject_IsTrue(pyvar_IsAutoCad) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecaddrawingdataset_put_isautocad_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadDrawingDataset->put_IsAutoCad(b_IsAutoCad);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadDrawingDataset.put_IsAutoCad() returned %ld", (long)hr);
        goto idecaddrawingdataset_put_isautocad_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for IsAutoCad

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecaddrawingdataset_put_isautocad_method_cleanup;

    idecaddrawingdataset_put_isautocad_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsAutoCad
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadDrawingDataset.put_IsAutoCad");
    return return_tuple;
}

static PyObject*
IDECadDrawingDatasetMethod_get_IsDgn(PyIDECadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsDgn = VARIANT_FALSE;
    PyObject* pyvar_IsDgn = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsDgn

    // Call method on actual COM interface
    hr = self->m_pIDECadDrawingDataset->get_IsDgn(&b_IsDgn);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadDrawingDataset.get_IsDgn() returned %ld", (long)hr);
        goto idecaddrawingdataset_get_isdgn_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsDgn = ((b_IsDgn == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecaddrawingdataset_get_isdgn_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsDgn);
    goto idecaddrawingdataset_get_isdgn_method_cleanup;

    idecaddrawingdataset_get_isdgn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsDgn
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadDrawingDataset.get_IsDgn");
    return return_tuple;
}

static PyObject*
IDECadDrawingDatasetMethod_put_IsDgn(PyIDECadDrawingDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsDgn = VARIANT_FALSE;
    PyObject* pyvar_IsDgn = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_IsDgn))
      goto idecaddrawingdataset_put_isdgn_method_cleanup;

    // Set up initial variable values as needed
    b_IsDgn = ((PyObject_IsTrue(pyvar_IsDgn) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecaddrawingdataset_put_isdgn_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadDrawingDataset->put_IsDgn(b_IsDgn);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadDrawingDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadDrawingDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadDrawingDataset.put_IsDgn() returned %ld", (long)hr);
        goto idecaddrawingdataset_put_isdgn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for IsDgn

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecaddrawingdataset_put_isdgn_method_cleanup;

    idecaddrawingdataset_put_isdgn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsDgn
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadDrawingDataset.put_IsDgn");
    return return_tuple;
}


PyMethodDef PyIDECadDrawingDatasetMethods[] = {
    {"supports", (PyCFunction)PyIDECadDrawingDataset_SupportsInterface, METH_O, ""},
    {"get_Is2d", (PyCFunction)IDECadDrawingDatasetMethod_get_Is2d, METH_VARARGS, ""},
    {"put_Is2d", (PyCFunction)IDECadDrawingDatasetMethod_put_Is2d, METH_VARARGS, ""},
    {"get_Is3d", (PyCFunction)IDECadDrawingDatasetMethod_get_Is3d, METH_VARARGS, ""},
    {"put_Is3d", (PyCFunction)IDECadDrawingDatasetMethod_put_Is3d, METH_VARARGS, ""},
    {"get_IsAutoCad", (PyCFunction)IDECadDrawingDatasetMethod_get_IsAutoCad, METH_VARARGS, ""},
    {"put_IsAutoCad", (PyCFunction)IDECadDrawingDatasetMethod_put_IsAutoCad, METH_VARARGS, ""},
    {"get_IsDgn", (PyCFunction)IDECadDrawingDatasetMethod_get_IsDgn, METH_VARARGS, ""},
    {"put_IsDgn", (PyCFunction)IDECadDrawingDatasetMethod_put_IsDgn, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDECadDrawingDatasetGetSet[] = {
  {"_pUnk", (getter)PyIDECadDrawingDataset_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDECadDrawingDataset", NULL},
  {"_pointer", (getter)PyIDECadDrawingDataset_GetPointer, NULL, "Get memory address for IDECadDrawingDataset", NULL},
  {"_IID", (getter)PyIDECadDrawingDataset_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDECadDrawingDataset_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDECadDrawingDataset_GetIgnoreFailures, (setter)PyIDECadDrawingDataset_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDECadDrawingDatasetObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDECadDrawingDatasetObject",                          
                                              /* tp_name */
  sizeof(PyIDECadDrawingDatasetObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDECadDrawingDatasetObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDECadDrawingDatasetMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDECadDrawingDatasetGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDECadDrawingDatasetObject_new,                      
                                              /* tp_new */
};

// Interface IGPLayer

typedef struct PyIGPLayerObject {
    PyObject_HEAD
    IGPLayer* m_pIGPLayer;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGPLayerObject;

static PyObject*
PyIGPLayerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGPLayerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGPLayer* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGPLayer, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGPLayer with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGPLayerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGPLayer");
            return NULL;
        }
        self->m_pIGPLayer = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGPLayer");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGPLayer");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGPLayer* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGPLayer, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGPLayer");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGPLayerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGPLayer");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGPLayer = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGPLayerObject_dealloc(PyIGPLayerObject* self)
{
    if (self->m_pIGPLayer)
        self->m_pIGPLayer->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGPLayer_GetpUnk(PyIGPLayerObject* self)
{
    if (!self->m_pIGPLayer)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGPLayer->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGPLayer to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGPLayer_GetPointer(PyIGPLayerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGPLayer);
}

static PyObject*
PyIGPLayer_GetIID(PyIGPLayerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ea30b18d-2d75-4593-bf44-b3620f41d8db");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGPLayer_GetHR(PyIGPLayerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGPLayer_GetIgnoreFailures(PyIGPLayerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGPLayer_SetIgnoreFailures(PyIGPLayerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGPLayer_SupportsInterface(PyIGPLayerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGPLayer->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGPLayerMethod_get_NameString(PyIGPLayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspNamestring;
    PyObject* pyvar_pNamestring = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pNamestring

    // Call method on actual COM interface
    hr = self->m_pIGPLayer->get_NameString(&bspNamestring);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPLayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPLayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPLayer.get_NameString() returned %ld", (long)hr);
        goto igplayer_get_namestring_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pNamestring = PyUnicode_FromWideChar(bspNamestring,::SysStringLen(bspNamestring));
    ::SysFreeString(bspNamestring);
    
    if (PyErr_Occurred())
      goto igplayer_get_namestring_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pNamestring);
    goto igplayer_get_namestring_method_cleanup;

    igplayer_get_namestring_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pNamestring != Py_None)
        Py_XDECREF(pyvar_pNamestring);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPLayer.get_NameString");
    return return_tuple;
}

static PyObject*
IGPLayerMethod_put_NameString(PyIGPLayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspNamestring = 0;
    PyObject* pyvar_pNamestring;
    PyObject* unicodepNamestring = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pNamestring))
      goto igplayer_put_namestring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pNamestring))
        unicodepNamestring = PyUnicode_FromObject(pyvar_pNamestring);
    else if (PyUnicode_Check(pyvar_pNamestring))
    {
        unicodepNamestring = pyvar_pNamestring;
        Py_INCREF(unicodepNamestring);
    }
    else if (pyvar_pNamestring != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pNamestring at index 0");
    if (unicodepNamestring)
        bspNamestring = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepNamestring), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepNamestring));
    
    if (PyErr_Occurred())
      goto igplayer_put_namestring_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPLayer->put_NameString(bspNamestring);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPLayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPLayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPLayer.put_NameString() returned %ld", (long)hr);
        goto igplayer_put_namestring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pNamestring

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igplayer_put_namestring_method_cleanup;

    igplayer_put_namestring_method_cleanup:
    self->m_HR = hr;
    if (bspNamestring)
        ::SysFreeString(bspNamestring);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPLayer.put_NameString");
    return return_tuple;
}

static PyObject*
IGPLayerMethod_get_AreaOfInterest(PyIGPLayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExtent

    // Call method on actual COM interface
    hr = self->m_pIGPLayer->get_AreaOfInterest(&ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPLayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPLayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPLayer.get_AreaOfInterest() returned %ld", (long)hr);
        goto igplayer_get_areaofinterest_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
    {
        IUnknown* pUnk = NULL;
        ipppExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtent)
    {
        if (py_ppExtent)
           Py_DECREF(py_ppExtent);
        py_ppExtent = Py_None;
        Py_INCREF(py_ppExtent);
    }
    if (PyErr_Occurred())
      goto igplayer_get_areaofinterest_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExtent);
    goto igplayer_get_areaofinterest_method_cleanup;

    igplayer_get_areaofinterest_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPLayer.get_AreaOfInterest");
    return return_tuple;
}

static PyObject*
IGPLayerMethod_putref_AreaOfInterest(PyIGPLayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppExtent))
      goto igplayer_putref_areaofinterest_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppExtent, &IID_IEnvelope, (void**)&ipppExtent))
        PyErr_SetString(PyExc_TypeError, "Argument ppExtent (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto igplayer_putref_areaofinterest_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPLayer->putref_AreaOfInterest(ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPLayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPLayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPLayer.putref_AreaOfInterest() returned %ld", (long)hr);
        goto igplayer_putref_areaofinterest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppExtent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igplayer_putref_areaofinterest_method_cleanup;

    igplayer_putref_areaofinterest_method_cleanup:
    self->m_HR = hr;
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPLayer.putref_AreaOfInterest");
    return return_tuple;
}

static PyObject*
IGPLayerMethod_SetAOICoords(PyIGPLayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dxMin = 0;
    double dyMin = 0;
    double dxMax = 0;
    double dyMax = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "dddd", &dxMin, &dyMin, &dxMax, &dyMax))
      goto igplayer_setaoicoords_method_cleanup;

    // Set up initial variable values as needed
    // No setup for xMin
    // No setup for yMin
    // No setup for xMax
    // No setup for yMax

    // Call method on actual COM interface
    hr = self->m_pIGPLayer->SetAOICoords(dxMin, dyMin, dxMax, dyMax);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPLayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPLayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPLayer.SetAOICoords() returned %ld", (long)hr);
        goto igplayer_setaoicoords_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for xMin
    // No teardown for yMin
    // No teardown for xMax
    // No teardown for yMax

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igplayer_setaoicoords_method_cleanup;

    igplayer_setaoicoords_method_cleanup:
    self->m_HR = hr;
    // No cleanup for xMin
    // No cleanup for yMin
    // No cleanup for xMax
    // No cleanup for yMax
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPLayer.SetAOICoords");
    return return_tuple;
}

static PyObject*
IGPLayerMethod_get_DataElement(PyIGPLayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDataElement* ipppDataElement = NULL;
    PyObject* py_ppDataElement = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppDataElement

    // Call method on actual COM interface
    hr = self->m_pIGPLayer->get_DataElement(&ipppDataElement);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPLayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPLayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPLayer.get_DataElement() returned %ld", (long)hr);
        goto igplayer_get_dataelement_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppDataElement);
    if (ipppDataElement)
    {
        IUnknown* pUnk = NULL;
        ipppDataElement->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDataElement = IUnknownToPythonIIDObject(pUnk, &IID_IDataElement);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDataElement)
    {
        if (py_ppDataElement)
           Py_DECREF(py_ppDataElement);
        py_ppDataElement = Py_None;
        Py_INCREF(py_ppDataElement);
    }
    if (PyErr_Occurred())
      goto igplayer_get_dataelement_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDataElement);
    goto igplayer_get_dataelement_method_cleanup;

    igplayer_get_dataelement_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppDataElement);
    if (ipppDataElement)
      ipppDataElement->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPLayer.get_DataElement");
    return return_tuple;
}

static PyObject*
IGPLayerMethod_putref_DataElement(PyIGPLayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDataElement* ipppDataElement = NULL;
    PyObject* py_ppDataElement;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppDataElement))
      goto igplayer_putref_dataelement_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppDataElement, &IID_IDataElement, (void**)&ipppDataElement))
        PyErr_SetString(PyExc_TypeError, "Argument ppDataElement (position 0) is not IDataElement");
    
    if (PyErr_Occurred())
      goto igplayer_putref_dataelement_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPLayer->putref_DataElement(ipppDataElement);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPLayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPLayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPLayer.putref_DataElement() returned %ld", (long)hr);
        goto igplayer_putref_dataelement_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppDataElement

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igplayer_putref_dataelement_method_cleanup;

    igplayer_putref_dataelement_method_cleanup:
    self->m_HR = hr;
    if (ipppDataElement)
      ipppDataElement->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPLayer.putref_DataElement");
    return return_tuple;
}


PyMethodDef PyIGPLayerMethods[] = {
    {"supports", (PyCFunction)PyIGPLayer_SupportsInterface, METH_O, ""},
    {"get_NameString", (PyCFunction)IGPLayerMethod_get_NameString, METH_VARARGS, ""},
    {"put_NameString", (PyCFunction)IGPLayerMethod_put_NameString, METH_VARARGS, ""},
    {"get_AreaOfInterest", (PyCFunction)IGPLayerMethod_get_AreaOfInterest, METH_VARARGS, ""},
    {"putref_AreaOfInterest", (PyCFunction)IGPLayerMethod_putref_AreaOfInterest, METH_VARARGS, ""},
    {"SetAOICoords", (PyCFunction)IGPLayerMethod_SetAOICoords, METH_VARARGS, ""},
    {"get_DataElement", (PyCFunction)IGPLayerMethod_get_DataElement, METH_VARARGS, ""},
    {"putref_DataElement", (PyCFunction)IGPLayerMethod_putref_DataElement, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGPLayerGetSet[] = {
  {"_pUnk", (getter)PyIGPLayer_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGPLayer", NULL},
  {"_pointer", (getter)PyIGPLayer_GetPointer, NULL, "Get memory address for IGPLayer", NULL},
  {"_IID", (getter)PyIGPLayer_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGPLayer_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGPLayer_GetIgnoreFailures, (setter)PyIGPLayer_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGPLayerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IGPLayerObject",                          
                                              /* tp_name */
  sizeof(PyIGPLayerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGPLayerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGPLayerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGPLayerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGPLayerObject_new,                      
                                              /* tp_new */
};

// Interface IDELayer

typedef struct PyIDELayerObject {
    PyObject_HEAD
    IDELayer* m_pIDELayer;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDELayerObject;

static PyObject*
PyIDELayerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDELayerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDELayer* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDELayer, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDELayer with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDELayerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDELayer");
            return NULL;
        }
        self->m_pIDELayer = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDELayer");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDELayer");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDELayer* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDELayer, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDELayer");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDELayerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDELayer");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDELayer = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDELayerObject_dealloc(PyIDELayerObject* self)
{
    if (self->m_pIDELayer)
        self->m_pIDELayer->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDELayer_GetpUnk(PyIDELayerObject* self)
{
    if (!self->m_pIDELayer)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDELayer->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDELayer to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDELayer_GetPointer(PyIDELayerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDELayer);
}

static PyObject*
PyIDELayer_GetIID(PyIDELayerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "991993e4-7dfd-4e23-bca0-689b174e3030");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDELayer_GetHR(PyIDELayerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDELayer_GetIgnoreFailures(PyIDELayerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDELayer_SetIgnoreFailures(PyIDELayerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDELayer_SupportsInterface(PyIDELayerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDELayer->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDELayerMethod_get_GPLayer(PyIDELayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPLayer* ipppLayer = NULL;
    PyObject* py_ppLayer = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppLayer

    // Call method on actual COM interface
    hr = self->m_pIDELayer->get_GPLayer(&ipppLayer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELayer.get_GPLayer() returned %ld", (long)hr);
        goto idelayer_get_gplayer_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppLayer);
    if (ipppLayer)
    {
        IUnknown* pUnk = NULL;
        ipppLayer->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppLayer = IUnknownToPythonIIDObject(pUnk, &IID_IGPLayer);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppLayer)
    {
        if (py_ppLayer)
           Py_DECREF(py_ppLayer);
        py_ppLayer = Py_None;
        Py_INCREF(py_ppLayer);
    }
    if (PyErr_Occurred())
      goto idelayer_get_gplayer_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppLayer);
    goto idelayer_get_gplayer_method_cleanup;

    idelayer_get_gplayer_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppLayer);
    if (ipppLayer)
      ipppLayer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELayer.get_GPLayer");
    return return_tuple;
}

static PyObject*
IDELayerMethod_putref_GPLayer(PyIDELayerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPLayer* ipppLayer = NULL;
    PyObject* py_ppLayer;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppLayer))
      goto idelayer_putref_gplayer_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppLayer, &IID_IGPLayer, (void**)&ipppLayer))
        PyErr_SetString(PyExc_TypeError, "Argument ppLayer (position 0) is not IGPLayer");
    
    if (PyErr_Occurred())
      goto idelayer_putref_gplayer_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDELayer->putref_GPLayer(ipppLayer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELayer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELayer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELayer.putref_GPLayer() returned %ld", (long)hr);
        goto idelayer_putref_gplayer_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppLayer

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idelayer_putref_gplayer_method_cleanup;

    idelayer_putref_gplayer_method_cleanup:
    self->m_HR = hr;
    if (ipppLayer)
      ipppLayer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELayer.putref_GPLayer");
    return return_tuple;
}


PyMethodDef PyIDELayerMethods[] = {
    {"supports", (PyCFunction)PyIDELayer_SupportsInterface, METH_O, ""},
    {"get_GPLayer", (PyCFunction)IDELayerMethod_get_GPLayer, METH_VARARGS, ""},
    {"putref_GPLayer", (PyCFunction)IDELayerMethod_putref_GPLayer, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDELayerGetSet[] = {
  {"_pUnk", (getter)PyIDELayer_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDELayer", NULL},
  {"_pointer", (getter)PyIDELayer_GetPointer, NULL, "Get memory address for IDELayer", NULL},
  {"_IID", (getter)PyIDELayer_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDELayer_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDELayer_GetIgnoreFailures, (setter)PyIDELayer_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDELayerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDELayerObject",                          
                                              /* tp_name */
  sizeof(PyIDELayerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDELayerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDELayerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDELayerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDELayerObject_new,                      
                                              /* tp_new */
};

// Interface IDEPrjFile

typedef struct PyIDEPrjFileObject {
    PyObject_HEAD
    IDEPrjFile* m_pIDEPrjFile;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDEPrjFileObject;

static PyObject*
PyIDEPrjFileObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDEPrjFileObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDEPrjFile* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDEPrjFile, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDEPrjFile with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDEPrjFileObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDEPrjFile");
            return NULL;
        }
        self->m_pIDEPrjFile = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDEPrjFile");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDEPrjFile");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDEPrjFile* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDEPrjFile, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDEPrjFile");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDEPrjFileObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDEPrjFile");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDEPrjFile = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDEPrjFileObject_dealloc(PyIDEPrjFileObject* self)
{
    if (self->m_pIDEPrjFile)
        self->m_pIDEPrjFile->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDEPrjFile_GetpUnk(PyIDEPrjFileObject* self)
{
    if (!self->m_pIDEPrjFile)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDEPrjFile->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDEPrjFile to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDEPrjFile_GetPointer(PyIDEPrjFileObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDEPrjFile);
}

static PyObject*
PyIDEPrjFile_GetIID(PyIDEPrjFileObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f69ca920-cfbb-11d5-933d-0080c71a3226");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDEPrjFile_GetHR(PyIDEPrjFileObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDEPrjFile_GetIgnoreFailures(PyIDEPrjFileObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDEPrjFile_SetIgnoreFailures(PyIDEPrjFileObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDEPrjFile_SupportsInterface(PyIDEPrjFileObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDEPrjFile->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDEPrjFileMethod_get_SpatialReference(PyIDEPrjFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialReference = NULL;
    PyObject* py_ppSpatialReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialReference

    // Call method on actual COM interface
    hr = self->m_pIDEPrjFile->get_SpatialReference(&ipppSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEPrjFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEPrjFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEPrjFile.get_SpatialReference() returned %ld", (long)hr);
        goto ideprjfile_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialReference = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialReference)
    {
        if (py_ppSpatialReference)
           Py_DECREF(py_ppSpatialReference);
        py_ppSpatialReference = Py_None;
        Py_INCREF(py_ppSpatialReference);
    }
    if (PyErr_Occurred())
      goto ideprjfile_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialReference);
    goto ideprjfile_get_spatialreference_method_cleanup;

    ideprjfile_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
      ipppSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEPrjFile.get_SpatialReference");
    return return_tuple;
}

static PyObject*
IDEPrjFileMethod_putref_SpatialReference(PyIDEPrjFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialReference = NULL;
    PyObject* py_ppSpatialReference;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppSpatialReference))
      goto ideprjfile_putref_spatialreference_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppSpatialReference, &IID_ISpatialReference, (void**)&ipppSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument ppSpatialReference (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto ideprjfile_putref_spatialreference_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDEPrjFile->putref_SpatialReference(ipppSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEPrjFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEPrjFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEPrjFile.putref_SpatialReference() returned %ld", (long)hr);
        goto ideprjfile_putref_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppSpatialReference

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideprjfile_putref_spatialreference_method_cleanup;

    ideprjfile_putref_spatialreference_method_cleanup:
    self->m_HR = hr;
    if (ipppSpatialReference)
      ipppSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEPrjFile.putref_SpatialReference");
    return return_tuple;
}


PyMethodDef PyIDEPrjFileMethods[] = {
    {"supports", (PyCFunction)PyIDEPrjFile_SupportsInterface, METH_O, ""},
    {"get_SpatialReference", (PyCFunction)IDEPrjFileMethod_get_SpatialReference, METH_VARARGS, ""},
    {"putref_SpatialReference", (PyCFunction)IDEPrjFileMethod_putref_SpatialReference, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDEPrjFileGetSet[] = {
  {"_pUnk", (getter)PyIDEPrjFile_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDEPrjFile", NULL},
  {"_pointer", (getter)PyIDEPrjFile_GetPointer, NULL, "Get memory address for IDEPrjFile", NULL},
  {"_IID", (getter)PyIDEPrjFile_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDEPrjFile_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDEPrjFile_GetIgnoreFailures, (setter)PyIDEPrjFile_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDEPrjFileObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDEPrjFileObject",                          
                                              /* tp_name */
  sizeof(PyIDEPrjFileObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDEPrjFileObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDEPrjFileMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDEPrjFileGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDEPrjFileObject_new,                      
                                              /* tp_new */
};

// Interface IDETin

typedef struct PyIDETinObject {
    PyObject_HEAD
    IDETin* m_pIDETin;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDETinObject;

static PyObject*
PyIDETinObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDETinObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDETin* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDETin, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDETin with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDETinObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDETin");
            return NULL;
        }
        self->m_pIDETin = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDETin");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDETin");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDETin* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDETin, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDETin");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDETinObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDETin");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDETin = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDETinObject_dealloc(PyIDETinObject* self)
{
    if (self->m_pIDETin)
        self->m_pIDETin->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDETin_GetpUnk(PyIDETinObject* self)
{
    if (!self->m_pIDETin)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDETin->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDETin to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDETin_GetPointer(PyIDETinObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDETin);
}

static PyObject*
PyIDETin_GetIID(PyIDETinObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b0b62284-0080-4ea3-9716-de5293a73f6e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDETin_GetHR(PyIDETinObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDETin_GetIgnoreFailures(PyIDETinObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDETin_SetIgnoreFailures(PyIDETinObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDETin_SupportsInterface(PyIDETinObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDETinMethod_get_IsDelaunay(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsDelaunay = VARIANT_FALSE;
    PyObject* pyvar_pbIsDelaunay = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsDelaunay

    // Call method on actual COM interface
    hr = self->m_pIDETin->get_IsDelaunay(&b_pbIsDelaunay);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.get_IsDelaunay() returned %ld", (long)hr);
        goto idetin_get_isdelaunay_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsDelaunay = ((b_pbIsDelaunay == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idetin_get_isdelaunay_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsDelaunay);
    goto idetin_get_isdelaunay_method_cleanup;

    idetin_get_isdelaunay_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsDelaunay
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.get_IsDelaunay");
    return return_tuple;
}

static PyObject*
IDETinMethod_put_IsDelaunay(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsDelaunay = VARIANT_FALSE;
    PyObject* pyvar_pbIsDelaunay = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbIsDelaunay))
      goto idetin_put_isdelaunay_method_cleanup;

    // Set up initial variable values as needed
    b_pbIsDelaunay = ((PyObject_IsTrue(pyvar_pbIsDelaunay) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idetin_put_isdelaunay_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDETin->put_IsDelaunay(b_pbIsDelaunay);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.put_IsDelaunay() returned %ld", (long)hr);
        goto idetin_put_isdelaunay_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbIsDelaunay

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idetin_put_isdelaunay_method_cleanup;

    idetin_put_isdelaunay_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsDelaunay
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.put_IsDelaunay");
    return return_tuple;
}

static PyObject*
IDETinMethod_get_ZFactor(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpFactor = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFactor

    // Call method on actual COM interface
    hr = self->m_pIDETin->get_ZFactor(&dpFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.get_ZFactor() returned %ld", (long)hr);
        goto idetin_get_zfactor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFactor

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpFactor);
    goto idetin_get_zfactor_method_cleanup;

    idetin_get_zfactor_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFactor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.get_ZFactor");
    return return_tuple;
}

static PyObject*
IDETinMethod_put_ZFactor(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpFactor = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpFactor))
      goto idetin_put_zfactor_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pFactor

    // Call method on actual COM interface
    hr = self->m_pIDETin->put_ZFactor(dpFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.put_ZFactor() returned %ld", (long)hr);
        goto idetin_put_zfactor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFactor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idetin_put_zfactor_method_cleanup;

    idetin_put_zfactor_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFactor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.put_ZFactor");
    return return_tuple;
}

static PyObject*
IDETinMethod_get_HasNodeTagValues(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasNodeValues = VARIANT_FALSE;
    PyObject* pyvar_pbHasNodeValues = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasNodeValues

    // Call method on actual COM interface
    hr = self->m_pIDETin->get_HasNodeTagValues(&b_pbHasNodeValues);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.get_HasNodeTagValues() returned %ld", (long)hr);
        goto idetin_get_hasnodetagvalues_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasNodeValues = ((b_pbHasNodeValues == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idetin_get_hasnodetagvalues_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasNodeValues);
    goto idetin_get_hasnodetagvalues_method_cleanup;

    idetin_get_hasnodetagvalues_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasNodeValues
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.get_HasNodeTagValues");
    return return_tuple;
}

static PyObject*
IDETinMethod_put_HasNodeTagValues(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasNodeValues = VARIANT_FALSE;
    PyObject* pyvar_pbHasNodeValues = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbHasNodeValues))
      goto idetin_put_hasnodetagvalues_method_cleanup;

    // Set up initial variable values as needed
    b_pbHasNodeValues = ((PyObject_IsTrue(pyvar_pbHasNodeValues) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idetin_put_hasnodetagvalues_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDETin->put_HasNodeTagValues(b_pbHasNodeValues);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.put_HasNodeTagValues() returned %ld", (long)hr);
        goto idetin_put_hasnodetagvalues_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbHasNodeValues

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idetin_put_hasnodetagvalues_method_cleanup;

    idetin_put_hasnodetagvalues_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasNodeValues
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.put_HasNodeTagValues");
    return return_tuple;
}

static PyObject*
IDETinMethod_get_HasEdgeTagValues(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasEdgeValues = VARIANT_FALSE;
    PyObject* pyvar_pbHasEdgeValues = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasEdgeValues

    // Call method on actual COM interface
    hr = self->m_pIDETin->get_HasEdgeTagValues(&b_pbHasEdgeValues);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.get_HasEdgeTagValues() returned %ld", (long)hr);
        goto idetin_get_hasedgetagvalues_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasEdgeValues = ((b_pbHasEdgeValues == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idetin_get_hasedgetagvalues_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasEdgeValues);
    goto idetin_get_hasedgetagvalues_method_cleanup;

    idetin_get_hasedgetagvalues_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasEdgeValues
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.get_HasEdgeTagValues");
    return return_tuple;
}

static PyObject*
IDETinMethod_put_HasEdgeTagValues(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasEdgeValues = VARIANT_FALSE;
    PyObject* pyvar_pbHasEdgeValues = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbHasEdgeValues))
      goto idetin_put_hasedgetagvalues_method_cleanup;

    // Set up initial variable values as needed
    b_pbHasEdgeValues = ((PyObject_IsTrue(pyvar_pbHasEdgeValues) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idetin_put_hasedgetagvalues_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDETin->put_HasEdgeTagValues(b_pbHasEdgeValues);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.put_HasEdgeTagValues() returned %ld", (long)hr);
        goto idetin_put_hasedgetagvalues_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbHasEdgeValues

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idetin_put_hasedgetagvalues_method_cleanup;

    idetin_put_hasedgetagvalues_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasEdgeValues
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.put_HasEdgeTagValues");
    return return_tuple;
}

static PyObject*
IDETinMethod_get_HasTriangleTagValues(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasTriangleValues = VARIANT_FALSE;
    PyObject* pyvar_pbHasTriangleValues = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasTriangleValues

    // Call method on actual COM interface
    hr = self->m_pIDETin->get_HasTriangleTagValues(&b_pbHasTriangleValues);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.get_HasTriangleTagValues() returned %ld", (long)hr);
        goto idetin_get_hastriangletagvalues_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasTriangleValues = ((b_pbHasTriangleValues == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idetin_get_hastriangletagvalues_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasTriangleValues);
    goto idetin_get_hastriangletagvalues_method_cleanup;

    idetin_get_hastriangletagvalues_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasTriangleValues
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.get_HasTriangleTagValues");
    return return_tuple;
}

static PyObject*
IDETinMethod_put_HasTriangleTagValues(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasTriangleValues = VARIANT_FALSE;
    PyObject* pyvar_pbHasTriangleValues = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbHasTriangleValues))
      goto idetin_put_hastriangletagvalues_method_cleanup;

    // Set up initial variable values as needed
    b_pbHasTriangleValues = ((PyObject_IsTrue(pyvar_pbHasTriangleValues) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idetin_put_hastriangletagvalues_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDETin->put_HasTriangleTagValues(b_pbHasTriangleValues);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.put_HasTriangleTagValues() returned %ld", (long)hr);
        goto idetin_put_hastriangletagvalues_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbHasTriangleValues

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idetin_put_hastriangletagvalues_method_cleanup;

    idetin_put_hastriangletagvalues_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasTriangleValues
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.put_HasTriangleTagValues");
    return return_tuple;
}

static PyObject*
IDETinMethod_get_Fields(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipppFields = NULL;
    PyObject* py_ppFields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppFields

    // Call method on actual COM interface
    hr = self->m_pIDETin->get_Fields(&ipppFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.get_Fields() returned %ld", (long)hr);
        goto idetin_get_fields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppFields);
    if (ipppFields)
    {
        IUnknown* pUnk = NULL;
        ipppFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFields)
    {
        if (py_ppFields)
           Py_DECREF(py_ppFields);
        py_ppFields = Py_None;
        Py_INCREF(py_ppFields);
    }
    if (PyErr_Occurred())
      goto idetin_get_fields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppFields);
    goto idetin_get_fields_method_cleanup;

    idetin_get_fields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppFields);
    if (ipppFields)
      ipppFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.get_Fields");
    return return_tuple;
}

static PyObject*
IDETinMethod_putref_Fields(PyIDETinObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipppFields = NULL;
    PyObject* py_ppFields;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppFields))
      goto idetin_putref_fields_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppFields, &IID_IFields, (void**)&ipppFields))
        PyErr_SetString(PyExc_TypeError, "Argument ppFields (position 0) is not IFields");
    
    if (PyErr_Occurred())
      goto idetin_putref_fields_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDETin->putref_Fields(ipppFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETin->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETin) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETin.putref_Fields() returned %ld", (long)hr);
        goto idetin_putref_fields_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppFields

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idetin_putref_fields_method_cleanup;

    idetin_putref_fields_method_cleanup:
    self->m_HR = hr;
    if (ipppFields)
      ipppFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETin.putref_Fields");
    return return_tuple;
}


PyMethodDef PyIDETinMethods[] = {
    {"supports", (PyCFunction)PyIDETin_SupportsInterface, METH_O, ""},
    {"get_IsDelaunay", (PyCFunction)IDETinMethod_get_IsDelaunay, METH_VARARGS, ""},
    {"put_IsDelaunay", (PyCFunction)IDETinMethod_put_IsDelaunay, METH_VARARGS, ""},
    {"get_ZFactor", (PyCFunction)IDETinMethod_get_ZFactor, METH_VARARGS, ""},
    {"put_ZFactor", (PyCFunction)IDETinMethod_put_ZFactor, METH_VARARGS, ""},
    {"get_HasNodeTagValues", (PyCFunction)IDETinMethod_get_HasNodeTagValues, METH_VARARGS, ""},
    {"put_HasNodeTagValues", (PyCFunction)IDETinMethod_put_HasNodeTagValues, METH_VARARGS, ""},
    {"get_HasEdgeTagValues", (PyCFunction)IDETinMethod_get_HasEdgeTagValues, METH_VARARGS, ""},
    {"put_HasEdgeTagValues", (PyCFunction)IDETinMethod_put_HasEdgeTagValues, METH_VARARGS, ""},
    {"get_HasTriangleTagValues", (PyCFunction)IDETinMethod_get_HasTriangleTagValues, METH_VARARGS, ""},
    {"put_HasTriangleTagValues", (PyCFunction)IDETinMethod_put_HasTriangleTagValues, METH_VARARGS, ""},
    {"get_Fields", (PyCFunction)IDETinMethod_get_Fields, METH_VARARGS, ""},
    {"putref_Fields", (PyCFunction)IDETinMethod_putref_Fields, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDETinGetSet[] = {
  {"_pUnk", (getter)PyIDETin_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDETin", NULL},
  {"_pointer", (getter)PyIDETin_GetPointer, NULL, "Get memory address for IDETin", NULL},
  {"_IID", (getter)PyIDETin_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDETin_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDETin_GetIgnoreFailures, (setter)PyIDETin_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDETinObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDETinObject",                          
                                              /* tp_name */
  sizeof(PyIDETinObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDETinObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDETinMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDETinGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDETinObject_new,                      
                                              /* tp_new */
};

// Interface IDELasDataset

typedef struct PyIDELasDatasetObject {
    PyObject_HEAD
    IDELasDataset* m_pIDELasDataset;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDELasDatasetObject;

static PyObject*
PyIDELasDatasetObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDELasDatasetObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDELasDataset* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDELasDataset, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDELasDataset with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDELasDatasetObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDELasDataset");
            return NULL;
        }
        self->m_pIDELasDataset = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDELasDataset");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDELasDataset");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDELasDataset* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDELasDataset, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDELasDataset");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDELasDatasetObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDELasDataset");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDELasDataset = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDELasDatasetObject_dealloc(PyIDELasDatasetObject* self)
{
    if (self->m_pIDELasDataset)
        self->m_pIDELasDataset->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDELasDataset_GetpUnk(PyIDELasDatasetObject* self)
{
    if (!self->m_pIDELasDataset)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDELasDataset->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDELasDataset to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDELasDataset_GetPointer(PyIDELasDatasetObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDELasDataset);
}

static PyObject*
PyIDELasDataset_GetIID(PyIDELasDatasetObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1508d058-f970-487c-afbe-31db1c3ed594");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDELasDataset_GetHR(PyIDELasDatasetObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDELasDataset_GetIgnoreFailures(PyIDELasDatasetObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDELasDataset_SetIgnoreFailures(PyIDELasDatasetObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDELasDataset_SupportsInterface(PyIDELasDatasetObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDELasDatasetMethod_get_FileCount(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFileCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFileCount

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->get_FileCount(&lpFileCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.get_FileCount() returned %ld", (long)hr);
        goto idelasdataset_get_filecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFileCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpFileCount);
    goto idelasdataset_get_filecount_method_cleanup;

    idelasdataset_get_filecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFileCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.get_FileCount");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_put_FileCount(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFileCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpFileCount))
      goto idelasdataset_put_filecount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pFileCount

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->put_FileCount(lpFileCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.put_FileCount() returned %ld", (long)hr);
        goto idelasdataset_put_filecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFileCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idelasdataset_put_filecount_method_cleanup;

    idelasdataset_put_filecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFileCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.put_FileCount");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_get_PointCount(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpPointCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPointCount

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->get_PointCount(&lpPointCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.get_PointCount() returned %ld", (long)hr);
        goto idelasdataset_get_pointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPointCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpPointCount);
    goto idelasdataset_get_pointcount_method_cleanup;

    idelasdataset_get_pointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPointCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.get_PointCount");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_put_PointCount(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpPointCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpPointCount))
      goto idelasdataset_put_pointcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pPointCount

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->put_PointCount(lpPointCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.put_PointCount() returned %ld", (long)hr);
        goto idelasdataset_put_pointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPointCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idelasdataset_put_pointcount_method_cleanup;

    idelasdataset_put_pointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPointCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.put_PointCount");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_get_SurfaceConstraintCount(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpSurfaceConstraintCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pSurfaceConstraintCount

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->get_SurfaceConstraintCount(&lpSurfaceConstraintCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.get_SurfaceConstraintCount() returned %ld", (long)hr);
        goto idelasdataset_get_surfaceconstraintcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSurfaceConstraintCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpSurfaceConstraintCount);
    goto idelasdataset_get_surfaceconstraintcount_method_cleanup;

    idelasdataset_get_surfaceconstraintcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSurfaceConstraintCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.get_SurfaceConstraintCount");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_put_SurfaceConstraintCount(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpSurfaceConstraintCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpSurfaceConstraintCount))
      goto idelasdataset_put_surfaceconstraintcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pSurfaceConstraintCount

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->put_SurfaceConstraintCount(lpSurfaceConstraintCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.put_SurfaceConstraintCount() returned %ld", (long)hr);
        goto idelasdataset_put_surfaceconstraintcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSurfaceConstraintCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idelasdataset_put_surfaceconstraintcount_method_cleanup;

    idelasdataset_put_surfaceconstraintcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSurfaceConstraintCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.put_SurfaceConstraintCount");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_get_HasStatistics(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasStatistics = VARIANT_FALSE;
    PyObject* pyvar_pbHasStatistics = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasStatistics

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->get_HasStatistics(&b_pbHasStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.get_HasStatistics() returned %ld", (long)hr);
        goto idelasdataset_get_hasstatistics_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasStatistics = ((b_pbHasStatistics == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idelasdataset_get_hasstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasStatistics);
    goto idelasdataset_get_hasstatistics_method_cleanup;

    idelasdataset_get_hasstatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasStatistics
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.get_HasStatistics");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_put_HasStatistics(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasStatistics = VARIANT_FALSE;
    PyObject* pyvar_pbHasStatistics = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbHasStatistics))
      goto idelasdataset_put_hasstatistics_method_cleanup;

    // Set up initial variable values as needed
    b_pbHasStatistics = ((PyObject_IsTrue(pyvar_pbHasStatistics) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idelasdataset_put_hasstatistics_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->put_HasStatistics(b_pbHasStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.put_HasStatistics() returned %ld", (long)hr);
        goto idelasdataset_put_hasstatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbHasStatistics

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idelasdataset_put_hasstatistics_method_cleanup;

    idelasdataset_put_hasstatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasStatistics
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.put_HasStatistics");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_get_NeedsUpdateStatistics(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbNeedsUpdateStatistics = VARIANT_FALSE;
    PyObject* pyvar_pbNeedsUpdateStatistics = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbNeedsUpdateStatistics

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->get_NeedsUpdateStatistics(&b_pbNeedsUpdateStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.get_NeedsUpdateStatistics() returned %ld", (long)hr);
        goto idelasdataset_get_needsupdatestatistics_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbNeedsUpdateStatistics = ((b_pbNeedsUpdateStatistics == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idelasdataset_get_needsupdatestatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbNeedsUpdateStatistics);
    goto idelasdataset_get_needsupdatestatistics_method_cleanup;

    idelasdataset_get_needsupdatestatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbNeedsUpdateStatistics
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.get_NeedsUpdateStatistics");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_put_NeedsUpdateStatistics(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbNeedsUpdateStatistics = VARIANT_FALSE;
    PyObject* pyvar_pbNeedsUpdateStatistics = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbNeedsUpdateStatistics))
      goto idelasdataset_put_needsupdatestatistics_method_cleanup;

    // Set up initial variable values as needed
    b_pbNeedsUpdateStatistics = ((PyObject_IsTrue(pyvar_pbNeedsUpdateStatistics) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idelasdataset_put_needsupdatestatistics_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->put_NeedsUpdateStatistics(b_pbNeedsUpdateStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.put_NeedsUpdateStatistics() returned %ld", (long)hr);
        goto idelasdataset_put_needsupdatestatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbNeedsUpdateStatistics

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idelasdataset_put_needsupdatestatistics_method_cleanup;

    idelasdataset_put_needsupdatestatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbNeedsUpdateStatistics
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.put_NeedsUpdateStatistics");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_get_UsesRelativePath(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbUsesRelativePath = VARIANT_FALSE;
    PyObject* pyvar_pbUsesRelativePath = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbUsesRelativePath

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->get_UsesRelativePath(&b_pbUsesRelativePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.get_UsesRelativePath() returned %ld", (long)hr);
        goto idelasdataset_get_usesrelativepath_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbUsesRelativePath = ((b_pbUsesRelativePath == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idelasdataset_get_usesrelativepath_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbUsesRelativePath);
    goto idelasdataset_get_usesrelativepath_method_cleanup;

    idelasdataset_get_usesrelativepath_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbUsesRelativePath
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.get_UsesRelativePath");
    return return_tuple;
}

static PyObject*
IDELasDatasetMethod_put_UsesRelativePath(PyIDELasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbUsesRelativePath = VARIANT_FALSE;
    PyObject* pyvar_pbUsesRelativePath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbUsesRelativePath))
      goto idelasdataset_put_usesrelativepath_method_cleanup;

    // Set up initial variable values as needed
    b_pbUsesRelativePath = ((PyObject_IsTrue(pyvar_pbUsesRelativePath) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idelasdataset_put_usesrelativepath_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDELasDataset->put_UsesRelativePath(b_pbUsesRelativePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDELasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDELasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDELasDataset.put_UsesRelativePath() returned %ld", (long)hr);
        goto idelasdataset_put_usesrelativepath_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbUsesRelativePath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idelasdataset_put_usesrelativepath_method_cleanup;

    idelasdataset_put_usesrelativepath_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbUsesRelativePath
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDELasDataset.put_UsesRelativePath");
    return return_tuple;
}


PyMethodDef PyIDELasDatasetMethods[] = {
    {"supports", (PyCFunction)PyIDELasDataset_SupportsInterface, METH_O, ""},
    {"get_FileCount", (PyCFunction)IDELasDatasetMethod_get_FileCount, METH_VARARGS, ""},
    {"put_FileCount", (PyCFunction)IDELasDatasetMethod_put_FileCount, METH_VARARGS, ""},
    {"get_PointCount", (PyCFunction)IDELasDatasetMethod_get_PointCount, METH_VARARGS, ""},
    {"put_PointCount", (PyCFunction)IDELasDatasetMethod_put_PointCount, METH_VARARGS, ""},
    {"get_SurfaceConstraintCount", (PyCFunction)IDELasDatasetMethod_get_SurfaceConstraintCount, METH_VARARGS, ""},
    {"put_SurfaceConstraintCount", (PyCFunction)IDELasDatasetMethod_put_SurfaceConstraintCount, METH_VARARGS, ""},
    {"get_HasStatistics", (PyCFunction)IDELasDatasetMethod_get_HasStatistics, METH_VARARGS, ""},
    {"put_HasStatistics", (PyCFunction)IDELasDatasetMethod_put_HasStatistics, METH_VARARGS, ""},
    {"get_NeedsUpdateStatistics", (PyCFunction)IDELasDatasetMethod_get_NeedsUpdateStatistics, METH_VARARGS, ""},
    {"put_NeedsUpdateStatistics", (PyCFunction)IDELasDatasetMethod_put_NeedsUpdateStatistics, METH_VARARGS, ""},
    {"get_UsesRelativePath", (PyCFunction)IDELasDatasetMethod_get_UsesRelativePath, METH_VARARGS, ""},
    {"put_UsesRelativePath", (PyCFunction)IDELasDatasetMethod_put_UsesRelativePath, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDELasDatasetGetSet[] = {
  {"_pUnk", (getter)PyIDELasDataset_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDELasDataset", NULL},
  {"_pointer", (getter)PyIDELasDataset_GetPointer, NULL, "Get memory address for IDELasDataset", NULL},
  {"_IID", (getter)PyIDELasDataset_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDELasDataset_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDELasDataset_GetIgnoreFailures, (setter)PyIDELasDataset_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDELasDatasetObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDELasDatasetObject",                          
                                              /* tp_name */
  sizeof(PyIDELasDatasetObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDELasDatasetObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDELasDatasetMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDELasDatasetGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDELasDatasetObject_new,                      
                                              /* tp_new */
};

// Interface IDECoverage

typedef struct PyIDECoverageObject {
    PyObject_HEAD
    IDECoverage* m_pIDECoverage;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDECoverageObject;

static PyObject*
PyIDECoverageObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDECoverageObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDECoverage* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDECoverage, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDECoverage with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDECoverageObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECoverage");
            return NULL;
        }
        self->m_pIDECoverage = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDECoverage");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDECoverage");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDECoverage* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDECoverage, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDECoverage");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDECoverageObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECoverage");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDECoverage = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDECoverageObject_dealloc(PyIDECoverageObject* self)
{
    if (self->m_pIDECoverage)
        self->m_pIDECoverage->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDECoverage_GetpUnk(PyIDECoverageObject* self)
{
    if (!self->m_pIDECoverage)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDECoverage->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDECoverage to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDECoverage_GetPointer(PyIDECoverageObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDECoverage);
}

static PyObject*
PyIDECoverage_GetIID(PyIDECoverageObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "bde67d8b-bf5e-45ec-a3fd-09ac77efe850");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDECoverage_GetHR(PyIDECoverageObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDECoverage_GetIgnoreFailures(PyIDECoverageObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDECoverage_SetIgnoreFailures(PyIDECoverageObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDECoverage_SupportsInterface(PyIDECoverageObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDECoverage->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDECoverageMethod_get_Tolerances(PyIDECoverageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippropertySet = NULL;
    PyObject* py_propertySet = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for propertySet

    // Call method on actual COM interface
    hr = self->m_pIDECoverage->get_Tolerances(&ippropertySet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECoverage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECoverage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECoverage.get_Tolerances() returned %ld", (long)hr);
        goto idecoverage_get_tolerances_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_propertySet);
    if (ippropertySet)
    {
        IUnknown* pUnk = NULL;
        ippropertySet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_propertySet = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_propertySet)
    {
        if (py_propertySet)
           Py_DECREF(py_propertySet);
        py_propertySet = Py_None;
        Py_INCREF(py_propertySet);
    }
    if (PyErr_Occurred())
      goto idecoverage_get_tolerances_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_propertySet);
    goto idecoverage_get_tolerances_method_cleanup;

    idecoverage_get_tolerances_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_propertySet);
    if (ippropertySet)
      ippropertySet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECoverage.get_Tolerances");
    return return_tuple;
}

static PyObject*
IDECoverageMethod_putref_Tolerances(PyIDECoverageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ippropertySet = NULL;
    PyObject* py_propertySet;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_propertySet))
      goto idecoverage_putref_tolerances_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_propertySet, &IID_IPropertySet, (void**)&ippropertySet))
        PyErr_SetString(PyExc_TypeError, "Argument propertySet (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto idecoverage_putref_tolerances_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECoverage->putref_Tolerances(ippropertySet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECoverage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECoverage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECoverage.putref_Tolerances() returned %ld", (long)hr);
        goto idecoverage_putref_tolerances_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for propertySet

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecoverage_putref_tolerances_method_cleanup;

    idecoverage_putref_tolerances_method_cleanup:
    self->m_HR = hr;
    if (ippropertySet)
      ippropertySet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECoverage.putref_Tolerances");
    return return_tuple;
}


PyMethodDef PyIDECoverageMethods[] = {
    {"supports", (PyCFunction)PyIDECoverage_SupportsInterface, METH_O, ""},
    {"get_Tolerances", (PyCFunction)IDECoverageMethod_get_Tolerances, METH_VARARGS, ""},
    {"putref_Tolerances", (PyCFunction)IDECoverageMethod_putref_Tolerances, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDECoverageGetSet[] = {
  {"_pUnk", (getter)PyIDECoverage_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDECoverage", NULL},
  {"_pointer", (getter)PyIDECoverage_GetPointer, NULL, "Get memory address for IDECoverage", NULL},
  {"_IID", (getter)PyIDECoverage_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDECoverage_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDECoverage_GetIgnoreFailures, (setter)PyIDECoverage_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDECoverageObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDECoverageObject",                          
                                              /* tp_name */
  sizeof(PyIDECoverageObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDECoverageObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDECoverageMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDECoverageGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDECoverageObject_new,                      
                                              /* tp_new */
};

// Interface IDECoverageFeatureClass

typedef struct PyIDECoverageFeatureClassObject {
    PyObject_HEAD
    IDECoverageFeatureClass* m_pIDECoverageFeatureClass;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDECoverageFeatureClassObject;

static PyObject*
PyIDECoverageFeatureClassObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDECoverageFeatureClassObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDECoverageFeatureClass* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDECoverageFeatureClass, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDECoverageFeatureClass with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDECoverageFeatureClassObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECoverageFeatureClass");
            return NULL;
        }
        self->m_pIDECoverageFeatureClass = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDECoverageFeatureClass");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDECoverageFeatureClass");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDECoverageFeatureClass* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDECoverageFeatureClass, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDECoverageFeatureClass");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDECoverageFeatureClassObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECoverageFeatureClass");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDECoverageFeatureClass = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDECoverageFeatureClassObject_dealloc(PyIDECoverageFeatureClassObject* self)
{
    if (self->m_pIDECoverageFeatureClass)
        self->m_pIDECoverageFeatureClass->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDECoverageFeatureClass_GetpUnk(PyIDECoverageFeatureClassObject* self)
{
    if (!self->m_pIDECoverageFeatureClass)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDECoverageFeatureClass->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDECoverageFeatureClass to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDECoverageFeatureClass_GetPointer(PyIDECoverageFeatureClassObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDECoverageFeatureClass);
}

static PyObject*
PyIDECoverageFeatureClass_GetIID(PyIDECoverageFeatureClassObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "25ea15b1-7425-452b-8fb6-ca3f8d088129");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDECoverageFeatureClass_GetHR(PyIDECoverageFeatureClassObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDECoverageFeatureClass_GetIgnoreFailures(PyIDECoverageFeatureClassObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDECoverageFeatureClass_SetIgnoreFailures(PyIDECoverageFeatureClassObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDECoverageFeatureClass_SupportsInterface(PyIDECoverageFeatureClassObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDECoverageFeatureClass->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDECoverageFeatureClassMethod_get_FeatureClassType(PyIDECoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FeatureClassType

    // Call method on actual COM interface
    hr = self->m_pIDECoverageFeatureClass->get_FeatureClassType(&eFeatureClassType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECoverageFeatureClass.get_FeatureClassType() returned %ld", (long)hr);
        goto idecoveragefeatureclass_get_featureclasstype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eFeatureClassType);
    goto idecoveragefeatureclass_get_featureclasstype_method_cleanup;

    idecoveragefeatureclass_get_featureclasstype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECoverageFeatureClass.get_FeatureClassType");
    return return_tuple;
}

static PyObject*
IDECoverageFeatureClassMethod_put_FeatureClassType(PyIDECoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eFeatureClassType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eFeatureClassType))
      goto idecoveragefeatureclass_put_featureclasstype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FeatureClassType

    // Call method on actual COM interface
    hr = self->m_pIDECoverageFeatureClass->put_FeatureClassType(eFeatureClassType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECoverageFeatureClass.put_FeatureClassType() returned %ld", (long)hr);
        goto idecoveragefeatureclass_put_featureclasstype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClassType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecoveragefeatureclass_put_featureclasstype_method_cleanup;

    idecoveragefeatureclass_put_featureclasstype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FeatureClassType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECoverageFeatureClass.put_FeatureClassType");
    return return_tuple;
}

static PyObject*
IDECoverageFeatureClassMethod_get_HasFAT(PyIDECoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HasFAT = VARIANT_FALSE;
    PyObject* pyvar_HasFAT = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HasFAT

    // Call method on actual COM interface
    hr = self->m_pIDECoverageFeatureClass->get_HasFAT(&b_HasFAT);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECoverageFeatureClass.get_HasFAT() returned %ld", (long)hr);
        goto idecoveragefeatureclass_get_hasfat_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HasFAT = ((b_HasFAT == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecoveragefeatureclass_get_hasfat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HasFAT);
    goto idecoveragefeatureclass_get_hasfat_method_cleanup;

    idecoveragefeatureclass_get_hasfat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HasFAT
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECoverageFeatureClass.get_HasFAT");
    return return_tuple;
}

static PyObject*
IDECoverageFeatureClassMethod_put_HasFAT(PyIDECoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HasFAT = VARIANT_FALSE;
    PyObject* pyvar_HasFAT = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_HasFAT))
      goto idecoveragefeatureclass_put_hasfat_method_cleanup;

    // Set up initial variable values as needed
    b_HasFAT = ((PyObject_IsTrue(pyvar_HasFAT) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecoveragefeatureclass_put_hasfat_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECoverageFeatureClass->put_HasFAT(b_HasFAT);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECoverageFeatureClass.put_HasFAT() returned %ld", (long)hr);
        goto idecoveragefeatureclass_put_hasfat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HasFAT

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecoveragefeatureclass_put_hasfat_method_cleanup;

    idecoveragefeatureclass_put_hasfat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HasFAT
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECoverageFeatureClass.put_HasFAT");
    return return_tuple;
}

static PyObject*
IDECoverageFeatureClassMethod_get_Topology(PyIDECoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureClassTopology epTopology;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pTopology

    // Call method on actual COM interface
    hr = self->m_pIDECoverageFeatureClass->get_Topology(&epTopology);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECoverageFeatureClass.get_Topology() returned %ld", (long)hr);
        goto idecoveragefeatureclass_get_topology_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTopology

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epTopology);
    goto idecoveragefeatureclass_get_topology_method_cleanup;

    idecoveragefeatureclass_get_topology_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTopology
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECoverageFeatureClass.get_Topology");
    return return_tuple;
}

static PyObject*
IDECoverageFeatureClassMethod_put_Topology(PyIDECoverageFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureClassTopology epTopology;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epTopology))
      goto idecoveragefeatureclass_put_topology_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pTopology

    // Call method on actual COM interface
    hr = self->m_pIDECoverageFeatureClass->put_Topology(epTopology);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECoverageFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECoverageFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECoverageFeatureClass.put_Topology() returned %ld", (long)hr);
        goto idecoveragefeatureclass_put_topology_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTopology

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecoveragefeatureclass_put_topology_method_cleanup;

    idecoveragefeatureclass_put_topology_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTopology
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECoverageFeatureClass.put_Topology");
    return return_tuple;
}


PyMethodDef PyIDECoverageFeatureClassMethods[] = {
    {"supports", (PyCFunction)PyIDECoverageFeatureClass_SupportsInterface, METH_O, ""},
    {"get_FeatureClassType", (PyCFunction)IDECoverageFeatureClassMethod_get_FeatureClassType, METH_VARARGS, ""},
    {"put_FeatureClassType", (PyCFunction)IDECoverageFeatureClassMethod_put_FeatureClassType, METH_VARARGS, ""},
    {"get_HasFAT", (PyCFunction)IDECoverageFeatureClassMethod_get_HasFAT, METH_VARARGS, ""},
    {"put_HasFAT", (PyCFunction)IDECoverageFeatureClassMethod_put_HasFAT, METH_VARARGS, ""},
    {"get_Topology", (PyCFunction)IDECoverageFeatureClassMethod_get_Topology, METH_VARARGS, ""},
    {"put_Topology", (PyCFunction)IDECoverageFeatureClassMethod_put_Topology, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDECoverageFeatureClassGetSet[] = {
  {"_pUnk", (getter)PyIDECoverageFeatureClass_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDECoverageFeatureClass", NULL},
  {"_pointer", (getter)PyIDECoverageFeatureClass_GetPointer, NULL, "Get memory address for IDECoverageFeatureClass", NULL},
  {"_IID", (getter)PyIDECoverageFeatureClass_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDECoverageFeatureClass_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDECoverageFeatureClass_GetIgnoreFailures, (setter)PyIDECoverageFeatureClass_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDECoverageFeatureClassObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDECoverageFeatureClassObject",                          
                                              /* tp_name */
  sizeof(PyIDECoverageFeatureClassObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDECoverageFeatureClassObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDECoverageFeatureClassMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDECoverageFeatureClassGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDECoverageFeatureClassObject_new,                      
                                              /* tp_new */
};

// Interface IDEArcInfoTable

typedef struct PyIDEArcInfoTableObject {
    PyObject_HEAD
    IDEArcInfoTable* m_pIDEArcInfoTable;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDEArcInfoTableObject;

static PyObject*
PyIDEArcInfoTableObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDEArcInfoTableObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDEArcInfoTable* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDEArcInfoTable, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDEArcInfoTable with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDEArcInfoTableObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDEArcInfoTable");
            return NULL;
        }
        self->m_pIDEArcInfoTable = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDEArcInfoTable");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDEArcInfoTable");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDEArcInfoTable* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDEArcInfoTable, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDEArcInfoTable");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDEArcInfoTableObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDEArcInfoTable");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDEArcInfoTable = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDEArcInfoTableObject_dealloc(PyIDEArcInfoTableObject* self)
{
    if (self->m_pIDEArcInfoTable)
        self->m_pIDEArcInfoTable->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDEArcInfoTable_GetpUnk(PyIDEArcInfoTableObject* self)
{
    if (!self->m_pIDEArcInfoTable)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDEArcInfoTable->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDEArcInfoTable to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDEArcInfoTable_GetPointer(PyIDEArcInfoTableObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDEArcInfoTable);
}

static PyObject*
PyIDEArcInfoTable_GetIID(PyIDEArcInfoTableObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "dc3b7fdb-ce0f-4aee-945c-0755f89109e4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDEArcInfoTable_GetHR(PyIDEArcInfoTableObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDEArcInfoTable_GetIgnoreFailures(PyIDEArcInfoTableObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDEArcInfoTable_SetIgnoreFailures(PyIDEArcInfoTableObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDEArcInfoTable_SupportsInterface(PyIDEArcInfoTableObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDEArcInfoTable->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDEArcInfoTableMethod_get_ItemSet(PyIDEArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ipppItems = NULL;
    PyObject* py_ppItems = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppItems

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoTable->get_ItemSet(&ipppItems);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoTable.get_ItemSet() returned %ld", (long)hr);
        goto idearcinfotable_get_itemset_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppItems);
    if (ipppItems)
    {
        IUnknown* pUnk = NULL;
        ipppItems->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppItems = IUnknownToPythonIIDObject(pUnk, &IID_IArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppItems)
    {
        if (py_ppItems)
           Py_DECREF(py_ppItems);
        py_ppItems = Py_None;
        Py_INCREF(py_ppItems);
    }
    if (PyErr_Occurred())
      goto idearcinfotable_get_itemset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppItems);
    goto idearcinfotable_get_itemset_method_cleanup;

    idearcinfotable_get_itemset_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppItems);
    if (ipppItems)
      ipppItems->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoTable.get_ItemSet");
    return return_tuple;
}

static PyObject*
IDEArcInfoTableMethod_putref_ItemSet(PyIDEArcInfoTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ipppItems = NULL;
    PyObject* py_ppItems;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppItems))
      goto idearcinfotable_putref_itemset_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppItems, &IID_IArray, (void**)&ipppItems))
        PyErr_SetString(PyExc_TypeError, "Argument ppItems (position 0) is not IArray");
    
    if (PyErr_Occurred())
      goto idearcinfotable_putref_itemset_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoTable->putref_ItemSet(ipppItems);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoTable.putref_ItemSet() returned %ld", (long)hr);
        goto idearcinfotable_putref_itemset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppItems

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idearcinfotable_putref_itemset_method_cleanup;

    idearcinfotable_putref_itemset_method_cleanup:
    self->m_HR = hr;
    if (ipppItems)
      ipppItems->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoTable.putref_ItemSet");
    return return_tuple;
}


PyMethodDef PyIDEArcInfoTableMethods[] = {
    {"supports", (PyCFunction)PyIDEArcInfoTable_SupportsInterface, METH_O, ""},
    {"get_ItemSet", (PyCFunction)IDEArcInfoTableMethod_get_ItemSet, METH_VARARGS, ""},
    {"putref_ItemSet", (PyCFunction)IDEArcInfoTableMethod_putref_ItemSet, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDEArcInfoTableGetSet[] = {
  {"_pUnk", (getter)PyIDEArcInfoTable_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDEArcInfoTable", NULL},
  {"_pointer", (getter)PyIDEArcInfoTable_GetPointer, NULL, "Get memory address for IDEArcInfoTable", NULL},
  {"_IID", (getter)PyIDEArcInfoTable_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDEArcInfoTable_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDEArcInfoTable_GetIgnoreFailures, (setter)PyIDEArcInfoTable_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDEArcInfoTableObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDEArcInfoTableObject",                          
                                              /* tp_name */
  sizeof(PyIDEArcInfoTableObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDEArcInfoTableObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDEArcInfoTableMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDEArcInfoTableGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDEArcInfoTableObject_new,                      
                                              /* tp_new */
};

// Interface IGPArcInfoItem

typedef struct PyIGPArcInfoItemObject {
    PyObject_HEAD
    IGPArcInfoItem* m_pIGPArcInfoItem;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGPArcInfoItemObject;

static PyObject*
PyIGPArcInfoItemObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGPArcInfoItemObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGPArcInfoItem* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGPArcInfoItem, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGPArcInfoItem with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGPArcInfoItemObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGPArcInfoItem");
            return NULL;
        }
        self->m_pIGPArcInfoItem = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGPArcInfoItem");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGPArcInfoItem");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGPArcInfoItem* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGPArcInfoItem, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGPArcInfoItem");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGPArcInfoItemObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGPArcInfoItem");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGPArcInfoItem = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGPArcInfoItemObject_dealloc(PyIGPArcInfoItemObject* self)
{
    if (self->m_pIGPArcInfoItem)
        self->m_pIGPArcInfoItem->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGPArcInfoItem_GetpUnk(PyIGPArcInfoItemObject* self)
{
    if (!self->m_pIGPArcInfoItem)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGPArcInfoItem->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGPArcInfoItem to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGPArcInfoItem_GetPointer(PyIGPArcInfoItemObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGPArcInfoItem);
}

static PyObject*
PyIGPArcInfoItem_GetIID(PyIGPArcInfoItemObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c95b22e0-a3c3-11d5-931c-0080c71a3226");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGPArcInfoItem_GetHR(PyIGPArcInfoItemObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGPArcInfoItem_GetIgnoreFailures(PyIGPArcInfoItemObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGPArcInfoItem_SetIgnoreFailures(PyIGPArcInfoItemObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGPArcInfoItem_SupportsInterface(PyIGPArcInfoItemObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGPArcInfoItemMethod_get_Name(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_Name() returned %ld", (long)hr);
        goto igparcinfoitem_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto igparcinfoitem_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto igparcinfoitem_get_name_method_cleanup;

    igparcinfoitem_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_Name");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_Name(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto igparcinfoitem_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto igparcinfoitem_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_Name() returned %ld", (long)hr);
        goto igparcinfoitem_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_name_method_cleanup;

    igparcinfoitem_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_Name");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_StartPosition(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Position

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_StartPosition(&lPosition);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_StartPosition() returned %ld", (long)hr);
        goto igparcinfoitem_get_startposition_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lPosition);
    goto igparcinfoitem_get_startposition_method_cleanup;

    igparcinfoitem_get_startposition_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_StartPosition");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_StartPosition(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPosition = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPosition))
      goto igparcinfoitem_put_startposition_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Position

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_StartPosition(lPosition);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_StartPosition() returned %ld", (long)hr);
        goto igparcinfoitem_put_startposition_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Position

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_startposition_method_cleanup;

    igparcinfoitem_put_startposition_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Position
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_StartPosition");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_Width(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_Width(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_Width() returned %ld", (long)hr);
        goto igparcinfoitem_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto igparcinfoitem_get_width_method_cleanup;

    igparcinfoitem_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_Width");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_Width(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lWidth))
      goto igparcinfoitem_put_width_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_Width(lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_Width() returned %ld", (long)hr);
        goto igparcinfoitem_put_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_width_method_cleanup;

    igparcinfoitem_put_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_Width");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_OutputWidth(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_OutputWidth(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_OutputWidth() returned %ld", (long)hr);
        goto igparcinfoitem_get_outputwidth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto igparcinfoitem_get_outputwidth_method_cleanup;

    igparcinfoitem_get_outputwidth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_OutputWidth");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_OutputWidth(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lWidth))
      goto igparcinfoitem_put_outputwidth_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_OutputWidth(lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_OutputWidth() returned %ld", (long)hr);
        goto igparcinfoitem_put_outputwidth_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_outputwidth_method_cleanup;

    igparcinfoitem_put_outputwidth_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_OutputWidth");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_Type(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriArcInfoItemType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_Type(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_Type() returned %ld", (long)hr);
        goto igparcinfoitem_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto igparcinfoitem_get_type_method_cleanup;

    igparcinfoitem_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_Type");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_Type(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriArcInfoItemType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto igparcinfoitem_put_type_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_Type(eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_Type() returned %ld", (long)hr);
        goto igparcinfoitem_put_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_type_method_cleanup;

    igparcinfoitem_put_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_Type");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_NumberDecimals(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnumber = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for number

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_NumberDecimals(&lnumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_NumberDecimals() returned %ld", (long)hr);
        goto igparcinfoitem_get_numberdecimals_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for number

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lnumber);
    goto igparcinfoitem_get_numberdecimals_method_cleanup;

    igparcinfoitem_get_numberdecimals_method_cleanup:
    self->m_HR = hr;
    // No cleanup for number
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_NumberDecimals");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_NumberDecimals(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnumber = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnumber))
      goto igparcinfoitem_put_numberdecimals_method_cleanup;

    // Set up initial variable values as needed
    // No setup for number

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_NumberDecimals(lnumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_NumberDecimals() returned %ld", (long)hr);
        goto igparcinfoitem_put_numberdecimals_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for number

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_numberdecimals_method_cleanup;

    igparcinfoitem_put_numberdecimals_method_cleanup:
    self->m_HR = hr;
    // No cleanup for number
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_NumberDecimals");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_AlternateName(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAlternateName;
    PyObject* pyvar_AlternateName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for AlternateName

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_AlternateName(&bsAlternateName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_AlternateName() returned %ld", (long)hr);
        goto igparcinfoitem_get_alternatename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_AlternateName = PyUnicode_FromWideChar(bsAlternateName,::SysStringLen(bsAlternateName));
    ::SysFreeString(bsAlternateName);
    
    if (PyErr_Occurred())
      goto igparcinfoitem_get_alternatename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_AlternateName);
    goto igparcinfoitem_get_alternatename_method_cleanup;

    igparcinfoitem_get_alternatename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_AlternateName != Py_None)
        Py_XDECREF(pyvar_AlternateName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_AlternateName");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_AlternateName(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsAlternateName = 0;
    PyObject* pyvar_AlternateName;
    PyObject* unicodeAlternateName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_AlternateName))
      goto igparcinfoitem_put_alternatename_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_AlternateName))
        unicodeAlternateName = PyUnicode_FromObject(pyvar_AlternateName);
    else if (PyUnicode_Check(pyvar_AlternateName))
    {
        unicodeAlternateName = pyvar_AlternateName;
        Py_INCREF(unicodeAlternateName);
    }
    else if (pyvar_AlternateName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter AlternateName at index 0");
    if (unicodeAlternateName)
        bsAlternateName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeAlternateName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeAlternateName));
    
    if (PyErr_Occurred())
      goto igparcinfoitem_put_alternatename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_AlternateName(bsAlternateName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_AlternateName() returned %ld", (long)hr);
        goto igparcinfoitem_put_alternatename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for AlternateName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_alternatename_method_cleanup;

    igparcinfoitem_put_alternatename_method_cleanup:
    self->m_HR = hr;
    if (bsAlternateName)
        ::SysFreeString(bsAlternateName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_AlternateName");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_IsRedefined(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_redefined = VARIANT_FALSE;
    PyObject* pyvar_redefined = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for redefined

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_IsRedefined(&b_redefined);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_IsRedefined() returned %ld", (long)hr);
        goto igparcinfoitem_get_isredefined_method_cleanup;
    }

    // Set up return values as needed
    pyvar_redefined = ((b_redefined == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igparcinfoitem_get_isredefined_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_redefined);
    goto igparcinfoitem_get_isredefined_method_cleanup;

    igparcinfoitem_get_isredefined_method_cleanup:
    self->m_HR = hr;
    // No cleanup for redefined
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_IsRedefined");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_IsRedefined(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_redefined = VARIANT_FALSE;
    PyObject* pyvar_redefined = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_redefined))
      goto igparcinfoitem_put_isredefined_method_cleanup;

    // Set up initial variable values as needed
    b_redefined = ((PyObject_IsTrue(pyvar_redefined) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igparcinfoitem_put_isredefined_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_IsRedefined(b_redefined);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_IsRedefined() returned %ld", (long)hr);
        goto igparcinfoitem_put_isredefined_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for redefined

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_isredefined_method_cleanup;

    igparcinfoitem_put_isredefined_method_cleanup:
    self->m_HR = hr;
    // No cleanup for redefined
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_IsRedefined");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_IsIndexed(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsIndexed = VARIANT_FALSE;
    PyObject* pyvar_IsIndexed = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for IsIndexed

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_IsIndexed(&b_IsIndexed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_IsIndexed() returned %ld", (long)hr);
        goto igparcinfoitem_get_isindexed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_IsIndexed = ((b_IsIndexed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igparcinfoitem_get_isindexed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_IsIndexed);
    goto igparcinfoitem_get_isindexed_method_cleanup;

    igparcinfoitem_get_isindexed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsIndexed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_IsIndexed");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_IsIndexed(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_IsIndexed = VARIANT_FALSE;
    PyObject* pyvar_IsIndexed = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_IsIndexed))
      goto igparcinfoitem_put_isindexed_method_cleanup;

    // Set up initial variable values as needed
    b_IsIndexed = ((PyObject_IsTrue(pyvar_IsIndexed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igparcinfoitem_put_isindexed_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_IsIndexed(b_IsIndexed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_IsIndexed() returned %ld", (long)hr);
        goto igparcinfoitem_put_isindexed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for IsIndexed

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_isindexed_method_cleanup;

    igparcinfoitem_put_isindexed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for IsIndexed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_IsIndexed");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_get_IsPseudo(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_isPsuedo = VARIANT_FALSE;
    PyObject* pyvar_isPsuedo = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for isPsuedo

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->get_IsPseudo(&b_isPsuedo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.get_IsPseudo() returned %ld", (long)hr);
        goto igparcinfoitem_get_ispseudo_method_cleanup;
    }

    // Set up return values as needed
    pyvar_isPsuedo = ((b_isPsuedo == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igparcinfoitem_get_ispseudo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isPsuedo);
    goto igparcinfoitem_get_ispseudo_method_cleanup;

    igparcinfoitem_get_ispseudo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for isPsuedo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.get_IsPseudo");
    return return_tuple;
}

static PyObject*
IGPArcInfoItemMethod_put_IsPseudo(PyIGPArcInfoItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_isPsuedo = VARIANT_FALSE;
    PyObject* pyvar_isPsuedo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_isPsuedo))
      goto igparcinfoitem_put_ispseudo_method_cleanup;

    // Set up initial variable values as needed
    b_isPsuedo = ((PyObject_IsTrue(pyvar_isPsuedo) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igparcinfoitem_put_ispseudo_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPArcInfoItem->put_IsPseudo(b_isPsuedo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPArcInfoItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPArcInfoItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPArcInfoItem.put_IsPseudo() returned %ld", (long)hr);
        goto igparcinfoitem_put_ispseudo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for isPsuedo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igparcinfoitem_put_ispseudo_method_cleanup;

    igparcinfoitem_put_ispseudo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for isPsuedo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPArcInfoItem.put_IsPseudo");
    return return_tuple;
}


PyMethodDef PyIGPArcInfoItemMethods[] = {
    {"supports", (PyCFunction)PyIGPArcInfoItem_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IGPArcInfoItemMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IGPArcInfoItemMethod_put_Name, METH_VARARGS, ""},
    {"get_StartPosition", (PyCFunction)IGPArcInfoItemMethod_get_StartPosition, METH_VARARGS, ""},
    {"put_StartPosition", (PyCFunction)IGPArcInfoItemMethod_put_StartPosition, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IGPArcInfoItemMethod_get_Width, METH_VARARGS, ""},
    {"put_Width", (PyCFunction)IGPArcInfoItemMethod_put_Width, METH_VARARGS, ""},
    {"get_OutputWidth", (PyCFunction)IGPArcInfoItemMethod_get_OutputWidth, METH_VARARGS, ""},
    {"put_OutputWidth", (PyCFunction)IGPArcInfoItemMethod_put_OutputWidth, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IGPArcInfoItemMethod_get_Type, METH_VARARGS, ""},
    {"put_Type", (PyCFunction)IGPArcInfoItemMethod_put_Type, METH_VARARGS, ""},
    {"get_NumberDecimals", (PyCFunction)IGPArcInfoItemMethod_get_NumberDecimals, METH_VARARGS, ""},
    {"put_NumberDecimals", (PyCFunction)IGPArcInfoItemMethod_put_NumberDecimals, METH_VARARGS, ""},
    {"get_AlternateName", (PyCFunction)IGPArcInfoItemMethod_get_AlternateName, METH_VARARGS, ""},
    {"put_AlternateName", (PyCFunction)IGPArcInfoItemMethod_put_AlternateName, METH_VARARGS, ""},
    {"get_IsRedefined", (PyCFunction)IGPArcInfoItemMethod_get_IsRedefined, METH_VARARGS, ""},
    {"put_IsRedefined", (PyCFunction)IGPArcInfoItemMethod_put_IsRedefined, METH_VARARGS, ""},
    {"get_IsIndexed", (PyCFunction)IGPArcInfoItemMethod_get_IsIndexed, METH_VARARGS, ""},
    {"put_IsIndexed", (PyCFunction)IGPArcInfoItemMethod_put_IsIndexed, METH_VARARGS, ""},
    {"get_IsPseudo", (PyCFunction)IGPArcInfoItemMethod_get_IsPseudo, METH_VARARGS, ""},
    {"put_IsPseudo", (PyCFunction)IGPArcInfoItemMethod_put_IsPseudo, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGPArcInfoItemGetSet[] = {
  {"_pUnk", (getter)PyIGPArcInfoItem_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGPArcInfoItem", NULL},
  {"_pointer", (getter)PyIGPArcInfoItem_GetPointer, NULL, "Get memory address for IGPArcInfoItem", NULL},
  {"_IID", (getter)PyIGPArcInfoItem_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGPArcInfoItem_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGPArcInfoItem_GetIgnoreFailures, (setter)PyIGPArcInfoItem_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGPArcInfoItemObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IGPArcInfoItemObject",                          
                                              /* tp_name */
  sizeof(PyIGPArcInfoItemObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGPArcInfoItemObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGPArcInfoItemMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGPArcInfoItemGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGPArcInfoItemObject_new,                      
                                              /* tp_new */
};

// Interface IDEArcInfoUtilities

typedef struct PyIDEArcInfoUtilitiesObject {
    PyObject_HEAD
    IDEArcInfoUtilities* m_pIDEArcInfoUtilities;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDEArcInfoUtilitiesObject;

static PyObject*
PyIDEArcInfoUtilitiesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDEArcInfoUtilitiesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDEArcInfoUtilities* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDEArcInfoUtilities, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDEArcInfoUtilities with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDEArcInfoUtilitiesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDEArcInfoUtilities");
            return NULL;
        }
        self->m_pIDEArcInfoUtilities = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDEArcInfoUtilities");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDEArcInfoUtilities");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDEArcInfoUtilities* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDEArcInfoUtilities, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDEArcInfoUtilities");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDEArcInfoUtilitiesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDEArcInfoUtilities");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDEArcInfoUtilities = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDEArcInfoUtilitiesObject_dealloc(PyIDEArcInfoUtilitiesObject* self)
{
    if (self->m_pIDEArcInfoUtilities)
        self->m_pIDEArcInfoUtilities->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDEArcInfoUtilities_GetpUnk(PyIDEArcInfoUtilitiesObject* self)
{
    if (!self->m_pIDEArcInfoUtilities)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDEArcInfoUtilities->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDEArcInfoUtilities to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDEArcInfoUtilities_GetPointer(PyIDEArcInfoUtilitiesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDEArcInfoUtilities);
}

static PyObject*
PyIDEArcInfoUtilities_GetIID(PyIDEArcInfoUtilitiesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1c1d3491-9e02-4283-be2f-b8177cc8f01f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDEArcInfoUtilities_GetHR(PyIDEArcInfoUtilitiesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDEArcInfoUtilities_GetIgnoreFailures(PyIDEArcInfoUtilitiesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDEArcInfoUtilities_SetIgnoreFailures(PyIDEArcInfoUtilitiesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDEArcInfoUtilities_SupportsInterface(PyIDEArcInfoUtilitiesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDEArcInfoUtilitiesMethod_AssignCoverageProperties(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICoverage* ippCoverage = NULL;
    PyObject* py_pCoverage;
    IDataElement* ippDataElement = NULL;
    PyObject* py_pDataElement;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pCoverage, &py_pDataElement))
      goto idearcinfoutilities_assigncoverageproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCoverage, &IID_ICoverage, (void**)&ippCoverage))
        PyErr_SetString(PyExc_TypeError, "Argument pCoverage (position 0) is not ICoverage");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_assigncoverageproperties_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDataElement, &IID_IDataElement, (void**)&ippDataElement))
        PyErr_SetString(PyExc_TypeError, "Argument pDataElement (position 1) is not IDataElement");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_assigncoverageproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->AssignCoverageProperties(ippCoverage, ippDataElement);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.AssignCoverageProperties() returned %ld", (long)hr);
        goto idearcinfoutilities_assigncoverageproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCoverage
    // No teardown for pDataElement

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idearcinfoutilities_assigncoverageproperties_method_cleanup;

    idearcinfoutilities_assigncoverageproperties_method_cleanup:
    self->m_HR = hr;
    if (ippCoverage)
      ippCoverage->Release();
    if (ippDataElement)
      ippDataElement->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.AssignCoverageProperties");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_AssignArcInfoTableProperties(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArcInfoTable* ippArcInfoTable = NULL;
    PyObject* py_pArcInfoTable;
    IDataElement* ippDataElement = NULL;
    PyObject* py_pDataElement;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pArcInfoTable, &py_pDataElement))
      goto idearcinfoutilities_assignarcinfotableproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pArcInfoTable, &IID_IArcInfoTable, (void**)&ippArcInfoTable))
        PyErr_SetString(PyExc_TypeError, "Argument pArcInfoTable (position 0) is not IArcInfoTable");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_assignarcinfotableproperties_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDataElement, &IID_IDataElement, (void**)&ippDataElement))
        PyErr_SetString(PyExc_TypeError, "Argument pDataElement (position 1) is not IDataElement");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_assignarcinfotableproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->AssignArcInfoTableProperties(ippArcInfoTable, ippDataElement);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.AssignArcInfoTableProperties() returned %ld", (long)hr);
        goto idearcinfoutilities_assignarcinfotableproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pArcInfoTable
    // No teardown for pDataElement

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idearcinfoutilities_assignarcinfotableproperties_method_cleanup;

    idearcinfoutilities_assignarcinfotableproperties_method_cleanup:
    self->m_HR = hr;
    if (ippArcInfoTable)
      ippArcInfoTable->Release();
    if (ippDataElement)
      ippDataElement->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.AssignArcInfoTableProperties");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_AssignCoverageFeatureClassProperties(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICoverageFeatureClass* ippCoverageFeatureClass = NULL;
    PyObject* py_pCoverageFeatureClass;
    IDataElement* ippDataElement = NULL;
    PyObject* py_pDataElement;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pCoverageFeatureClass, &py_pDataElement))
      goto idearcinfoutilities_assigncoveragefeatureclassproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCoverageFeatureClass, &IID_ICoverageFeatureClass, (void**)&ippCoverageFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pCoverageFeatureClass (position 0) is not ICoverageFeatureClass");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_assigncoveragefeatureclassproperties_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDataElement, &IID_IDataElement, (void**)&ippDataElement))
        PyErr_SetString(PyExc_TypeError, "Argument pDataElement (position 1) is not IDataElement");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_assigncoveragefeatureclassproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->AssignCoverageFeatureClassProperties(ippCoverageFeatureClass, ippDataElement);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.AssignCoverageFeatureClassProperties() returned %ld", (long)hr);
        goto idearcinfoutilities_assigncoveragefeatureclassproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCoverageFeatureClass
    // No teardown for pDataElement

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idearcinfoutilities_assigncoveragefeatureclassproperties_method_cleanup;

    idearcinfoutilities_assigncoveragefeatureclassproperties_method_cleanup:
    self->m_HR = hr;
    if (ippCoverageFeatureClass)
      ippCoverageFeatureClass->Release();
    if (ippDataElement)
      ippDataElement->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.AssignCoverageFeatureClassProperties");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_AssignCoverageFeatureClassNameProperties(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICoverageFeatureClassName* ippCoverageFeatureClassName = NULL;
    PyObject* py_pCoverageFeatureClassName;
    IDataElement* ippDataElement = NULL;
    PyObject* py_pDataElement;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pCoverageFeatureClassName, &py_pDataElement))
      goto idearcinfoutilities_assigncoveragefeatureclassnameproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCoverageFeatureClassName, &IID_ICoverageFeatureClassName, (void**)&ippCoverageFeatureClassName))
        PyErr_SetString(PyExc_TypeError, "Argument pCoverageFeatureClassName (position 0) is not ICoverageFeatureClassName");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_assigncoveragefeatureclassnameproperties_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDataElement, &IID_IDataElement, (void**)&ippDataElement))
        PyErr_SetString(PyExc_TypeError, "Argument pDataElement (position 1) is not IDataElement");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_assigncoveragefeatureclassnameproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->AssignCoverageFeatureClassNameProperties(ippCoverageFeatureClassName, ippDataElement);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.AssignCoverageFeatureClassNameProperties() returned %ld", (long)hr);
        goto idearcinfoutilities_assigncoveragefeatureclassnameproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCoverageFeatureClassName
    // No teardown for pDataElement

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idearcinfoutilities_assigncoveragefeatureclassnameproperties_method_cleanup;

    idearcinfoutilities_assigncoveragefeatureclassnameproperties_method_cleanup:
    self->m_HR = hr;
    if (ippCoverageFeatureClassName)
      ippCoverageFeatureClassName->Release();
    if (ippDataElement)
      ippDataElement->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.AssignCoverageFeatureClassNameProperties");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_MakeDETolerances(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICoverage* ippCoverage = NULL;
    PyObject* py_pCoverage;
    IPropertySet* ipppTolerances = NULL;
    PyObject* py_ppTolerances = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pCoverage))
      goto idearcinfoutilities_makedetolerances_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCoverage, &IID_ICoverage, (void**)&ippCoverage))
        PyErr_SetString(PyExc_TypeError, "Argument pCoverage (position 0) is not ICoverage");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_makedetolerances_method_cleanup;
    
    // No setup for ppTolerances

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->MakeDETolerances(ippCoverage, &ipppTolerances);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.MakeDETolerances() returned %ld", (long)hr);
        goto idearcinfoutilities_makedetolerances_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCoverage
    Py_XDECREF(py_ppTolerances);
    if (ipppTolerances)
    {
        IUnknown* pUnk = NULL;
        ipppTolerances->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTolerances = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTolerances)
    {
        if (py_ppTolerances)
           Py_DECREF(py_ppTolerances);
        py_ppTolerances = Py_None;
        Py_INCREF(py_ppTolerances);
    }
    if (PyErr_Occurred())
      goto idearcinfoutilities_makedetolerances_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTolerances);
    goto idearcinfoutilities_makedetolerances_method_cleanup;

    idearcinfoutilities_makedetolerances_method_cleanup:
    self->m_HR = hr;
    if (ippCoverage)
      ippCoverage->Release();
    Py_XDECREF(py_ppTolerances);
    if (ipppTolerances)
      ipppTolerances->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.MakeDETolerances");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_MakeGPItems(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArcInfoItems* ippItems = NULL;
    PyObject* py_pItems;
    IArray* ipppGPItems = NULL;
    PyObject* py_ppGPItems = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pItems))
      goto idearcinfoutilities_makegpitems_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pItems, &IID_IArcInfoItems, (void**)&ippItems))
        PyErr_SetString(PyExc_TypeError, "Argument pItems (position 0) is not IArcInfoItems");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_makegpitems_method_cleanup;
    
    // No setup for ppGPItems

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->MakeGPItems(ippItems, &ipppGPItems);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.MakeGPItems() returned %ld", (long)hr);
        goto idearcinfoutilities_makegpitems_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pItems
    Py_XDECREF(py_ppGPItems);
    if (ipppGPItems)
    {
        IUnknown* pUnk = NULL;
        ipppGPItems->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppGPItems = IUnknownToPythonIIDObject(pUnk, &IID_IArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppGPItems)
    {
        if (py_ppGPItems)
           Py_DECREF(py_ppGPItems);
        py_ppGPItems = Py_None;
        Py_INCREF(py_ppGPItems);
    }
    if (PyErr_Occurred())
      goto idearcinfoutilities_makegpitems_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppGPItems);
    goto idearcinfoutilities_makegpitems_method_cleanup;

    idearcinfoutilities_makegpitems_method_cleanup:
    self->m_HR = hr;
    if (ippItems)
      ippItems->Release();
    Py_XDECREF(py_ppGPItems);
    if (ipppGPItems)
      ipppGPItems->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.MakeGPItems");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_MakeGPItem(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArcInfoItem* ippItem = NULL;
    PyObject* py_pItem;
    IGPArcInfoItem* ipppGPItem = NULL;
    PyObject* py_ppGPItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pItem))
      goto idearcinfoutilities_makegpitem_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pItem, &IID_IArcInfoItem, (void**)&ippItem))
        PyErr_SetString(PyExc_TypeError, "Argument pItem (position 0) is not IArcInfoItem");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_makegpitem_method_cleanup;
    
    // No setup for ppGPItem

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->MakeGPItem(ippItem, &ipppGPItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.MakeGPItem() returned %ld", (long)hr);
        goto idearcinfoutilities_makegpitem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pItem
    Py_XDECREF(py_ppGPItem);
    if (ipppGPItem)
    {
        IUnknown* pUnk = NULL;
        ipppGPItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppGPItem = IUnknownToPythonIIDObject(pUnk, &IID_IGPArcInfoItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppGPItem)
    {
        if (py_ppGPItem)
           Py_DECREF(py_ppGPItem);
        py_ppGPItem = Py_None;
        Py_INCREF(py_ppGPItem);
    }
    if (PyErr_Occurred())
      goto idearcinfoutilities_makegpitem_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppGPItem);
    goto idearcinfoutilities_makegpitem_method_cleanup;

    idearcinfoutilities_makegpitem_method_cleanup:
    self->m_HR = hr;
    if (ippItem)
      ippItem->Release();
    Py_XDECREF(py_ppGPItem);
    if (ipppGPItem)
      ipppGPItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.MakeGPItem");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_GetCoverageFeatureClassTypeFromString(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdesc = 0;
    PyObject* pyvar_desc;
    PyObject* unicodedesc = NULL;
    esriCoverageFeatureClassType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_desc))
      goto idearcinfoutilities_getcoveragefeatureclasstypefromstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_desc))
        unicodedesc = PyUnicode_FromObject(pyvar_desc);
    else if (PyUnicode_Check(pyvar_desc))
    {
        unicodedesc = pyvar_desc;
        Py_INCREF(unicodedesc);
    }
    else if (pyvar_desc != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter desc at index 0");
    if (unicodedesc)
        bsdesc = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedesc), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedesc));
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_getcoveragefeatureclasstypefromstring_method_cleanup;
    
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->GetCoverageFeatureClassTypeFromString(bsdesc, &eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.GetCoverageFeatureClassTypeFromString() returned %ld", (long)hr);
        goto idearcinfoutilities_getcoveragefeatureclasstypefromstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for desc
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto idearcinfoutilities_getcoveragefeatureclasstypefromstring_method_cleanup;

    idearcinfoutilities_getcoveragefeatureclasstypefromstring_method_cleanup:
    self->m_HR = hr;
    if (bsdesc)
        ::SysFreeString(bsdesc);
    
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.GetCoverageFeatureClassTypeFromString");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_GetCoverageFeatureClassTypeDescription(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCoverageFeatureClassType eType;
    BSTR bsdesc;
    PyObject* pyvar_desc = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto idearcinfoutilities_getcoveragefeatureclasstypedescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type
    // No setup for desc

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->GetCoverageFeatureClassTypeDescription(eType, &bsdesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.GetCoverageFeatureClassTypeDescription() returned %ld", (long)hr);
        goto idearcinfoutilities_getcoveragefeatureclasstypedescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type
    pyvar_desc = PyUnicode_FromWideChar(bsdesc,::SysStringLen(bsdesc));
    ::SysFreeString(bsdesc);
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_getcoveragefeatureclasstypedescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_desc);
    goto idearcinfoutilities_getcoveragefeatureclasstypedescription_method_cleanup;

    idearcinfoutilities_getcoveragefeatureclasstypedescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (pyvar_desc != Py_None)
        Py_XDECREF(pyvar_desc);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.GetCoverageFeatureClassTypeDescription");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_GetFeatureClassTopologyFromString(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdesc = 0;
    PyObject* pyvar_desc;
    PyObject* unicodedesc = NULL;
    esriFeatureClassTopology eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_desc))
      goto idearcinfoutilities_getfeatureclasstopologyfromstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_desc))
        unicodedesc = PyUnicode_FromObject(pyvar_desc);
    else if (PyUnicode_Check(pyvar_desc))
    {
        unicodedesc = pyvar_desc;
        Py_INCREF(unicodedesc);
    }
    else if (pyvar_desc != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter desc at index 0");
    if (unicodedesc)
        bsdesc = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedesc), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedesc));
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_getfeatureclasstopologyfromstring_method_cleanup;
    
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->GetFeatureClassTopologyFromString(bsdesc, &eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.GetFeatureClassTopologyFromString() returned %ld", (long)hr);
        goto idearcinfoutilities_getfeatureclasstopologyfromstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for desc
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto idearcinfoutilities_getfeatureclasstopologyfromstring_method_cleanup;

    idearcinfoutilities_getfeatureclasstopologyfromstring_method_cleanup:
    self->m_HR = hr;
    if (bsdesc)
        ::SysFreeString(bsdesc);
    
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.GetFeatureClassTopologyFromString");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_GetFeatureClassTopologyDescription(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureClassTopology eType;
    BSTR bsdesc;
    PyObject* pyvar_desc = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto idearcinfoutilities_getfeatureclasstopologydescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type
    // No setup for desc

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->GetFeatureClassTopologyDescription(eType, &bsdesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.GetFeatureClassTopologyDescription() returned %ld", (long)hr);
        goto idearcinfoutilities_getfeatureclasstopologydescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type
    pyvar_desc = PyUnicode_FromWideChar(bsdesc,::SysStringLen(bsdesc));
    ::SysFreeString(bsdesc);
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_getfeatureclasstopologydescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_desc);
    goto idearcinfoutilities_getfeatureclasstopologydescription_method_cleanup;

    idearcinfoutilities_getfeatureclasstopologydescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (pyvar_desc != Py_None)
        Py_XDECREF(pyvar_desc);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.GetFeatureClassTopologyDescription");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_GetItemTypeFromString(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdesc = 0;
    PyObject* pyvar_desc;
    PyObject* unicodedesc = NULL;
    esriArcInfoItemType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_desc))
      goto idearcinfoutilities_getitemtypefromstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_desc))
        unicodedesc = PyUnicode_FromObject(pyvar_desc);
    else if (PyUnicode_Check(pyvar_desc))
    {
        unicodedesc = pyvar_desc;
        Py_INCREF(unicodedesc);
    }
    else if (pyvar_desc != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter desc at index 0");
    if (unicodedesc)
        bsdesc = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedesc), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedesc));
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_getitemtypefromstring_method_cleanup;
    
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->GetItemTypeFromString(bsdesc, &eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.GetItemTypeFromString() returned %ld", (long)hr);
        goto idearcinfoutilities_getitemtypefromstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for desc
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto idearcinfoutilities_getitemtypefromstring_method_cleanup;

    idearcinfoutilities_getitemtypefromstring_method_cleanup:
    self->m_HR = hr;
    if (bsdesc)
        ::SysFreeString(bsdesc);
    
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.GetItemTypeFromString");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_GetItemTypeDescription(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriArcInfoItemType eType;
    BSTR bsdesc;
    PyObject* pyvar_desc = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto idearcinfoutilities_getitemtypedescription_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type
    // No setup for desc

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->GetItemTypeDescription(eType, &bsdesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.GetItemTypeDescription() returned %ld", (long)hr);
        goto idearcinfoutilities_getitemtypedescription_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type
    pyvar_desc = PyUnicode_FromWideChar(bsdesc,::SysStringLen(bsdesc));
    ::SysFreeString(bsdesc);
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_getitemtypedescription_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_desc);
    goto idearcinfoutilities_getitemtypedescription_method_cleanup;

    idearcinfoutilities_getitemtypedescription_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (pyvar_desc != Py_None)
        Py_XDECREF(pyvar_desc);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.GetItemTypeDescription");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_ItemExists(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDEArcInfoTable* ippDEArcInfoTable = NULL;
    PyObject* py_pDEArcInfoTable;
    IGPArcInfoItem* ippGPItem = NULL;
    PyObject* py_pGPItem;
    VARIANT_BOOL b_pExists = VARIANT_FALSE;
    PyObject* pyvar_pExists = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pDEArcInfoTable, &py_pGPItem))
      goto idearcinfoutilities_itemexists_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pDEArcInfoTable, &IID_IDEArcInfoTable, (void**)&ippDEArcInfoTable))
        PyErr_SetString(PyExc_TypeError, "Argument pDEArcInfoTable (position 0) is not IDEArcInfoTable");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_itemexists_method_cleanup;
    
    if (!IFaceFromPyObject(py_pGPItem, &IID_IGPArcInfoItem, (void**)&ippGPItem))
        PyErr_SetString(PyExc_TypeError, "Argument pGPItem (position 1) is not IGPArcInfoItem");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_itemexists_method_cleanup;
    
    // No setup for pExists

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->ItemExists(ippDEArcInfoTable, ippGPItem, &b_pExists);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.ItemExists() returned %ld", (long)hr);
        goto idearcinfoutilities_itemexists_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDEArcInfoTable
    // No teardown for pGPItem
    pyvar_pExists = ((b_pExists == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idearcinfoutilities_itemexists_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pExists);
    goto idearcinfoutilities_itemexists_method_cleanup;

    idearcinfoutilities_itemexists_method_cleanup:
    self->m_HR = hr;
    if (ippDEArcInfoTable)
      ippDEArcInfoTable->Release();
    if (ippGPItem)
      ippGPItem->Release();
    // No cleanup for pExists
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.ItemExists");
    return return_tuple;
}

static PyObject*
IDEArcInfoUtilitiesMethod_FindItem(PyIDEArcInfoUtilitiesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDEArcInfoTable* ippDEArcInfoTable = NULL;
    PyObject* py_pDEArcInfoTable;
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    IGPArcInfoItem* ipppGPItem = NULL;
    PyObject* py_ppGPItem = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pDEArcInfoTable, &pyvar_Name))
      goto idearcinfoutilities_finditem_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pDEArcInfoTable, &IID_IDEArcInfoTable, (void**)&ippDEArcInfoTable))
        PyErr_SetString(PyExc_TypeError, "Argument pDEArcInfoTable (position 0) is not IDEArcInfoTable");
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_finditem_method_cleanup;
    
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 1");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto idearcinfoutilities_finditem_method_cleanup;
    
    // No setup for ppGPItem

    // Call method on actual COM interface
    hr = self->m_pIDEArcInfoUtilities->FindItem(ippDEArcInfoTable, bsName, &ipppGPItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDEArcInfoUtilities->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDEArcInfoUtilities) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDEArcInfoUtilities.FindItem() returned %ld", (long)hr);
        goto idearcinfoutilities_finditem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDEArcInfoTable
    // No teardown for Name
    Py_XDECREF(py_ppGPItem);
    if (ipppGPItem)
    {
        IUnknown* pUnk = NULL;
        ipppGPItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppGPItem = IUnknownToPythonIIDObject(pUnk, &IID_IGPArcInfoItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppGPItem)
    {
        if (py_ppGPItem)
           Py_DECREF(py_ppGPItem);
        py_ppGPItem = Py_None;
        Py_INCREF(py_ppGPItem);
    }
    if (PyErr_Occurred())
      goto idearcinfoutilities_finditem_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppGPItem);
    goto idearcinfoutilities_finditem_method_cleanup;

    idearcinfoutilities_finditem_method_cleanup:
    self->m_HR = hr;
    if (ippDEArcInfoTable)
      ippDEArcInfoTable->Release();
    if (bsName)
        ::SysFreeString(bsName);
    
    Py_XDECREF(py_ppGPItem);
    if (ipppGPItem)
      ipppGPItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDEArcInfoUtilities.FindItem");
    return return_tuple;
}


PyMethodDef PyIDEArcInfoUtilitiesMethods[] = {
    {"supports", (PyCFunction)PyIDEArcInfoUtilities_SupportsInterface, METH_O, ""},
    {"AssignCoverageProperties", (PyCFunction)IDEArcInfoUtilitiesMethod_AssignCoverageProperties, METH_VARARGS, ""},
    {"AssignArcInfoTableProperties", (PyCFunction)IDEArcInfoUtilitiesMethod_AssignArcInfoTableProperties, METH_VARARGS, ""},
    {"AssignCoverageFeatureClassProperties", (PyCFunction)IDEArcInfoUtilitiesMethod_AssignCoverageFeatureClassProperties, METH_VARARGS, ""},
    {"AssignCoverageFeatureClassNameProperties", (PyCFunction)IDEArcInfoUtilitiesMethod_AssignCoverageFeatureClassNameProperties, METH_VARARGS, ""},
    {"MakeDETolerances", (PyCFunction)IDEArcInfoUtilitiesMethod_MakeDETolerances, METH_VARARGS, ""},
    {"MakeGPItems", (PyCFunction)IDEArcInfoUtilitiesMethod_MakeGPItems, METH_VARARGS, ""},
    {"MakeGPItem", (PyCFunction)IDEArcInfoUtilitiesMethod_MakeGPItem, METH_VARARGS, ""},
    {"GetCoverageFeatureClassTypeFromString", (PyCFunction)IDEArcInfoUtilitiesMethod_GetCoverageFeatureClassTypeFromString, METH_VARARGS, ""},
    {"GetCoverageFeatureClassTypeDescription", (PyCFunction)IDEArcInfoUtilitiesMethod_GetCoverageFeatureClassTypeDescription, METH_VARARGS, ""},
    {"GetFeatureClassTopologyFromString", (PyCFunction)IDEArcInfoUtilitiesMethod_GetFeatureClassTopologyFromString, METH_VARARGS, ""},
    {"GetFeatureClassTopologyDescription", (PyCFunction)IDEArcInfoUtilitiesMethod_GetFeatureClassTopologyDescription, METH_VARARGS, ""},
    {"GetItemTypeFromString", (PyCFunction)IDEArcInfoUtilitiesMethod_GetItemTypeFromString, METH_VARARGS, ""},
    {"GetItemTypeDescription", (PyCFunction)IDEArcInfoUtilitiesMethod_GetItemTypeDescription, METH_VARARGS, ""},
    {"ItemExists", (PyCFunction)IDEArcInfoUtilitiesMethod_ItemExists, METH_VARARGS, ""},
    {"FindItem", (PyCFunction)IDEArcInfoUtilitiesMethod_FindItem, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDEArcInfoUtilitiesGetSet[] = {
  {"_pUnk", (getter)PyIDEArcInfoUtilities_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDEArcInfoUtilities", NULL},
  {"_pointer", (getter)PyIDEArcInfoUtilities_GetPointer, NULL, "Get memory address for IDEArcInfoUtilities", NULL},
  {"_IID", (getter)PyIDEArcInfoUtilities_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDEArcInfoUtilities_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDEArcInfoUtilities_GetIgnoreFailures, (setter)PyIDEArcInfoUtilities_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDEArcInfoUtilitiesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriDataSourcesFile.IDEArcInfoUtilitiesObject",                          
                                              /* tp_name */
  sizeof(PyIDEArcInfoUtilitiesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDEArcInfoUtilitiesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDEArcInfoUtilitiesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDEArcInfoUtilitiesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDEArcInfoUtilitiesObject_new,                      
                                              /* tp_new */
};





static PyObject*
CoCreateArcInfoWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ArcInfoWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ArcInfoWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("1d887452-d9f2-11d1-aa81-00c04fa33a15")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "1d887452-d9f2-11d1-aa81-00c04fa33a15");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateArcInfoItems(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ArcInfoItems, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ArcInfoItems");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5bb90fa2-d013-11d2-b0dc-0000f8780820")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5bb90fa2-d013-11d2-b0dc-0000f8780820");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateArcInfoItem(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ArcInfoItem, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ArcInfoItem");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5bb90fa1-d013-11d2-b0dc-0000f8780820")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5bb90fa1-d013-11d2-b0dc-0000f8780820");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCoverageFeatureClassName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CoverageFeatureClassName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CoverageFeatureClassName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("72f77de8-122a-11d3-9f31-00c04f79927c")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "72f77de8-122a-11d3-9f31-00c04f79927c");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCoverageName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CoverageName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CoverageName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("1e921c72-122f-11d3-9f31-00c04f79927c")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "1e921c72-122f-11d3-9f31-00c04f79927c");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePCCoverageWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_PCCoverageWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of PCCoverageWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("6de812d2-9ab6-11d2-b0d7-0000f8780820")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "6de812d2-9ab6-11d2-b0d7-0000f8780820");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateStreetMapWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_StreetMapWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of StreetMapWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ae2469e8-e110-4cd6-b3f4-a756cbf921ca")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ae2469e8-e110-4cd6-b3f4-a756cbf921ca");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSDCWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SDCWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SDCWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("34dae34f-dbe2-409c-8f85-ddbb46138011")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "34dae34f-dbe2-409c-8f85-ddbb46138011");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSDCNetworkSource(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SDCNetworkSource, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SDCNetworkSource");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5be00c09-a03f-4a69-b678-985108a500d3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5be00c09-a03f-4a69-b678-985108a500d3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSDCNetworkAttribute(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SDCNetworkAttribute, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SDCNetworkAttribute");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a2ab1fba-aa5f-485e-97fe-79d0f5ff9984")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a2ab1fba-aa5f-485e-97fe-79d0f5ff9984");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateShapefileWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ShapefileWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ShapefileWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a06adb96-d95c-11d1-aa81-00c04fa33a15")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a06adb96-d95c-11d1-aa81-00c04fa33a15");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateVpfWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_VpfWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of VpfWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("397847f9-c865-11d3-9b56-00c04fa33299")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "397847f9-c865-11d3-9b56-00c04fa33299");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTinWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TinWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TinWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ad4e89d9-00a5-11d2-b1ca-00c04f8edeff")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ad4e89d9-00a5-11d2-b1ca-00c04f8edeff");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGeoRSSWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GeoRSSWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GeoRSSWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("894af6a1-157a-47ba-bdec-3cf98d4cce74")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "894af6a1-157a-47ba-bdec-3cf98d4cce74");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9e2c27ce-62c6-11d2-9aed-00c04fa33299")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9e2c27ce-62c6-11d2-9aed-00c04fa33299");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadDrawingName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadDrawingName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadDrawingName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("d4224309-a5cb-11d2-9b10-00c04fa33299")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "d4224309-a5cb-11d2-9b10-00c04fa33299");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSdcExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SdcExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SdcExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("3c8b1a03-64b8-4e29-86ad-d4c4cb371ec1")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "3c8b1a03-64b8-4e29-86ad-d4c4cb371ec1");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMRouterPoint(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMRouterPoint, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMRouterPoint");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b65fee-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b65fee-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMRouterEnvelope(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMRouterEnvelope, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMRouterEnvelope");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b65ff1-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b65ff1-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMPointsCollection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMPointsCollection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMPointsCollection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b65ff4-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b65ff4-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMNetAttribute(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMNetAttribute, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMNetAttribute");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b65ff7-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b65ff7-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMNetAttributesCollection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMNetAttributesCollection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMNetAttributesCollection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b65ffa-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b65ffa-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMNetBarrier(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMNetBarrier, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMNetBarrier");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b65ffd-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b65ffd-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMNetBarriersCollection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMNetBarriersCollection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMNetBarriersCollection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66000-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66000-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMRoadPreferences(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMRoadPreferences, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMRoadPreferences");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66003-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66003-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMSpeedGroup(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMSpeedGroup, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMSpeedGroup");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66006-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66006-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMSpeedGroups(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMSpeedGroups, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMSpeedGroups");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66009-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66009-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMTripPlanSettings(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMTripPlanSettings, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMTripPlanSettings");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b6600c-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b6600c-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMFlag(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMFlag, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMFlag");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66012-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66012-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMStop(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMStop, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMStop");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66015-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66015-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMStopsCollection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMStopsCollection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMStopsCollection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66018-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66018-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMDirItem(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMDirItem, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMDirItem");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b6601b-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b6601b-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMDirections(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMDirections, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMDirections");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b6601e-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b6601e-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMRouter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMRouter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMRouter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66021-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66021-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMRouterFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMRouterFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMRouterFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8b66024-5850-11d7-b321-008048db11de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8b66024-5850-11d7-b321-008048db11de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMNetAttributesAccess(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMNetAttributesAccess, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMNetAttributesAccess");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2041d5a1-c9b6-4c74-8954-033af25557b8")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2041d5a1-c9b6-4c74-8954-033af25557b8");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMFlagCreator(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMFlagCreator, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMFlagCreator");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("38a979e8-086f-4ca8-ac30-890f22e65ebc")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "38a979e8-086f-4ca8-ac30-890f22e65ebc");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSMRestriction(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SMRestriction, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SMRestriction");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("71a8e2b4-5a6c-4bdd-b005-a0fb02414197")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "71a8e2b4-5a6c-4bdd-b005-a0fb02414197");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLicensedDataExtension(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LicensedDataExtension, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LicensedDataExtension");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("39bc41a4-b140-4f7b-b1c9-accd507ee339")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "39bc41a4-b140-4f7b-b1c9-accd507ee339");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECadDrawingDatasetType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECadDrawingDatasetType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECadDrawingDatasetType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("43a72293-aac8-4f0c-b8f8-8b2cdb298f85")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "43a72293-aac8-4f0c-b8f8-8b2cdb298f85");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECadDrawingDataset(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECadDrawingDataset, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECadDrawingDataset");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f786332d-20b2-4607-bf34-0a53e4d0b413")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f786332d-20b2-4607-bf34-0a53e4d0b413");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDELayerType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DELayerType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DELayerType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("775700af-8577-442d-adc9-74d7a9aa3c41")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "775700af-8577-442d-adc9-74d7a9aa3c41");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEShapeFileType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEShapeFileType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEShapeFileType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("44a51f3f-ef06-4fd9-bc52-010e6ca0e84b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "44a51f3f-ef06-4fd9-bc52-010e6ca0e84b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEDbaseTableType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEDbaseTableType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEDbaseTableType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("11e37cd0-a664-11d5-931d-0080c71a3226")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "11e37cd0-a664-11d5-931d-0080c71a3226");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDELayer(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DELayer, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DELayer");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("bdd71708-3463-4787-a491-b9363b937dbe")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "bdd71708-3463-4787-a491-b9363b937dbe");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEShapeFile(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEShapeFile, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEShapeFile");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("03e6fb47-aa38-476c-934b-1df5765c76eb")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "03e6fb47-aa38-476c-934b-1df5765c76eb");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEDbaseTable(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEDbaseTable, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEDbaseTable");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("69e84176-fb98-4036-a8ff-e69c8e82f013")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "69e84176-fb98-4036-a8ff-e69c8e82f013");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECatalogRootType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECatalogRootType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECatalogRootType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("07359aea-34ba-4b5a-ab2c-0b43c7e8e9fb")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "07359aea-34ba-4b5a-ab2c-0b43c7e8e9fb");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEDiskConnectionType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEDiskConnectionType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEDiskConnectionType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("36afbb31-cdbe-41cb-bb11-58484c2acf45")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "36afbb31-cdbe-41cb-bb11-58484c2acf45");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEFolderType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEFolderType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEFolderType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fe29b0ed-decf-4a61-8ed0-be233bfe376b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fe29b0ed-decf-4a61-8ed0-be233bfe376b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEFileType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEFileType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEFileType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("c486aa07-9027-4d78-88fc-4a7a940bb367")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "c486aa07-9027-4d78-88fc-4a7a940bb367");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEPrjFileType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEPrjFileType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEPrjFileType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ebfebc90-cfbf-11d5-933d-0080c71a3226")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ebfebc90-cfbf-11d5-933d-0080c71a3226");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEMapDocumentType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEMapDocumentType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEMapDocumentType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ec42ceb1-8029-4f90-a18c-5790ae1fad01")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ec42ceb1-8029-4f90-a18c-5790ae1fad01");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDERemoteDatabaseFolderType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DERemoteDatabaseFolderType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DERemoteDatabaseFolderType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2919c9ef-dc76-4c52-9539-f357a4f68925")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2919c9ef-dc76-4c52-9539-f357a4f68925");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDESpatialReferencesFolderType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DESpatialReferencesFolderType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DESpatialReferencesFolderType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9fd4b414-498a-48b8-bf2f-82302524d513")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9fd4b414-498a-48b8-bf2f-82302524d513");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECatalogRoot(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECatalogRoot, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECatalogRoot");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("01d6ebdd-de9a-4217-8bfe-327265855fa2")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "01d6ebdd-de9a-4217-8bfe-327265855fa2");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEDiskConnection(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEDiskConnection, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEDiskConnection");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8e5e855a-7d60-4ce1-afd0-45929c9f492c")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8e5e855a-7d60-4ce1-afd0-45929c9f492c");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEFolder(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEFolder, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEFolder");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("273ccebc-1aa2-4429-bbd5-4cb7c6e20465")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "273ccebc-1aa2-4429-bbd5-4cb7c6e20465");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEFile(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEFile, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEFile");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("175cf2c5-12bf-413a-8fdf-3da30cc09bee")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "175cf2c5-12bf-413a-8fdf-3da30cc09bee");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEMapDocument(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEMapDocument, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEMapDocument");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("c0bed5d9-13e2-469b-a7d8-22704b0c8630")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "c0bed5d9-13e2-469b-a7d8-22704b0c8630");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDERemoteDatabaseFolder(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DERemoteDatabaseFolder, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DERemoteDatabaseFolder");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("db3e6fdf-d5f8-4c94-b743-47ab4de79a05")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "db3e6fdf-d5f8-4c94-b743-47ab4de79a05");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDESpatialReferencesFolder(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DESpatialReferencesFolder, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DESpatialReferencesFolder");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("3189f8fc-a9c8-4b8e-8c47-43c758a7a8bd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "3189f8fc-a9c8-4b8e-8c47-43c758a7a8bd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEPrjFile(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEPrjFile, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEPrjFile");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("7e704bb0-cfbe-11d5-933d-0080c71a3226")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "7e704bb0-cfbe-11d5-933d-0080c71a3226");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDETextFile(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DETextFile, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DETextFile");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("e98d0766-c13e-45ca-ba78-1def8b60cab2")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "e98d0766-c13e-45ca-ba78-1def8b60cab2");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDETextFileType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DETextFileType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DETextFileType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9a4700e6-c10c-4ecb-aae6-90d382ae22c4")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9a4700e6-c10c-4ecb-aae6-90d382ae22c4");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDETinType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DETinType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DETinType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f0b41a32-ee77-4b16-a5ee-16bce3d8f3cc")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f0b41a32-ee77-4b16-a5ee-16bce3d8f3cc");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDETin(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DETin, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DETin");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5edc32f1-c1b2-4808-88e0-2ed68e77269d")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5edc32f1-c1b2-4808-88e0-2ed68e77269d");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDELasDatasetType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DELasDatasetType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DELasDatasetType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("160bc182-ce75-4dab-8abf-8e6dc866c73b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "160bc182-ce75-4dab-8abf-8e6dc866c73b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDELasDataset(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DELasDataset, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DELasDataset");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ea006709-cd03-439d-80a1-9254e25412e3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ea006709-cd03-439d-80a1-9254e25412e3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECoverageType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECoverageType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECoverageType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("80172db6-5715-4157-b253-6150ea74203e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "80172db6-5715-4157-b253-6150ea74203e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECoverageFeatureClassType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECoverageFeatureClassType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECoverageFeatureClassType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("874e63d8-b362-457b-a3c8-aa0f3f443e0b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "874e63d8-b362-457b-a3c8-aa0f3f443e0b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEArcInfoTableType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEArcInfoTableType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEArcInfoTableType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("0e3f5cb0-2445-4abb-be9a-fcf0492e180a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "0e3f5cb0-2445-4abb-be9a-fcf0492e180a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGPArcInfoItemType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GPArcInfoItemType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GPArcInfoItemType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5356dadd-53e4-4e70-99c9-996cdd224e25")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5356dadd-53e4-4e70-99c9-996cdd224e25");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECoverage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECoverage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECoverage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("96b70c47-2c7f-405f-b9fd-deaa3cdc084c")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "96b70c47-2c7f-405f-b9fd-deaa3cdc084c");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECoverageFeatureClass(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECoverageFeatureClass, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECoverageFeatureClass");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("b7ec3865-805b-41a4-804c-8b4a30aa4128")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "b7ec3865-805b-41a4-804c-8b4a30aa4128");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEArcInfoTable(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEArcInfoTable, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEArcInfoTable");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("1cc786ec-5efe-493c-8a25-b546844665d7")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "1cc786ec-5efe-493c-8a25-b546844665d7");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGPArcInfoItem(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GPArcInfoItem, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GPArcInfoItem");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("6dddbbb2-41dc-4f12-913e-803196eb33fa")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "6dddbbb2-41dc-4f12-913e-803196eb33fa");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEArcInfoUtilities(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEArcInfoUtilities, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEArcInfoUtilities");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("95d74728-cadd-41c2-af2b-7e816364d905")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "95d74728-cadd-41c2-af2b-7e816364d905");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEVPFTableType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEVPFTableType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEVPFTableType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("3f3c713f-cc15-4ea7-a780-193e021d4251")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "3f3c713f-cc15-4ea7-a780-193e021d4251");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEVPFTable(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEVPFTable, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEVPFTable");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("48aab232-6f1f-4261-9dac-cba55d183649")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "48aab232-6f1f-4261-9dac-cba55d183649");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEVPFCoverageType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEVPFCoverageType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEVPFCoverageType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("728bbf56-85fa-4598-9ce8-77fc8ba73127")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "728bbf56-85fa-4598-9ce8-77fc8ba73127");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDEVPFCoverage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DEVPFCoverage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DEVPFCoverage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ca4ff80d-85a9-445c-adb2-a5c7811b3c36")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ca4ff80d-85a9-445c-adb2-a5c7811b3c36");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyMethodDef _esriDataSourcesFileMethods[] = {
    {"ArcInfoWorkspaceFactory", (PyCFunction)CoCreateArcInfoWorkspaceFactory, METH_NOARGS,
     "Create instance of ArcInfoWorkspaceFactory\n"},
    {"ArcInfoItems", (PyCFunction)CoCreateArcInfoItems, METH_NOARGS,
     "Create instance of ArcInfoItems\n"},
    {"ArcInfoItem", (PyCFunction)CoCreateArcInfoItem, METH_NOARGS,
     "Create instance of ArcInfoItem\n"},
    {"CoverageFeatureClassName", (PyCFunction)CoCreateCoverageFeatureClassName, METH_NOARGS,
     "Create instance of CoverageFeatureClassName\n"},
    {"CoverageName", (PyCFunction)CoCreateCoverageName, METH_NOARGS,
     "Create instance of CoverageName\n"},
    {"PCCoverageWorkspaceFactory", (PyCFunction)CoCreatePCCoverageWorkspaceFactory, METH_NOARGS,
     "Create instance of PCCoverageWorkspaceFactory\n"},
    {"StreetMapWorkspaceFactory", (PyCFunction)CoCreateStreetMapWorkspaceFactory, METH_NOARGS,
     "Create instance of StreetMapWorkspaceFactory\n"},
    {"SDCWorkspaceFactory", (PyCFunction)CoCreateSDCWorkspaceFactory, METH_NOARGS,
     "Create instance of SDCWorkspaceFactory\n"},
    {"SDCNetworkSource", (PyCFunction)CoCreateSDCNetworkSource, METH_NOARGS,
     "Create instance of SDCNetworkSource\n"},
    {"SDCNetworkAttribute", (PyCFunction)CoCreateSDCNetworkAttribute, METH_NOARGS,
     "Create instance of SDCNetworkAttribute\n"},
    {"ShapefileWorkspaceFactory", (PyCFunction)CoCreateShapefileWorkspaceFactory, METH_NOARGS,
     "Create instance of ShapefileWorkspaceFactory\n"},
    {"VpfWorkspaceFactory", (PyCFunction)CoCreateVpfWorkspaceFactory, METH_NOARGS,
     "Create instance of VpfWorkspaceFactory\n"},
    {"TinWorkspaceFactory", (PyCFunction)CoCreateTinWorkspaceFactory, METH_NOARGS,
     "Create instance of TinWorkspaceFactory\n"},
    {"GeoRSSWorkspaceFactory", (PyCFunction)CoCreateGeoRSSWorkspaceFactory, METH_NOARGS,
     "Create instance of GeoRSSWorkspaceFactory\n"},
    {"CadWorkspaceFactory", (PyCFunction)CoCreateCadWorkspaceFactory, METH_NOARGS,
     "Create instance of CadWorkspaceFactory\n"},
    {"CadDrawingName", (PyCFunction)CoCreateCadDrawingName, METH_NOARGS,
     "Create instance of CadDrawingName\n"},
    {"SdcExporter", (PyCFunction)CoCreateSdcExporter, METH_NOARGS,
     "Create instance of SdcExporter\n"},
    {"SMRouterPoint", (PyCFunction)CoCreateSMRouterPoint, METH_NOARGS,
     "Create instance of SMRouterPoint\n"},
    {"SMRouterEnvelope", (PyCFunction)CoCreateSMRouterEnvelope, METH_NOARGS,
     "Create instance of SMRouterEnvelope\n"},
    {"SMPointsCollection", (PyCFunction)CoCreateSMPointsCollection, METH_NOARGS,
     "Create instance of SMPointsCollection\n"},
    {"SMNetAttribute", (PyCFunction)CoCreateSMNetAttribute, METH_NOARGS,
     "Create instance of SMNetAttribute\n"},
    {"SMNetAttributesCollection", (PyCFunction)CoCreateSMNetAttributesCollection, METH_NOARGS,
     "Create instance of SMNetAttributesCollection\n"},
    {"SMNetBarrier", (PyCFunction)CoCreateSMNetBarrier, METH_NOARGS,
     "Create instance of SMNetBarrier\n"},
    {"SMNetBarriersCollection", (PyCFunction)CoCreateSMNetBarriersCollection, METH_NOARGS,
     "Create instance of SMNetBarriersCollection\n"},
    {"SMRoadPreferences", (PyCFunction)CoCreateSMRoadPreferences, METH_NOARGS,
     "Create instance of SMRoadPreferences\n"},
    {"SMSpeedGroup", (PyCFunction)CoCreateSMSpeedGroup, METH_NOARGS,
     "Create instance of SMSpeedGroup\n"},
    {"SMSpeedGroups", (PyCFunction)CoCreateSMSpeedGroups, METH_NOARGS,
     "Create instance of SMSpeedGroups\n"},
    {"SMTripPlanSettings", (PyCFunction)CoCreateSMTripPlanSettings, METH_NOARGS,
     "Create instance of SMTripPlanSettings\n"},
    {"SMFlag", (PyCFunction)CoCreateSMFlag, METH_NOARGS,
     "Create instance of SMFlag\n"},
    {"SMStop", (PyCFunction)CoCreateSMStop, METH_NOARGS,
     "Create instance of SMStop\n"},
    {"SMStopsCollection", (PyCFunction)CoCreateSMStopsCollection, METH_NOARGS,
     "Create instance of SMStopsCollection\n"},
    {"SMDirItem", (PyCFunction)CoCreateSMDirItem, METH_NOARGS,
     "Create instance of SMDirItem\n"},
    {"SMDirections", (PyCFunction)CoCreateSMDirections, METH_NOARGS,
     "Create instance of SMDirections\n"},
    {"SMRouter", (PyCFunction)CoCreateSMRouter, METH_NOARGS,
     "Create instance of SMRouter\n"},
    {"SMRouterFactory", (PyCFunction)CoCreateSMRouterFactory, METH_NOARGS,
     "Create instance of SMRouterFactory\n"},
    {"SMNetAttributesAccess", (PyCFunction)CoCreateSMNetAttributesAccess, METH_NOARGS,
     "Create instance of SMNetAttributesAccess\n"},
    {"SMFlagCreator", (PyCFunction)CoCreateSMFlagCreator, METH_NOARGS,
     "Create instance of SMFlagCreator\n"},
    {"SMRestriction", (PyCFunction)CoCreateSMRestriction, METH_NOARGS,
     "Create instance of SMRestriction\n"},
    {"LicensedDataExtension", (PyCFunction)CoCreateLicensedDataExtension, METH_NOARGS,
     "Create instance of LicensedDataExtension\n"},
    {"DECadDrawingDatasetType", (PyCFunction)CoCreateDECadDrawingDatasetType, METH_NOARGS,
     "Create instance of DECadDrawingDatasetType\n"},
    {"DECadDrawingDataset", (PyCFunction)CoCreateDECadDrawingDataset, METH_NOARGS,
     "Create instance of DECadDrawingDataset\n"},
    {"DELayerType", (PyCFunction)CoCreateDELayerType, METH_NOARGS,
     "Create instance of DELayerType\n"},
    {"DEShapeFileType", (PyCFunction)CoCreateDEShapeFileType, METH_NOARGS,
     "Create instance of DEShapeFileType\n"},
    {"DEDbaseTableType", (PyCFunction)CoCreateDEDbaseTableType, METH_NOARGS,
     "Create instance of DEDbaseTableType\n"},
    {"DELayer", (PyCFunction)CoCreateDELayer, METH_NOARGS,
     "Create instance of DELayer\n"},
    {"DEShapeFile", (PyCFunction)CoCreateDEShapeFile, METH_NOARGS,
     "Create instance of DEShapeFile\n"},
    {"DEDbaseTable", (PyCFunction)CoCreateDEDbaseTable, METH_NOARGS,
     "Create instance of DEDbaseTable\n"},
    {"DECatalogRootType", (PyCFunction)CoCreateDECatalogRootType, METH_NOARGS,
     "Create instance of DECatalogRootType\n"},
    {"DEDiskConnectionType", (PyCFunction)CoCreateDEDiskConnectionType, METH_NOARGS,
     "Create instance of DEDiskConnectionType\n"},
    {"DEFolderType", (PyCFunction)CoCreateDEFolderType, METH_NOARGS,
     "Create instance of DEFolderType\n"},
    {"DEFileType", (PyCFunction)CoCreateDEFileType, METH_NOARGS,
     "Create instance of DEFileType\n"},
    {"DEPrjFileType", (PyCFunction)CoCreateDEPrjFileType, METH_NOARGS,
     "Create instance of DEPrjFileType\n"},
    {"DEMapDocumentType", (PyCFunction)CoCreateDEMapDocumentType, METH_NOARGS,
     "Create instance of DEMapDocumentType\n"},
    {"DERemoteDatabaseFolderType", (PyCFunction)CoCreateDERemoteDatabaseFolderType, METH_NOARGS,
     "Create instance of DERemoteDatabaseFolderType\n"},
    {"DESpatialReferencesFolderType", (PyCFunction)CoCreateDESpatialReferencesFolderType, METH_NOARGS,
     "Create instance of DESpatialReferencesFolderType\n"},
    {"DECatalogRoot", (PyCFunction)CoCreateDECatalogRoot, METH_NOARGS,
     "Create instance of DECatalogRoot\n"},
    {"DEDiskConnection", (PyCFunction)CoCreateDEDiskConnection, METH_NOARGS,
     "Create instance of DEDiskConnection\n"},
    {"DEFolder", (PyCFunction)CoCreateDEFolder, METH_NOARGS,
     "Create instance of DEFolder\n"},
    {"DEFile", (PyCFunction)CoCreateDEFile, METH_NOARGS,
     "Create instance of DEFile\n"},
    {"DEMapDocument", (PyCFunction)CoCreateDEMapDocument, METH_NOARGS,
     "Create instance of DEMapDocument\n"},
    {"DERemoteDatabaseFolder", (PyCFunction)CoCreateDERemoteDatabaseFolder, METH_NOARGS,
     "Create instance of DERemoteDatabaseFolder\n"},
    {"DESpatialReferencesFolder", (PyCFunction)CoCreateDESpatialReferencesFolder, METH_NOARGS,
     "Create instance of DESpatialReferencesFolder\n"},
    {"DEPrjFile", (PyCFunction)CoCreateDEPrjFile, METH_NOARGS,
     "Create instance of DEPrjFile\n"},
    {"DETextFile", (PyCFunction)CoCreateDETextFile, METH_NOARGS,
     "Create instance of DETextFile\n"},
    {"DETextFileType", (PyCFunction)CoCreateDETextFileType, METH_NOARGS,
     "Create instance of DETextFileType\n"},
    {"DETinType", (PyCFunction)CoCreateDETinType, METH_NOARGS,
     "Create instance of DETinType\n"},
    {"DETin", (PyCFunction)CoCreateDETin, METH_NOARGS,
     "Create instance of DETin\n"},
    {"DELasDatasetType", (PyCFunction)CoCreateDELasDatasetType, METH_NOARGS,
     "Create instance of DELasDatasetType\n"},
    {"DELasDataset", (PyCFunction)CoCreateDELasDataset, METH_NOARGS,
     "Create instance of DELasDataset\n"},
    {"DECoverageType", (PyCFunction)CoCreateDECoverageType, METH_NOARGS,
     "Create instance of DECoverageType\n"},
    {"DECoverageFeatureClassType", (PyCFunction)CoCreateDECoverageFeatureClassType, METH_NOARGS,
     "Create instance of DECoverageFeatureClassType\n"},
    {"DEArcInfoTableType", (PyCFunction)CoCreateDEArcInfoTableType, METH_NOARGS,
     "Create instance of DEArcInfoTableType\n"},
    {"GPArcInfoItemType", (PyCFunction)CoCreateGPArcInfoItemType, METH_NOARGS,
     "Create instance of GPArcInfoItemType\n"},
    {"DECoverage", (PyCFunction)CoCreateDECoverage, METH_NOARGS,
     "Create instance of DECoverage\n"},
    {"DECoverageFeatureClass", (PyCFunction)CoCreateDECoverageFeatureClass, METH_NOARGS,
     "Create instance of DECoverageFeatureClass\n"},
    {"DEArcInfoTable", (PyCFunction)CoCreateDEArcInfoTable, METH_NOARGS,
     "Create instance of DEArcInfoTable\n"},
    {"GPArcInfoItem", (PyCFunction)CoCreateGPArcInfoItem, METH_NOARGS,
     "Create instance of GPArcInfoItem\n"},
    {"DEArcInfoUtilities", (PyCFunction)CoCreateDEArcInfoUtilities, METH_NOARGS,
     "Create instance of DEArcInfoUtilities\n"},
    {"DEVPFTableType", (PyCFunction)CoCreateDEVPFTableType, METH_NOARGS,
     "Create instance of DEVPFTableType\n"},
    {"DEVPFTable", (PyCFunction)CoCreateDEVPFTable, METH_NOARGS,
     "Create instance of DEVPFTable\n"},
    {"DEVPFCoverageType", (PyCFunction)CoCreateDEVPFCoverageType, METH_NOARGS,
     "Create instance of DEVPFCoverageType\n"},
    {"DEVPFCoverage", (PyCFunction)CoCreateDEVPFCoverage, METH_NOARGS,
     "Create instance of DEVPFCoverage\n"},
    {NULL, NULL, 0, NULL}
};

extern "C" {

    PyMODINIT_FUNC
    init_esriDataSourcesFile(void)
    {
        // Import UUID module and keep a global pointer to the UUID object
        PyObject* uuid_module = PyImport_ImportModuleNoBlock("uuid");
        if (!uuid_module)
        {
            PyErr_SetString(PyExc_ImportError, "Could not import UUID module");
            return;
        }
        if (g_pUUID_type)
            Py_DECREF(g_pUUID_type);
        g_pUUID_type = PyObject_GetAttrString(uuid_module, "UUID");

        // Initialize module, make it show up in the right place
        PyObject* module;
        module = Py_InitModule3("cartocomutils._esriDataSourcesFile",
                                 _esriDataSourcesFileMethods,
                                "Type library");
        Py_INCREF(module);

        // Add IUnknown base type to parent module so every typelib is using the same
        // Py_Type pointer when typechecking.
        PyObject* parent = PyImport_ImportModuleNoBlock("cartocomutils");
        if (parent)
        {
            if (!PyObject_HasAttrString(parent, "IUnknown"))
            {
                // Bootstrapping
                PyType_Ready(&IUnknownObject_Type);
                PyModule_AddObject(parent, "IUnknown", (PyObject*)(&IUnknownObject_Type));
                // Also probably means we need to coinitialize
                ::CoInitialize(NULL);
            }
            g_pUnk_type = PyObject_GetAttrString(parent, "IUnknown");
            if (!PyObject_HasAttrString(parent, "_IIDMap"))
                PyModule_AddObject(parent, "_IIDMap", PyDict_New());
            if (!PyObject_HasAttrString(parent, "_CLSIDMap"))
                PyModule_AddObject(parent, "_CLSIDMap", PyDict_New());
            g_pIIDMap = PyObject_GetAttrString(parent, "_IIDMap");
            Py_XINCREF(g_pIIDMap);
            // Set global unknown object
            if (g_pUnk_type && g_pIIDMap)
                PyDict_SetItem(g_pIIDMap, PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}"), g_pUnk_type);
            g_pCLSIDMap = PyObject_GetAttrString(parent, "_CLSIDMap");
            Py_XINCREF(g_pCLSIDMap);
            g_pRecordMap = PyObject_GetAttrString(parent, "_RecordMap");
            Py_XINCREF(g_pRecordMap);
            PyErr_Clear();
        }

        // Bulk add all interfaces as objects
        // IArcInfoItem
        PyType_Ready(&PyIArcInfoItemObject_Type);
        Py_INCREF((PyObject* )&PyIArcInfoItemObject_Type);
        PyModule_AddObject(module, "IArcInfoItem", 
                           (PyObject *)&PyIArcInfoItemObject_Type);

        // IArcInfoItemEdit
        PyType_Ready(&PyIArcInfoItemEditObject_Type);
        Py_INCREF((PyObject* )&PyIArcInfoItemEditObject_Type);
        PyModule_AddObject(module, "IArcInfoItemEdit", 
                           (PyObject *)&PyIArcInfoItemEditObject_Type);

        // IArcInfoItems
        PyType_Ready(&PyIArcInfoItemsObject_Type);
        Py_INCREF((PyObject* )&PyIArcInfoItemsObject_Type);
        PyModule_AddObject(module, "IArcInfoItems", 
                           (PyObject *)&PyIArcInfoItemsObject_Type);

        // IArcInfoItemsEdit
        PyType_Ready(&PyIArcInfoItemsEditObject_Type);
        Py_INCREF((PyObject* )&PyIArcInfoItemsEditObject_Type);
        PyModule_AddObject(module, "IArcInfoItemsEdit", 
                           (PyObject *)&PyIArcInfoItemsEditObject_Type);

        // IArcInfoTable
        PyType_Ready(&PyIArcInfoTableObject_Type);
        Py_INCREF((PyObject* )&PyIArcInfoTableObject_Type);
        PyModule_AddObject(module, "IArcInfoTable", 
                           (PyObject *)&PyIArcInfoTableObject_Type);

        // IArcInfoTable2
        PyType_Ready(&PyIArcInfoTable2Object_Type);
        Py_INCREF((PyObject* )&PyIArcInfoTable2Object_Type);
        PyModule_AddObject(module, "IArcInfoTable2", 
                           (PyObject *)&PyIArcInfoTable2Object_Type);

        // ICoverageFeatureClass
        PyType_Ready(&PyICoverageFeatureClassObject_Type);
        Py_INCREF((PyObject* )&PyICoverageFeatureClassObject_Type);
        PyModule_AddObject(module, "ICoverageFeatureClass", 
                           (PyObject *)&PyICoverageFeatureClassObject_Type);

        // ICoverageFeatureClass2
        PyType_Ready(&PyICoverageFeatureClass2Object_Type);
        Py_INCREF((PyObject* )&PyICoverageFeatureClass2Object_Type);
        PyModule_AddObject(module, "ICoverageFeatureClass2", 
                           (PyObject *)&PyICoverageFeatureClass2Object_Type);

        // ICoverage
        PyType_Ready(&PyICoverageObject_Type);
        Py_INCREF((PyObject* )&PyICoverageObject_Type);
        PyModule_AddObject(module, "ICoverage", 
                           (PyObject *)&PyICoverageObject_Type);

        // ICoverage2
        PyType_Ready(&PyICoverage2Object_Type);
        Py_INCREF((PyObject* )&PyICoverage2Object_Type);
        PyModule_AddObject(module, "ICoverage2", 
                           (PyObject *)&PyICoverage2Object_Type);

        // IArcInfoWorkspace
        PyType_Ready(&PyIArcInfoWorkspaceObject_Type);
        Py_INCREF((PyObject* )&PyIArcInfoWorkspaceObject_Type);
        PyModule_AddObject(module, "IArcInfoWorkspace", 
                           (PyObject *)&PyIArcInfoWorkspaceObject_Type);

        // IInfoTableOnlyWorkspaceEdit
        PyType_Ready(&PyIInfoTableOnlyWorkspaceEditObject_Type);
        Py_INCREF((PyObject* )&PyIInfoTableOnlyWorkspaceEditObject_Type);
        PyModule_AddObject(module, "IInfoTableOnlyWorkspaceEdit", 
                           (PyObject *)&PyIInfoTableOnlyWorkspaceEditObject_Type);

        // ICoverageFeatureClassName
        PyType_Ready(&PyICoverageFeatureClassNameObject_Type);
        Py_INCREF((PyObject* )&PyICoverageFeatureClassNameObject_Type);
        PyModule_AddObject(module, "ICoverageFeatureClassName", 
                           (PyObject *)&PyICoverageFeatureClassNameObject_Type);

        // ICoverageName
        PyType_Ready(&PyICoverageNameObject_Type);
        Py_INCREF((PyObject* )&PyICoverageNameObject_Type);
        PyModule_AddObject(module, "ICoverageName", 
                           (PyObject *)&PyICoverageNameObject_Type);

        // IArcInfoWorkspaceUtil
        PyType_Ready(&PyIArcInfoWorkspaceUtilObject_Type);
        Py_INCREF((PyObject* )&PyIArcInfoWorkspaceUtilObject_Type);
        PyModule_AddObject(module, "IArcInfoWorkspaceUtil", 
                           (PyObject *)&PyIArcInfoWorkspaceUtilObject_Type);

        // ICadSettings
        PyType_Ready(&PyICadSettingsObject_Type);
        Py_INCREF((PyObject* )&PyICadSettingsObject_Type);
        PyModule_AddObject(module, "ICadSettings", 
                           (PyObject *)&PyICadSettingsObject_Type);

        // ICadDrawingLayers
        PyType_Ready(&PyICadDrawingLayersObject_Type);
        Py_INCREF((PyObject* )&PyICadDrawingLayersObject_Type);
        PyModule_AddObject(module, "ICadDrawingLayers", 
                           (PyObject *)&PyICadDrawingLayersObject_Type);

        // ICadTransformations
        PyType_Ready(&PyICadTransformationsObject_Type);
        Py_INCREF((PyObject* )&PyICadTransformationsObject_Type);
        PyModule_AddObject(module, "ICadTransformations", 
                           (PyObject *)&PyICadTransformationsObject_Type);

        // ICadDrawingDataset
        PyType_Ready(&PyICadDrawingDatasetObject_Type);
        Py_INCREF((PyObject* )&PyICadDrawingDatasetObject_Type);
        PyModule_AddObject(module, "ICadDrawingDataset", 
                           (PyObject *)&PyICadDrawingDatasetObject_Type);

        // ICadDrawingWorkspace
        PyType_Ready(&PyICadDrawingWorkspaceObject_Type);
        Py_INCREF((PyObject* )&PyICadDrawingWorkspaceObject_Type);
        PyModule_AddObject(module, "ICadDrawingWorkspace", 
                           (PyObject *)&PyICadDrawingWorkspaceObject_Type);

        // ISdcExporter
        PyType_Ready(&PyISdcExporterObject_Type);
        Py_INCREF((PyObject* )&PyISdcExporterObject_Type);
        PyModule_AddObject(module, "ISdcExporter", 
                           (PyObject *)&PyISdcExporterObject_Type);

        // ISMRouterPoint
        PyType_Ready(&PyISMRouterPointObject_Type);
        Py_INCREF((PyObject* )&PyISMRouterPointObject_Type);
        PyModule_AddObject(module, "ISMRouterPoint", 
                           (PyObject *)&PyISMRouterPointObject_Type);

        // ISMRouterEnvelope
        PyType_Ready(&PyISMRouterEnvelopeObject_Type);
        Py_INCREF((PyObject* )&PyISMRouterEnvelopeObject_Type);
        PyModule_AddObject(module, "ISMRouterEnvelope", 
                           (PyObject *)&PyISMRouterEnvelopeObject_Type);

        // ISMPointsCollection
        PyType_Ready(&PyISMPointsCollectionObject_Type);
        Py_INCREF((PyObject* )&PyISMPointsCollectionObject_Type);
        PyModule_AddObject(module, "ISMPointsCollection", 
                           (PyObject *)&PyISMPointsCollectionObject_Type);

        // ISMNetAttribute
        PyType_Ready(&PyISMNetAttributeObject_Type);
        Py_INCREF((PyObject* )&PyISMNetAttributeObject_Type);
        PyModule_AddObject(module, "ISMNetAttribute", 
                           (PyObject *)&PyISMNetAttributeObject_Type);

        // ISMNetAttribute2
        PyType_Ready(&PyISMNetAttribute2Object_Type);
        Py_INCREF((PyObject* )&PyISMNetAttribute2Object_Type);
        PyModule_AddObject(module, "ISMNetAttribute2", 
                           (PyObject *)&PyISMNetAttribute2Object_Type);

        // ISMNetAttributesCollection
        PyType_Ready(&PyISMNetAttributesCollectionObject_Type);
        Py_INCREF((PyObject* )&PyISMNetAttributesCollectionObject_Type);
        PyModule_AddObject(module, "ISMNetAttributesCollection", 
                           (PyObject *)&PyISMNetAttributesCollectionObject_Type);

        // ISMNetBarrier
        PyType_Ready(&PyISMNetBarrierObject_Type);
        Py_INCREF((PyObject* )&PyISMNetBarrierObject_Type);
        PyModule_AddObject(module, "ISMNetBarrier", 
                           (PyObject *)&PyISMNetBarrierObject_Type);

        // ISMNetBarriersCollection
        PyType_Ready(&PyISMNetBarriersCollectionObject_Type);
        Py_INCREF((PyObject* )&PyISMNetBarriersCollectionObject_Type);
        PyModule_AddObject(module, "ISMNetBarriersCollection", 
                           (PyObject *)&PyISMNetBarriersCollectionObject_Type);

        // ISMRoadPreferences
        PyType_Ready(&PyISMRoadPreferencesObject_Type);
        Py_INCREF((PyObject* )&PyISMRoadPreferencesObject_Type);
        PyModule_AddObject(module, "ISMRoadPreferences", 
                           (PyObject *)&PyISMRoadPreferencesObject_Type);

        // ISMSpeedGroup
        PyType_Ready(&PyISMSpeedGroupObject_Type);
        Py_INCREF((PyObject* )&PyISMSpeedGroupObject_Type);
        PyModule_AddObject(module, "ISMSpeedGroup", 
                           (PyObject *)&PyISMSpeedGroupObject_Type);

        // ISMSpeedGroup2
        PyType_Ready(&PyISMSpeedGroup2Object_Type);
        Py_INCREF((PyObject* )&PyISMSpeedGroup2Object_Type);
        PyModule_AddObject(module, "ISMSpeedGroup2", 
                           (PyObject *)&PyISMSpeedGroup2Object_Type);

        // ISMSpeedGroups
        PyType_Ready(&PyISMSpeedGroupsObject_Type);
        Py_INCREF((PyObject* )&PyISMSpeedGroupsObject_Type);
        PyModule_AddObject(module, "ISMSpeedGroups", 
                           (PyObject *)&PyISMSpeedGroupsObject_Type);

        // ISMTripPlanSettings
        PyType_Ready(&PyISMTripPlanSettingsObject_Type);
        Py_INCREF((PyObject* )&PyISMTripPlanSettingsObject_Type);
        PyModule_AddObject(module, "ISMTripPlanSettings", 
                           (PyObject *)&PyISMTripPlanSettingsObject_Type);

        // ISMFlag
        PyType_Ready(&PyISMFlagObject_Type);
        Py_INCREF((PyObject* )&PyISMFlagObject_Type);
        PyModule_AddObject(module, "ISMFlag", 
                           (PyObject *)&PyISMFlagObject_Type);

        // ISMFlagCreator
        PyType_Ready(&PyISMFlagCreatorObject_Type);
        Py_INCREF((PyObject* )&PyISMFlagCreatorObject_Type);
        PyModule_AddObject(module, "ISMFlagCreator", 
                           (PyObject *)&PyISMFlagCreatorObject_Type);

        // ISMFlagCreator2
        PyType_Ready(&PyISMFlagCreator2Object_Type);
        Py_INCREF((PyObject* )&PyISMFlagCreator2Object_Type);
        PyModule_AddObject(module, "ISMFlagCreator2", 
                           (PyObject *)&PyISMFlagCreator2Object_Type);

        // ISMStop
        PyType_Ready(&PyISMStopObject_Type);
        Py_INCREF((PyObject* )&PyISMStopObject_Type);
        PyModule_AddObject(module, "ISMStop", 
                           (PyObject *)&PyISMStopObject_Type);

        // ISMStopsCollection
        PyType_Ready(&PyISMStopsCollectionObject_Type);
        Py_INCREF((PyObject* )&PyISMStopsCollectionObject_Type);
        PyModule_AddObject(module, "ISMStopsCollection", 
                           (PyObject *)&PyISMStopsCollectionObject_Type);

        // ISMDirItem
        PyType_Ready(&PyISMDirItemObject_Type);
        Py_INCREF((PyObject* )&PyISMDirItemObject_Type);
        PyModule_AddObject(module, "ISMDirItem", 
                           (PyObject *)&PyISMDirItemObject_Type);

        // ISMDirections
        PyType_Ready(&PyISMDirectionsObject_Type);
        Py_INCREF((PyObject* )&PyISMDirectionsObject_Type);
        PyModule_AddObject(module, "ISMDirections", 
                           (PyObject *)&PyISMDirectionsObject_Type);

        // ISMBreakTracker
        PyType_Ready(&PyISMBreakTrackerObject_Type);
        Py_INCREF((PyObject* )&PyISMBreakTrackerObject_Type);
        PyModule_AddObject(module, "ISMBreakTracker", 
                           (PyObject *)&PyISMBreakTrackerObject_Type);

        // ISMNetAttributesAccess
        PyType_Ready(&PyISMNetAttributesAccessObject_Type);
        Py_INCREF((PyObject* )&PyISMNetAttributesAccessObject_Type);
        PyModule_AddObject(module, "ISMNetAttributesAccess", 
                           (PyObject *)&PyISMNetAttributesAccessObject_Type);

        // ISMRouter
        PyType_Ready(&PyISMRouterObject_Type);
        Py_INCREF((PyObject* )&PyISMRouterObject_Type);
        PyModule_AddObject(module, "ISMRouter", 
                           (PyObject *)&PyISMRouterObject_Type);

        // ISMRouterFactory
        PyType_Ready(&PyISMRouterFactoryObject_Type);
        Py_INCREF((PyObject* )&PyISMRouterFactoryObject_Type);
        PyModule_AddObject(module, "ISMRouterFactory", 
                           (PyObject *)&PyISMRouterFactoryObject_Type);

        // ISMRoutingMetaData
        PyType_Ready(&PyISMRoutingMetaDataObject_Type);
        Py_INCREF((PyObject* )&PyISMRoutingMetaDataObject_Type);
        PyModule_AddObject(module, "ISMRoutingMetaData", 
                           (PyObject *)&PyISMRoutingMetaDataObject_Type);

        // ISMRestriction
        PyType_Ready(&PyISMRestrictionObject_Type);
        Py_INCREF((PyObject* )&PyISMRestrictionObject_Type);
        PyModule_AddObject(module, "ISMRestriction", 
                           (PyObject *)&PyISMRestrictionObject_Type);

        // ISMRouterSetup
        PyType_Ready(&PyISMRouterSetupObject_Type);
        Py_INCREF((PyObject* )&PyISMRouterSetupObject_Type);
        PyModule_AddObject(module, "ISMRouterSetup", 
                           (PyObject *)&PyISMRouterSetupObject_Type);

        // ISMRouterSetup2
        PyType_Ready(&PyISMRouterSetup2Object_Type);
        Py_INCREF((PyObject* )&PyISMRouterSetup2Object_Type);
        PyModule_AddObject(module, "ISMRouterSetup2", 
                           (PyObject *)&PyISMRouterSetup2Object_Type);

        // IUsageModeOption
        PyType_Ready(&PyIUsageModeOptionObject_Type);
        Py_INCREF((PyObject* )&PyIUsageModeOptionObject_Type);
        PyModule_AddObject(module, "IUsageModeOption", 
                           (PyObject *)&PyIUsageModeOptionObject_Type);

        // IUsageModeInfo
        PyType_Ready(&PyIUsageModeInfoObject_Type);
        Py_INCREF((PyObject* )&PyIUsageModeInfoObject_Type);
        PyModule_AddObject(module, "IUsageModeInfo", 
                           (PyObject *)&PyIUsageModeInfoObject_Type);

        // IMetaInfo
        PyType_Ready(&PyIMetaInfoObject_Type);
        Py_INCREF((PyObject* )&PyIMetaInfoObject_Type);
        PyModule_AddObject(module, "IMetaInfo", 
                           (PyObject *)&PyIMetaInfoObject_Type);

        // IDataLicenseInfo
        PyType_Ready(&PyIDataLicenseInfoObject_Type);
        Py_INCREF((PyObject* )&PyIDataLicenseInfoObject_Type);
        PyModule_AddObject(module, "IDataLicenseInfo", 
                           (PyObject *)&PyIDataLicenseInfoObject_Type);

        // IDataLicenseManager
        PyType_Ready(&PyIDataLicenseManagerObject_Type);
        Py_INCREF((PyObject* )&PyIDataLicenseManagerObject_Type);
        PyModule_AddObject(module, "IDataLicenseManager", 
                           (PyObject *)&PyIDataLicenseManagerObject_Type);

        // IDECadDrawingDataset
        PyType_Ready(&PyIDECadDrawingDatasetObject_Type);
        Py_INCREF((PyObject* )&PyIDECadDrawingDatasetObject_Type);
        PyModule_AddObject(module, "IDECadDrawingDataset", 
                           (PyObject *)&PyIDECadDrawingDatasetObject_Type);

        // IGPLayer
        PyType_Ready(&PyIGPLayerObject_Type);
        Py_INCREF((PyObject* )&PyIGPLayerObject_Type);
        PyModule_AddObject(module, "IGPLayer", 
                           (PyObject *)&PyIGPLayerObject_Type);

        // IDELayer
        PyType_Ready(&PyIDELayerObject_Type);
        Py_INCREF((PyObject* )&PyIDELayerObject_Type);
        PyModule_AddObject(module, "IDELayer", 
                           (PyObject *)&PyIDELayerObject_Type);

        // IDEPrjFile
        PyType_Ready(&PyIDEPrjFileObject_Type);
        Py_INCREF((PyObject* )&PyIDEPrjFileObject_Type);
        PyModule_AddObject(module, "IDEPrjFile", 
                           (PyObject *)&PyIDEPrjFileObject_Type);

        // IDETin
        PyType_Ready(&PyIDETinObject_Type);
        Py_INCREF((PyObject* )&PyIDETinObject_Type);
        PyModule_AddObject(module, "IDETin", 
                           (PyObject *)&PyIDETinObject_Type);

        // IDELasDataset
        PyType_Ready(&PyIDELasDatasetObject_Type);
        Py_INCREF((PyObject* )&PyIDELasDatasetObject_Type);
        PyModule_AddObject(module, "IDELasDataset", 
                           (PyObject *)&PyIDELasDatasetObject_Type);

        // IDECoverage
        PyType_Ready(&PyIDECoverageObject_Type);
        Py_INCREF((PyObject* )&PyIDECoverageObject_Type);
        PyModule_AddObject(module, "IDECoverage", 
                           (PyObject *)&PyIDECoverageObject_Type);

        // IDECoverageFeatureClass
        PyType_Ready(&PyIDECoverageFeatureClassObject_Type);
        Py_INCREF((PyObject* )&PyIDECoverageFeatureClassObject_Type);
        PyModule_AddObject(module, "IDECoverageFeatureClass", 
                           (PyObject *)&PyIDECoverageFeatureClassObject_Type);

        // IDEArcInfoTable
        PyType_Ready(&PyIDEArcInfoTableObject_Type);
        Py_INCREF((PyObject* )&PyIDEArcInfoTableObject_Type);
        PyModule_AddObject(module, "IDEArcInfoTable", 
                           (PyObject *)&PyIDEArcInfoTableObject_Type);

        // IGPArcInfoItem
        PyType_Ready(&PyIGPArcInfoItemObject_Type);
        Py_INCREF((PyObject* )&PyIGPArcInfoItemObject_Type);
        PyModule_AddObject(module, "IGPArcInfoItem", 
                           (PyObject *)&PyIGPArcInfoItemObject_Type);

        // IDEArcInfoUtilities
        PyType_Ready(&PyIDEArcInfoUtilitiesObject_Type);
        Py_INCREF((PyObject* )&PyIDEArcInfoUtilitiesObject_Type);
        PyModule_AddObject(module, "IDEArcInfoUtilities", 
                           (PyObject *)&PyIDEArcInfoUtilitiesObject_Type);


        // Bulk add all the IID_* CLSID_* from this type lib
        if (g_pUUID_type)
        {
            // guids registration for interfaces
            if (g_pIIDMap)
            {
// Disabled for now, done in the .py file
            }

            // clsids registration for known coclasses
            if (g_pCLSIDMap)
            {
// Disabled for now, done in the .py file
            }
        }
        Py_XDECREF(g_pIIDMap);
        Py_XDECREF(g_pCLSIDMap);
    }

}
