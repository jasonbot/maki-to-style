// This source is all automatically generated. Editing it may very
// well be an exercise in futility and frustration.
#include "Python.h"
#include "datetime.h"

// imports
#import "ArcGISVersion.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids, rename("esriProductCode", "esriVersionProductCode"), rename("VersionManager", "ArcGISVersionManager")
#import "esriSystem.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("OLE_COLOR", "OLE_HANDLE", "VARTYPE")
#import "esriSystemUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeometry.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsCore.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsSymbols.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDisplay.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriServer.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriOutput.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabase.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseDistributed.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseExtensions.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabasePS.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGISClient.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesFile.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesGDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesOleDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRaster.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesNetCDF.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRasterUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriCarto.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("UINT_PTR")


// Globals we need to keep around -- a reference to the UUID class for mapping
// GUIDs to Python-usable UUIDs and the IUnknown type we'll be using across the
// board.
static PyObject* g_pUUID_type = NULL;
static PyObject* g_pUnk_type = NULL;
static PyObject* g_pIIDMap = NULL;
static PyObject* g_pCLSIDMap = NULL;
static PyObject* g_pRecordMap = NULL;

// PyObject destructor for PyCObjects that hold IUnknown* in them
static void
destr_unknown(void* pvUnk)
{
    IUnknown* pUnk = (IUnknown*)pvUnk;
    if (pUnk)
        pUnk->Release();
}

// Checker/caster to see if we can get a GUID from a Python object, either
// by  checking if the object is an instance of the uuid.UUID type, or if
// it is a string, coercing it with the constructor and seeing if it accepts
// it.
//
// def GuidFromPyObject(potentialIID, GUID*):
//     if isinstance(potentialIID, basestring):
//         try:
//             potentialIID = uuid.UUID(potentialIID)
//         except:
//             return False
//     if isinstance(potentialIID, uuid.UUID):
//         if (<copy raw bytes of UUID data in object to out GUID*>):
//             return True
//     return False
//
static bool
GuidFromPyObject(PyObject* potentialIID, GUID* pOutGUID)
{
    if (!g_pUUID_type)
        return false;

    // See if we can cast a string into a UUID instance, if that's what we've got.
    if (PyString_Check(potentialIID) || PyUnicode_Check(potentialIID))
    {
        PyObject* piid_object = PyObject_CallFunction(g_pUUID_type, "O", potentialIID);
        bool retval = (piid_object)?GuidFromPyObject(piid_object, pOutGUID): false;
        Py_XDECREF(piid_object);
        if (!piid_object || PyErr_Occurred())
        {
            PyErr_Clear();
            PyObject* unicodearg = NULL;
            if (PyString_Check(potentialIID))
                unicodearg = PyUnicode_FromObject(potentialIID);
            else if (PyUnicode_Check(potentialIID))
            {
                unicodearg = potentialIID;
                Py_INCREF(unicodearg);
            }
            if (unicodearg)
            {
                BSTR classname = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodearg),
                                                     (UINT)PyUnicode_GET_SIZE(unicodearg));
                CLSID clsid;
                if (CLSIDFromProgID(classname, &clsid) == S_OK)
                {
                    retval = true;
                    if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)&clsid, 16))
                        retval = false;
                }
                ::SysFreeString(classname);
            }
            Py_XDECREF(unicodearg);
        }
        return retval;
    }
    else if (PyObject_IsInstance(potentialIID, g_pUUID_type))
    {
        // Fetch raw bytes string -- need to fetch "bytes" on big-endian, 
        // "bytes_le" on little-endian architectures
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )        
            pBytes = PyObject_GetAttrString(potentialIID, "bytes");
        else
            pBytes = PyObject_GetAttrString(potentialIID, "bytes_le");
        if (pBytes)
        {
            bool retval = true;
            // Pointer to raw data
            char* pRawBytes = PyString_AsString(pBytes);
            if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)pRawBytes, 16))
                retval = false;
            Py_XDECREF(pBytes);
            return retval;
        }
        PyErr_Clear();
    }
    return false;
}

static PyObject*
GUIDToPythonUUID(const GUID* UUID)
{
    if (UUID)
    {
        // Lie to Python and tell it that our GUID is a 16-byte string
        PyObject* PyUUIDString = PyString_FromStringAndSize((char *)UUID, sizeof(GUID));
        if (!PyUUIDString)
            return NULL;
        // Args, varargs
        PyObject* PyArgs = PyTuple_New(0);
        PyObject* PyKWArgs = PyDict_New();
        PyObject* RetVal = NULL;
        // Dict with single value: the keyword argument bytes_le.
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )
            PyDict_SetItemString(PyKWArgs, "bytes", PyUUIDString);
        else
            PyDict_SetItemString(PyKWArgs, "bytes_le", PyUUIDString);
        // New UUID with KW
        if (g_pUUID_type)
            RetVal = PyObject_Call(g_pUUID_type, PyArgs, PyKWArgs);
        else
            PyErr_SetString(PyExc_ImportError, "UUID module import failed");

        Py_DECREF(PyUUIDString);
        Py_DECREF(PyArgs);
        Py_DECREF(PyKWArgs);
        return RetVal;
    }
    else
    {
        PyErr_SetString(PyExc_ValueError, "Bad GUID");
        return NULL;
    }
}

static PyObject*
IUnknownToPythonIIDObject(IUnknown* pUnk, const GUID* IID)
{
    PyObject* RetVal = NULL;
    pUnk->AddRef();
    PyObject* PyUnk = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    //return PyUnk;

    PyObject* pCall = NULL;

    PyObject* pGuidObject = GUIDToPythonUUID(IID);
    if (!pGuidObject || !g_pIIDMap)
        return PyUnk;

    if (PyDict_Contains(g_pIIDMap, pGuidObject) == 1)
        pCall = PyDict_GetItem(g_pIIDMap, pGuidObject);
    if (!pCall)
        pCall = g_pUnk_type;
    if (pCall)
        RetVal = PyObject_CallFunction(pCall, "O", PyUnk);

    if (!RetVal)
        RetVal = PyUnk;
    else
        Py_DECREF(PyUnk);

    Py_XDECREF(pGuidObject);
    return RetVal;
}

static PyObject*
DATE_AsPyObject(DATE in_date)
{
  PyDateTime_IMPORT;
  // Round to even number of days
  int days = (int)in_date;
  // Convert what's left (after the decimal) to seconds; 86400 seconds per day.
  int seconds = (int)((in_date - (double)days) * 86400.0);
  if (in_date < 0)
    seconds *= -1;
  // TimeDelta to add to the date representing the start of all Variant VT_DATEs
  PyObject* pDelta = PyDelta_FromDSU(days, seconds, 0);
  // Midnight 30 December 1899
  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  // Do addition of computed delta to 1899-12-30 00:00:00
  PyObject* pRetVal = PyObject_CallMethod(pStartOfVariantTime, "__add__", "O", pDelta);

  Py_XDECREF(pDelta);
  Py_XDECREF(pStartOfVariantTime);

  return pRetVal;
}

static DATE
PyObject_AsDATE(PyObject* in_date)
{
  PyDateTime_IMPORT;
  if (!PyDateTime_Check(in_date))
  {
    PyErr_SetString(PyExc_ValueError, "Cannot convert this Python object to a datetime");
    return (DATE)0.0;
  }

  double out_date;

  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  PyDateTime_Delta* pDelta = (PyDateTime_Delta *)PyObject_CallMethod(in_date, "__sub__", "O", pStartOfVariantTime);
  Py_XDECREF(pStartOfVariantTime);
  
  if (pDelta && PyDelta_Check((PyObject *)pDelta))
  {
    out_date = (double)pDelta->days;
    out_date += (double)(pDelta->seconds) / 86400.0;
  }
  
  Py_XDECREF(pDelta);
  return (DATE)out_date;
}

static bool
PyObject_AsVariant(PyObject* in_object, VARIANT* out_variant)
{
  ::VariantClear(out_variant);
  PyDateTime_IMPORT;

  if (in_object == Py_None)
    return true;
  else if (PyUnicode_Check(in_object))
  {
    out_variant->vt = VT_BSTR;
    BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(in_object), 
                                          (UINT)PyUnicode_GET_SIZE(in_object));
    out_variant->bstrVal = out_string;
    return true;
  }
  else if (PyString_Check(in_object))
  {
    PyObject* pUnicode = PyUnicode_FromObject(in_object);
    if (pUnicode)
    {
      out_variant->vt = VT_BSTR;
      BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(pUnicode), 
                                            (UINT)PyUnicode_GET_SIZE(pUnicode));
      out_variant->bstrVal = out_string;
      Py_DECREF(pUnicode);
      return true;
    }
    return false;
  }
  else if (PyFloat_Check(in_object))
  {
    out_variant->vt = VT_R8;
    out_variant->dblVal = PyFloat_AsDouble(in_object);
    return true;
  }
  else if (PyInt_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyInt_AsLong(in_object);
    return true;
  }
  else if (PyLong_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyLong_AsLongLong(in_object);
    if (PyErr_Occurred())
    {
      PyErr_Clear();
      PyObject* strval = PyObject_Str(in_object);
      if (strval)
      {
        PyObject* unival = PyUnicode_FromObject(strval);
        out_variant->vt = VT_BSTR;
        BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unival), 
                                              (UINT)PyUnicode_GET_SIZE(unival));
        out_variant->bstrVal = out_string;
        Py_DecRef(unival);
        Py_DecRef(strval);
        return true;
      }
      return false;
    }
    else
      return true;
  }
  else if (PyDateTime_Check(in_object))
  {
    out_variant->vt = VT_DATE;
    out_variant->date = PyObject_AsDATE(in_object);

    return true;
  }
  else if (PyObject_HasAttrString(in_object, "_pUnk"))
  {
    PyObject* pUnk = PyObject_GetAttrString(in_object, "_pUnk");
    if (pUnk && PyCObject_Check(pUnk))
    {
      IUnknown* pIUnknown = (IUnknown*)PyCObject_AsVoidPtr(pUnk);
      pIUnknown->AddRef();
      out_variant->vt = VT_UNKNOWN;
      out_variant->punkVal = pIUnknown;
      Py_DecRef(pUnk);
      return true;
    }
    Py_XDECREF(pUnk);
  }
  PyObject* repr = PyObject_Repr(in_object);
  PyErr_Format(PyExc_ValueError, "Can't convert %s to Variant.", repr?PyString_AsString(repr):"<Undef>", NULL);
  Py_XDECREF(repr);
  return false;
}

// Forward decl!
static PyObject* SAFEARRAYToPyObject(SAFEARRAY*, VARTYPE);

static PyObject*
Variant_AsPyObject(VARIANT* in_variant)
{
  if (in_variant->vt == VT_EMPTY)
    Py_RETURN_NONE;
  else if (in_variant->vt  == (VT_BYREF|VT_I1))
    return PyInt_FromLong(*(in_variant->pcVal)); //CHAR                *
  else if (in_variant->vt == (VT_BYREF|VT_UI2))
    return PyInt_FromLong(*(in_variant->puiVal)); //USHORT              *
  else if (in_variant->vt == (VT_BYREF|VT_UI4))
    return PyInt_FromLong(*(in_variant->pulVal)); //ULONG               *
  else if (in_variant->vt == (VT_BYREF|VT_UI8))
    return PyLong_FromUnsignedLongLong(*(in_variant->pullVal)); //ULONGLONG           *
  else if (in_variant->vt == (VT_BYREF|VT_INT))
    return PyInt_FromLong(*(in_variant->pintVal)); //INT                 *
  else if (in_variant->vt == (VT_BYREF|VT_UINT))
    return PyInt_FromLong(*(in_variant->puintVal)); //UINT                *
  else if (in_variant->vt == (VT_BYREF|VT_UI1))
    return PyInt_FromLong(*(in_variant->pbVal)); //BYTE                *
  else if (in_variant->vt == (VT_BYREF|VT_I2))
    return PyInt_FromLong(*(in_variant->piVal)); //SHORT               *
  else if (in_variant->vt == (VT_BYREF|VT_I4))
    return PyInt_FromLong(*(in_variant->plVal)); //LONG                *
  else if (in_variant->vt == (VT_BYREF|VT_I8))
    return PyLong_FromLongLong(*(in_variant->pllVal)); //LONGLONG            *
  else if (in_variant->vt == (VT_BYREF|VT_R4))
    return PyFloat_FromDouble((double)*(in_variant->pfltVal)); //FLOAT               *
  else if (in_variant->vt == (VT_BYREF|VT_R8))
    return PyFloat_FromDouble((double)*(in_variant->pdblVal)); //DOUBLE              *
  else if (in_variant->vt == (VT_BYREF|VT_BOOL))
    if ((*(in_variant->pboolVal)) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;
  else if (in_variant->vt == (VT_BYREF|VT_BSTR))
    return PyUnicode_FromWideChar(*(in_variant->pbstrVal),::SysStringLen(*(in_variant->pbstrVal)));  //BSTR                *
  else if (in_variant->vt == (VT_BYREF|VT_UNKNOWN))
  {
    IUnknown* pUnk = *(in_variant->ppunkVal);
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_DISPATCH))
  {
    IDispatch* pDisp = *(in_variant->ppdispVal);
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_VARIANT))
    return Variant_AsPyObject(in_variant->pvarVal); //VARIANT             *
  else if (in_variant->vt  == VT_I8)
    return PyLong_FromLongLong(in_variant->llVal); //LONGLONG           
  else if (in_variant->vt == VT_I4)
    return PyInt_FromLong(in_variant->lVal); //LONG               
  else if (in_variant->vt == VT_UI1)
    return PyInt_FromLong((unsigned)in_variant->bVal); //BYTE               
  else if (in_variant->vt == VT_I2)
    return PyInt_FromLong(in_variant->iVal); //SHORT              
  else if (in_variant->vt == VT_R4)
    return PyFloat_FromDouble((double)(in_variant->fltVal)); //FLOAT              
  else if (in_variant->vt == VT_R8)
    return PyFloat_FromDouble((double)(in_variant->dblVal)); //DOUBLE             
  else if (in_variant->vt == VT_BOOL)
    if ((in_variant->boolVal) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;              
  else if (in_variant->vt == VT_BSTR)
    return PyUnicode_FromWideChar(in_variant->bstrVal, ::SysStringLen(in_variant->bstrVal)); //BSTR               
  else if (in_variant->vt == VT_UNKNOWN)
  {
    IUnknown* pUnk = in_variant->punkVal;
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_DISPATCH)
  {
    IDispatch* pDisp = in_variant->pdispVal;
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_I1)
    return PyInt_FromLong(in_variant->cVal); //CHAR               
  else if (in_variant->vt == VT_UI2)
    return PyInt_FromLong(in_variant->uiVal); //USHORT             
  else if (in_variant->vt == VT_UI4)
    return PyInt_FromLong(in_variant->ulVal); //ULONG              
  else if (in_variant->vt == VT_UI8)
    return PyLong_FromUnsignedLongLong(in_variant->ullVal); //ULONGLONG          
  else if (in_variant->vt == VT_INT)
    return PyInt_FromLong(in_variant->intVal); //INT                
  else if (in_variant->vt == VT_UINT)
    return PyInt_FromLong(in_variant->uintVal); //UINT               
  else if ((in_variant->vt & VT_DATE) == VT_DATE)
  {
    DATE in_date = (in_variant->vt & VT_BYREF)?(*(in_variant->pdate)):in_variant->date;
    return DATE_AsPyObject(in_date);
  }
  else if (in_variant->vt & VT_ARRAY)
  {
    return SAFEARRAYToPyObject((in_variant->vt & VT_BYREF) ? 
                                        *(in_variant->pparray) : 
                                        in_variant->parray,
                                (in_variant->vt));
  }

  PyErr_SetString(PyExc_ValueError, "Cannot convert this variant to a Python object");
  return NULL;
}

static PyObject*
SAFEARRAYToPyObject(SAFEARRAY* pArray, VARTYPE vt)
{
  if (!pArray)
    Py_RETURN_NONE;
  PyObject* return_array(NULL);
  long entry_count(1);
  for (ssize_t dimension(0); dimension < pArray->cDims; ++dimension)
    entry_count *= (pArray->rgsabound[dimension]).cElements;
  if (pArray->fFeatures & FADF_BSTR)
  {
    return_array = PyList_New(0);
    BSTR* barray = (BSTR*)pArray->pvData;
    for (long string_index = 0; string_index < entry_count; ++string_index)
    {
      PyObject* new_string = PyUnicode_FromWideChar(barray[string_index], ::SysStringLen(barray[string_index]));
      PyList_Append(return_array, new_string);
      Py_DECREF(new_string);
    }
  }
  else if (pArray->fFeatures & FADF_VARIANT)
  {
    return_array = PyList_New(0);
    VARIANT* varray = (VARIANT*)pArray->pvData;
    for (long variant_index(0); variant_index < entry_count; ++variant_index)
    {
      PyObject* new_variant = Variant_AsPyObject(&varray[variant_index]);
      if (new_variant)
      {
        PyList_Append(return_array, new_variant);
        Py_DECREF(new_variant);
      }
      else
      {
        PyErr_Clear();
        PyList_Append(return_array, Py_None);
      }
    }
  }
  else if (pArray->fFeatures & FADF_UNKNOWN)
  {
    return_array = PyList_New(0);
    IUnknown** oarray = (IUnknown**)pArray->pvData;
    for (long object_index(0); object_index < entry_count; ++object_index)
    {
      PyObject* new_object = IUnknownToPythonIIDObject(oarray[object_index], &IID_IUnknown);
      PyList_Append(return_array, new_object);
      Py_DECREF(new_object);
    }
  }
  else if (vt == (VT_UI1 | VT_ARRAY))
  {
    return_array = PyByteArray_FromStringAndSize((char*)(pArray->pvData), entry_count);
  }

  if (!return_array)
  {
    if (PyErr_WarnEx(PyExc_Warning, "conversion for this error type not implemented", -1) != 0)
      return 0;

    return_array = Py_BuildValue("(HHNK)", (unsigned short)vt,
                                           (unsigned short)pArray->fFeatures,
                                           PyByteArray_FromStringAndSize((char*)(pArray->pvData), 
                                                                         sizeof(pArray->pvData)),
                                           (unsigned long long)pArray->pvData);
  }
  return return_array;
}

// Attempt to get an interface pointer from a Python object
static bool
IFaceFromPyObject(PyObject* pIn, const GUID* pOutGuid, void** pOutIFace)
{
    IUnknown* pUnk = NULL;

    if (pIn == Py_None)
    {
        *pOutIFace = NULL;
        return true;
    }
    else if (PyCObject_Check(pIn))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(pIn);
    }
    else
    {
        bool need_decref(false);
        if (PyObject_HasAttrString(pIn, "_arc_object"))
        {
          pIn = PyObject_GetAttrString(pIn, "_arc_object");
          if (pIn)
            need_decref = true;
        }
        PyObject* pObject = PyObject_GetAttrString(pIn, "_pUnk");
        if (!pObject)
            return false;
        if (!PyCObject_Check(pObject))
            return false;
        else
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(pObject);
        if (need_decref)
            Py_DECREF(pIn);
        Py_XDECREF(pObject);
    }
    if (pUnk && SUCCEEDED(pUnk->QueryInterface(*pOutGuid, pOutIFace)))
        return true;

    return false;
}



// Every module implements this IUnknown thing but only one reference to the 
// _Type struct will be used between them, so type checking will still work.
// This has the happy side effect of letting us pick and choose which of the
// OLBs that are offered as wrappers (and just plain remove them) without 
// needing to worry about it. Whichever of the C modules in the suite that gets
// imported first is fully capable and will do its best to bootstrap the system.

typedef struct IUnknownObject {
    PyObject_HEAD
    IUnknown* m_pUnk;
} IUnknownObject;

static PyObject*
IUnknownObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    IUnknownObject* self;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {        
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUnknown with provided CLSID");
            return NULL;
        }
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        pUnk->AddRef();
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUnknown");
            return NULL;
        }
        if (!PyCObject_Check(argument))
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUnknown");
            return NULL;
        }
        else
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
            pUnk->AddRef();
        }
        if (argument)
            Py_DECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    if (!(self = ((IUnknownObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUnknown");
        return NULL;
    }

    self->m_pUnk = pUnk;
    return (PyObject *)self;
}

static void
IUnknownObject_dealloc(IUnknownObject* self)
{
    if (self->m_pUnk)
        self->m_pUnk->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
IUnknown_GetpUnk(IUnknownObject* self)
{
    if (!self->m_pUnk)
        Py_RETURN_NONE;
    self->m_pUnk->AddRef();
    return PyCObject_FromVoidPtr((void*)self->m_pUnk, destr_unknown);
}

static PyObject*
IUnknown_GetPointer(IUnknownObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pUnk);
}

static PyObject*
IUnknown_GetIID(IUnknownObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
IUnknown_SupportsInterface(IUnknownObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pUnk->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}

PyMethodDef IUnknownMethods[] = {
    {"supports", (PyCFunction)IUnknown_SupportsInterface, METH_O, ""},
};

PyGetSetDef IUnknownGetSet[] = {
  {"_IID", (getter)IUnknown_GetIID, NULL, "Get IID for Unknown", NULL},
  {"_pUnk", (getter)IUnknown_GetpUnk, NULL, "Get opaque pointer to Unknown", NULL},
  {"_pointer", (getter)IUnknown_GetPointer, NULL, "Get long pointer to Unknown", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject IUnknownObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "cartocomutils.IUnknown",
                                              /* tp_name */
  sizeof(IUnknownObject),                     /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)IUnknownObject_dealloc,         /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "IUnknown",                                 /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  IUnknownMethods,                            /* tp_methods */
  0,                                          /* tp_members */
  IUnknownGetSet,                             /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  IUnknownObject_new,                         /* tp_new */
};




// Interface IModifiedClassInfo

typedef struct PyIModifiedClassInfoObject {
    PyObject_HEAD
    IModifiedClassInfo* m_pIModifiedClassInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIModifiedClassInfoObject;

static PyObject*
PyIModifiedClassInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIModifiedClassInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IModifiedClassInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IModifiedClassInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IModifiedClassInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIModifiedClassInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IModifiedClassInfo");
            return NULL;
        }
        self->m_pIModifiedClassInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IModifiedClassInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IModifiedClassInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IModifiedClassInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IModifiedClassInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IModifiedClassInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIModifiedClassInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IModifiedClassInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIModifiedClassInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIModifiedClassInfoObject_dealloc(PyIModifiedClassInfoObject* self)
{
    if (self->m_pIModifiedClassInfo)
        self->m_pIModifiedClassInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIModifiedClassInfo_GetpUnk(PyIModifiedClassInfoObject* self)
{
    if (!self->m_pIModifiedClassInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIModifiedClassInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IModifiedClassInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIModifiedClassInfo_GetPointer(PyIModifiedClassInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIModifiedClassInfo);
}

static PyObject*
PyIModifiedClassInfo_GetIID(PyIModifiedClassInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0952a2d7-fa43-4740-aea5-d6c902eb6a2c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIModifiedClassInfo_GetHR(PyIModifiedClassInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIModifiedClassInfo_GetIgnoreFailures(PyIModifiedClassInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIModifiedClassInfo_SetIgnoreFailures(PyIModifiedClassInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIModifiedClassInfo_SupportsInterface(PyIModifiedClassInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIModifiedClassInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IModifiedClassInfoMethod_get_ChildClassName(PyIModifiedClassInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscClassName;
    PyObject* pyvar_cClassName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for cClassName

    // Call method on actual COM interface
    hr = self->m_pIModifiedClassInfo->get_ChildClassName(&bscClassName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModifiedClassInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModifiedClassInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModifiedClassInfo.get_ChildClassName() returned %ld", (long)hr);
        goto imodifiedclassinfo_get_childclassname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_cClassName = PyUnicode_FromWideChar(bscClassName,::SysStringLen(bscClassName));
    ::SysFreeString(bscClassName);
    
    if (PyErr_Occurred())
      goto imodifiedclassinfo_get_childclassname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_cClassName);
    goto imodifiedclassinfo_get_childclassname_method_cleanup;

    imodifiedclassinfo_get_childclassname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_cClassName != Py_None)
        Py_XDECREF(pyvar_cClassName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModifiedClassInfo.get_ChildClassName");
    return return_tuple;
}

static PyObject*
IModifiedClassInfoMethod_get_ClassID(PyIModifiedClassInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lChildClassID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ChildClassID

    // Call method on actual COM interface
    hr = self->m_pIModifiedClassInfo->get_ClassID(&lChildClassID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModifiedClassInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModifiedClassInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModifiedClassInfo.get_ClassID() returned %ld", (long)hr);
        goto imodifiedclassinfo_get_classid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ChildClassID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lChildClassID);
    goto imodifiedclassinfo_get_classid_method_cleanup;

    imodifiedclassinfo_get_classid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ChildClassID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModifiedClassInfo.get_ClassID");
    return return_tuple;
}

static PyObject*
IModifiedClassInfoMethod_get_ParentClassName(PyIModifiedClassInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsrName;
    PyObject* pyvar_rName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for rName

    // Call method on actual COM interface
    hr = self->m_pIModifiedClassInfo->get_ParentClassName(&bsrName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModifiedClassInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModifiedClassInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModifiedClassInfo.get_ParentClassName() returned %ld", (long)hr);
        goto imodifiedclassinfo_get_parentclassname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_rName = PyUnicode_FromWideChar(bsrName,::SysStringLen(bsrName));
    ::SysFreeString(bsrName);
    
    if (PyErr_Occurred())
      goto imodifiedclassinfo_get_parentclassname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_rName);
    goto imodifiedclassinfo_get_parentclassname_method_cleanup;

    imodifiedclassinfo_get_parentclassname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_rName != Py_None)
        Py_XDECREF(pyvar_rName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModifiedClassInfo.get_ParentClassName");
    return return_tuple;
}

static PyObject*
IModifiedClassInfoMethod_get_DatasetType(PyIModifiedClassInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDatasetType edType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for dType

    // Call method on actual COM interface
    hr = self->m_pIModifiedClassInfo->get_DatasetType(&edType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModifiedClassInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModifiedClassInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModifiedClassInfo.get_DatasetType() returned %ld", (long)hr);
        goto imodifiedclassinfo_get_datasettype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)edType);
    goto imodifiedclassinfo_get_datasettype_method_cleanup;

    imodifiedclassinfo_get_datasettype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModifiedClassInfo.get_DatasetType");
    return return_tuple;
}

static PyObject*
IModifiedClassInfoMethod_get_ParentDatabase(PyIModifiedClassInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsParentDatabase;
    PyObject* pyvar_ParentDatabase = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentDatabase

    // Call method on actual COM interface
    hr = self->m_pIModifiedClassInfo->get_ParentDatabase(&bsParentDatabase);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModifiedClassInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModifiedClassInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModifiedClassInfo.get_ParentDatabase() returned %ld", (long)hr);
        goto imodifiedclassinfo_get_parentdatabase_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ParentDatabase = PyUnicode_FromWideChar(bsParentDatabase,::SysStringLen(bsParentDatabase));
    ::SysFreeString(bsParentDatabase);
    
    if (PyErr_Occurred())
      goto imodifiedclassinfo_get_parentdatabase_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ParentDatabase);
    goto imodifiedclassinfo_get_parentdatabase_method_cleanup;

    imodifiedclassinfo_get_parentdatabase_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ParentDatabase != Py_None)
        Py_XDECREF(pyvar_ParentDatabase);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModifiedClassInfo.get_ParentDatabase");
    return return_tuple;
}

static PyObject*
IModifiedClassInfoMethod_get_ParentOwner(PyIModifiedClassInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsParentOwner;
    PyObject* pyvar_ParentOwner = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentOwner

    // Call method on actual COM interface
    hr = self->m_pIModifiedClassInfo->get_ParentOwner(&bsParentOwner);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModifiedClassInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModifiedClassInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModifiedClassInfo.get_ParentOwner() returned %ld", (long)hr);
        goto imodifiedclassinfo_get_parentowner_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ParentOwner = PyUnicode_FromWideChar(bsParentOwner,::SysStringLen(bsParentOwner));
    ::SysFreeString(bsParentOwner);
    
    if (PyErr_Occurred())
      goto imodifiedclassinfo_get_parentowner_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ParentOwner);
    goto imodifiedclassinfo_get_parentowner_method_cleanup;

    imodifiedclassinfo_get_parentowner_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ParentOwner != Py_None)
        Py_XDECREF(pyvar_ParentOwner);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModifiedClassInfo.get_ParentOwner");
    return return_tuple;
}


PyMethodDef PyIModifiedClassInfoMethods[] = {
    {"supports", (PyCFunction)PyIModifiedClassInfo_SupportsInterface, METH_O, ""},
    {"get_ChildClassName", (PyCFunction)IModifiedClassInfoMethod_get_ChildClassName, METH_VARARGS, ""},
    {"get_ClassID", (PyCFunction)IModifiedClassInfoMethod_get_ClassID, METH_VARARGS, ""},
    {"get_ParentClassName", (PyCFunction)IModifiedClassInfoMethod_get_ParentClassName, METH_VARARGS, ""},
    {"get_DatasetType", (PyCFunction)IModifiedClassInfoMethod_get_DatasetType, METH_VARARGS, ""},
    {"get_ParentDatabase", (PyCFunction)IModifiedClassInfoMethod_get_ParentDatabase, METH_VARARGS, ""},
    {"get_ParentOwner", (PyCFunction)IModifiedClassInfoMethod_get_ParentOwner, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIModifiedClassInfoGetSet[] = {
  {"_pUnk", (getter)PyIModifiedClassInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from IModifiedClassInfo", NULL},
  {"_pointer", (getter)PyIModifiedClassInfo_GetPointer, NULL, "Get memory address for IModifiedClassInfo", NULL},
  {"_IID", (getter)PyIModifiedClassInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIModifiedClassInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIModifiedClassInfo_GetIgnoreFailures, (setter)PyIModifiedClassInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIModifiedClassInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IModifiedClassInfoObject",                          
                                              /* tp_name */
  sizeof(PyIModifiedClassInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIModifiedClassInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIModifiedClassInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIModifiedClassInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIModifiedClassInfoObject_new,                      
                                              /* tp_new */
};

// Interface IEnumModifiedClassInfo

typedef struct PyIEnumModifiedClassInfoObject {
    PyObject_HEAD
    IEnumModifiedClassInfo* m_pIEnumModifiedClassInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIEnumModifiedClassInfoObject;

static PyObject*
PyIEnumModifiedClassInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIEnumModifiedClassInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IEnumModifiedClassInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IEnumModifiedClassInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IEnumModifiedClassInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIEnumModifiedClassInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumModifiedClassInfo");
            return NULL;
        }
        self->m_pIEnumModifiedClassInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IEnumModifiedClassInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IEnumModifiedClassInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IEnumModifiedClassInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IEnumModifiedClassInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IEnumModifiedClassInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIEnumModifiedClassInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumModifiedClassInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIEnumModifiedClassInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIEnumModifiedClassInfoObject_dealloc(PyIEnumModifiedClassInfoObject* self)
{
    if (self->m_pIEnumModifiedClassInfo)
        self->m_pIEnumModifiedClassInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIEnumModifiedClassInfo_GetpUnk(PyIEnumModifiedClassInfoObject* self)
{
    if (!self->m_pIEnumModifiedClassInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIEnumModifiedClassInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IEnumModifiedClassInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIEnumModifiedClassInfo_GetPointer(PyIEnumModifiedClassInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIEnumModifiedClassInfo);
}

static PyObject*
PyIEnumModifiedClassInfo_GetIID(PyIEnumModifiedClassInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b3924a28-0d3a-47c6-9d63-71544f1634da");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIEnumModifiedClassInfo_GetHR(PyIEnumModifiedClassInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIEnumModifiedClassInfo_GetIgnoreFailures(PyIEnumModifiedClassInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIEnumModifiedClassInfo_SetIgnoreFailures(PyIEnumModifiedClassInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIEnumModifiedClassInfo_SupportsInterface(PyIEnumModifiedClassInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIEnumModifiedClassInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IEnumModifiedClassInfoMethod_Reset(PyIEnumModifiedClassInfoObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIEnumModifiedClassInfo->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumModifiedClassInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumModifiedClassInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumModifiedClassInfo.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IEnumModifiedClassInfoMethod_Next(PyIEnumModifiedClassInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IModifiedClassInfo* ipModifiedClassInfo = NULL;
    PyObject* py_ModifiedClassInfo = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ModifiedClassInfo

    // Call method on actual COM interface
    hr = self->m_pIEnumModifiedClassInfo->Next(&ipModifiedClassInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumModifiedClassInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumModifiedClassInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumModifiedClassInfo.Next() returned %ld", (long)hr);
        goto ienummodifiedclassinfo_next_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ModifiedClassInfo);
    if (ipModifiedClassInfo)
    {
        IUnknown* pUnk = NULL;
        ipModifiedClassInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ModifiedClassInfo = IUnknownToPythonIIDObject(pUnk, &IID_IModifiedClassInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ModifiedClassInfo)
    {
        if (py_ModifiedClassInfo)
           Py_DECREF(py_ModifiedClassInfo);
        py_ModifiedClassInfo = Py_None;
        Py_INCREF(py_ModifiedClassInfo);
    }
    if (PyErr_Occurred())
      goto ienummodifiedclassinfo_next_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ModifiedClassInfo);
    goto ienummodifiedclassinfo_next_method_cleanup;

    ienummodifiedclassinfo_next_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ModifiedClassInfo);
    if (ipModifiedClassInfo)
      ipModifiedClassInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumModifiedClassInfo.Next");
    return return_tuple;
}


PyMethodDef PyIEnumModifiedClassInfoMethods[] = {
    {"supports", (PyCFunction)PyIEnumModifiedClassInfo_SupportsInterface, METH_O, ""},
    {"Reset", (PyCFunction)IEnumModifiedClassInfoMethod_Reset, METH_NOARGS, ""},
    {"Next", (PyCFunction)IEnumModifiedClassInfoMethod_Next, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIEnumModifiedClassInfoGetSet[] = {
  {"_pUnk", (getter)PyIEnumModifiedClassInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from IEnumModifiedClassInfo", NULL},
  {"_pointer", (getter)PyIEnumModifiedClassInfo_GetPointer, NULL, "Get memory address for IEnumModifiedClassInfo", NULL},
  {"_IID", (getter)PyIEnumModifiedClassInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIEnumModifiedClassInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIEnumModifiedClassInfo_GetIgnoreFailures, (setter)PyIEnumModifiedClassInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIEnumModifiedClassInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IEnumModifiedClassInfoObject",                          
                                              /* tp_name */
  sizeof(PyIEnumModifiedClassInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIEnumModifiedClassInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIEnumModifiedClassInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIEnumModifiedClassInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIEnumModifiedClassInfoObject_new,                      
                                              /* tp_new */
};

// Interface ISchemaChangesInit

typedef struct PyISchemaChangesInitObject {
    PyObject_HEAD
    ISchemaChangesInit* m_pISchemaChangesInit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISchemaChangesInitObject;

static PyObject*
PyISchemaChangesInitObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISchemaChangesInitObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISchemaChangesInit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISchemaChangesInit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISchemaChangesInit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISchemaChangesInitObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISchemaChangesInit");
            return NULL;
        }
        self->m_pISchemaChangesInit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISchemaChangesInit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISchemaChangesInit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISchemaChangesInit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISchemaChangesInit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISchemaChangesInit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISchemaChangesInitObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISchemaChangesInit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISchemaChangesInit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISchemaChangesInitObject_dealloc(PyISchemaChangesInitObject* self)
{
    if (self->m_pISchemaChangesInit)
        self->m_pISchemaChangesInit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISchemaChangesInit_GetpUnk(PyISchemaChangesInitObject* self)
{
    if (!self->m_pISchemaChangesInit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISchemaChangesInit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISchemaChangesInit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISchemaChangesInit_GetPointer(PyISchemaChangesInitObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISchemaChangesInit);
}

static PyObject*
PyISchemaChangesInit_GetIID(PyISchemaChangesInitObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e94e335a-e1f0-4a55-9e8d-e6492b033333");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISchemaChangesInit_GetHR(PyISchemaChangesInitObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISchemaChangesInit_GetIgnoreFailures(PyISchemaChangesInitObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISchemaChangesInit_SetIgnoreFailures(PyISchemaChangesInitObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISchemaChangesInit_SupportsInterface(PyISchemaChangesInitObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISchemaChangesInit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISchemaChangesInitMethod_Init(PyISchemaChangesInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplica* ipReplica = NULL;
    PyObject* py_Replica;
    IWorkspaceName* ipTargetWorkspaceName = NULL;
    PyObject* py_TargetWorkspaceName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_Replica, &py_TargetWorkspaceName))
      goto ischemachangesinit_init_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Replica, &IID_IReplica, (void**)&ipReplica))
        PyErr_SetString(PyExc_TypeError, "Argument Replica (position 0) is not IReplica");
    
    if (PyErr_Occurred())
      goto ischemachangesinit_init_method_cleanup;
    
    if (!IFaceFromPyObject(py_TargetWorkspaceName, &IID_IWorkspaceName, (void**)&ipTargetWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument TargetWorkspaceName (position 1) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ischemachangesinit_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISchemaChangesInit->Init(ipReplica, ipTargetWorkspaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangesInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangesInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangesInit.Init() returned %ld", (long)hr);
        goto ischemachangesinit_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Replica
    // No teardown for TargetWorkspaceName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ischemachangesinit_init_method_cleanup;

    ischemachangesinit_init_method_cleanup:
    self->m_HR = hr;
    if (ipReplica)
      ipReplica->Release();
    if (ipTargetWorkspaceName)
      ipTargetWorkspaceName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangesInit.Init");
    return return_tuple;
}

static PyObject*
ISchemaChangesInitMethod_InitFromSchemaDocument(PyISchemaChangesInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsxmlFile = 0;
    PyObject* pyvar_xmlFile;
    PyObject* unicodexmlFile = NULL;
    IWorkspaceName* ipTargetWorkspaceName = NULL;
    PyObject* py_TargetWorkspaceName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_xmlFile, &py_TargetWorkspaceName))
      goto ischemachangesinit_initfromschemadocument_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_xmlFile))
        unicodexmlFile = PyUnicode_FromObject(pyvar_xmlFile);
    else if (PyUnicode_Check(pyvar_xmlFile))
    {
        unicodexmlFile = pyvar_xmlFile;
        Py_INCREF(unicodexmlFile);
    }
    else if (pyvar_xmlFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter xmlFile at index 0");
    if (unicodexmlFile)
        bsxmlFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodexmlFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodexmlFile));
    
    if (PyErr_Occurred())
      goto ischemachangesinit_initfromschemadocument_method_cleanup;
    
    if (!IFaceFromPyObject(py_TargetWorkspaceName, &IID_IWorkspaceName, (void**)&ipTargetWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument TargetWorkspaceName (position 1) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ischemachangesinit_initfromschemadocument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISchemaChangesInit->InitFromSchemaDocument(bsxmlFile, ipTargetWorkspaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangesInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangesInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangesInit.InitFromSchemaDocument() returned %ld", (long)hr);
        goto ischemachangesinit_initfromschemadocument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for xmlFile
    // No teardown for TargetWorkspaceName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ischemachangesinit_initfromschemadocument_method_cleanup;

    ischemachangesinit_initfromschemadocument_method_cleanup:
    self->m_HR = hr;
    if (bsxmlFile)
        ::SysFreeString(bsxmlFile);
    
    if (ipTargetWorkspaceName)
      ipTargetWorkspaceName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangesInit.InitFromSchemaDocument");
    return return_tuple;
}

static PyObject*
ISchemaChangesInitMethod_InitFromSchemaDifferencesDocument(PyISchemaChangesInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsxmlFile = 0;
    PyObject* pyvar_xmlFile;
    PyObject* unicodexmlFile = NULL;
    IWorkspaceName* ipTargetWorkspaceName = NULL;
    PyObject* py_TargetWorkspaceName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_xmlFile, &py_TargetWorkspaceName))
      goto ischemachangesinit_initfromschemadifferencesdocument_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_xmlFile))
        unicodexmlFile = PyUnicode_FromObject(pyvar_xmlFile);
    else if (PyUnicode_Check(pyvar_xmlFile))
    {
        unicodexmlFile = pyvar_xmlFile;
        Py_INCREF(unicodexmlFile);
    }
    else if (pyvar_xmlFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter xmlFile at index 0");
    if (unicodexmlFile)
        bsxmlFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodexmlFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodexmlFile));
    
    if (PyErr_Occurred())
      goto ischemachangesinit_initfromschemadifferencesdocument_method_cleanup;
    
    if (!IFaceFromPyObject(py_TargetWorkspaceName, &IID_IWorkspaceName, (void**)&ipTargetWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument TargetWorkspaceName (position 1) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ischemachangesinit_initfromschemadifferencesdocument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISchemaChangesInit->InitFromSchemaDifferencesDocument(bsxmlFile, ipTargetWorkspaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangesInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangesInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangesInit.InitFromSchemaDifferencesDocument() returned %ld", (long)hr);
        goto ischemachangesinit_initfromschemadifferencesdocument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for xmlFile
    // No teardown for TargetWorkspaceName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ischemachangesinit_initfromschemadifferencesdocument_method_cleanup;

    ischemachangesinit_initfromschemadifferencesdocument_method_cleanup:
    self->m_HR = hr;
    if (bsxmlFile)
        ::SysFreeString(bsxmlFile);
    
    if (ipTargetWorkspaceName)
      ipTargetWorkspaceName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangesInit.InitFromSchemaDifferencesDocument");
    return return_tuple;
}


PyMethodDef PyISchemaChangesInitMethods[] = {
    {"supports", (PyCFunction)PyISchemaChangesInit_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)ISchemaChangesInitMethod_Init, METH_VARARGS, ""},
    {"InitFromSchemaDocument", (PyCFunction)ISchemaChangesInitMethod_InitFromSchemaDocument, METH_VARARGS, ""},
    {"InitFromSchemaDifferencesDocument", (PyCFunction)ISchemaChangesInitMethod_InitFromSchemaDifferencesDocument, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISchemaChangesInitGetSet[] = {
  {"_pUnk", (getter)PyISchemaChangesInit_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISchemaChangesInit", NULL},
  {"_pointer", (getter)PyISchemaChangesInit_GetPointer, NULL, "Get memory address for ISchemaChangesInit", NULL},
  {"_IID", (getter)PyISchemaChangesInit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISchemaChangesInit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISchemaChangesInit_GetIgnoreFailures, (setter)PyISchemaChangesInit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISchemaChangesInitObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ISchemaChangesInitObject",                          
                                              /* tp_name */
  sizeof(PyISchemaChangesInitObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISchemaChangesInitObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISchemaChangesInitMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISchemaChangesInitGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISchemaChangesInitObject_new,                      
                                              /* tp_new */
};

// Interface IXMLDocumentVersion

typedef struct PyIXMLDocumentVersionObject {
    PyObject_HEAD
    IXMLDocumentVersion* m_pIXMLDocumentVersion;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIXMLDocumentVersionObject;

static PyObject*
PyIXMLDocumentVersionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIXMLDocumentVersionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IXMLDocumentVersion* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IXMLDocumentVersion, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IXMLDocumentVersion with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIXMLDocumentVersionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IXMLDocumentVersion");
            return NULL;
        }
        self->m_pIXMLDocumentVersion = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IXMLDocumentVersion");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IXMLDocumentVersion");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IXMLDocumentVersion* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IXMLDocumentVersion, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IXMLDocumentVersion");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIXMLDocumentVersionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IXMLDocumentVersion");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIXMLDocumentVersion = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIXMLDocumentVersionObject_dealloc(PyIXMLDocumentVersionObject* self)
{
    if (self->m_pIXMLDocumentVersion)
        self->m_pIXMLDocumentVersion->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIXMLDocumentVersion_GetpUnk(PyIXMLDocumentVersionObject* self)
{
    if (!self->m_pIXMLDocumentVersion)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIXMLDocumentVersion->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IXMLDocumentVersion to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIXMLDocumentVersion_GetPointer(PyIXMLDocumentVersionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIXMLDocumentVersion);
}

static PyObject*
PyIXMLDocumentVersion_GetIID(PyIXMLDocumentVersionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "80effd28-c665-47d2-aa21-c4196efcc9d3");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIXMLDocumentVersion_GetHR(PyIXMLDocumentVersionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIXMLDocumentVersion_GetIgnoreFailures(PyIXMLDocumentVersionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIXMLDocumentVersion_SetIgnoreFailures(PyIXMLDocumentVersionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIXMLDocumentVersion_SupportsInterface(PyIXMLDocumentVersionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIXMLDocumentVersion->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IXMLDocumentVersionMethod_put_NamespaceToExportTo(PyIXMLDocumentVersionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bs_arg1 = 0;
    PyObject* pyvar__arg1;
    PyObject* unicode_arg1 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar__arg1))
      goto ixmldocumentversion_put_namespacetoexportto_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar__arg1))
        unicode_arg1 = PyUnicode_FromObject(pyvar__arg1);
    else if (PyUnicode_Check(pyvar__arg1))
    {
        unicode_arg1 = pyvar__arg1;
        Py_INCREF(unicode_arg1);
    }
    else if (pyvar__arg1 != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter _arg1 at index 0");
    if (unicode_arg1)
        bs_arg1 = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicode_arg1), 
                                            (UINT)PyUnicode_GET_SIZE(unicode_arg1));
    
    if (PyErr_Occurred())
      goto ixmldocumentversion_put_namespacetoexportto_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIXMLDocumentVersion->put_NamespaceToExportTo(bs_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIXMLDocumentVersion->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IXMLDocumentVersion) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IXMLDocumentVersion.put_NamespaceToExportTo() returned %ld", (long)hr);
        goto ixmldocumentversion_put_namespacetoexportto_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ixmldocumentversion_put_namespacetoexportto_method_cleanup;

    ixmldocumentversion_put_namespacetoexportto_method_cleanup:
    self->m_HR = hr;
    if (bs_arg1)
        ::SysFreeString(bs_arg1);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IXMLDocumentVersion.put_NamespaceToExportTo");
    return return_tuple;
}


PyMethodDef PyIXMLDocumentVersionMethods[] = {
    {"supports", (PyCFunction)PyIXMLDocumentVersion_SupportsInterface, METH_O, ""},
    {"put_NamespaceToExportTo", (PyCFunction)IXMLDocumentVersionMethod_put_NamespaceToExportTo, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIXMLDocumentVersionGetSet[] = {
  {"_pUnk", (getter)PyIXMLDocumentVersion_GetpUnk, NULL, "Get opaque pointer to an Unknown from IXMLDocumentVersion", NULL},
  {"_pointer", (getter)PyIXMLDocumentVersion_GetPointer, NULL, "Get memory address for IXMLDocumentVersion", NULL},
  {"_IID", (getter)PyIXMLDocumentVersion_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIXMLDocumentVersion_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIXMLDocumentVersion_GetIgnoreFailures, (setter)PyIXMLDocumentVersion_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIXMLDocumentVersionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IXMLDocumentVersionObject",                          
                                              /* tp_name */
  sizeof(PyIXMLDocumentVersionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIXMLDocumentVersionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIXMLDocumentVersionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIXMLDocumentVersionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIXMLDocumentVersionObject_new,                      
                                              /* tp_new */
};

// Interface IReplicaProgress

typedef struct PyIReplicaProgressObject {
    PyObject_HEAD
    IReplicaProgress* m_pIReplicaProgress;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicaProgressObject;

static PyObject*
PyIReplicaProgressObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicaProgressObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicaProgress* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicaProgress, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicaProgress with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicaProgressObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaProgress");
            return NULL;
        }
        self->m_pIReplicaProgress = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicaProgress");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicaProgress");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicaProgress* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicaProgress, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicaProgress");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicaProgressObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaProgress");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicaProgress = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicaProgressObject_dealloc(PyIReplicaProgressObject* self)
{
    if (self->m_pIReplicaProgress)
        self->m_pIReplicaProgress->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicaProgress_GetpUnk(PyIReplicaProgressObject* self)
{
    if (!self->m_pIReplicaProgress)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicaProgress->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicaProgress to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicaProgress_GetPointer(PyIReplicaProgressObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicaProgress);
}

static PyObject*
PyIReplicaProgress_GetIID(PyIReplicaProgressObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5435d16a-5aa0-427f-bdad-24bd6aabf858");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicaProgress_GetHR(PyIReplicaProgressObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicaProgress_GetIgnoreFailures(PyIReplicaProgressObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicaProgress_SetIgnoreFailures(PyIReplicaProgressObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicaProgress_SupportsInterface(PyIReplicaProgressObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicaProgress->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicaProgressMethod_Startup(PyIReplicaProgressObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaProgress erProgress;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&erProgress))
      goto ireplicaprogress_startup_method_cleanup;

    // Set up initial variable values as needed
    // No setup for rProgress

    // Call method on actual COM interface
    hr = self->m_pIReplicaProgress->Startup(erProgress);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaProgress->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaProgress) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaProgress.Startup() returned %ld", (long)hr);
        goto ireplicaprogress_startup_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for rProgress

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicaprogress_startup_method_cleanup;

    ireplicaprogress_startup_method_cleanup:
    self->m_HR = hr;
    // No cleanup for rProgress
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaProgress.Startup");
    return return_tuple;
}

static PyObject*
IReplicaProgressMethod_put_CurrentReplicaOperation(PyIReplicaProgressObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaProgress e_arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&e_arg1))
      goto ireplicaprogress_put_currentreplicaoperation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIReplicaProgress->put_CurrentReplicaOperation(e_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaProgress->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaProgress) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaProgress.put_CurrentReplicaOperation() returned %ld", (long)hr);
        goto ireplicaprogress_put_currentreplicaoperation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicaprogress_put_currentreplicaoperation_method_cleanup;

    ireplicaprogress_put_currentreplicaoperation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaProgress.put_CurrentReplicaOperation");
    return return_tuple;
}

static PyObject*
IReplicaProgressMethod_put_ReplicaOperations(PyIReplicaProgressObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto ireplicaprogress_put_replicaoperations_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIReplicaProgress->put_ReplicaOperations(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaProgress->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaProgress) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaProgress.put_ReplicaOperations() returned %ld", (long)hr);
        goto ireplicaprogress_put_replicaoperations_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicaprogress_put_replicaoperations_method_cleanup;

    ireplicaprogress_put_replicaoperations_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaProgress.put_ReplicaOperations");
    return return_tuple;
}

static PyObject*
IReplicaProgressMethod_put_ReplicaObjectCount(PyIReplicaProgressObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto ireplicaprogress_put_replicaobjectcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIReplicaProgress->put_ReplicaObjectCount(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaProgress->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaProgress) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaProgress.put_ReplicaObjectCount() returned %ld", (long)hr);
        goto ireplicaprogress_put_replicaobjectcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicaprogress_put_replicaobjectcount_method_cleanup;

    ireplicaprogress_put_replicaobjectcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaProgress.put_ReplicaObjectCount");
    return return_tuple;
}


PyMethodDef PyIReplicaProgressMethods[] = {
    {"supports", (PyCFunction)PyIReplicaProgress_SupportsInterface, METH_O, ""},
    {"Startup", (PyCFunction)IReplicaProgressMethod_Startup, METH_VARARGS, ""},
    {"put_CurrentReplicaOperation", (PyCFunction)IReplicaProgressMethod_put_CurrentReplicaOperation, METH_VARARGS, ""},
    {"put_ReplicaOperations", (PyCFunction)IReplicaProgressMethod_put_ReplicaOperations, METH_VARARGS, ""},
    {"put_ReplicaObjectCount", (PyCFunction)IReplicaProgressMethod_put_ReplicaObjectCount, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicaProgressGetSet[] = {
  {"_pUnk", (getter)PyIReplicaProgress_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicaProgress", NULL},
  {"_pointer", (getter)PyIReplicaProgress_GetPointer, NULL, "Get memory address for IReplicaProgress", NULL},
  {"_IID", (getter)PyIReplicaProgress_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicaProgress_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicaProgress_GetIgnoreFailures, (setter)PyIReplicaProgress_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicaProgressObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicaProgressObject",                          
                                              /* tp_name */
  sizeof(PyIReplicaProgressObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicaProgressObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicaProgressMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicaProgressGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicaProgressObject_new,                      
                                              /* tp_new */
};

// Interface IOperationProgress

typedef struct PyIOperationProgressObject {
    PyObject_HEAD
    IOperationProgress* m_pIOperationProgress;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIOperationProgressObject;

static PyObject*
PyIOperationProgressObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIOperationProgressObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IOperationProgress* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IOperationProgress, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IOperationProgress with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIOperationProgressObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IOperationProgress");
            return NULL;
        }
        self->m_pIOperationProgress = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IOperationProgress");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IOperationProgress");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IOperationProgress* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IOperationProgress, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IOperationProgress");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIOperationProgressObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IOperationProgress");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIOperationProgress = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIOperationProgressObject_dealloc(PyIOperationProgressObject* self)
{
    if (self->m_pIOperationProgress)
        self->m_pIOperationProgress->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIOperationProgress_GetpUnk(PyIOperationProgressObject* self)
{
    if (!self->m_pIOperationProgress)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIOperationProgress->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IOperationProgress to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIOperationProgress_GetPointer(PyIOperationProgressObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIOperationProgress);
}

static PyObject*
PyIOperationProgress_GetIID(PyIOperationProgressObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7e1f4a6f-a857-475f-82ea-a089122dbdd4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIOperationProgress_GetHR(PyIOperationProgressObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIOperationProgress_GetIgnoreFailures(PyIOperationProgressObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIOperationProgress_SetIgnoreFailures(PyIOperationProgressObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIOperationProgress_SupportsInterface(PyIOperationProgressObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIOperationProgress->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IOperationProgressMethod_Startup(PyIOperationProgressObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriOperationProgress erProgress;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&erProgress))
      goto ioperationprogress_startup_method_cleanup;

    // Set up initial variable values as needed
    // No setup for rProgress

    // Call method on actual COM interface
    hr = self->m_pIOperationProgress->Startup(erProgress);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOperationProgress->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOperationProgress) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOperationProgress.Startup() returned %ld", (long)hr);
        goto ioperationprogress_startup_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for rProgress

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioperationprogress_startup_method_cleanup;

    ioperationprogress_startup_method_cleanup:
    self->m_HR = hr;
    // No cleanup for rProgress
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOperationProgress.Startup");
    return return_tuple;
}

static PyObject*
IOperationProgressMethod_put_CurrentOperation(PyIOperationProgressObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriOperationProgress e_arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&e_arg1))
      goto ioperationprogress_put_currentoperation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIOperationProgress->put_CurrentOperation(e_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOperationProgress->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOperationProgress) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOperationProgress.put_CurrentOperation() returned %ld", (long)hr);
        goto ioperationprogress_put_currentoperation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioperationprogress_put_currentoperation_method_cleanup;

    ioperationprogress_put_currentoperation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOperationProgress.put_CurrentOperation");
    return return_tuple;
}

static PyObject*
IOperationProgressMethod_put_Operations(PyIOperationProgressObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto ioperationprogress_put_operations_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIOperationProgress->put_Operations(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOperationProgress->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOperationProgress) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOperationProgress.put_Operations() returned %ld", (long)hr);
        goto ioperationprogress_put_operations_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioperationprogress_put_operations_method_cleanup;

    ioperationprogress_put_operations_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOperationProgress.put_Operations");
    return return_tuple;
}

static PyObject*
IOperationProgressMethod_put_ObjectCount(PyIOperationProgressObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto ioperationprogress_put_objectcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pIOperationProgress->put_ObjectCount(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIOperationProgress->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IOperationProgress) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IOperationProgress.put_ObjectCount() returned %ld", (long)hr);
        goto ioperationprogress_put_objectcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ioperationprogress_put_objectcount_method_cleanup;

    ioperationprogress_put_objectcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IOperationProgress.put_ObjectCount");
    return return_tuple;
}


PyMethodDef PyIOperationProgressMethods[] = {
    {"supports", (PyCFunction)PyIOperationProgress_SupportsInterface, METH_O, ""},
    {"Startup", (PyCFunction)IOperationProgressMethod_Startup, METH_VARARGS, ""},
    {"put_CurrentOperation", (PyCFunction)IOperationProgressMethod_put_CurrentOperation, METH_VARARGS, ""},
    {"put_Operations", (PyCFunction)IOperationProgressMethod_put_Operations, METH_VARARGS, ""},
    {"put_ObjectCount", (PyCFunction)IOperationProgressMethod_put_ObjectCount, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIOperationProgressGetSet[] = {
  {"_pUnk", (getter)PyIOperationProgress_GetpUnk, NULL, "Get opaque pointer to an Unknown from IOperationProgress", NULL},
  {"_pointer", (getter)PyIOperationProgress_GetPointer, NULL, "Get memory address for IOperationProgress", NULL},
  {"_IID", (getter)PyIOperationProgress_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIOperationProgress_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIOperationProgress_GetIgnoreFailures, (setter)PyIOperationProgress_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIOperationProgressObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IOperationProgressObject",                          
                                              /* tp_name */
  sizeof(PyIOperationProgressObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIOperationProgressObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIOperationProgressMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIOperationProgressGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIOperationProgressObject_new,                      
                                              /* tp_new */
};

// Interface IDataExtraction

typedef struct PyIDataExtractionObject {
    PyObject_HEAD
    IDataExtraction* m_pIDataExtraction;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataExtractionObject;

static PyObject*
PyIDataExtractionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataExtractionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataExtraction* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataExtraction, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataExtraction with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataExtractionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataExtraction");
            return NULL;
        }
        self->m_pIDataExtraction = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataExtraction");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataExtraction");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataExtraction* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataExtraction, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataExtraction");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataExtractionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataExtraction");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataExtraction = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataExtractionObject_dealloc(PyIDataExtractionObject* self)
{
    if (self->m_pIDataExtraction)
        self->m_pIDataExtraction->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataExtraction_GetpUnk(PyIDataExtractionObject* self)
{
    if (!self->m_pIDataExtraction)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataExtraction->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataExtraction to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataExtraction_GetPointer(PyIDataExtractionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataExtraction);
}

static PyObject*
PyIDataExtraction_GetIID(PyIDataExtractionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cf7e4cf0-e0c0-4302-ab42-c32899835602");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataExtraction_GetHR(PyIDataExtractionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataExtraction_GetIgnoreFailures(PyIDataExtractionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataExtraction_SetIgnoreFailures(PyIDataExtractionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataExtraction_SupportsInterface(PyIDataExtractionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataExtraction->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataExtractionMethod_Extract(PyIDataExtractionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplicaDescription* iprDDescription = NULL;
    PyObject* py_rDDescription;
    VARIANT_BOOL b_transferRelObjects = VARIANT_FALSE;
    PyObject* pyvar_transferRelObjects = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_rDDescription, &pyvar_transferRelObjects))
      goto idataextraction_extract_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_rDDescription, &IID_IReplicaDescription, (void**)&iprDDescription))
        PyErr_SetString(PyExc_TypeError, "Argument rDDescription (position 0) is not IReplicaDescription");
    
    if (PyErr_Occurred())
      goto idataextraction_extract_method_cleanup;
    
    b_transferRelObjects = ((PyObject_IsTrue(pyvar_transferRelObjects) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idataextraction_extract_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataExtraction->Extract(iprDDescription, b_transferRelObjects);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataExtraction->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataExtraction) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataExtraction.Extract() returned %ld", (long)hr);
        goto idataextraction_extract_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for rDDescription
    // No teardown for transferRelObjects

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idataextraction_extract_method_cleanup;

    idataextraction_extract_method_cleanup:
    self->m_HR = hr;
    if (iprDDescription)
      iprDDescription->Release();
    // No cleanup for transferRelObjects
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataExtraction.Extract");
    return return_tuple;
}

static PyObject*
IDataExtractionMethod_ExtractSchema(PyIDataExtractionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplicaDescription* iprSDescription = NULL;
    PyObject* py_rSDescription;
    ISpatialReference* ipoutputSpatialReference = NULL;
    PyObject* py_outputSpatialReference;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_rSDescription, &py_outputSpatialReference))
      goto idataextraction_extractschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_rSDescription, &IID_IReplicaDescription, (void**)&iprSDescription))
        PyErr_SetString(PyExc_TypeError, "Argument rSDescription (position 0) is not IReplicaDescription");
    
    if (PyErr_Occurred())
      goto idataextraction_extractschema_method_cleanup;
    
    if (!IFaceFromPyObject(py_outputSpatialReference, &IID_ISpatialReference, (void**)&ipoutputSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument outputSpatialReference (position 1) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto idataextraction_extractschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataExtraction->ExtractSchema(iprSDescription, ipoutputSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataExtraction->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataExtraction) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataExtraction.ExtractSchema() returned %ld", (long)hr);
        goto idataextraction_extractschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for rSDescription
    // No teardown for outputSpatialReference

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idataextraction_extractschema_method_cleanup;

    idataextraction_extractschema_method_cleanup:
    self->m_HR = hr;
    if (iprSDescription)
      iprSDescription->Release();
    if (ipoutputSpatialReference)
      ipoutputSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataExtraction.ExtractSchema");
    return return_tuple;
}


PyMethodDef PyIDataExtractionMethods[] = {
    {"supports", (PyCFunction)PyIDataExtraction_SupportsInterface, METH_O, ""},
    {"Extract", (PyCFunction)IDataExtractionMethod_Extract, METH_VARARGS, ""},
    {"ExtractSchema", (PyCFunction)IDataExtractionMethod_ExtractSchema, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataExtractionGetSet[] = {
  {"_pUnk", (getter)PyIDataExtraction_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataExtraction", NULL},
  {"_pointer", (getter)PyIDataExtraction_GetPointer, NULL, "Get memory address for IDataExtraction", NULL},
  {"_IID", (getter)PyIDataExtraction_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataExtraction_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataExtraction_GetIgnoreFailures, (setter)PyIDataExtraction_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataExtractionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDataExtractionObject",                          
                                              /* tp_name */
  sizeof(PyIDataExtractionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataExtractionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataExtractionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataExtractionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataExtractionObject_new,                      
                                              /* tp_new */
};

// Interface IReplicaDataChanges

typedef struct PyIReplicaDataChangesObject {
    PyObject_HEAD
    IReplicaDataChanges* m_pIReplicaDataChanges;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicaDataChangesObject;

static PyObject*
PyIReplicaDataChangesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicaDataChangesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicaDataChanges* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicaDataChanges, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicaDataChanges with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicaDataChangesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaDataChanges");
            return NULL;
        }
        self->m_pIReplicaDataChanges = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicaDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicaDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicaDataChanges* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicaDataChanges, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicaDataChanges");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicaDataChangesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaDataChanges");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicaDataChanges = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicaDataChangesObject_dealloc(PyIReplicaDataChangesObject* self)
{
    if (self->m_pIReplicaDataChanges)
        self->m_pIReplicaDataChanges->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicaDataChanges_GetpUnk(PyIReplicaDataChangesObject* self)
{
    if (!self->m_pIReplicaDataChanges)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicaDataChanges->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicaDataChanges to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicaDataChanges_GetPointer(PyIReplicaDataChangesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicaDataChanges);
}

static PyObject*
PyIReplicaDataChanges_GetIID(PyIReplicaDataChangesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8612b096-c19b-4197-80ac-86961ac9426c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicaDataChanges_GetHR(PyIReplicaDataChangesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicaDataChanges_GetIgnoreFailures(PyIReplicaDataChangesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicaDataChanges_SetIgnoreFailures(PyIReplicaDataChangesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicaDataChanges_SupportsInterface(PyIReplicaDataChangesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicaDataChanges->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicaDataChangesMethod_get_Workspace(PyIReplicaDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspace* ippWorkspace = NULL;
    PyObject* py_pWorkspace = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pWorkspace

    // Call method on actual COM interface
    hr = self->m_pIReplicaDataChanges->get_Workspace(&ippWorkspace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaDataChanges.get_Workspace() returned %ld", (long)hr);
        goto ireplicadatachanges_get_workspace_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pWorkspace);
    if (ippWorkspace)
    {
        IUnknown* pUnk = NULL;
        ippWorkspace->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pWorkspace = IUnknownToPythonIIDObject(pUnk, &IID_IWorkspace);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pWorkspace)
    {
        if (py_pWorkspace)
           Py_DECREF(py_pWorkspace);
        py_pWorkspace = Py_None;
        Py_INCREF(py_pWorkspace);
    }
    if (PyErr_Occurred())
      goto ireplicadatachanges_get_workspace_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pWorkspace);
    goto ireplicadatachanges_get_workspace_method_cleanup;

    ireplicadatachanges_get_workspace_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pWorkspace);
    if (ippWorkspace)
      ippWorkspace->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaDataChanges.get_Workspace");
    return return_tuple;
}


PyMethodDef PyIReplicaDataChangesMethods[] = {
    {"supports", (PyCFunction)PyIReplicaDataChanges_SupportsInterface, METH_O, ""},
    {"get_Workspace", (PyCFunction)IReplicaDataChangesMethod_get_Workspace, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicaDataChangesGetSet[] = {
  {"_pUnk", (getter)PyIReplicaDataChanges_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicaDataChanges", NULL},
  {"_pointer", (getter)PyIReplicaDataChanges_GetPointer, NULL, "Get memory address for IReplicaDataChanges", NULL},
  {"_IID", (getter)PyIReplicaDataChanges_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicaDataChanges_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicaDataChanges_GetIgnoreFailures, (setter)PyIReplicaDataChanges_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicaDataChangesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicaDataChangesObject",                          
                                              /* tp_name */
  sizeof(PyIReplicaDataChangesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicaDataChangesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicaDataChangesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicaDataChangesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicaDataChangesObject_new,                      
                                              /* tp_new */
};

// Interface IReplicaDataChangesInit

typedef struct PyIReplicaDataChangesInitObject {
    PyObject_HEAD
    IReplicaDataChangesInit* m_pIReplicaDataChangesInit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicaDataChangesInitObject;

static PyObject*
PyIReplicaDataChangesInitObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicaDataChangesInitObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicaDataChangesInit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicaDataChangesInit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicaDataChangesInit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicaDataChangesInitObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaDataChangesInit");
            return NULL;
        }
        self->m_pIReplicaDataChangesInit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicaDataChangesInit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicaDataChangesInit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicaDataChangesInit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicaDataChangesInit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicaDataChangesInit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicaDataChangesInitObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaDataChangesInit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicaDataChangesInit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicaDataChangesInitObject_dealloc(PyIReplicaDataChangesInitObject* self)
{
    if (self->m_pIReplicaDataChangesInit)
        self->m_pIReplicaDataChangesInit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicaDataChangesInit_GetpUnk(PyIReplicaDataChangesInitObject* self)
{
    if (!self->m_pIReplicaDataChangesInit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicaDataChangesInit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicaDataChangesInit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicaDataChangesInit_GetPointer(PyIReplicaDataChangesInitObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicaDataChangesInit);
}

static PyObject*
PyIReplicaDataChangesInit_GetIID(PyIReplicaDataChangesInitObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e513366a-6fe2-42d4-ac95-40dec7122f57");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicaDataChangesInit_GetHR(PyIReplicaDataChangesInitObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicaDataChangesInit_GetIgnoreFailures(PyIReplicaDataChangesInitObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicaDataChangesInit_SetIgnoreFailures(PyIReplicaDataChangesInitObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicaDataChangesInit_SupportsInterface(PyIReplicaDataChangesInitObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicaDataChangesInit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicaDataChangesInitMethod_Init(PyIReplicaDataChangesInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplica* ipReplica = NULL;
    PyObject* py_Replica;
    IWorkspaceName* ipcheckoutWorkspace = NULL;
    PyObject* py_checkoutWorkspace;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_Replica, &py_checkoutWorkspace))
      goto ireplicadatachangesinit_init_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Replica, &IID_IReplica, (void**)&ipReplica))
        PyErr_SetString(PyExc_TypeError, "Argument Replica (position 0) is not IReplica");
    
    if (PyErr_Occurred())
      goto ireplicadatachangesinit_init_method_cleanup;
    
    if (!IFaceFromPyObject(py_checkoutWorkspace, &IID_IWorkspaceName, (void**)&ipcheckoutWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument checkoutWorkspace (position 1) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicadatachangesinit_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicaDataChangesInit->Init(ipReplica, ipcheckoutWorkspace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaDataChangesInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaDataChangesInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaDataChangesInit.Init() returned %ld", (long)hr);
        goto ireplicadatachangesinit_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Replica
    // No teardown for checkoutWorkspace

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicadatachangesinit_init_method_cleanup;

    ireplicadatachangesinit_init_method_cleanup:
    self->m_HR = hr;
    if (ipReplica)
      ipReplica->Release();
    if (ipcheckoutWorkspace)
      ipcheckoutWorkspace->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaDataChangesInit.Init");
    return return_tuple;
}


PyMethodDef PyIReplicaDataChangesInitMethods[] = {
    {"supports", (PyCFunction)PyIReplicaDataChangesInit_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)IReplicaDataChangesInitMethod_Init, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicaDataChangesInitGetSet[] = {
  {"_pUnk", (getter)PyIReplicaDataChangesInit_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicaDataChangesInit", NULL},
  {"_pointer", (getter)PyIReplicaDataChangesInit_GetPointer, NULL, "Get memory address for IReplicaDataChangesInit", NULL},
  {"_IID", (getter)PyIReplicaDataChangesInit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicaDataChangesInit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicaDataChangesInit_GetIgnoreFailures, (setter)PyIReplicaDataChangesInit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicaDataChangesInitObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicaDataChangesInitObject",                          
                                              /* tp_name */
  sizeof(PyIReplicaDataChangesInitObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicaDataChangesInitObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicaDataChangesInitMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicaDataChangesInitGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicaDataChangesInitObject_new,                      
                                              /* tp_new */
};

// Interface IReplicaDataChangesInit2

typedef struct PyIReplicaDataChangesInit2Object {
    PyObject_HEAD
    IReplicaDataChangesInit2* m_pIReplicaDataChangesInit2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicaDataChangesInit2Object;

static PyObject*
PyIReplicaDataChangesInit2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicaDataChangesInit2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicaDataChangesInit2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicaDataChangesInit2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicaDataChangesInit2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicaDataChangesInit2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaDataChangesInit2");
            return NULL;
        }
        self->m_pIReplicaDataChangesInit2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicaDataChangesInit2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicaDataChangesInit2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicaDataChangesInit2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicaDataChangesInit2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicaDataChangesInit2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicaDataChangesInit2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaDataChangesInit2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicaDataChangesInit2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicaDataChangesInit2Object_dealloc(PyIReplicaDataChangesInit2Object* self)
{
    if (self->m_pIReplicaDataChangesInit2)
        self->m_pIReplicaDataChangesInit2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicaDataChangesInit2_GetpUnk(PyIReplicaDataChangesInit2Object* self)
{
    if (!self->m_pIReplicaDataChangesInit2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicaDataChangesInit2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicaDataChangesInit2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicaDataChangesInit2_GetPointer(PyIReplicaDataChangesInit2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicaDataChangesInit2);
}

static PyObject*
PyIReplicaDataChangesInit2_GetIID(PyIReplicaDataChangesInit2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "92267ee9-0766-43ea-ba8b-7dfd5c8e8517");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicaDataChangesInit2_GetHR(PyIReplicaDataChangesInit2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicaDataChangesInit2_GetIgnoreFailures(PyIReplicaDataChangesInit2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicaDataChangesInit2_SetIgnoreFailures(PyIReplicaDataChangesInit2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicaDataChangesInit2_SupportsInterface(PyIReplicaDataChangesInit2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicaDataChangesInit2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicaDataChangesInit2Method_Init2(PyIReplicaDataChangesInit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplica* ipReplica = NULL;
    PyObject* py_Replica;
    IWorkspaceName* ipcheckoutWorkspace = NULL;
    PyObject* py_checkoutWorkspace;
    esriExportGenerationsOption eGenOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOi", &py_Replica, &py_checkoutWorkspace, (int *)&eGenOption))
      goto ireplicadatachangesinit2_init2_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Replica, &IID_IReplica, (void**)&ipReplica))
        PyErr_SetString(PyExc_TypeError, "Argument Replica (position 0) is not IReplica");
    
    if (PyErr_Occurred())
      goto ireplicadatachangesinit2_init2_method_cleanup;
    
    if (!IFaceFromPyObject(py_checkoutWorkspace, &IID_IWorkspaceName, (void**)&ipcheckoutWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument checkoutWorkspace (position 1) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicadatachangesinit2_init2_method_cleanup;
    
    // No setup for GenOption

    // Call method on actual COM interface
    hr = self->m_pIReplicaDataChangesInit2->Init2(ipReplica, ipcheckoutWorkspace, eGenOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaDataChangesInit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaDataChangesInit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaDataChangesInit2.Init2() returned %ld", (long)hr);
        goto ireplicadatachangesinit2_init2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Replica
    // No teardown for checkoutWorkspace
    // No teardown for GenOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicadatachangesinit2_init2_method_cleanup;

    ireplicadatachangesinit2_init2_method_cleanup:
    self->m_HR = hr;
    if (ipReplica)
      ipReplica->Release();
    if (ipcheckoutWorkspace)
      ipcheckoutWorkspace->Release();
    // No cleanup for GenOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaDataChangesInit2.Init2");
    return return_tuple;
}

static PyObject*
IReplicaDataChangesInit2Method_Init(PyIReplicaDataChangesInit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplica* ipReplica = NULL;
    PyObject* py_Replica;
    IWorkspaceName* ipcheckoutWorkspace = NULL;
    PyObject* py_checkoutWorkspace;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_Replica, &py_checkoutWorkspace))
      goto ireplicadatachangesinit2_init_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Replica, &IID_IReplica, (void**)&ipReplica))
        PyErr_SetString(PyExc_TypeError, "Argument Replica (position 0) is not IReplica");
    
    if (PyErr_Occurred())
      goto ireplicadatachangesinit2_init_method_cleanup;
    
    if (!IFaceFromPyObject(py_checkoutWorkspace, &IID_IWorkspaceName, (void**)&ipcheckoutWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument checkoutWorkspace (position 1) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicadatachangesinit2_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicaDataChangesInit2->Init(ipReplica, ipcheckoutWorkspace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaDataChangesInit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaDataChangesInit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaDataChangesInit2.Init() returned %ld", (long)hr);
        goto ireplicadatachangesinit2_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Replica
    // No teardown for checkoutWorkspace

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicadatachangesinit2_init_method_cleanup;

    ireplicadatachangesinit2_init_method_cleanup:
    self->m_HR = hr;
    if (ipReplica)
      ipReplica->Release();
    if (ipcheckoutWorkspace)
      ipcheckoutWorkspace->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaDataChangesInit2.Init");
    return return_tuple;
}


PyMethodDef PyIReplicaDataChangesInit2Methods[] = {
    {"supports", (PyCFunction)PyIReplicaDataChangesInit2_SupportsInterface, METH_O, ""},
    {"Init2", (PyCFunction)IReplicaDataChangesInit2Method_Init2, METH_VARARGS, ""},
    {"Init", (PyCFunction)IReplicaDataChangesInit2Method_Init, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicaDataChangesInit2GetSet[] = {
  {"_pUnk", (getter)PyIReplicaDataChangesInit2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicaDataChangesInit2", NULL},
  {"_pointer", (getter)PyIReplicaDataChangesInit2_GetPointer, NULL, "Get memory address for IReplicaDataChangesInit2", NULL},
  {"_IID", (getter)PyIReplicaDataChangesInit2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicaDataChangesInit2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicaDataChangesInit2_GetIgnoreFailures, (setter)PyIReplicaDataChangesInit2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicaDataChangesInit2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicaDataChangesInit2Object",                          
                                              /* tp_name */
  sizeof(PyIReplicaDataChangesInit2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicaDataChangesInit2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicaDataChangesInit2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicaDataChangesInit2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicaDataChangesInit2Object_new,                      
                                              /* tp_new */
};

// Interface IDataChanges

typedef struct PyIDataChangesObject {
    PyObject_HEAD
    IDataChanges* m_pIDataChanges;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataChangesObject;

static PyObject*
PyIDataChangesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataChangesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataChanges* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataChanges, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataChanges with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataChangesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChanges");
            return NULL;
        }
        self->m_pIDataChanges = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataChanges* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataChanges, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataChanges");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataChangesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChanges");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataChanges = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataChangesObject_dealloc(PyIDataChangesObject* self)
{
    if (self->m_pIDataChanges)
        self->m_pIDataChanges->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataChanges_GetpUnk(PyIDataChangesObject* self)
{
    if (!self->m_pIDataChanges)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataChanges->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataChanges to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataChanges_GetPointer(PyIDataChangesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataChanges);
}

static PyObject*
PyIDataChanges_GetIID(PyIDataChangesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e0951743-0d52-42ff-ab5e-32d07b5b8951");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataChanges_GetHR(PyIDataChangesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataChanges_GetIgnoreFailures(PyIDataChangesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataChanges_SetIgnoreFailures(PyIDataChangesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataChanges_SupportsInterface(PyIDataChangesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataChanges->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataChangesMethod_GetModifiedClassesInfo(PyIDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumModifiedClassInfo* ipenumModifiedClasses = NULL;
    PyObject* py_enumModifiedClasses = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for enumModifiedClasses

    // Call method on actual COM interface
    hr = self->m_pIDataChanges->GetModifiedClassesInfo(&ipenumModifiedClasses);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges.GetModifiedClassesInfo() returned %ld", (long)hr);
        goto idatachanges_getmodifiedclassesinfo_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_enumModifiedClasses);
    if (ipenumModifiedClasses)
    {
        IUnknown* pUnk = NULL;
        ipenumModifiedClasses->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_enumModifiedClasses = IUnknownToPythonIIDObject(pUnk, &IID_IEnumModifiedClassInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_enumModifiedClasses)
    {
        if (py_enumModifiedClasses)
           Py_DECREF(py_enumModifiedClasses);
        py_enumModifiedClasses = Py_None;
        Py_INCREF(py_enumModifiedClasses);
    }
    if (PyErr_Occurred())
      goto idatachanges_getmodifiedclassesinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_enumModifiedClasses);
    goto idatachanges_getmodifiedclassesinfo_method_cleanup;

    idatachanges_getmodifiedclassesinfo_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_enumModifiedClasses);
    if (ipenumModifiedClasses)
      ipenumModifiedClasses->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges.GetModifiedClassesInfo");
    return return_tuple;
}

static PyObject*
IDataChangesMethod_Extract(PyIDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstableName = 0;
    PyObject* pyvar_tableName;
    PyObject* unicodetableName = NULL;
    esriDataChangeType echangeType;
    IDifferenceCursor* ipcursor = NULL;
    PyObject* py_cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_tableName, (int *)&echangeType))
      goto idatachanges_extract_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_tableName))
        unicodetableName = PyUnicode_FromObject(pyvar_tableName);
    else if (PyUnicode_Check(pyvar_tableName))
    {
        unicodetableName = pyvar_tableName;
        Py_INCREF(unicodetableName);
    }
    else if (pyvar_tableName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter tableName at index 0");
    if (unicodetableName)
        bstableName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetableName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetableName));
    
    if (PyErr_Occurred())
      goto idatachanges_extract_method_cleanup;
    
    // No setup for changeType
    // No setup for cursor

    // Call method on actual COM interface
    hr = self->m_pIDataChanges->Extract(bstableName, echangeType, &ipcursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges.Extract() returned %ld", (long)hr);
        goto idatachanges_extract_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for tableName
    // No teardown for changeType
    Py_XDECREF(py_cursor);
    if (ipcursor)
    {
        IUnknown* pUnk = NULL;
        ipcursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_cursor = IUnknownToPythonIIDObject(pUnk, &IID_IDifferenceCursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_cursor)
    {
        if (py_cursor)
           Py_DECREF(py_cursor);
        py_cursor = Py_None;
        Py_INCREF(py_cursor);
    }
    if (PyErr_Occurred())
      goto idatachanges_extract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_cursor);
    goto idatachanges_extract_method_cleanup;

    idatachanges_extract_method_cleanup:
    self->m_HR = hr;
    if (bstableName)
        ::SysFreeString(bstableName);
    
    // No cleanup for changeType
    Py_XDECREF(py_cursor);
    if (ipcursor)
      ipcursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges.Extract");
    return return_tuple;
}

static PyObject*
IDataChangesMethod_get_ParentWorkspaceName(PyIDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipParentWorkspaceName = NULL;
    PyObject* py_ParentWorkspaceName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentWorkspaceName

    // Call method on actual COM interface
    hr = self->m_pIDataChanges->get_ParentWorkspaceName(&ipParentWorkspaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges.get_ParentWorkspaceName() returned %ld", (long)hr);
        goto idatachanges_get_parentworkspacename_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ParentWorkspaceName);
    if (ipParentWorkspaceName)
    {
        IUnknown* pUnk = NULL;
        ipParentWorkspaceName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ParentWorkspaceName = IUnknownToPythonIIDObject(pUnk, &IID_IWorkspaceName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ParentWorkspaceName)
    {
        if (py_ParentWorkspaceName)
           Py_DECREF(py_ParentWorkspaceName);
        py_ParentWorkspaceName = Py_None;
        Py_INCREF(py_ParentWorkspaceName);
    }
    if (PyErr_Occurred())
      goto idatachanges_get_parentworkspacename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ParentWorkspaceName);
    goto idatachanges_get_parentworkspacename_method_cleanup;

    idatachanges_get_parentworkspacename_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ParentWorkspaceName);
    if (ipParentWorkspaceName)
      ipParentWorkspaceName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges.get_ParentWorkspaceName");
    return return_tuple;
}

static PyObject*
IDataChangesMethod_get_ParentReplicaID(PyIDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParentReplicaID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentReplicaID

    // Call method on actual COM interface
    hr = self->m_pIDataChanges->get_ParentReplicaID(&lParentReplicaID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges.get_ParentReplicaID() returned %ld", (long)hr);
        goto idatachanges_get_parentreplicaid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParentReplicaID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lParentReplicaID);
    goto idatachanges_get_parentreplicaid_method_cleanup;

    idatachanges_get_parentreplicaid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParentReplicaID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges.get_ParentReplicaID");
    return return_tuple;
}

static PyObject*
IDataChangesMethod_get_ReplicaGuid(PyIDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaGuid;
    PyObject* pyvar_ReplicaGuid = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ReplicaGuid

    // Call method on actual COM interface
    hr = self->m_pIDataChanges->get_ReplicaGuid(&bsReplicaGuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges.get_ReplicaGuid() returned %ld", (long)hr);
        goto idatachanges_get_replicaguid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ReplicaGuid = PyUnicode_FromWideChar(bsReplicaGuid,::SysStringLen(bsReplicaGuid));
    ::SysFreeString(bsReplicaGuid);
    
    if (PyErr_Occurred())
      goto idatachanges_get_replicaguid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ReplicaGuid);
    goto idatachanges_get_replicaguid_method_cleanup;

    idatachanges_get_replicaguid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ReplicaGuid != Py_None)
        Py_XDECREF(pyvar_ReplicaGuid);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges.get_ReplicaGuid");
    return return_tuple;
}


PyMethodDef PyIDataChangesMethods[] = {
    {"supports", (PyCFunction)PyIDataChanges_SupportsInterface, METH_O, ""},
    {"GetModifiedClassesInfo", (PyCFunction)IDataChangesMethod_GetModifiedClassesInfo, METH_VARARGS, ""},
    {"Extract", (PyCFunction)IDataChangesMethod_Extract, METH_VARARGS, ""},
    {"get_ParentWorkspaceName", (PyCFunction)IDataChangesMethod_get_ParentWorkspaceName, METH_VARARGS, ""},
    {"get_ParentReplicaID", (PyCFunction)IDataChangesMethod_get_ParentReplicaID, METH_VARARGS, ""},
    {"get_ReplicaGuid", (PyCFunction)IDataChangesMethod_get_ReplicaGuid, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataChangesGetSet[] = {
  {"_pUnk", (getter)PyIDataChanges_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataChanges", NULL},
  {"_pointer", (getter)PyIDataChanges_GetPointer, NULL, "Get memory address for IDataChanges", NULL},
  {"_IID", (getter)PyIDataChanges_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataChanges_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataChanges_GetIgnoreFailures, (setter)PyIDataChanges_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataChangesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDataChangesObject",                          
                                              /* tp_name */
  sizeof(PyIDataChangesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataChangesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataChangesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataChangesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataChangesObject_new,                      
                                              /* tp_new */
};

// Interface IExportDataChanges

typedef struct PyIExportDataChangesObject {
    PyObject_HEAD
    IExportDataChanges* m_pIExportDataChanges;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportDataChangesObject;

static PyObject*
PyIExportDataChangesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportDataChangesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportDataChanges* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportDataChanges, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportDataChanges with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportDataChangesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportDataChanges");
            return NULL;
        }
        self->m_pIExportDataChanges = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportDataChanges* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportDataChanges, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportDataChanges");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportDataChangesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportDataChanges");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportDataChanges = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportDataChangesObject_dealloc(PyIExportDataChangesObject* self)
{
    if (self->m_pIExportDataChanges)
        self->m_pIExportDataChanges->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportDataChanges_GetpUnk(PyIExportDataChangesObject* self)
{
    if (!self->m_pIExportDataChanges)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportDataChanges->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportDataChanges to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportDataChanges_GetPointer(PyIExportDataChangesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportDataChanges);
}

static PyObject*
PyIExportDataChanges_GetIID(PyIExportDataChangesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e290f6a3-535f-49a9-8fd4-c60fc44bf109");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportDataChanges_GetHR(PyIExportDataChangesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportDataChanges_GetIgnoreFailures(PyIExportDataChangesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportDataChanges_SetIgnoreFailures(PyIExportDataChangesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportDataChanges_SupportsInterface(PyIExportDataChangesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportDataChanges->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportDataChangesMethod_ExportDataChanges(PyIExportDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsexportFileName = 0;
    PyObject* pyvar_exportFileName;
    PyObject* unicodeexportFileName = NULL;
    esriExportDataChangesOption eexportOption;
    IDataChanges* ipDataChanges = NULL;
    PyObject* py_DataChanges;
    VARIANT_BOOL b_OverwriteIfExists = VARIANT_FALSE;
    PyObject* pyvar_OverwriteIfExists = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiOO", &pyvar_exportFileName, (int *)&eexportOption, &py_DataChanges, &pyvar_OverwriteIfExists))
      goto iexportdatachanges_exportdatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_exportFileName))
        unicodeexportFileName = PyUnicode_FromObject(pyvar_exportFileName);
    else if (PyUnicode_Check(pyvar_exportFileName))
    {
        unicodeexportFileName = pyvar_exportFileName;
        Py_INCREF(unicodeexportFileName);
    }
    else if (pyvar_exportFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter exportFileName at index 0");
    if (unicodeexportFileName)
        bsexportFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeexportFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeexportFileName));
    
    if (PyErr_Occurred())
      goto iexportdatachanges_exportdatachanges_method_cleanup;
    
    // No setup for exportOption
    if (!IFaceFromPyObject(py_DataChanges, &IID_IDataChanges, (void**)&ipDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DataChanges (position 2) is not IDataChanges");
    
    if (PyErr_Occurred())
      goto iexportdatachanges_exportdatachanges_method_cleanup;
    
    b_OverwriteIfExists = ((PyObject_IsTrue(pyvar_OverwriteIfExists) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges_exportdatachanges_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportDataChanges->ExportDataChanges(bsexportFileName, eexportOption, ipDataChanges, b_OverwriteIfExists);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportDataChanges.ExportDataChanges() returned %ld", (long)hr);
        goto iexportdatachanges_exportdatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for exportFileName
    // No teardown for exportOption
    // No teardown for DataChanges
    // No teardown for OverwriteIfExists

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportdatachanges_exportdatachanges_method_cleanup;

    iexportdatachanges_exportdatachanges_method_cleanup:
    self->m_HR = hr;
    if (bsexportFileName)
        ::SysFreeString(bsexportFileName);
    
    // No cleanup for exportOption
    if (ipDataChanges)
      ipDataChanges->Release();
    // No cleanup for OverwriteIfExists
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportDataChanges.ExportDataChanges");
    return return_tuple;
}


PyMethodDef PyIExportDataChangesMethods[] = {
    {"supports", (PyCFunction)PyIExportDataChanges_SupportsInterface, METH_O, ""},
    {"ExportDataChanges", (PyCFunction)IExportDataChangesMethod_ExportDataChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportDataChangesGetSet[] = {
  {"_pUnk", (getter)PyIExportDataChanges_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportDataChanges", NULL},
  {"_pointer", (getter)PyIExportDataChanges_GetPointer, NULL, "Get memory address for IExportDataChanges", NULL},
  {"_IID", (getter)PyIExportDataChanges_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportDataChanges_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportDataChanges_GetIgnoreFailures, (setter)PyIExportDataChanges_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportDataChangesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IExportDataChangesObject",                          
                                              /* tp_name */
  sizeof(PyIExportDataChangesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportDataChangesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportDataChangesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportDataChangesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportDataChangesObject_new,                      
                                              /* tp_new */
};

// Interface IExportDataChanges2

typedef struct PyIExportDataChanges2Object {
    PyObject_HEAD
    IExportDataChanges2* m_pIExportDataChanges2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportDataChanges2Object;

static PyObject*
PyIExportDataChanges2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportDataChanges2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportDataChanges2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportDataChanges2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportDataChanges2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportDataChanges2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportDataChanges2");
            return NULL;
        }
        self->m_pIExportDataChanges2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportDataChanges2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportDataChanges2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportDataChanges2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportDataChanges2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportDataChanges2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportDataChanges2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportDataChanges2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportDataChanges2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportDataChanges2Object_dealloc(PyIExportDataChanges2Object* self)
{
    if (self->m_pIExportDataChanges2)
        self->m_pIExportDataChanges2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportDataChanges2_GetpUnk(PyIExportDataChanges2Object* self)
{
    if (!self->m_pIExportDataChanges2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportDataChanges2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportDataChanges2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportDataChanges2_GetPointer(PyIExportDataChanges2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportDataChanges2);
}

static PyObject*
PyIExportDataChanges2_GetIID(PyIExportDataChanges2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8ec3471a-80e3-4552-9cc7-dfce334cc809");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportDataChanges2_GetHR(PyIExportDataChanges2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportDataChanges2_GetIgnoreFailures(PyIExportDataChanges2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportDataChanges2_SetIgnoreFailures(PyIExportDataChanges2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportDataChanges2_SupportsInterface(PyIExportDataChanges2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportDataChanges2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportDataChanges2Method_ExportDataChanges2(PyIExportDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsexportFileName = 0;
    PyObject* pyvar_exportFileName;
    PyObject* unicodeexportFileName = NULL;
    esriExportDataChangesOption eexportOption;
    IDataChanges* ipDataChanges = NULL;
    PyObject* py_DataChanges;
    VARIANT_BOOL b_OverwriteIfExists = VARIANT_FALSE;
    PyObject* pyvar_OverwriteIfExists = NULL;
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = NULL;
    VARIANT_BOOL b_BinaryGeometry = VARIANT_FALSE;
    PyObject* pyvar_BinaryGeometry = NULL;
    VARIANT_BOOL b_LastSend = VARIANT_FALSE;
    PyObject* pyvar_LastSend = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiOOOOO", &pyvar_exportFileName, (int *)&eexportOption, &py_DataChanges, &pyvar_OverwriteIfExists, &pyvar_Compressed, &pyvar_BinaryGeometry, &pyvar_LastSend))
      goto iexportdatachanges2_exportdatachanges2_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_exportFileName))
        unicodeexportFileName = PyUnicode_FromObject(pyvar_exportFileName);
    else if (PyUnicode_Check(pyvar_exportFileName))
    {
        unicodeexportFileName = pyvar_exportFileName;
        Py_INCREF(unicodeexportFileName);
    }
    else if (pyvar_exportFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter exportFileName at index 0");
    if (unicodeexportFileName)
        bsexportFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeexportFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeexportFileName));
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges2_method_cleanup;
    
    // No setup for exportOption
    if (!IFaceFromPyObject(py_DataChanges, &IID_IDataChanges, (void**)&ipDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DataChanges (position 2) is not IDataChanges");
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges2_method_cleanup;
    
    b_OverwriteIfExists = ((PyObject_IsTrue(pyvar_OverwriteIfExists) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges2_method_cleanup;
    
    b_Compressed = ((PyObject_IsTrue(pyvar_Compressed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges2_method_cleanup;
    
    b_BinaryGeometry = ((PyObject_IsTrue(pyvar_BinaryGeometry) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges2_method_cleanup;
    
    b_LastSend = ((PyObject_IsTrue(pyvar_LastSend) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportDataChanges2->ExportDataChanges2(bsexportFileName, eexportOption, ipDataChanges, b_OverwriteIfExists, b_Compressed, b_BinaryGeometry, b_LastSend);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportDataChanges2.ExportDataChanges2() returned %ld", (long)hr);
        goto iexportdatachanges2_exportdatachanges2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for exportFileName
    // No teardown for exportOption
    // No teardown for DataChanges
    // No teardown for OverwriteIfExists
    // No teardown for Compressed
    // No teardown for BinaryGeometry
    // No teardown for LastSend

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportdatachanges2_exportdatachanges2_method_cleanup;

    iexportdatachanges2_exportdatachanges2_method_cleanup:
    self->m_HR = hr;
    if (bsexportFileName)
        ::SysFreeString(bsexportFileName);
    
    // No cleanup for exportOption
    if (ipDataChanges)
      ipDataChanges->Release();
    // No cleanup for OverwriteIfExists
    // No cleanup for Compressed
    // No cleanup for BinaryGeometry
    // No cleanup for LastSend
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportDataChanges2.ExportDataChanges2");
    return return_tuple;
}

static PyObject*
IExportDataChanges2Method_ReExportDataChanges(PyIExportDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsexportFileName = 0;
    PyObject* pyvar_exportFileName;
    PyObject* unicodeexportFileName = NULL;
    esriExportDataChangesOption eexportOption;
    IReplica2* ipSourceReplica = NULL;
    PyObject* py_SourceReplica;
    esriReExportGenerationsOption eGenOption;
    VARIANT_BOOL b_OverwriteIfExists = VARIANT_FALSE;
    PyObject* pyvar_OverwriteIfExists = NULL;
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = NULL;
    VARIANT_BOOL b_BinaryGeometry = VARIANT_FALSE;
    PyObject* pyvar_BinaryGeometry = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiOiOOO", &pyvar_exportFileName, (int *)&eexportOption, &py_SourceReplica, (int *)&eGenOption, &pyvar_OverwriteIfExists, &pyvar_Compressed, &pyvar_BinaryGeometry))
      goto iexportdatachanges2_reexportdatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_exportFileName))
        unicodeexportFileName = PyUnicode_FromObject(pyvar_exportFileName);
    else if (PyUnicode_Check(pyvar_exportFileName))
    {
        unicodeexportFileName = pyvar_exportFileName;
        Py_INCREF(unicodeexportFileName);
    }
    else if (pyvar_exportFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter exportFileName at index 0");
    if (unicodeexportFileName)
        bsexportFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeexportFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeexportFileName));
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_reexportdatachanges_method_cleanup;
    
    // No setup for exportOption
    if (!IFaceFromPyObject(py_SourceReplica, &IID_IReplica2, (void**)&ipSourceReplica))
        PyErr_SetString(PyExc_TypeError, "Argument SourceReplica (position 2) is not IReplica2");
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_reexportdatachanges_method_cleanup;
    
    // No setup for GenOption
    b_OverwriteIfExists = ((PyObject_IsTrue(pyvar_OverwriteIfExists) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_reexportdatachanges_method_cleanup;
    
    b_Compressed = ((PyObject_IsTrue(pyvar_Compressed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_reexportdatachanges_method_cleanup;
    
    b_BinaryGeometry = ((PyObject_IsTrue(pyvar_BinaryGeometry) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_reexportdatachanges_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportDataChanges2->ReExportDataChanges(bsexportFileName, eexportOption, ipSourceReplica, eGenOption, b_OverwriteIfExists, b_Compressed, b_BinaryGeometry);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportDataChanges2.ReExportDataChanges() returned %ld", (long)hr);
        goto iexportdatachanges2_reexportdatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for exportFileName
    // No teardown for exportOption
    // No teardown for SourceReplica
    // No teardown for GenOption
    // No teardown for OverwriteIfExists
    // No teardown for Compressed
    // No teardown for BinaryGeometry

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportdatachanges2_reexportdatachanges_method_cleanup;

    iexportdatachanges2_reexportdatachanges_method_cleanup:
    self->m_HR = hr;
    if (bsexportFileName)
        ::SysFreeString(bsexportFileName);
    
    // No cleanup for exportOption
    if (ipSourceReplica)
      ipSourceReplica->Release();
    // No cleanup for GenOption
    // No cleanup for OverwriteIfExists
    // No cleanup for Compressed
    // No cleanup for BinaryGeometry
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportDataChanges2.ReExportDataChanges");
    return return_tuple;
}

static PyObject*
IExportDataChanges2Method_ExportDataChanges(PyIExportDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsexportFileName = 0;
    PyObject* pyvar_exportFileName;
    PyObject* unicodeexportFileName = NULL;
    esriExportDataChangesOption eexportOption;
    IDataChanges* ipDataChanges = NULL;
    PyObject* py_DataChanges;
    VARIANT_BOOL b_OverwriteIfExists = VARIANT_FALSE;
    PyObject* pyvar_OverwriteIfExists = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiOO", &pyvar_exportFileName, (int *)&eexportOption, &py_DataChanges, &pyvar_OverwriteIfExists))
      goto iexportdatachanges2_exportdatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_exportFileName))
        unicodeexportFileName = PyUnicode_FromObject(pyvar_exportFileName);
    else if (PyUnicode_Check(pyvar_exportFileName))
    {
        unicodeexportFileName = pyvar_exportFileName;
        Py_INCREF(unicodeexportFileName);
    }
    else if (pyvar_exportFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter exportFileName at index 0");
    if (unicodeexportFileName)
        bsexportFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeexportFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeexportFileName));
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges_method_cleanup;
    
    // No setup for exportOption
    if (!IFaceFromPyObject(py_DataChanges, &IID_IDataChanges, (void**)&ipDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DataChanges (position 2) is not IDataChanges");
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges_method_cleanup;
    
    b_OverwriteIfExists = ((PyObject_IsTrue(pyvar_OverwriteIfExists) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iexportdatachanges2_exportdatachanges_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportDataChanges2->ExportDataChanges(bsexportFileName, eexportOption, ipDataChanges, b_OverwriteIfExists);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportDataChanges2.ExportDataChanges() returned %ld", (long)hr);
        goto iexportdatachanges2_exportdatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for exportFileName
    // No teardown for exportOption
    // No teardown for DataChanges
    // No teardown for OverwriteIfExists

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportdatachanges2_exportdatachanges_method_cleanup;

    iexportdatachanges2_exportdatachanges_method_cleanup:
    self->m_HR = hr;
    if (bsexportFileName)
        ::SysFreeString(bsexportFileName);
    
    // No cleanup for exportOption
    if (ipDataChanges)
      ipDataChanges->Release();
    // No cleanup for OverwriteIfExists
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportDataChanges2.ExportDataChanges");
    return return_tuple;
}


PyMethodDef PyIExportDataChanges2Methods[] = {
    {"supports", (PyCFunction)PyIExportDataChanges2_SupportsInterface, METH_O, ""},
    {"ExportDataChanges2", (PyCFunction)IExportDataChanges2Method_ExportDataChanges2, METH_VARARGS, ""},
    {"ReExportDataChanges", (PyCFunction)IExportDataChanges2Method_ReExportDataChanges, METH_VARARGS, ""},
    {"ExportDataChanges", (PyCFunction)IExportDataChanges2Method_ExportDataChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportDataChanges2GetSet[] = {
  {"_pUnk", (getter)PyIExportDataChanges2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportDataChanges2", NULL},
  {"_pointer", (getter)PyIExportDataChanges2_GetPointer, NULL, "Get memory address for IExportDataChanges2", NULL},
  {"_IID", (getter)PyIExportDataChanges2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportDataChanges2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportDataChanges2_GetIgnoreFailures, (setter)PyIExportDataChanges2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportDataChanges2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IExportDataChanges2Object",                          
                                              /* tp_name */
  sizeof(PyIExportDataChanges2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportDataChanges2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportDataChanges2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportDataChanges2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportDataChanges2Object_new,                      
                                              /* tp_new */
};

// Interface IVersionDataChangesInit

typedef struct PyIVersionDataChangesInitObject {
    PyObject_HEAD
    IVersionDataChangesInit* m_pIVersionDataChangesInit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIVersionDataChangesInitObject;

static PyObject*
PyIVersionDataChangesInitObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIVersionDataChangesInitObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IVersionDataChangesInit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IVersionDataChangesInit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IVersionDataChangesInit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIVersionDataChangesInitObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IVersionDataChangesInit");
            return NULL;
        }
        self->m_pIVersionDataChangesInit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IVersionDataChangesInit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IVersionDataChangesInit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IVersionDataChangesInit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IVersionDataChangesInit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IVersionDataChangesInit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIVersionDataChangesInitObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IVersionDataChangesInit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIVersionDataChangesInit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIVersionDataChangesInitObject_dealloc(PyIVersionDataChangesInitObject* self)
{
    if (self->m_pIVersionDataChangesInit)
        self->m_pIVersionDataChangesInit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIVersionDataChangesInit_GetpUnk(PyIVersionDataChangesInitObject* self)
{
    if (!self->m_pIVersionDataChangesInit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIVersionDataChangesInit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IVersionDataChangesInit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIVersionDataChangesInit_GetPointer(PyIVersionDataChangesInitObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIVersionDataChangesInit);
}

static PyObject*
PyIVersionDataChangesInit_GetIID(PyIVersionDataChangesInitObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "51ddd7ac-b00b-420a-adb9-30540c7e81d4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIVersionDataChangesInit_GetHR(PyIVersionDataChangesInitObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIVersionDataChangesInit_GetIgnoreFailures(PyIVersionDataChangesInitObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIVersionDataChangesInit_SetIgnoreFailures(PyIVersionDataChangesInitObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIVersionDataChangesInit_SupportsInterface(PyIVersionDataChangesInitObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIVersionDataChangesInit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IVersionDataChangesInitMethod_Init(PyIVersionDataChangesInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipSourceVersionedWorkspace = NULL;
    PyObject* py_SourceVersionedWorkspace;
    IWorkspaceName* ipTargetVersionedWorkspace = NULL;
    PyObject* py_TargetVersionedWorkspace;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_SourceVersionedWorkspace, &py_TargetVersionedWorkspace))
      goto iversiondatachangesinit_init_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_SourceVersionedWorkspace, &IID_IWorkspaceName, (void**)&ipSourceVersionedWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument SourceVersionedWorkspace (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iversiondatachangesinit_init_method_cleanup;
    
    if (!IFaceFromPyObject(py_TargetVersionedWorkspace, &IID_IWorkspaceName, (void**)&ipTargetVersionedWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument TargetVersionedWorkspace (position 1) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iversiondatachangesinit_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIVersionDataChangesInit->Init(ipSourceVersionedWorkspace, ipTargetVersionedWorkspace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIVersionDataChangesInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IVersionDataChangesInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IVersionDataChangesInit.Init() returned %ld", (long)hr);
        goto iversiondatachangesinit_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SourceVersionedWorkspace
    // No teardown for TargetVersionedWorkspace

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iversiondatachangesinit_init_method_cleanup;

    iversiondatachangesinit_init_method_cleanup:
    self->m_HR = hr;
    if (ipSourceVersionedWorkspace)
      ipSourceVersionedWorkspace->Release();
    if (ipTargetVersionedWorkspace)
      ipTargetVersionedWorkspace->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IVersionDataChangesInit.Init");
    return return_tuple;
}


PyMethodDef PyIVersionDataChangesInitMethods[] = {
    {"supports", (PyCFunction)PyIVersionDataChangesInit_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)IVersionDataChangesInitMethod_Init, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIVersionDataChangesInitGetSet[] = {
  {"_pUnk", (getter)PyIVersionDataChangesInit_GetpUnk, NULL, "Get opaque pointer to an Unknown from IVersionDataChangesInit", NULL},
  {"_pointer", (getter)PyIVersionDataChangesInit_GetPointer, NULL, "Get memory address for IVersionDataChangesInit", NULL},
  {"_IID", (getter)PyIVersionDataChangesInit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIVersionDataChangesInit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIVersionDataChangesInit_GetIgnoreFailures, (setter)PyIVersionDataChangesInit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIVersionDataChangesInitObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IVersionDataChangesInitObject",                          
                                              /* tp_name */
  sizeof(PyIVersionDataChangesInitObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIVersionDataChangesInitObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIVersionDataChangesInitMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIVersionDataChangesInitGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIVersionDataChangesInitObject_new,                      
                                              /* tp_new */
};

// Interface IDeltaDataChanges

typedef struct PyIDeltaDataChangesObject {
    PyObject_HEAD
    IDeltaDataChanges* m_pIDeltaDataChanges;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDeltaDataChangesObject;

static PyObject*
PyIDeltaDataChangesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDeltaDataChangesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDeltaDataChanges* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDeltaDataChanges, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDeltaDataChanges with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDeltaDataChangesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChanges");
            return NULL;
        }
        self->m_pIDeltaDataChanges = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDeltaDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDeltaDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDeltaDataChanges* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDeltaDataChanges, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDeltaDataChanges");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDeltaDataChangesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChanges");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDeltaDataChanges = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDeltaDataChangesObject_dealloc(PyIDeltaDataChangesObject* self)
{
    if (self->m_pIDeltaDataChanges)
        self->m_pIDeltaDataChanges->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDeltaDataChanges_GetpUnk(PyIDeltaDataChangesObject* self)
{
    if (!self->m_pIDeltaDataChanges)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDeltaDataChanges->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDeltaDataChanges to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDeltaDataChanges_GetPointer(PyIDeltaDataChangesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDeltaDataChanges);
}

static PyObject*
PyIDeltaDataChanges_GetIID(PyIDeltaDataChangesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a598405f-8302-42b8-a6a2-121cbb2b3e0a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDeltaDataChanges_GetHR(PyIDeltaDataChangesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDeltaDataChanges_GetIgnoreFailures(PyIDeltaDataChangesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDeltaDataChanges_SetIgnoreFailures(PyIDeltaDataChangesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDeltaDataChanges_SupportsInterface(PyIDeltaDataChangesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDeltaDataChanges->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDeltaDataChangesMethod_get_Container(PyIDeltaDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ipContainer = NULL;
    PyObject* py_Container = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Container

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChanges->get_Container(&ipContainer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChanges.get_Container() returned %ld", (long)hr);
        goto ideltadatachanges_get_container_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Container);
    if (ipContainer)
    {
        IUnknown* pUnk = NULL;
        ipContainer->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Container = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Container)
    {
        if (py_Container)
           Py_DECREF(py_Container);
        py_Container = Py_None;
        Py_INCREF(py_Container);
    }
    if (PyErr_Occurred())
      goto ideltadatachanges_get_container_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Container);
    goto ideltadatachanges_get_container_method_cleanup;

    ideltadatachanges_get_container_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Container);
    if (ipContainer)
      ipContainer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChanges.get_Container");
    return return_tuple;
}


PyMethodDef PyIDeltaDataChangesMethods[] = {
    {"supports", (PyCFunction)PyIDeltaDataChanges_SupportsInterface, METH_O, ""},
    {"get_Container", (PyCFunction)IDeltaDataChangesMethod_get_Container, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDeltaDataChangesGetSet[] = {
  {"_pUnk", (getter)PyIDeltaDataChanges_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDeltaDataChanges", NULL},
  {"_pointer", (getter)PyIDeltaDataChanges_GetPointer, NULL, "Get memory address for IDeltaDataChanges", NULL},
  {"_IID", (getter)PyIDeltaDataChanges_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDeltaDataChanges_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDeltaDataChanges_GetIgnoreFailures, (setter)PyIDeltaDataChanges_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDeltaDataChangesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDeltaDataChangesObject",                          
                                              /* tp_name */
  sizeof(PyIDeltaDataChangesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDeltaDataChangesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDeltaDataChangesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDeltaDataChangesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDeltaDataChangesObject_new,                      
                                              /* tp_new */
};

// Interface IDeltaDataChanges2

typedef struct PyIDeltaDataChanges2Object {
    PyObject_HEAD
    IDeltaDataChanges2* m_pIDeltaDataChanges2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDeltaDataChanges2Object;

static PyObject*
PyIDeltaDataChanges2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDeltaDataChanges2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDeltaDataChanges2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDeltaDataChanges2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDeltaDataChanges2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDeltaDataChanges2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChanges2");
            return NULL;
        }
        self->m_pIDeltaDataChanges2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDeltaDataChanges2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDeltaDataChanges2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDeltaDataChanges2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDeltaDataChanges2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDeltaDataChanges2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDeltaDataChanges2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChanges2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDeltaDataChanges2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDeltaDataChanges2Object_dealloc(PyIDeltaDataChanges2Object* self)
{
    if (self->m_pIDeltaDataChanges2)
        self->m_pIDeltaDataChanges2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDeltaDataChanges2_GetpUnk(PyIDeltaDataChanges2Object* self)
{
    if (!self->m_pIDeltaDataChanges2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDeltaDataChanges2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDeltaDataChanges2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDeltaDataChanges2_GetPointer(PyIDeltaDataChanges2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDeltaDataChanges2);
}

static PyObject*
PyIDeltaDataChanges2_GetIID(PyIDeltaDataChanges2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "288ac87d-ed18-460b-b720-dc4d082da610");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDeltaDataChanges2_GetHR(PyIDeltaDataChanges2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDeltaDataChanges2_GetIgnoreFailures(PyIDeltaDataChanges2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDeltaDataChanges2_SetIgnoreFailures(PyIDeltaDataChanges2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDeltaDataChanges2_SupportsInterface(PyIDeltaDataChanges2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDeltaDataChanges2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDeltaDataChanges2Method_get_ReplicaMessageType(PyIDeltaDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaMessageType eMessageType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MessageType

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChanges2->get_ReplicaMessageType(&eMessageType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChanges2.get_ReplicaMessageType() returned %ld", (long)hr);
        goto ideltadatachanges2_get_replicamessagetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MessageType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eMessageType);
    goto ideltadatachanges2_get_replicamessagetype_method_cleanup;

    ideltadatachanges2_get_replicamessagetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for MessageType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChanges2.get_ReplicaMessageType");
    return return_tuple;
}

static PyObject*
IDeltaDataChanges2Method_get_Container(PyIDeltaDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ipContainer = NULL;
    PyObject* py_Container = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Container

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChanges2->get_Container(&ipContainer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChanges2.get_Container() returned %ld", (long)hr);
        goto ideltadatachanges2_get_container_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Container);
    if (ipContainer)
    {
        IUnknown* pUnk = NULL;
        ipContainer->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Container = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Container)
    {
        if (py_Container)
           Py_DECREF(py_Container);
        py_Container = Py_None;
        Py_INCREF(py_Container);
    }
    if (PyErr_Occurred())
      goto ideltadatachanges2_get_container_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Container);
    goto ideltadatachanges2_get_container_method_cleanup;

    ideltadatachanges2_get_container_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Container);
    if (ipContainer)
      ipContainer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChanges2.get_Container");
    return return_tuple;
}


PyMethodDef PyIDeltaDataChanges2Methods[] = {
    {"supports", (PyCFunction)PyIDeltaDataChanges2_SupportsInterface, METH_O, ""},
    {"get_ReplicaMessageType", (PyCFunction)IDeltaDataChanges2Method_get_ReplicaMessageType, METH_VARARGS, ""},
    {"get_Container", (PyCFunction)IDeltaDataChanges2Method_get_Container, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDeltaDataChanges2GetSet[] = {
  {"_pUnk", (getter)PyIDeltaDataChanges2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDeltaDataChanges2", NULL},
  {"_pointer", (getter)PyIDeltaDataChanges2_GetPointer, NULL, "Get memory address for IDeltaDataChanges2", NULL},
  {"_IID", (getter)PyIDeltaDataChanges2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDeltaDataChanges2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDeltaDataChanges2_GetIgnoreFailures, (setter)PyIDeltaDataChanges2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDeltaDataChanges2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDeltaDataChanges2Object",                          
                                              /* tp_name */
  sizeof(PyIDeltaDataChanges2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDeltaDataChanges2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDeltaDataChanges2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDeltaDataChanges2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDeltaDataChanges2Object_new,                      
                                              /* tp_new */
};

// Interface IDeltaDataChangesInit

typedef struct PyIDeltaDataChangesInitObject {
    PyObject_HEAD
    IDeltaDataChangesInit* m_pIDeltaDataChangesInit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDeltaDataChangesInitObject;

static PyObject*
PyIDeltaDataChangesInitObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDeltaDataChangesInitObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDeltaDataChangesInit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDeltaDataChangesInit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDeltaDataChangesInit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDeltaDataChangesInitObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChangesInit");
            return NULL;
        }
        self->m_pIDeltaDataChangesInit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDeltaDataChangesInit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDeltaDataChangesInit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDeltaDataChangesInit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDeltaDataChangesInit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDeltaDataChangesInit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDeltaDataChangesInitObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChangesInit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDeltaDataChangesInit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDeltaDataChangesInitObject_dealloc(PyIDeltaDataChangesInitObject* self)
{
    if (self->m_pIDeltaDataChangesInit)
        self->m_pIDeltaDataChangesInit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDeltaDataChangesInit_GetpUnk(PyIDeltaDataChangesInitObject* self)
{
    if (!self->m_pIDeltaDataChangesInit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDeltaDataChangesInit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDeltaDataChangesInit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDeltaDataChangesInit_GetPointer(PyIDeltaDataChangesInitObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDeltaDataChangesInit);
}

static PyObject*
PyIDeltaDataChangesInit_GetIID(PyIDeltaDataChangesInitObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "725451c9-cd9d-4431-8020-c9ed11bb40f0");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDeltaDataChangesInit_GetHR(PyIDeltaDataChangesInitObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDeltaDataChangesInit_GetIgnoreFailures(PyIDeltaDataChangesInitObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDeltaDataChangesInit_SetIgnoreFailures(PyIDeltaDataChangesInitObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDeltaDataChangesInit_SupportsInterface(PyIDeltaDataChangesInitObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDeltaDataChangesInit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDeltaDataChangesInitMethod_Init(PyIDeltaDataChangesInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bschangesFileName = 0;
    PyObject* pyvar_changesFileName;
    PyObject* unicodechangesFileName = NULL;
    esriExportDataChangesOption eexportOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_changesFileName, (int *)&eexportOption))
      goto ideltadatachangesinit_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_changesFileName))
        unicodechangesFileName = PyUnicode_FromObject(pyvar_changesFileName);
    else if (PyUnicode_Check(pyvar_changesFileName))
    {
        unicodechangesFileName = pyvar_changesFileName;
        Py_INCREF(unicodechangesFileName);
    }
    else if (pyvar_changesFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter changesFileName at index 0");
    if (unicodechangesFileName)
        bschangesFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodechangesFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodechangesFileName));
    
    if (PyErr_Occurred())
      goto ideltadatachangesinit_init_method_cleanup;
    
    // No setup for exportOption

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChangesInit->Init(bschangesFileName, eexportOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChangesInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChangesInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChangesInit.Init() returned %ld", (long)hr);
        goto ideltadatachangesinit_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for changesFileName
    // No teardown for exportOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideltadatachangesinit_init_method_cleanup;

    ideltadatachangesinit_init_method_cleanup:
    self->m_HR = hr;
    if (bschangesFileName)
        ::SysFreeString(bschangesFileName);
    
    // No cleanup for exportOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChangesInit.Init");
    return return_tuple;
}


PyMethodDef PyIDeltaDataChangesInitMethods[] = {
    {"supports", (PyCFunction)PyIDeltaDataChangesInit_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)IDeltaDataChangesInitMethod_Init, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDeltaDataChangesInitGetSet[] = {
  {"_pUnk", (getter)PyIDeltaDataChangesInit_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDeltaDataChangesInit", NULL},
  {"_pointer", (getter)PyIDeltaDataChangesInit_GetPointer, NULL, "Get memory address for IDeltaDataChangesInit", NULL},
  {"_IID", (getter)PyIDeltaDataChangesInit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDeltaDataChangesInit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDeltaDataChangesInit_GetIgnoreFailures, (setter)PyIDeltaDataChangesInit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDeltaDataChangesInitObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDeltaDataChangesInitObject",                          
                                              /* tp_name */
  sizeof(PyIDeltaDataChangesInitObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDeltaDataChangesInitObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDeltaDataChangesInitMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDeltaDataChangesInitGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDeltaDataChangesInitObject_new,                      
                                              /* tp_new */
};

// Interface IDeltaDataChangesInit2

typedef struct PyIDeltaDataChangesInit2Object {
    PyObject_HEAD
    IDeltaDataChangesInit2* m_pIDeltaDataChangesInit2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDeltaDataChangesInit2Object;

static PyObject*
PyIDeltaDataChangesInit2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDeltaDataChangesInit2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDeltaDataChangesInit2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDeltaDataChangesInit2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDeltaDataChangesInit2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDeltaDataChangesInit2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChangesInit2");
            return NULL;
        }
        self->m_pIDeltaDataChangesInit2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDeltaDataChangesInit2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDeltaDataChangesInit2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDeltaDataChangesInit2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDeltaDataChangesInit2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDeltaDataChangesInit2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDeltaDataChangesInit2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChangesInit2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDeltaDataChangesInit2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDeltaDataChangesInit2Object_dealloc(PyIDeltaDataChangesInit2Object* self)
{
    if (self->m_pIDeltaDataChangesInit2)
        self->m_pIDeltaDataChangesInit2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDeltaDataChangesInit2_GetpUnk(PyIDeltaDataChangesInit2Object* self)
{
    if (!self->m_pIDeltaDataChangesInit2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDeltaDataChangesInit2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDeltaDataChangesInit2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDeltaDataChangesInit2_GetPointer(PyIDeltaDataChangesInit2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDeltaDataChangesInit2);
}

static PyObject*
PyIDeltaDataChangesInit2_GetIID(PyIDeltaDataChangesInit2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4c7fd0cf-fa09-4d49-b168-4767cf945c14");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDeltaDataChangesInit2_GetHR(PyIDeltaDataChangesInit2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDeltaDataChangesInit2_GetIgnoreFailures(PyIDeltaDataChangesInit2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDeltaDataChangesInit2_SetIgnoreFailures(PyIDeltaDataChangesInit2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDeltaDataChangesInit2_SupportsInterface(PyIDeltaDataChangesInit2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDeltaDataChangesInit2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDeltaDataChangesInit2Method_Init2(PyIDeltaDataChangesInit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bschangesFileName = 0;
    PyObject* pyvar_changesFileName;
    PyObject* unicodechangesFileName = NULL;
    esriExportDataChangesOption eexportOption;
    VARIANT_BOOL b_RandomAccess = VARIANT_FALSE;
    PyObject* pyvar_RandomAccess = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiO", &pyvar_changesFileName, (int *)&eexportOption, &pyvar_RandomAccess))
      goto ideltadatachangesinit2_init2_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_changesFileName))
        unicodechangesFileName = PyUnicode_FromObject(pyvar_changesFileName);
    else if (PyUnicode_Check(pyvar_changesFileName))
    {
        unicodechangesFileName = pyvar_changesFileName;
        Py_INCREF(unicodechangesFileName);
    }
    else if (pyvar_changesFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter changesFileName at index 0");
    if (unicodechangesFileName)
        bschangesFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodechangesFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodechangesFileName));
    
    if (PyErr_Occurred())
      goto ideltadatachangesinit2_init2_method_cleanup;
    
    // No setup for exportOption
    b_RandomAccess = ((PyObject_IsTrue(pyvar_RandomAccess) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ideltadatachangesinit2_init2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChangesInit2->Init2(bschangesFileName, eexportOption, b_RandomAccess);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChangesInit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChangesInit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChangesInit2.Init2() returned %ld", (long)hr);
        goto ideltadatachangesinit2_init2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for changesFileName
    // No teardown for exportOption
    // No teardown for RandomAccess

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideltadatachangesinit2_init2_method_cleanup;

    ideltadatachangesinit2_init2_method_cleanup:
    self->m_HR = hr;
    if (bschangesFileName)
        ::SysFreeString(bschangesFileName);
    
    // No cleanup for exportOption
    // No cleanup for RandomAccess
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChangesInit2.Init2");
    return return_tuple;
}

static PyObject*
IDeltaDataChangesInit2Method_Init(PyIDeltaDataChangesInit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bschangesFileName = 0;
    PyObject* pyvar_changesFileName;
    PyObject* unicodechangesFileName = NULL;
    esriExportDataChangesOption eexportOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_changesFileName, (int *)&eexportOption))
      goto ideltadatachangesinit2_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_changesFileName))
        unicodechangesFileName = PyUnicode_FromObject(pyvar_changesFileName);
    else if (PyUnicode_Check(pyvar_changesFileName))
    {
        unicodechangesFileName = pyvar_changesFileName;
        Py_INCREF(unicodechangesFileName);
    }
    else if (pyvar_changesFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter changesFileName at index 0");
    if (unicodechangesFileName)
        bschangesFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodechangesFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodechangesFileName));
    
    if (PyErr_Occurred())
      goto ideltadatachangesinit2_init_method_cleanup;
    
    // No setup for exportOption

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChangesInit2->Init(bschangesFileName, eexportOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChangesInit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChangesInit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChangesInit2.Init() returned %ld", (long)hr);
        goto ideltadatachangesinit2_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for changesFileName
    // No teardown for exportOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideltadatachangesinit2_init_method_cleanup;

    ideltadatachangesinit2_init_method_cleanup:
    self->m_HR = hr;
    if (bschangesFileName)
        ::SysFreeString(bschangesFileName);
    
    // No cleanup for exportOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChangesInit2.Init");
    return return_tuple;
}


PyMethodDef PyIDeltaDataChangesInit2Methods[] = {
    {"supports", (PyCFunction)PyIDeltaDataChangesInit2_SupportsInterface, METH_O, ""},
    {"Init2", (PyCFunction)IDeltaDataChangesInit2Method_Init2, METH_VARARGS, ""},
    {"Init", (PyCFunction)IDeltaDataChangesInit2Method_Init, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDeltaDataChangesInit2GetSet[] = {
  {"_pUnk", (getter)PyIDeltaDataChangesInit2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDeltaDataChangesInit2", NULL},
  {"_pointer", (getter)PyIDeltaDataChangesInit2_GetPointer, NULL, "Get memory address for IDeltaDataChangesInit2", NULL},
  {"_IID", (getter)PyIDeltaDataChangesInit2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDeltaDataChangesInit2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDeltaDataChangesInit2_GetIgnoreFailures, (setter)PyIDeltaDataChangesInit2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDeltaDataChangesInit2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDeltaDataChangesInit2Object",                          
                                              /* tp_name */
  sizeof(PyIDeltaDataChangesInit2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDeltaDataChangesInit2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDeltaDataChangesInit2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDeltaDataChangesInit2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDeltaDataChangesInit2Object_new,                      
                                              /* tp_new */
};

// Interface IDeltaDataChangesRelease

typedef struct PyIDeltaDataChangesReleaseObject {
    PyObject_HEAD
    IDeltaDataChangesRelease* m_pIDeltaDataChangesRelease;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDeltaDataChangesReleaseObject;

static PyObject*
PyIDeltaDataChangesReleaseObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDeltaDataChangesReleaseObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDeltaDataChangesRelease* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDeltaDataChangesRelease, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDeltaDataChangesRelease with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDeltaDataChangesReleaseObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChangesRelease");
            return NULL;
        }
        self->m_pIDeltaDataChangesRelease = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDeltaDataChangesRelease");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDeltaDataChangesRelease");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDeltaDataChangesRelease* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDeltaDataChangesRelease, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDeltaDataChangesRelease");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDeltaDataChangesReleaseObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDeltaDataChangesRelease");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDeltaDataChangesRelease = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDeltaDataChangesReleaseObject_dealloc(PyIDeltaDataChangesReleaseObject* self)
{
    if (self->m_pIDeltaDataChangesRelease)
        self->m_pIDeltaDataChangesRelease->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDeltaDataChangesRelease_GetpUnk(PyIDeltaDataChangesReleaseObject* self)
{
    if (!self->m_pIDeltaDataChangesRelease)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDeltaDataChangesRelease->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDeltaDataChangesRelease to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDeltaDataChangesRelease_GetPointer(PyIDeltaDataChangesReleaseObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDeltaDataChangesRelease);
}

static PyObject*
PyIDeltaDataChangesRelease_GetIID(PyIDeltaDataChangesReleaseObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cb41732d-ec82-4e84-bfc1-a9a1135b02b5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDeltaDataChangesRelease_GetHR(PyIDeltaDataChangesReleaseObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDeltaDataChangesRelease_GetIgnoreFailures(PyIDeltaDataChangesReleaseObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDeltaDataChangesRelease_SetIgnoreFailures(PyIDeltaDataChangesReleaseObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDeltaDataChangesRelease_SupportsInterface(PyIDeltaDataChangesReleaseObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDeltaDataChangesRelease->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDeltaDataChangesReleaseMethod_get_MajorVersion(PyIDeltaDataChangesReleaseObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lversionNumber = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for versionNumber

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChangesRelease->get_MajorVersion(&lversionNumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChangesRelease->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChangesRelease) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChangesRelease.get_MajorVersion() returned %ld", (long)hr);
        goto ideltadatachangesrelease_get_majorversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionNumber

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lversionNumber);
    goto ideltadatachangesrelease_get_majorversion_method_cleanup;

    ideltadatachangesrelease_get_majorversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for versionNumber
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChangesRelease.get_MajorVersion");
    return return_tuple;
}

static PyObject*
IDeltaDataChangesReleaseMethod_get_MinorVersion(PyIDeltaDataChangesReleaseObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lversionNumber = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for versionNumber

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChangesRelease->get_MinorVersion(&lversionNumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChangesRelease->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChangesRelease) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChangesRelease.get_MinorVersion() returned %ld", (long)hr);
        goto ideltadatachangesrelease_get_minorversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionNumber

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lversionNumber);
    goto ideltadatachangesrelease_get_minorversion_method_cleanup;

    ideltadatachangesrelease_get_minorversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for versionNumber
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChangesRelease.get_MinorVersion");
    return return_tuple;
}

static PyObject*
IDeltaDataChangesReleaseMethod_get_BugfixVersion(PyIDeltaDataChangesReleaseObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lversionNumber = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for versionNumber

    // Call method on actual COM interface
    hr = self->m_pIDeltaDataChangesRelease->get_BugfixVersion(&lversionNumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDeltaDataChangesRelease->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDeltaDataChangesRelease) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDeltaDataChangesRelease.get_BugfixVersion() returned %ld", (long)hr);
        goto ideltadatachangesrelease_get_bugfixversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionNumber

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lversionNumber);
    goto ideltadatachangesrelease_get_bugfixversion_method_cleanup;

    ideltadatachangesrelease_get_bugfixversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for versionNumber
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDeltaDataChangesRelease.get_BugfixVersion");
    return return_tuple;
}


PyMethodDef PyIDeltaDataChangesReleaseMethods[] = {
    {"supports", (PyCFunction)PyIDeltaDataChangesRelease_SupportsInterface, METH_O, ""},
    {"get_MajorVersion", (PyCFunction)IDeltaDataChangesReleaseMethod_get_MajorVersion, METH_VARARGS, ""},
    {"get_MinorVersion", (PyCFunction)IDeltaDataChangesReleaseMethod_get_MinorVersion, METH_VARARGS, ""},
    {"get_BugfixVersion", (PyCFunction)IDeltaDataChangesReleaseMethod_get_BugfixVersion, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDeltaDataChangesReleaseGetSet[] = {
  {"_pUnk", (getter)PyIDeltaDataChangesRelease_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDeltaDataChangesRelease", NULL},
  {"_pointer", (getter)PyIDeltaDataChangesRelease_GetPointer, NULL, "Get memory address for IDeltaDataChangesRelease", NULL},
  {"_IID", (getter)PyIDeltaDataChangesRelease_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDeltaDataChangesRelease_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDeltaDataChangesRelease_GetIgnoreFailures, (setter)PyIDeltaDataChangesRelease_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDeltaDataChangesReleaseObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDeltaDataChangesReleaseObject",                          
                                              /* tp_name */
  sizeof(PyIDeltaDataChangesReleaseObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDeltaDataChangesReleaseObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDeltaDataChangesReleaseMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDeltaDataChangesReleaseGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDeltaDataChangesReleaseObject_new,                      
                                              /* tp_new */
};

// Interface IGdbXmlExport

typedef struct PyIGdbXmlExportObject {
    PyObject_HEAD
    IGdbXmlExport* m_pIGdbXmlExport;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGdbXmlExportObject;

static PyObject*
PyIGdbXmlExportObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGdbXmlExportObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGdbXmlExport* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGdbXmlExport, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGdbXmlExport with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGdbXmlExportObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGdbXmlExport");
            return NULL;
        }
        self->m_pIGdbXmlExport = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGdbXmlExport");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGdbXmlExport");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGdbXmlExport* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGdbXmlExport, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGdbXmlExport");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGdbXmlExportObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGdbXmlExport");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGdbXmlExport = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGdbXmlExportObject_dealloc(PyIGdbXmlExportObject* self)
{
    if (self->m_pIGdbXmlExport)
        self->m_pIGdbXmlExport->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGdbXmlExport_GetpUnk(PyIGdbXmlExportObject* self)
{
    if (!self->m_pIGdbXmlExport)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGdbXmlExport->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGdbXmlExport to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGdbXmlExport_GetPointer(PyIGdbXmlExportObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGdbXmlExport);
}

static PyObject*
PyIGdbXmlExport_GetIID(PyIGdbXmlExportObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1f88e412-18ce-4324-a1e5-d1a32d5dff4a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGdbXmlExport_GetHR(PyIGdbXmlExportObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGdbXmlExport_GetIgnoreFailures(PyIGdbXmlExportObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGdbXmlExport_SetIgnoreFailures(PyIGdbXmlExportObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGdbXmlExport_SupportsInterface(PyIGdbXmlExportObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGdbXmlExport->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGdbXmlExportMethod_ExportWorkspace(PyIGdbXmlExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspace* ipWorkspace = NULL;
    PyObject* py_Workspace;
    BSTR bsoutFile = 0;
    PyObject* pyvar_outFile;
    PyObject* unicodeoutFile = NULL;
    VARIANT_BOOL b_BinaryGeometry = VARIANT_FALSE;
    PyObject* pyvar_BinaryGeometry = NULL;
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = NULL;
    VARIANT_BOOL b_retrieveMetadata = VARIANT_FALSE;
    PyObject* pyvar_retrieveMetadata = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOO", &py_Workspace, &pyvar_outFile, &pyvar_BinaryGeometry, &pyvar_Compressed, &pyvar_retrieveMetadata))
      goto igdbxmlexport_exportworkspace_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Workspace, &IID_IWorkspace, (void**)&ipWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument Workspace (position 0) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspace_method_cleanup;
    
    if (PyString_Check(pyvar_outFile))
        unicodeoutFile = PyUnicode_FromObject(pyvar_outFile);
    else if (PyUnicode_Check(pyvar_outFile))
    {
        unicodeoutFile = pyvar_outFile;
        Py_INCREF(unicodeoutFile);
    }
    else if (pyvar_outFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter outFile at index 1");
    if (unicodeoutFile)
        bsoutFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeoutFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeoutFile));
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspace_method_cleanup;
    
    b_BinaryGeometry = ((PyObject_IsTrue(pyvar_BinaryGeometry) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspace_method_cleanup;
    
    b_Compressed = ((PyObject_IsTrue(pyvar_Compressed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspace_method_cleanup;
    
    b_retrieveMetadata = ((PyObject_IsTrue(pyvar_retrieveMetadata) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspace_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlExport->ExportWorkspace(ipWorkspace, bsoutFile, b_BinaryGeometry, b_Compressed, b_retrieveMetadata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlExport.ExportWorkspace() returned %ld", (long)hr);
        goto igdbxmlexport_exportworkspace_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Workspace
    // No teardown for outFile
    // No teardown for BinaryGeometry
    // No teardown for Compressed
    // No teardown for retrieveMetadata

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbxmlexport_exportworkspace_method_cleanup;

    igdbxmlexport_exportworkspace_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspace)
      ipWorkspace->Release();
    if (bsoutFile)
        ::SysFreeString(bsoutFile);
    
    // No cleanup for BinaryGeometry
    // No cleanup for Compressed
    // No cleanup for retrieveMetadata
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlExport.ExportWorkspace");
    return return_tuple;
}

static PyObject*
IGdbXmlExportMethod_ExportWorkspaceSchema(PyIGdbXmlExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspace* ipWorkspace = NULL;
    PyObject* py_Workspace;
    BSTR bsoutFile = 0;
    PyObject* pyvar_outFile;
    PyObject* unicodeoutFile = NULL;
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = NULL;
    VARIANT_BOOL b_retrieveMetadata = VARIANT_FALSE;
    PyObject* pyvar_retrieveMetadata = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_Workspace, &pyvar_outFile, &pyvar_Compressed, &pyvar_retrieveMetadata))
      goto igdbxmlexport_exportworkspaceschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Workspace, &IID_IWorkspace, (void**)&ipWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument Workspace (position 0) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspaceschema_method_cleanup;
    
    if (PyString_Check(pyvar_outFile))
        unicodeoutFile = PyUnicode_FromObject(pyvar_outFile);
    else if (PyUnicode_Check(pyvar_outFile))
    {
        unicodeoutFile = pyvar_outFile;
        Py_INCREF(unicodeoutFile);
    }
    else if (pyvar_outFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter outFile at index 1");
    if (unicodeoutFile)
        bsoutFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeoutFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeoutFile));
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspaceschema_method_cleanup;
    
    b_Compressed = ((PyObject_IsTrue(pyvar_Compressed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspaceschema_method_cleanup;
    
    b_retrieveMetadata = ((PyObject_IsTrue(pyvar_retrieveMetadata) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportworkspaceschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlExport->ExportWorkspaceSchema(ipWorkspace, bsoutFile, b_Compressed, b_retrieveMetadata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlExport.ExportWorkspaceSchema() returned %ld", (long)hr);
        goto igdbxmlexport_exportworkspaceschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Workspace
    // No teardown for outFile
    // No teardown for Compressed
    // No teardown for retrieveMetadata

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbxmlexport_exportworkspaceschema_method_cleanup;

    igdbxmlexport_exportworkspaceschema_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspace)
      ipWorkspace->Release();
    if (bsoutFile)
        ::SysFreeString(bsoutFile);
    
    // No cleanup for Compressed
    // No cleanup for retrieveMetadata
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlExport.ExportWorkspaceSchema");
    return return_tuple;
}

static PyObject*
IGdbXmlExportMethod_ExportDatasets(PyIGdbXmlExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumNameMapping* ipEnumNameMapping = NULL;
    PyObject* py_EnumNameMapping;
    BSTR bsoutFile = 0;
    PyObject* pyvar_outFile;
    PyObject* unicodeoutFile = NULL;
    VARIANT_BOOL b_BinaryGeometry = VARIANT_FALSE;
    PyObject* pyvar_BinaryGeometry = NULL;
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = NULL;
    VARIANT_BOOL b_retrieveMetadata = VARIANT_FALSE;
    PyObject* pyvar_retrieveMetadata = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOO", &py_EnumNameMapping, &pyvar_outFile, &pyvar_BinaryGeometry, &pyvar_Compressed, &pyvar_retrieveMetadata))
      goto igdbxmlexport_exportdatasets_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_EnumNameMapping, &IID_IEnumNameMapping, (void**)&ipEnumNameMapping))
        PyErr_SetString(PyExc_TypeError, "Argument EnumNameMapping (position 0) is not IEnumNameMapping");
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasets_method_cleanup;
    
    if (PyString_Check(pyvar_outFile))
        unicodeoutFile = PyUnicode_FromObject(pyvar_outFile);
    else if (PyUnicode_Check(pyvar_outFile))
    {
        unicodeoutFile = pyvar_outFile;
        Py_INCREF(unicodeoutFile);
    }
    else if (pyvar_outFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter outFile at index 1");
    if (unicodeoutFile)
        bsoutFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeoutFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeoutFile));
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasets_method_cleanup;
    
    b_BinaryGeometry = ((PyObject_IsTrue(pyvar_BinaryGeometry) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasets_method_cleanup;
    
    b_Compressed = ((PyObject_IsTrue(pyvar_Compressed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasets_method_cleanup;
    
    b_retrieveMetadata = ((PyObject_IsTrue(pyvar_retrieveMetadata) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasets_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlExport->ExportDatasets(ipEnumNameMapping, bsoutFile, b_BinaryGeometry, b_Compressed, b_retrieveMetadata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlExport.ExportDatasets() returned %ld", (long)hr);
        goto igdbxmlexport_exportdatasets_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for EnumNameMapping
    // No teardown for outFile
    // No teardown for BinaryGeometry
    // No teardown for Compressed
    // No teardown for retrieveMetadata

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbxmlexport_exportdatasets_method_cleanup;

    igdbxmlexport_exportdatasets_method_cleanup:
    self->m_HR = hr;
    if (ipEnumNameMapping)
      ipEnumNameMapping->Release();
    if (bsoutFile)
        ::SysFreeString(bsoutFile);
    
    // No cleanup for BinaryGeometry
    // No cleanup for Compressed
    // No cleanup for retrieveMetadata
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlExport.ExportDatasets");
    return return_tuple;
}

static PyObject*
IGdbXmlExportMethod_ExportDatasetsSchema(PyIGdbXmlExportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumNameMapping* ipEnumNameMapping = NULL;
    PyObject* py_EnumNameMapping;
    BSTR bsoutFile = 0;
    PyObject* pyvar_outFile;
    PyObject* unicodeoutFile = NULL;
    VARIANT_BOOL b_Compressed = VARIANT_FALSE;
    PyObject* pyvar_Compressed = NULL;
    VARIANT_BOOL b_retrieveMetadata = VARIANT_FALSE;
    PyObject* pyvar_retrieveMetadata = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_EnumNameMapping, &pyvar_outFile, &pyvar_Compressed, &pyvar_retrieveMetadata))
      goto igdbxmlexport_exportdatasetsschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_EnumNameMapping, &IID_IEnumNameMapping, (void**)&ipEnumNameMapping))
        PyErr_SetString(PyExc_TypeError, "Argument EnumNameMapping (position 0) is not IEnumNameMapping");
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasetsschema_method_cleanup;
    
    if (PyString_Check(pyvar_outFile))
        unicodeoutFile = PyUnicode_FromObject(pyvar_outFile);
    else if (PyUnicode_Check(pyvar_outFile))
    {
        unicodeoutFile = pyvar_outFile;
        Py_INCREF(unicodeoutFile);
    }
    else if (pyvar_outFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter outFile at index 1");
    if (unicodeoutFile)
        bsoutFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeoutFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeoutFile));
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasetsschema_method_cleanup;
    
    b_Compressed = ((PyObject_IsTrue(pyvar_Compressed) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasetsschema_method_cleanup;
    
    b_retrieveMetadata = ((PyObject_IsTrue(pyvar_retrieveMetadata) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlexport_exportdatasetsschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlExport->ExportDatasetsSchema(ipEnumNameMapping, bsoutFile, b_Compressed, b_retrieveMetadata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlExport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlExport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlExport.ExportDatasetsSchema() returned %ld", (long)hr);
        goto igdbxmlexport_exportdatasetsschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for EnumNameMapping
    // No teardown for outFile
    // No teardown for Compressed
    // No teardown for retrieveMetadata

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbxmlexport_exportdatasetsschema_method_cleanup;

    igdbxmlexport_exportdatasetsschema_method_cleanup:
    self->m_HR = hr;
    if (ipEnumNameMapping)
      ipEnumNameMapping->Release();
    if (bsoutFile)
        ::SysFreeString(bsoutFile);
    
    // No cleanup for Compressed
    // No cleanup for retrieveMetadata
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlExport.ExportDatasetsSchema");
    return return_tuple;
}

static PyObject*
IGdbXmlExportMethod_ExportRecordSet(PyIGdbXmlExportObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'ITableName', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IGdbXmlExport.ExportRecordSet not implemented.");
    return NULL;
}


PyMethodDef PyIGdbXmlExportMethods[] = {
    {"supports", (PyCFunction)PyIGdbXmlExport_SupportsInterface, METH_O, ""},
    {"ExportWorkspace", (PyCFunction)IGdbXmlExportMethod_ExportWorkspace, METH_VARARGS, ""},
    {"ExportWorkspaceSchema", (PyCFunction)IGdbXmlExportMethod_ExportWorkspaceSchema, METH_VARARGS, ""},
    {"ExportDatasets", (PyCFunction)IGdbXmlExportMethod_ExportDatasets, METH_VARARGS, ""},
    {"ExportDatasetsSchema", (PyCFunction)IGdbXmlExportMethod_ExportDatasetsSchema, METH_VARARGS, ""},
    {"ExportRecordSet", (PyCFunction)IGdbXmlExportMethod_ExportRecordSet, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGdbXmlExportGetSet[] = {
  {"_pUnk", (getter)PyIGdbXmlExport_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGdbXmlExport", NULL},
  {"_pointer", (getter)PyIGdbXmlExport_GetPointer, NULL, "Get memory address for IGdbXmlExport", NULL},
  {"_IID", (getter)PyIGdbXmlExport_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGdbXmlExport_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGdbXmlExport_GetIgnoreFailures, (setter)PyIGdbXmlExport_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGdbXmlExportObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGdbXmlExportObject",                          
                                              /* tp_name */
  sizeof(PyIGdbXmlExportObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGdbXmlExportObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGdbXmlExportMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGdbXmlExportGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGdbXmlExportObject_new,                      
                                              /* tp_new */
};

// Interface IGdbXmlImport

typedef struct PyIGdbXmlImportObject {
    PyObject_HEAD
    IGdbXmlImport* m_pIGdbXmlImport;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGdbXmlImportObject;

static PyObject*
PyIGdbXmlImportObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGdbXmlImportObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGdbXmlImport* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGdbXmlImport, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGdbXmlImport with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGdbXmlImportObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGdbXmlImport");
            return NULL;
        }
        self->m_pIGdbXmlImport = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGdbXmlImport");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGdbXmlImport");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGdbXmlImport* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGdbXmlImport, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGdbXmlImport");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGdbXmlImportObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGdbXmlImport");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGdbXmlImport = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGdbXmlImportObject_dealloc(PyIGdbXmlImportObject* self)
{
    if (self->m_pIGdbXmlImport)
        self->m_pIGdbXmlImport->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGdbXmlImport_GetpUnk(PyIGdbXmlImportObject* self)
{
    if (!self->m_pIGdbXmlImport)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGdbXmlImport->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGdbXmlImport to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGdbXmlImport_GetPointer(PyIGdbXmlImportObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGdbXmlImport);
}

static PyObject*
PyIGdbXmlImport_GetIID(PyIGdbXmlImportObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "56cb26fb-6abf-4eb7-9f39-9ec7248c0873");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGdbXmlImport_GetHR(PyIGdbXmlImportObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGdbXmlImport_GetIgnoreFailures(PyIGdbXmlImportObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGdbXmlImport_SetIgnoreFailures(PyIGdbXmlImportObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGdbXmlImport_SupportsInterface(PyIGdbXmlImportObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGdbXmlImport->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGdbXmlImportMethod_GenerateNameMapping(PyIGdbXmlImportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsinFile = 0;
    PyObject* pyvar_inFile;
    PyObject* unicodeinFile = NULL;
    IWorkspace* ipWorkspace = NULL;
    PyObject* py_Workspace;
    IEnumNameMapping* ipEnumNameMapping = NULL;
    PyObject* py_EnumNameMapping = NULL;
    VARIANT_BOOL b_HasConflict = VARIANT_FALSE;
    PyObject* pyvar_HasConflict = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_inFile, &py_Workspace))
      goto igdbxmlimport_generatenamemapping_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_inFile))
        unicodeinFile = PyUnicode_FromObject(pyvar_inFile);
    else if (PyUnicode_Check(pyvar_inFile))
    {
        unicodeinFile = pyvar_inFile;
        Py_INCREF(unicodeinFile);
    }
    else if (pyvar_inFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter inFile at index 0");
    if (unicodeinFile)
        bsinFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeinFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeinFile));
    
    if (PyErr_Occurred())
      goto igdbxmlimport_generatenamemapping_method_cleanup;
    
    if (!IFaceFromPyObject(py_Workspace, &IID_IWorkspace, (void**)&ipWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument Workspace (position 1) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto igdbxmlimport_generatenamemapping_method_cleanup;
    
    // No setup for EnumNameMapping
    // No setup for HasConflict

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlImport->GenerateNameMapping(bsinFile, ipWorkspace, &ipEnumNameMapping, &b_HasConflict);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlImport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlImport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlImport.GenerateNameMapping() returned %ld", (long)hr);
        goto igdbxmlimport_generatenamemapping_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for inFile
    // No teardown for Workspace
    Py_XDECREF(py_EnumNameMapping);
    if (ipEnumNameMapping)
    {
        IUnknown* pUnk = NULL;
        ipEnumNameMapping->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_EnumNameMapping = IUnknownToPythonIIDObject(pUnk, &IID_IEnumNameMapping);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_EnumNameMapping)
    {
        if (py_EnumNameMapping)
           Py_DECREF(py_EnumNameMapping);
        py_EnumNameMapping = Py_None;
        Py_INCREF(py_EnumNameMapping);
    }
    if (PyErr_Occurred())
      goto igdbxmlimport_generatenamemapping_method_cleanup;
    
    pyvar_HasConflict = ((b_HasConflict == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igdbxmlimport_generatenamemapping_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_EnumNameMapping, pyvar_HasConflict);
    goto igdbxmlimport_generatenamemapping_method_cleanup;

    igdbxmlimport_generatenamemapping_method_cleanup:
    self->m_HR = hr;
    if (bsinFile)
        ::SysFreeString(bsinFile);
    
    if (ipWorkspace)
      ipWorkspace->Release();
    Py_XDECREF(py_EnumNameMapping);
    if (ipEnumNameMapping)
      ipEnumNameMapping->Release();
    // No cleanup for HasConflict
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlImport.GenerateNameMapping");
    return return_tuple;
}

static PyObject*
IGdbXmlImportMethod_ImportWorkspace(PyIGdbXmlImportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsinFile = 0;
    PyObject* pyvar_inFile;
    PyObject* unicodeinFile = NULL;
    IEnumNameMapping* ipEnumNameMapping = NULL;
    PyObject* py_EnumNameMapping;
    IWorkspace* ippWorkspace = NULL;
    PyObject* py_pWorkspace;
    VARIANT_BOOL b_schemaOnly = VARIANT_FALSE;
    PyObject* pyvar_schemaOnly = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_inFile, &py_EnumNameMapping, &py_pWorkspace, &pyvar_schemaOnly))
      goto igdbxmlimport_importworkspace_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_inFile))
        unicodeinFile = PyUnicode_FromObject(pyvar_inFile);
    else if (PyUnicode_Check(pyvar_inFile))
    {
        unicodeinFile = pyvar_inFile;
        Py_INCREF(unicodeinFile);
    }
    else if (pyvar_inFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter inFile at index 0");
    if (unicodeinFile)
        bsinFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeinFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeinFile));
    
    if (PyErr_Occurred())
      goto igdbxmlimport_importworkspace_method_cleanup;
    
    if (!IFaceFromPyObject(py_EnumNameMapping, &IID_IEnumNameMapping, (void**)&ipEnumNameMapping))
        PyErr_SetString(PyExc_TypeError, "Argument EnumNameMapping (position 1) is not IEnumNameMapping");
    
    if (PyErr_Occurred())
      goto igdbxmlimport_importworkspace_method_cleanup;
    
    if (!IFaceFromPyObject(py_pWorkspace, &IID_IWorkspace, (void**)&ippWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument pWorkspace (position 2) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto igdbxmlimport_importworkspace_method_cleanup;
    
    b_schemaOnly = ((PyObject_IsTrue(pyvar_schemaOnly) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdbxmlimport_importworkspace_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlImport->ImportWorkspace(bsinFile, ipEnumNameMapping, ippWorkspace, b_schemaOnly);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlImport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlImport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlImport.ImportWorkspace() returned %ld", (long)hr);
        goto igdbxmlimport_importworkspace_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for inFile
    // No teardown for EnumNameMapping
    // No teardown for pWorkspace
    // No teardown for schemaOnly

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbxmlimport_importworkspace_method_cleanup;

    igdbxmlimport_importworkspace_method_cleanup:
    self->m_HR = hr;
    if (bsinFile)
        ::SysFreeString(bsinFile);
    
    if (ipEnumNameMapping)
      ipEnumNameMapping->Release();
    if (ippWorkspace)
      ippWorkspace->Release();
    // No cleanup for schemaOnly
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlImport.ImportWorkspace");
    return return_tuple;
}

static PyObject*
IGdbXmlImportMethod_ImportRecordSet(PyIGdbXmlImportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsinFile = 0;
    PyObject* pyvar_inFile;
    PyObject* unicodeinFile = NULL;
    IFields* ipSourceFields = NULL;
    PyObject* py_SourceFields;
    IFields* ipTargetMappedFields = NULL;
    PyObject* py_TargetMappedFields;
    ITable* ippTable = NULL;
    PyObject* py_pTable;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_inFile, &py_SourceFields, &py_TargetMappedFields, &py_pTable))
      goto igdbxmlimport_importrecordset_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_inFile))
        unicodeinFile = PyUnicode_FromObject(pyvar_inFile);
    else if (PyUnicode_Check(pyvar_inFile))
    {
        unicodeinFile = pyvar_inFile;
        Py_INCREF(unicodeinFile);
    }
    else if (pyvar_inFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter inFile at index 0");
    if (unicodeinFile)
        bsinFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeinFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeinFile));
    
    if (PyErr_Occurred())
      goto igdbxmlimport_importrecordset_method_cleanup;
    
    if (!IFaceFromPyObject(py_SourceFields, &IID_IFields, (void**)&ipSourceFields))
        PyErr_SetString(PyExc_TypeError, "Argument SourceFields (position 1) is not IFields");
    
    if (PyErr_Occurred())
      goto igdbxmlimport_importrecordset_method_cleanup;
    
    if (!IFaceFromPyObject(py_TargetMappedFields, &IID_IFields, (void**)&ipTargetMappedFields))
        PyErr_SetString(PyExc_TypeError, "Argument TargetMappedFields (position 2) is not IFields");
    
    if (PyErr_Occurred())
      goto igdbxmlimport_importrecordset_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTable, &IID_ITable, (void**)&ippTable))
        PyErr_SetString(PyExc_TypeError, "Argument pTable (position 3) is not ITable");
    
    if (PyErr_Occurred())
      goto igdbxmlimport_importrecordset_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlImport->ImportRecordSet(bsinFile, ipSourceFields, ipTargetMappedFields, ippTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlImport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlImport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlImport.ImportRecordSet() returned %ld", (long)hr);
        goto igdbxmlimport_importrecordset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for inFile
    // No teardown for SourceFields
    // No teardown for TargetMappedFields
    // No teardown for pTable

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbxmlimport_importrecordset_method_cleanup;

    igdbxmlimport_importrecordset_method_cleanup:
    self->m_HR = hr;
    if (bsinFile)
        ::SysFreeString(bsinFile);
    
    if (ipSourceFields)
      ipSourceFields->Release();
    if (ipTargetMappedFields)
      ipTargetMappedFields->Release();
    if (ippTable)
      ippTable->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlImport.ImportRecordSet");
    return return_tuple;
}

static PyObject*
IGdbXmlImportMethod_GetRecordSetFields(PyIGdbXmlImportObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsinFile = 0;
    PyObject* pyvar_inFile;
    PyObject* unicodeinFile = NULL;
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_inFile))
      goto igdbxmlimport_getrecordsetfields_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_inFile))
        unicodeinFile = PyUnicode_FromObject(pyvar_inFile);
    else if (PyUnicode_Check(pyvar_inFile))
    {
        unicodeinFile = pyvar_inFile;
        Py_INCREF(unicodeinFile);
    }
    else if (pyvar_inFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter inFile at index 0");
    if (unicodeinFile)
        bsinFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeinFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeinFile));
    
    if (PyErr_Occurred())
      goto igdbxmlimport_getrecordsetfields_method_cleanup;
    
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlImport->GetRecordSetFields(bsinFile, &ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlImport->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlImport) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlImport.GetRecordSetFields() returned %ld", (long)hr);
        goto igdbxmlimport_getrecordsetfields_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for inFile
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto igdbxmlimport_getrecordsetfields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto igdbxmlimport_getrecordsetfields_method_cleanup;

    igdbxmlimport_getrecordsetfields_method_cleanup:
    self->m_HR = hr;
    if (bsinFile)
        ::SysFreeString(bsinFile);
    
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlImport.GetRecordSetFields");
    return return_tuple;
}


PyMethodDef PyIGdbXmlImportMethods[] = {
    {"supports", (PyCFunction)PyIGdbXmlImport_SupportsInterface, METH_O, ""},
    {"GenerateNameMapping", (PyCFunction)IGdbXmlImportMethod_GenerateNameMapping, METH_VARARGS, ""},
    {"ImportWorkspace", (PyCFunction)IGdbXmlImportMethod_ImportWorkspace, METH_VARARGS, ""},
    {"ImportRecordSet", (PyCFunction)IGdbXmlImportMethod_ImportRecordSet, METH_VARARGS, ""},
    {"GetRecordSetFields", (PyCFunction)IGdbXmlImportMethod_GetRecordSetFields, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGdbXmlImportGetSet[] = {
  {"_pUnk", (getter)PyIGdbXmlImport_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGdbXmlImport", NULL},
  {"_pointer", (getter)PyIGdbXmlImport_GetPointer, NULL, "Get memory address for IGdbXmlImport", NULL},
  {"_IID", (getter)PyIGdbXmlImport_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGdbXmlImport_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGdbXmlImport_GetIgnoreFailures, (setter)PyIGdbXmlImport_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGdbXmlImportObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGdbXmlImportObject",                          
                                              /* tp_name */
  sizeof(PyIGdbXmlImportObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGdbXmlImportObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGdbXmlImportMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGdbXmlImportGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGdbXmlImportObject_new,                      
                                              /* tp_new */
};

// Interface IGdbXmlExportEvents

typedef struct PyIGdbXmlExportEventsObject {
    PyObject_HEAD
    IGdbXmlExportEvents* m_pIGdbXmlExportEvents;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGdbXmlExportEventsObject;

static PyObject*
PyIGdbXmlExportEventsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGdbXmlExportEventsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGdbXmlExportEvents* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGdbXmlExportEvents, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGdbXmlExportEvents with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGdbXmlExportEventsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGdbXmlExportEvents");
            return NULL;
        }
        self->m_pIGdbXmlExportEvents = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGdbXmlExportEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGdbXmlExportEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGdbXmlExportEvents* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGdbXmlExportEvents, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGdbXmlExportEvents");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGdbXmlExportEventsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGdbXmlExportEvents");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGdbXmlExportEvents = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGdbXmlExportEventsObject_dealloc(PyIGdbXmlExportEventsObject* self)
{
    if (self->m_pIGdbXmlExportEvents)
        self->m_pIGdbXmlExportEvents->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGdbXmlExportEvents_GetpUnk(PyIGdbXmlExportEventsObject* self)
{
    if (!self->m_pIGdbXmlExportEvents)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGdbXmlExportEvents->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGdbXmlExportEvents to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGdbXmlExportEvents_GetPointer(PyIGdbXmlExportEventsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGdbXmlExportEvents);
}

static PyObject*
PyIGdbXmlExportEvents_GetIID(PyIGdbXmlExportEventsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "17ce60d7-24f8-49cc-8fc4-94471dbaf723");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGdbXmlExportEvents_GetHR(PyIGdbXmlExportEventsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGdbXmlExportEvents_GetIgnoreFailures(PyIGdbXmlExportEventsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGdbXmlExportEvents_SetIgnoreFailures(PyIGdbXmlExportEventsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGdbXmlExportEvents_SupportsInterface(PyIGdbXmlExportEventsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGdbXmlExportEvents->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGdbXmlExportEventsMethod_BeforeStartElement(PyIGdbXmlExportEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsElement = 0;
    PyObject* pyvar_Element;
    PyObject* unicodeElement = NULL;
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;
    IUnknown* ipObject = NULL;
    PyObject* py_Object;
    IXMLWriter* ippXMLWriter = NULL;
    PyObject* py_pXMLWriter;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_Element, &pyvar_URL, &py_Object, &py_pXMLWriter))
      goto igdbxmlexportevents_beforestartelement_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Element))
        unicodeElement = PyUnicode_FromObject(pyvar_Element);
    else if (PyUnicode_Check(pyvar_Element))
    {
        unicodeElement = pyvar_Element;
        Py_INCREF(unicodeElement);
    }
    else if (pyvar_Element != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Element at index 0");
    if (unicodeElement)
        bsElement = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeElement), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeElement));
    
    if (PyErr_Occurred())
      goto igdbxmlexportevents_beforestartelement_method_cleanup;
    
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 1");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto igdbxmlexportevents_beforestartelement_method_cleanup;
    
    if (!IFaceFromPyObject(py_Object, &IID_IUnknown, (void**)&ipObject))
        PyErr_SetString(PyExc_TypeError, "Argument Object (position 2) is not IUnknown");
    
    if (PyErr_Occurred())
      goto igdbxmlexportevents_beforestartelement_method_cleanup;
    
    if (!IFaceFromPyObject(py_pXMLWriter, &IID_IXMLWriter, (void**)&ippXMLWriter))
        PyErr_SetString(PyExc_TypeError, "Argument pXMLWriter (position 3) is not IXMLWriter");
    
    if (PyErr_Occurred())
      goto igdbxmlexportevents_beforestartelement_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlExportEvents->BeforeStartElement(bsElement, bsURL, ipObject, ippXMLWriter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlExportEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlExportEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlExportEvents.BeforeStartElement() returned %ld", (long)hr);
        goto igdbxmlexportevents_beforestartelement_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Element
    // No teardown for URL
    // No teardown for Object
    // No teardown for pXMLWriter

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbxmlexportevents_beforestartelement_method_cleanup;

    igdbxmlexportevents_beforestartelement_method_cleanup:
    self->m_HR = hr;
    if (bsElement)
        ::SysFreeString(bsElement);
    
    if (bsURL)
        ::SysFreeString(bsURL);
    
    if (ipObject)
      ipObject->Release();
    if (ippXMLWriter)
      ippXMLWriter->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlExportEvents.BeforeStartElement");
    return return_tuple;
}

static PyObject*
IGdbXmlExportEventsMethod_AfterEndElement(PyIGdbXmlExportEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsElement = 0;
    PyObject* pyvar_Element;
    PyObject* unicodeElement = NULL;
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;
    IUnknown* ipObject = NULL;
    PyObject* py_Object;
    IXMLWriter* ippXMLWriter = NULL;
    PyObject* py_pXMLWriter;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_Element, &pyvar_URL, &py_Object, &py_pXMLWriter))
      goto igdbxmlexportevents_afterendelement_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Element))
        unicodeElement = PyUnicode_FromObject(pyvar_Element);
    else if (PyUnicode_Check(pyvar_Element))
    {
        unicodeElement = pyvar_Element;
        Py_INCREF(unicodeElement);
    }
    else if (pyvar_Element != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Element at index 0");
    if (unicodeElement)
        bsElement = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeElement), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeElement));
    
    if (PyErr_Occurred())
      goto igdbxmlexportevents_afterendelement_method_cleanup;
    
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 1");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto igdbxmlexportevents_afterendelement_method_cleanup;
    
    if (!IFaceFromPyObject(py_Object, &IID_IUnknown, (void**)&ipObject))
        PyErr_SetString(PyExc_TypeError, "Argument Object (position 2) is not IUnknown");
    
    if (PyErr_Occurred())
      goto igdbxmlexportevents_afterendelement_method_cleanup;
    
    if (!IFaceFromPyObject(py_pXMLWriter, &IID_IXMLWriter, (void**)&ippXMLWriter))
        PyErr_SetString(PyExc_TypeError, "Argument pXMLWriter (position 3) is not IXMLWriter");
    
    if (PyErr_Occurred())
      goto igdbxmlexportevents_afterendelement_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbXmlExportEvents->AfterEndElement(bsElement, bsURL, ipObject, ippXMLWriter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbXmlExportEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbXmlExportEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbXmlExportEvents.AfterEndElement() returned %ld", (long)hr);
        goto igdbxmlexportevents_afterendelement_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Element
    // No teardown for URL
    // No teardown for Object
    // No teardown for pXMLWriter

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbxmlexportevents_afterendelement_method_cleanup;

    igdbxmlexportevents_afterendelement_method_cleanup:
    self->m_HR = hr;
    if (bsElement)
        ::SysFreeString(bsElement);
    
    if (bsURL)
        ::SysFreeString(bsURL);
    
    if (ipObject)
      ipObject->Release();
    if (ippXMLWriter)
      ippXMLWriter->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbXmlExportEvents.AfterEndElement");
    return return_tuple;
}


PyMethodDef PyIGdbXmlExportEventsMethods[] = {
    {"supports", (PyCFunction)PyIGdbXmlExportEvents_SupportsInterface, METH_O, ""},
    {"BeforeStartElement", (PyCFunction)IGdbXmlExportEventsMethod_BeforeStartElement, METH_VARARGS, ""},
    {"AfterEndElement", (PyCFunction)IGdbXmlExportEventsMethod_AfterEndElement, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGdbXmlExportEventsGetSet[] = {
  {"_pUnk", (getter)PyIGdbXmlExportEvents_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGdbXmlExportEvents", NULL},
  {"_pointer", (getter)PyIGdbXmlExportEvents_GetPointer, NULL, "Get memory address for IGdbXmlExportEvents", NULL},
  {"_IID", (getter)PyIGdbXmlExportEvents_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGdbXmlExportEvents_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGdbXmlExportEvents_GetIgnoreFailures, (setter)PyIGdbXmlExportEvents_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGdbXmlExportEventsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGdbXmlExportEventsObject",                          
                                              /* tp_name */
  sizeof(PyIGdbXmlExportEventsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGdbXmlExportEventsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGdbXmlExportEventsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGdbXmlExportEventsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGdbXmlExportEventsObject_new,                      
                                              /* tp_new */
};

// Interface IGdbSchemaCreator

typedef struct PyIGdbSchemaCreatorObject {
    PyObject_HEAD
    IGdbSchemaCreator* m_pIGdbSchemaCreator;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGdbSchemaCreatorObject;

static PyObject*
PyIGdbSchemaCreatorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGdbSchemaCreatorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGdbSchemaCreator* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGdbSchemaCreator, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGdbSchemaCreator with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGdbSchemaCreatorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGdbSchemaCreator");
            return NULL;
        }
        self->m_pIGdbSchemaCreator = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGdbSchemaCreator");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGdbSchemaCreator");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGdbSchemaCreator* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGdbSchemaCreator, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGdbSchemaCreator");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGdbSchemaCreatorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGdbSchemaCreator");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGdbSchemaCreator = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGdbSchemaCreatorObject_dealloc(PyIGdbSchemaCreatorObject* self)
{
    if (self->m_pIGdbSchemaCreator)
        self->m_pIGdbSchemaCreator->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGdbSchemaCreator_GetpUnk(PyIGdbSchemaCreatorObject* self)
{
    if (!self->m_pIGdbSchemaCreator)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGdbSchemaCreator->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGdbSchemaCreator to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGdbSchemaCreator_GetPointer(PyIGdbSchemaCreatorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGdbSchemaCreator);
}

static PyObject*
PyIGdbSchemaCreator_GetIID(PyIGdbSchemaCreatorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "077f55bf-9a00-44b3-9d6f-5e1d0fc822e7");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGdbSchemaCreator_GetHR(PyIGdbSchemaCreatorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGdbSchemaCreator_GetIgnoreFailures(PyIGdbSchemaCreatorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGdbSchemaCreator_SetIgnoreFailures(PyIGdbSchemaCreatorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGdbSchemaCreator_SupportsInterface(PyIGdbSchemaCreatorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGdbSchemaCreator->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGdbSchemaCreatorMethod_GenerateNameMapping(PyIGdbSchemaCreatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspace* ippWorkspace = NULL;
    PyObject* py_pWorkspace;
    IArray* ippDataElements = NULL;
    PyObject* py_pDataElements;
    IArray* ippDomains = NULL;
    PyObject* py_pDomains;
    IEnumNameMapping* ipppENM = NULL;
    PyObject* py_ppENM = NULL;
    VARIANT_BOOL b_pHasConflict = VARIANT_FALSE;
    PyObject* pyvar_pHasConflict = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_pWorkspace, &py_pDataElements, &py_pDomains))
      goto igdbschemacreator_generatenamemapping_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pWorkspace, &IID_IWorkspace, (void**)&ippWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument pWorkspace (position 0) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto igdbschemacreator_generatenamemapping_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDataElements, &IID_IArray, (void**)&ippDataElements))
        PyErr_SetString(PyExc_TypeError, "Argument pDataElements (position 1) is not IArray");
    
    if (PyErr_Occurred())
      goto igdbschemacreator_generatenamemapping_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDomains, &IID_IArray, (void**)&ippDomains))
        PyErr_SetString(PyExc_TypeError, "Argument pDomains (position 2) is not IArray");
    
    if (PyErr_Occurred())
      goto igdbschemacreator_generatenamemapping_method_cleanup;
    
    // No setup for ppENM
    // No setup for pHasConflict

    // Call method on actual COM interface
    hr = self->m_pIGdbSchemaCreator->GenerateNameMapping(ippWorkspace, ippDataElements, ippDomains, &ipppENM, &b_pHasConflict);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbSchemaCreator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbSchemaCreator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbSchemaCreator.GenerateNameMapping() returned %ld", (long)hr);
        goto igdbschemacreator_generatenamemapping_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWorkspace
    // No teardown for pDataElements
    // No teardown for pDomains
    Py_XDECREF(py_ppENM);
    if (ipppENM)
    {
        IUnknown* pUnk = NULL;
        ipppENM->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppENM = IUnknownToPythonIIDObject(pUnk, &IID_IEnumNameMapping);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppENM)
    {
        if (py_ppENM)
           Py_DECREF(py_ppENM);
        py_ppENM = Py_None;
        Py_INCREF(py_ppENM);
    }
    if (PyErr_Occurred())
      goto igdbschemacreator_generatenamemapping_method_cleanup;
    
    pyvar_pHasConflict = ((b_pHasConflict == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igdbschemacreator_generatenamemapping_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_ppENM, pyvar_pHasConflict);
    goto igdbschemacreator_generatenamemapping_method_cleanup;

    igdbschemacreator_generatenamemapping_method_cleanup:
    self->m_HR = hr;
    if (ippWorkspace)
      ippWorkspace->Release();
    if (ippDataElements)
      ippDataElements->Release();
    if (ippDomains)
      ippDomains->Release();
    Py_XDECREF(py_ppENM);
    if (ipppENM)
      ipppENM->Release();
    // No cleanup for pHasConflict
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbSchemaCreator.GenerateNameMapping");
    return return_tuple;
}

static PyObject*
IGdbSchemaCreatorMethod_CreateSchema(PyIGdbSchemaCreatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspace* ippWorkspace = NULL;
    PyObject* py_pWorkspace;
    IEnumNameMapping* ippENM = NULL;
    PyObject* py_pENM;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pWorkspace, &py_pENM))
      goto igdbschemacreator_createschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pWorkspace, &IID_IWorkspace, (void**)&ippWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument pWorkspace (position 0) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto igdbschemacreator_createschema_method_cleanup;
    
    if (!IFaceFromPyObject(py_pENM, &IID_IEnumNameMapping, (void**)&ippENM))
        PyErr_SetString(PyExc_TypeError, "Argument pENM (position 1) is not IEnumNameMapping");
    
    if (PyErr_Occurred())
      goto igdbschemacreator_createschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGdbSchemaCreator->CreateSchema(ippWorkspace, ippENM);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGdbSchemaCreator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGdbSchemaCreator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGdbSchemaCreator.CreateSchema() returned %ld", (long)hr);
        goto igdbschemacreator_createschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWorkspace
    // No teardown for pENM

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdbschemacreator_createschema_method_cleanup;

    igdbschemacreator_createschema_method_cleanup:
    self->m_HR = hr;
    if (ippWorkspace)
      ippWorkspace->Release();
    if (ippENM)
      ippENM->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGdbSchemaCreator.CreateSchema");
    return return_tuple;
}


PyMethodDef PyIGdbSchemaCreatorMethods[] = {
    {"supports", (PyCFunction)PyIGdbSchemaCreator_SupportsInterface, METH_O, ""},
    {"GenerateNameMapping", (PyCFunction)IGdbSchemaCreatorMethod_GenerateNameMapping, METH_VARARGS, ""},
    {"CreateSchema", (PyCFunction)IGdbSchemaCreatorMethod_CreateSchema, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGdbSchemaCreatorGetSet[] = {
  {"_pUnk", (getter)PyIGdbSchemaCreator_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGdbSchemaCreator", NULL},
  {"_pointer", (getter)PyIGdbSchemaCreator_GetPointer, NULL, "Get memory address for IGdbSchemaCreator", NULL},
  {"_IID", (getter)PyIGdbSchemaCreator_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGdbSchemaCreator_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGdbSchemaCreator_GetIgnoreFailures, (setter)PyIGdbSchemaCreator_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGdbSchemaCreatorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGdbSchemaCreatorObject",                          
                                              /* tp_name */
  sizeof(PyIGdbSchemaCreatorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGdbSchemaCreatorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGdbSchemaCreatorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGdbSchemaCreatorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGdbSchemaCreatorObject_new,                      
                                              /* tp_new */
};

// Interface IDataChanges2

typedef struct PyIDataChanges2Object {
    PyObject_HEAD
    IDataChanges2* m_pIDataChanges2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataChanges2Object;

static PyObject*
PyIDataChanges2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataChanges2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataChanges2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataChanges2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataChanges2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataChanges2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChanges2");
            return NULL;
        }
        self->m_pIDataChanges2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataChanges2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataChanges2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataChanges2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataChanges2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataChanges2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataChanges2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChanges2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataChanges2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataChanges2Object_dealloc(PyIDataChanges2Object* self)
{
    if (self->m_pIDataChanges2)
        self->m_pIDataChanges2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataChanges2_GetpUnk(PyIDataChanges2Object* self)
{
    if (!self->m_pIDataChanges2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataChanges2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataChanges2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataChanges2_GetPointer(PyIDataChanges2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataChanges2);
}

static PyObject*
PyIDataChanges2_GetIID(PyIDataChanges2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5f8f332e-316d-4fc0-9454-b2628cb9d546");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataChanges2_GetHR(PyIDataChanges2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataChanges2_GetIgnoreFailures(PyIDataChanges2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataChanges2_SetIgnoreFailures(PyIDataChanges2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataChanges2_SupportsInterface(PyIDataChanges2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataChanges2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataChanges2Method_get_ChangesModelType(PyIDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaModelType eModelType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ModelType

    // Call method on actual COM interface
    hr = self->m_pIDataChanges2->get_ChangesModelType(&eModelType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges2.get_ChangesModelType() returned %ld", (long)hr);
        goto idatachanges2_get_changesmodeltype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ModelType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eModelType);
    goto idatachanges2_get_changesmodeltype_method_cleanup;

    idatachanges2_get_changesmodeltype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ModelType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges2.get_ChangesModelType");
    return return_tuple;
}

static PyObject*
IDataChanges2Method_GetModifiedClassesInfo(PyIDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumModifiedClassInfo* ipenumModifiedClasses = NULL;
    PyObject* py_enumModifiedClasses = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for enumModifiedClasses

    // Call method on actual COM interface
    hr = self->m_pIDataChanges2->GetModifiedClassesInfo(&ipenumModifiedClasses);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges2.GetModifiedClassesInfo() returned %ld", (long)hr);
        goto idatachanges2_getmodifiedclassesinfo_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_enumModifiedClasses);
    if (ipenumModifiedClasses)
    {
        IUnknown* pUnk = NULL;
        ipenumModifiedClasses->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_enumModifiedClasses = IUnknownToPythonIIDObject(pUnk, &IID_IEnumModifiedClassInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_enumModifiedClasses)
    {
        if (py_enumModifiedClasses)
           Py_DECREF(py_enumModifiedClasses);
        py_enumModifiedClasses = Py_None;
        Py_INCREF(py_enumModifiedClasses);
    }
    if (PyErr_Occurred())
      goto idatachanges2_getmodifiedclassesinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_enumModifiedClasses);
    goto idatachanges2_getmodifiedclassesinfo_method_cleanup;

    idatachanges2_getmodifiedclassesinfo_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_enumModifiedClasses);
    if (ipenumModifiedClasses)
      ipenumModifiedClasses->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges2.GetModifiedClassesInfo");
    return return_tuple;
}

static PyObject*
IDataChanges2Method_Extract(PyIDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstableName = 0;
    PyObject* pyvar_tableName;
    PyObject* unicodetableName = NULL;
    esriDataChangeType echangeType;
    IDifferenceCursor* ipcursor = NULL;
    PyObject* py_cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_tableName, (int *)&echangeType))
      goto idatachanges2_extract_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_tableName))
        unicodetableName = PyUnicode_FromObject(pyvar_tableName);
    else if (PyUnicode_Check(pyvar_tableName))
    {
        unicodetableName = pyvar_tableName;
        Py_INCREF(unicodetableName);
    }
    else if (pyvar_tableName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter tableName at index 0");
    if (unicodetableName)
        bstableName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetableName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetableName));
    
    if (PyErr_Occurred())
      goto idatachanges2_extract_method_cleanup;
    
    // No setup for changeType
    // No setup for cursor

    // Call method on actual COM interface
    hr = self->m_pIDataChanges2->Extract(bstableName, echangeType, &ipcursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges2.Extract() returned %ld", (long)hr);
        goto idatachanges2_extract_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for tableName
    // No teardown for changeType
    Py_XDECREF(py_cursor);
    if (ipcursor)
    {
        IUnknown* pUnk = NULL;
        ipcursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_cursor = IUnknownToPythonIIDObject(pUnk, &IID_IDifferenceCursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_cursor)
    {
        if (py_cursor)
           Py_DECREF(py_cursor);
        py_cursor = Py_None;
        Py_INCREF(py_cursor);
    }
    if (PyErr_Occurred())
      goto idatachanges2_extract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_cursor);
    goto idatachanges2_extract_method_cleanup;

    idatachanges2_extract_method_cleanup:
    self->m_HR = hr;
    if (bstableName)
        ::SysFreeString(bstableName);
    
    // No cleanup for changeType
    Py_XDECREF(py_cursor);
    if (ipcursor)
      ipcursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges2.Extract");
    return return_tuple;
}

static PyObject*
IDataChanges2Method_get_ParentWorkspaceName(PyIDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipParentWorkspaceName = NULL;
    PyObject* py_ParentWorkspaceName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentWorkspaceName

    // Call method on actual COM interface
    hr = self->m_pIDataChanges2->get_ParentWorkspaceName(&ipParentWorkspaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges2.get_ParentWorkspaceName() returned %ld", (long)hr);
        goto idatachanges2_get_parentworkspacename_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ParentWorkspaceName);
    if (ipParentWorkspaceName)
    {
        IUnknown* pUnk = NULL;
        ipParentWorkspaceName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ParentWorkspaceName = IUnknownToPythonIIDObject(pUnk, &IID_IWorkspaceName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ParentWorkspaceName)
    {
        if (py_ParentWorkspaceName)
           Py_DECREF(py_ParentWorkspaceName);
        py_ParentWorkspaceName = Py_None;
        Py_INCREF(py_ParentWorkspaceName);
    }
    if (PyErr_Occurred())
      goto idatachanges2_get_parentworkspacename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ParentWorkspaceName);
    goto idatachanges2_get_parentworkspacename_method_cleanup;

    idatachanges2_get_parentworkspacename_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ParentWorkspaceName);
    if (ipParentWorkspaceName)
      ipParentWorkspaceName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges2.get_ParentWorkspaceName");
    return return_tuple;
}

static PyObject*
IDataChanges2Method_get_ParentReplicaID(PyIDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParentReplicaID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentReplicaID

    // Call method on actual COM interface
    hr = self->m_pIDataChanges2->get_ParentReplicaID(&lParentReplicaID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges2.get_ParentReplicaID() returned %ld", (long)hr);
        goto idatachanges2_get_parentreplicaid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParentReplicaID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lParentReplicaID);
    goto idatachanges2_get_parentreplicaid_method_cleanup;

    idatachanges2_get_parentreplicaid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParentReplicaID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges2.get_ParentReplicaID");
    return return_tuple;
}

static PyObject*
IDataChanges2Method_get_ReplicaGuid(PyIDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaGuid;
    PyObject* pyvar_ReplicaGuid = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ReplicaGuid

    // Call method on actual COM interface
    hr = self->m_pIDataChanges2->get_ReplicaGuid(&bsReplicaGuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges2.get_ReplicaGuid() returned %ld", (long)hr);
        goto idatachanges2_get_replicaguid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ReplicaGuid = PyUnicode_FromWideChar(bsReplicaGuid,::SysStringLen(bsReplicaGuid));
    ::SysFreeString(bsReplicaGuid);
    
    if (PyErr_Occurred())
      goto idatachanges2_get_replicaguid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ReplicaGuid);
    goto idatachanges2_get_replicaguid_method_cleanup;

    idatachanges2_get_replicaguid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ReplicaGuid != Py_None)
        Py_XDECREF(pyvar_ReplicaGuid);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges2.get_ReplicaGuid");
    return return_tuple;
}


PyMethodDef PyIDataChanges2Methods[] = {
    {"supports", (PyCFunction)PyIDataChanges2_SupportsInterface, METH_O, ""},
    {"get_ChangesModelType", (PyCFunction)IDataChanges2Method_get_ChangesModelType, METH_VARARGS, ""},
    {"GetModifiedClassesInfo", (PyCFunction)IDataChanges2Method_GetModifiedClassesInfo, METH_VARARGS, ""},
    {"Extract", (PyCFunction)IDataChanges2Method_Extract, METH_VARARGS, ""},
    {"get_ParentWorkspaceName", (PyCFunction)IDataChanges2Method_get_ParentWorkspaceName, METH_VARARGS, ""},
    {"get_ParentReplicaID", (PyCFunction)IDataChanges2Method_get_ParentReplicaID, METH_VARARGS, ""},
    {"get_ReplicaGuid", (PyCFunction)IDataChanges2Method_get_ReplicaGuid, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataChanges2GetSet[] = {
  {"_pUnk", (getter)PyIDataChanges2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataChanges2", NULL},
  {"_pointer", (getter)PyIDataChanges2_GetPointer, NULL, "Get memory address for IDataChanges2", NULL},
  {"_IID", (getter)PyIDataChanges2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataChanges2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataChanges2_GetIgnoreFailures, (setter)PyIDataChanges2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataChanges2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDataChanges2Object",                          
                                              /* tp_name */
  sizeof(PyIDataChanges2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataChanges2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataChanges2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataChanges2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataChanges2Object_new,                      
                                              /* tp_new */
};

// Interface IDataChanges3

typedef struct PyIDataChanges3Object {
    PyObject_HEAD
    IDataChanges3* m_pIDataChanges3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataChanges3Object;

static PyObject*
PyIDataChanges3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataChanges3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataChanges3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataChanges3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataChanges3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataChanges3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChanges3");
            return NULL;
        }
        self->m_pIDataChanges3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataChanges3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataChanges3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataChanges3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataChanges3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataChanges3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataChanges3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChanges3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataChanges3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataChanges3Object_dealloc(PyIDataChanges3Object* self)
{
    if (self->m_pIDataChanges3)
        self->m_pIDataChanges3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataChanges3_GetpUnk(PyIDataChanges3Object* self)
{
    if (!self->m_pIDataChanges3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataChanges3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataChanges3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataChanges3_GetPointer(PyIDataChanges3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataChanges3);
}

static PyObject*
PyIDataChanges3_GetIID(PyIDataChanges3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a289bd00-e42e-4820-9af0-c9bc64f707a8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataChanges3_GetHR(PyIDataChanges3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataChanges3_GetIgnoreFailures(PyIDataChanges3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataChanges3_SetIgnoreFailures(PyIDataChanges3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataChanges3_SupportsInterface(PyIDataChanges3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataChanges3Method_get_GenerationNumbers(PyIDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lsourceGenBegin = 0;
    long lsourceGenEnd = 0;
    long ltargetGen = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for sourceGenBegin
    // No setup for sourceGenEnd
    // No setup for targetGen

    // Call method on actual COM interface
    hr = self->m_pIDataChanges3->get_GenerationNumbers(&lsourceGenBegin, &lsourceGenEnd, &ltargetGen);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges3.get_GenerationNumbers() returned %ld", (long)hr);
        goto idatachanges3_get_generationnumbers_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for sourceGenBegin
    // No teardown for sourceGenEnd
    // No teardown for targetGen

    // Initialize output tuple
    return_tuple = Py_BuildValue("lll",
                                            lsourceGenBegin, lsourceGenEnd, ltargetGen);
    goto idatachanges3_get_generationnumbers_method_cleanup;

    idatachanges3_get_generationnumbers_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sourceGenBegin
    // No cleanup for sourceGenEnd
    // No cleanup for targetGen
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges3.get_GenerationNumbers");
    return return_tuple;
}

static PyObject*
IDataChanges3Method_get_ReplicaState(PyIDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaState eReplicaState;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ReplicaState

    // Call method on actual COM interface
    hr = self->m_pIDataChanges3->get_ReplicaState(&eReplicaState);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges3.get_ReplicaState() returned %ld", (long)hr);
        goto idatachanges3_get_replicastate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaState

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eReplicaState);
    goto idatachanges3_get_replicastate_method_cleanup;

    idatachanges3_get_replicastate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ReplicaState
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges3.get_ReplicaState");
    return return_tuple;
}

static PyObject*
IDataChanges3Method_get_ChangesModelType(PyIDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaModelType eModelType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ModelType

    // Call method on actual COM interface
    hr = self->m_pIDataChanges3->get_ChangesModelType(&eModelType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges3.get_ChangesModelType() returned %ld", (long)hr);
        goto idatachanges3_get_changesmodeltype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ModelType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eModelType);
    goto idatachanges3_get_changesmodeltype_method_cleanup;

    idatachanges3_get_changesmodeltype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ModelType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges3.get_ChangesModelType");
    return return_tuple;
}

static PyObject*
IDataChanges3Method_GetModifiedClassesInfo(PyIDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumModifiedClassInfo* ipenumModifiedClasses = NULL;
    PyObject* py_enumModifiedClasses = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for enumModifiedClasses

    // Call method on actual COM interface
    hr = self->m_pIDataChanges3->GetModifiedClassesInfo(&ipenumModifiedClasses);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges3.GetModifiedClassesInfo() returned %ld", (long)hr);
        goto idatachanges3_getmodifiedclassesinfo_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_enumModifiedClasses);
    if (ipenumModifiedClasses)
    {
        IUnknown* pUnk = NULL;
        ipenumModifiedClasses->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_enumModifiedClasses = IUnknownToPythonIIDObject(pUnk, &IID_IEnumModifiedClassInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_enumModifiedClasses)
    {
        if (py_enumModifiedClasses)
           Py_DECREF(py_enumModifiedClasses);
        py_enumModifiedClasses = Py_None;
        Py_INCREF(py_enumModifiedClasses);
    }
    if (PyErr_Occurred())
      goto idatachanges3_getmodifiedclassesinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_enumModifiedClasses);
    goto idatachanges3_getmodifiedclassesinfo_method_cleanup;

    idatachanges3_getmodifiedclassesinfo_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_enumModifiedClasses);
    if (ipenumModifiedClasses)
      ipenumModifiedClasses->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges3.GetModifiedClassesInfo");
    return return_tuple;
}

static PyObject*
IDataChanges3Method_Extract(PyIDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstableName = 0;
    PyObject* pyvar_tableName;
    PyObject* unicodetableName = NULL;
    esriDataChangeType echangeType;
    IDifferenceCursor* ipcursor = NULL;
    PyObject* py_cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_tableName, (int *)&echangeType))
      goto idatachanges3_extract_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_tableName))
        unicodetableName = PyUnicode_FromObject(pyvar_tableName);
    else if (PyUnicode_Check(pyvar_tableName))
    {
        unicodetableName = pyvar_tableName;
        Py_INCREF(unicodetableName);
    }
    else if (pyvar_tableName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter tableName at index 0");
    if (unicodetableName)
        bstableName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetableName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetableName));
    
    if (PyErr_Occurred())
      goto idatachanges3_extract_method_cleanup;
    
    // No setup for changeType
    // No setup for cursor

    // Call method on actual COM interface
    hr = self->m_pIDataChanges3->Extract(bstableName, echangeType, &ipcursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges3.Extract() returned %ld", (long)hr);
        goto idatachanges3_extract_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for tableName
    // No teardown for changeType
    Py_XDECREF(py_cursor);
    if (ipcursor)
    {
        IUnknown* pUnk = NULL;
        ipcursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_cursor = IUnknownToPythonIIDObject(pUnk, &IID_IDifferenceCursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_cursor)
    {
        if (py_cursor)
           Py_DECREF(py_cursor);
        py_cursor = Py_None;
        Py_INCREF(py_cursor);
    }
    if (PyErr_Occurred())
      goto idatachanges3_extract_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_cursor);
    goto idatachanges3_extract_method_cleanup;

    idatachanges3_extract_method_cleanup:
    self->m_HR = hr;
    if (bstableName)
        ::SysFreeString(bstableName);
    
    // No cleanup for changeType
    Py_XDECREF(py_cursor);
    if (ipcursor)
      ipcursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges3.Extract");
    return return_tuple;
}

static PyObject*
IDataChanges3Method_get_ParentWorkspaceName(PyIDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipParentWorkspaceName = NULL;
    PyObject* py_ParentWorkspaceName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentWorkspaceName

    // Call method on actual COM interface
    hr = self->m_pIDataChanges3->get_ParentWorkspaceName(&ipParentWorkspaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges3.get_ParentWorkspaceName() returned %ld", (long)hr);
        goto idatachanges3_get_parentworkspacename_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ParentWorkspaceName);
    if (ipParentWorkspaceName)
    {
        IUnknown* pUnk = NULL;
        ipParentWorkspaceName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ParentWorkspaceName = IUnknownToPythonIIDObject(pUnk, &IID_IWorkspaceName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ParentWorkspaceName)
    {
        if (py_ParentWorkspaceName)
           Py_DECREF(py_ParentWorkspaceName);
        py_ParentWorkspaceName = Py_None;
        Py_INCREF(py_ParentWorkspaceName);
    }
    if (PyErr_Occurred())
      goto idatachanges3_get_parentworkspacename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ParentWorkspaceName);
    goto idatachanges3_get_parentworkspacename_method_cleanup;

    idatachanges3_get_parentworkspacename_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ParentWorkspaceName);
    if (ipParentWorkspaceName)
      ipParentWorkspaceName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges3.get_ParentWorkspaceName");
    return return_tuple;
}

static PyObject*
IDataChanges3Method_get_ParentReplicaID(PyIDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParentReplicaID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParentReplicaID

    // Call method on actual COM interface
    hr = self->m_pIDataChanges3->get_ParentReplicaID(&lParentReplicaID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges3.get_ParentReplicaID() returned %ld", (long)hr);
        goto idatachanges3_get_parentreplicaid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParentReplicaID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lParentReplicaID);
    goto idatachanges3_get_parentreplicaid_method_cleanup;

    idatachanges3_get_parentreplicaid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParentReplicaID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges3.get_ParentReplicaID");
    return return_tuple;
}

static PyObject*
IDataChanges3Method_get_ReplicaGuid(PyIDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaGuid;
    PyObject* pyvar_ReplicaGuid = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ReplicaGuid

    // Call method on actual COM interface
    hr = self->m_pIDataChanges3->get_ReplicaGuid(&bsReplicaGuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChanges3.get_ReplicaGuid() returned %ld", (long)hr);
        goto idatachanges3_get_replicaguid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ReplicaGuid = PyUnicode_FromWideChar(bsReplicaGuid,::SysStringLen(bsReplicaGuid));
    ::SysFreeString(bsReplicaGuid);
    
    if (PyErr_Occurred())
      goto idatachanges3_get_replicaguid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ReplicaGuid);
    goto idatachanges3_get_replicaguid_method_cleanup;

    idatachanges3_get_replicaguid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_ReplicaGuid != Py_None)
        Py_XDECREF(pyvar_ReplicaGuid);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChanges3.get_ReplicaGuid");
    return return_tuple;
}


PyMethodDef PyIDataChanges3Methods[] = {
    {"supports", (PyCFunction)PyIDataChanges3_SupportsInterface, METH_O, ""},
    {"get_GenerationNumbers", (PyCFunction)IDataChanges3Method_get_GenerationNumbers, METH_VARARGS, ""},
    {"get_ReplicaState", (PyCFunction)IDataChanges3Method_get_ReplicaState, METH_VARARGS, ""},
    {"get_ChangesModelType", (PyCFunction)IDataChanges3Method_get_ChangesModelType, METH_VARARGS, ""},
    {"GetModifiedClassesInfo", (PyCFunction)IDataChanges3Method_GetModifiedClassesInfo, METH_VARARGS, ""},
    {"Extract", (PyCFunction)IDataChanges3Method_Extract, METH_VARARGS, ""},
    {"get_ParentWorkspaceName", (PyCFunction)IDataChanges3Method_get_ParentWorkspaceName, METH_VARARGS, ""},
    {"get_ParentReplicaID", (PyCFunction)IDataChanges3Method_get_ParentReplicaID, METH_VARARGS, ""},
    {"get_ReplicaGuid", (PyCFunction)IDataChanges3Method_get_ReplicaGuid, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataChanges3GetSet[] = {
  {"_pUnk", (getter)PyIDataChanges3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataChanges3", NULL},
  {"_pointer", (getter)PyIDataChanges3_GetPointer, NULL, "Get memory address for IDataChanges3", NULL},
  {"_IID", (getter)PyIDataChanges3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataChanges3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataChanges3_GetIgnoreFailures, (setter)PyIDataChanges3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataChanges3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDataChanges3Object",                          
                                              /* tp_name */
  sizeof(PyIDataChanges3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataChanges3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataChanges3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataChanges3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataChanges3Object_new,                      
                                              /* tp_new */
};

// Interface IDataChangesInfo

typedef struct PyIDataChangesInfoObject {
    PyObject_HEAD
    IDataChangesInfo* m_pIDataChangesInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataChangesInfoObject;

static PyObject*
PyIDataChangesInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataChangesInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataChangesInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataChangesInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataChangesInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataChangesInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChangesInfo");
            return NULL;
        }
        self->m_pIDataChangesInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataChangesInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataChangesInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataChangesInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataChangesInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataChangesInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataChangesInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChangesInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataChangesInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataChangesInfoObject_dealloc(PyIDataChangesInfoObject* self)
{
    if (self->m_pIDataChangesInfo)
        self->m_pIDataChangesInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataChangesInfo_GetpUnk(PyIDataChangesInfoObject* self)
{
    if (!self->m_pIDataChangesInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataChangesInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataChangesInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataChangesInfo_GetPointer(PyIDataChangesInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataChangesInfo);
}

static PyObject*
PyIDataChangesInfo_GetIID(PyIDataChangesInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "bf34062d-82cb-47db-be39-8c8902e8a05a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataChangesInfo_GetHR(PyIDataChangesInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataChangesInfo_GetIgnoreFailures(PyIDataChangesInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataChangesInfo_SetIgnoreFailures(PyIDataChangesInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataChangesInfo_SupportsInterface(PyIDataChangesInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataChangesInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataChangesInfoMethod_get_ChangedIDs(PyIDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsclassName = 0;
    PyObject* pyvar_className;
    PyObject* unicodeclassName = NULL;
    esriDataChangeType ediffType;
    IFIDSet* ipppFIDSet = NULL;
    PyObject* py_ppFIDSet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_className, (int *)&ediffType))
      goto idatachangesinfo_get_changedids_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_className))
        unicodeclassName = PyUnicode_FromObject(pyvar_className);
    else if (PyUnicode_Check(pyvar_className))
    {
        unicodeclassName = pyvar_className;
        Py_INCREF(unicodeclassName);
    }
    else if (pyvar_className != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter className at index 0");
    if (unicodeclassName)
        bsclassName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeclassName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeclassName));
    
    if (PyErr_Occurred())
      goto idatachangesinfo_get_changedids_method_cleanup;
    
    // No setup for diffType
    // No setup for ppFIDSet

    // Call method on actual COM interface
    hr = self->m_pIDataChangesInfo->get_ChangedIDs(bsclassName, ediffType, &ipppFIDSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChangesInfo.get_ChangedIDs() returned %ld", (long)hr);
        goto idatachangesinfo_get_changedids_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for className
    // No teardown for diffType
    Py_XDECREF(py_ppFIDSet);
    if (ipppFIDSet)
    {
        IUnknown* pUnk = NULL;
        ipppFIDSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFIDSet = IUnknownToPythonIIDObject(pUnk, &IID_IFIDSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFIDSet)
    {
        if (py_ppFIDSet)
           Py_DECREF(py_ppFIDSet);
        py_ppFIDSet = Py_None;
        Py_INCREF(py_ppFIDSet);
    }
    if (PyErr_Occurred())
      goto idatachangesinfo_get_changedids_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppFIDSet);
    goto idatachangesinfo_get_changedids_method_cleanup;

    idatachangesinfo_get_changedids_method_cleanup:
    self->m_HR = hr;
    if (bsclassName)
        ::SysFreeString(bsclassName);
    
    // No cleanup for diffType
    Py_XDECREF(py_ppFIDSet);
    if (ipppFIDSet)
      ipppFIDSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChangesInfo.get_ChangedIDs");
    return return_tuple;
}


PyMethodDef PyIDataChangesInfoMethods[] = {
    {"supports", (PyCFunction)PyIDataChangesInfo_SupportsInterface, METH_O, ""},
    {"get_ChangedIDs", (PyCFunction)IDataChangesInfoMethod_get_ChangedIDs, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataChangesInfoGetSet[] = {
  {"_pUnk", (getter)PyIDataChangesInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataChangesInfo", NULL},
  {"_pointer", (getter)PyIDataChangesInfo_GetPointer, NULL, "Get memory address for IDataChangesInfo", NULL},
  {"_IID", (getter)PyIDataChangesInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataChangesInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataChangesInfo_GetIgnoreFailures, (setter)PyIDataChangesInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataChangesInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDataChangesInfoObject",                          
                                              /* tp_name */
  sizeof(PyIDataChangesInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataChangesInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataChangesInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataChangesInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataChangesInfoObject_new,                      
                                              /* tp_new */
};

// Interface IDataChangesExt

typedef struct PyIDataChangesExtObject {
    PyObject_HEAD
    IDataChangesExt* m_pIDataChangesExt;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataChangesExtObject;

static PyObject*
PyIDataChangesExtObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataChangesExtObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataChangesExt* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataChangesExt, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataChangesExt with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataChangesExtObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChangesExt");
            return NULL;
        }
        self->m_pIDataChangesExt = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataChangesExt");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataChangesExt");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataChangesExt* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataChangesExt, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataChangesExt");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataChangesExtObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataChangesExt");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataChangesExt = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataChangesExtObject_dealloc(PyIDataChangesExtObject* self)
{
    if (self->m_pIDataChangesExt)
        self->m_pIDataChangesExt->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataChangesExt_GetpUnk(PyIDataChangesExtObject* self)
{
    if (!self->m_pIDataChangesExt)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataChangesExt->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataChangesExt to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataChangesExt_GetPointer(PyIDataChangesExtObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataChangesExt);
}

static PyObject*
PyIDataChangesExt_GetIID(PyIDataChangesExtObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fafbfa81-b7bd-4c25-a456-0108e11ea25b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataChangesExt_GetHR(PyIDataChangesExtObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataChangesExt_GetIgnoreFailures(PyIDataChangesExtObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataChangesExt_SetIgnoreFailures(PyIDataChangesExtObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataChangesExt_SupportsInterface(PyIDataChangesExtObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataChangesExt->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataChangesExtMethod_ExtractOriginalRows(PyIDataChangesExtObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstableName = 0;
    PyObject* pyvar_tableName;
    PyObject* unicodetableName = NULL;
    IFIDSet* ipIDs = NULL;
    PyObject* py_IDs;
    ICursor* ipOriginalRows = NULL;
    PyObject* py_OriginalRows = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_tableName, &py_IDs))
      goto idatachangesext_extractoriginalrows_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_tableName))
        unicodetableName = PyUnicode_FromObject(pyvar_tableName);
    else if (PyUnicode_Check(pyvar_tableName))
    {
        unicodetableName = pyvar_tableName;
        Py_INCREF(unicodetableName);
    }
    else if (pyvar_tableName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter tableName at index 0");
    if (unicodetableName)
        bstableName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetableName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetableName));
    
    if (PyErr_Occurred())
      goto idatachangesext_extractoriginalrows_method_cleanup;
    
    if (!IFaceFromPyObject(py_IDs, &IID_IFIDSet, (void**)&ipIDs))
        PyErr_SetString(PyExc_TypeError, "Argument IDs (position 1) is not IFIDSet");
    
    if (PyErr_Occurred())
      goto idatachangesext_extractoriginalrows_method_cleanup;
    
    // No setup for OriginalRows

    // Call method on actual COM interface
    hr = self->m_pIDataChangesExt->ExtractOriginalRows(bstableName, ipIDs, &ipOriginalRows);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataChangesExt->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataChangesExt) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataChangesExt.ExtractOriginalRows() returned %ld", (long)hr);
        goto idatachangesext_extractoriginalrows_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for tableName
    // No teardown for IDs
    Py_XDECREF(py_OriginalRows);
    if (ipOriginalRows)
    {
        IUnknown* pUnk = NULL;
        ipOriginalRows->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_OriginalRows = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_OriginalRows)
    {
        if (py_OriginalRows)
           Py_DECREF(py_OriginalRows);
        py_OriginalRows = Py_None;
        Py_INCREF(py_OriginalRows);
    }
    if (PyErr_Occurred())
      goto idatachangesext_extractoriginalrows_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_OriginalRows);
    goto idatachangesext_extractoriginalrows_method_cleanup;

    idatachangesext_extractoriginalrows_method_cleanup:
    self->m_HR = hr;
    if (bstableName)
        ::SysFreeString(bstableName);
    
    if (ipIDs)
      ipIDs->Release();
    Py_XDECREF(py_OriginalRows);
    if (ipOriginalRows)
      ipOriginalRows->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataChangesExt.ExtractOriginalRows");
    return return_tuple;
}


PyMethodDef PyIDataChangesExtMethods[] = {
    {"supports", (PyCFunction)PyIDataChangesExt_SupportsInterface, METH_O, ""},
    {"ExtractOriginalRows", (PyCFunction)IDataChangesExtMethod_ExtractOriginalRows, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataChangesExtGetSet[] = {
  {"_pUnk", (getter)PyIDataChangesExt_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataChangesExt", NULL},
  {"_pointer", (getter)PyIDataChangesExt_GetPointer, NULL, "Get memory address for IDataChangesExt", NULL},
  {"_IID", (getter)PyIDataChangesExt_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataChangesExt_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataChangesExt_GetIgnoreFailures, (setter)PyIDataChangesExt_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataChangesExtObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IDataChangesExtObject",                          
                                              /* tp_name */
  sizeof(PyIDataChangesExtObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataChangesExtObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataChangesExtMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataChangesExtGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataChangesExtObject_new,                      
                                              /* tp_new */
};

// Interface IImportDataChanges

typedef struct PyIImportDataChangesObject {
    PyObject_HEAD
    IImportDataChanges* m_pIImportDataChanges;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIImportDataChangesObject;

static PyObject*
PyIImportDataChangesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIImportDataChangesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IImportDataChanges* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IImportDataChanges, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IImportDataChanges with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIImportDataChangesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IImportDataChanges");
            return NULL;
        }
        self->m_pIImportDataChanges = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IImportDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IImportDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IImportDataChanges* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IImportDataChanges, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IImportDataChanges");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIImportDataChangesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IImportDataChanges");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIImportDataChanges = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIImportDataChangesObject_dealloc(PyIImportDataChangesObject* self)
{
    if (self->m_pIImportDataChanges)
        self->m_pIImportDataChanges->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIImportDataChanges_GetpUnk(PyIImportDataChangesObject* self)
{
    if (!self->m_pIImportDataChanges)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIImportDataChanges->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IImportDataChanges to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIImportDataChanges_GetPointer(PyIImportDataChangesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIImportDataChanges);
}

static PyObject*
PyIImportDataChanges_GetIID(PyIImportDataChangesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3eea0fb7-0478-400b-bf5c-122ea29c50a4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIImportDataChanges_GetHR(PyIImportDataChangesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIImportDataChanges_GetIgnoreFailures(PyIImportDataChangesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIImportDataChanges_SetIgnoreFailures(PyIImportDataChangesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIImportDataChanges_SupportsInterface(PyIImportDataChangesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIImportDataChanges->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IImportDataChangesMethod_ImportDataChanges(PyIImportDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipWorkspaceName = NULL;
    PyObject* py_WorkspaceName;
    IDeltaDataChanges* ipDeltaDataChanges = NULL;
    PyObject* py_DeltaDataChanges;
    VARIANT_BOOL b_ReconcileWithParent = VARIANT_FALSE;
    PyObject* pyvar_ReconcileWithParent = NULL;
    VARIANT_BOOL b_acceptDefaultConflictResolution = VARIANT_FALSE;
    PyObject* pyvar_acceptDefaultConflictResolution = NULL;
    VARIANT_BOOL b_pConflictDetected = VARIANT_FALSE;
    PyObject* pyvar_pConflictDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_WorkspaceName, &py_DeltaDataChanges, &pyvar_ReconcileWithParent, &pyvar_acceptDefaultConflictResolution))
      goto iimportdatachanges_importdatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_WorkspaceName, &IID_IWorkspaceName, (void**)&ipWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument WorkspaceName (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iimportdatachanges_importdatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_DeltaDataChanges, &IID_IDeltaDataChanges, (void**)&ipDeltaDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DeltaDataChanges (position 1) is not IDeltaDataChanges");
    
    if (PyErr_Occurred())
      goto iimportdatachanges_importdatachanges_method_cleanup;
    
    b_ReconcileWithParent = ((PyObject_IsTrue(pyvar_ReconcileWithParent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges_importdatachanges_method_cleanup;
    
    b_acceptDefaultConflictResolution = ((PyObject_IsTrue(pyvar_acceptDefaultConflictResolution) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges_importdatachanges_method_cleanup;
    
    // No setup for pConflictDetected

    // Call method on actual COM interface
    hr = self->m_pIImportDataChanges->ImportDataChanges(ipWorkspaceName, ipDeltaDataChanges, b_ReconcileWithParent, b_acceptDefaultConflictResolution, &b_pConflictDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIImportDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IImportDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IImportDataChanges.ImportDataChanges() returned %ld", (long)hr);
        goto iimportdatachanges_importdatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for WorkspaceName
    // No teardown for DeltaDataChanges
    // No teardown for ReconcileWithParent
    // No teardown for acceptDefaultConflictResolution
    pyvar_pConflictDetected = ((b_pConflictDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iimportdatachanges_importdatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pConflictDetected);
    goto iimportdatachanges_importdatachanges_method_cleanup;

    iimportdatachanges_importdatachanges_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspaceName)
      ipWorkspaceName->Release();
    if (ipDeltaDataChanges)
      ipDeltaDataChanges->Release();
    // No cleanup for ReconcileWithParent
    // No cleanup for acceptDefaultConflictResolution
    // No cleanup for pConflictDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IImportDataChanges.ImportDataChanges");
    return return_tuple;
}


PyMethodDef PyIImportDataChangesMethods[] = {
    {"supports", (PyCFunction)PyIImportDataChanges_SupportsInterface, METH_O, ""},
    {"ImportDataChanges", (PyCFunction)IImportDataChangesMethod_ImportDataChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIImportDataChangesGetSet[] = {
  {"_pUnk", (getter)PyIImportDataChanges_GetpUnk, NULL, "Get opaque pointer to an Unknown from IImportDataChanges", NULL},
  {"_pointer", (getter)PyIImportDataChanges_GetPointer, NULL, "Get memory address for IImportDataChanges", NULL},
  {"_IID", (getter)PyIImportDataChanges_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIImportDataChanges_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIImportDataChanges_GetIgnoreFailures, (setter)PyIImportDataChanges_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIImportDataChangesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IImportDataChangesObject",                          
                                              /* tp_name */
  sizeof(PyIImportDataChangesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIImportDataChangesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIImportDataChangesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIImportDataChangesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIImportDataChangesObject_new,                      
                                              /* tp_new */
};

// Interface IImportDataChanges2

typedef struct PyIImportDataChanges2Object {
    PyObject_HEAD
    IImportDataChanges2* m_pIImportDataChanges2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIImportDataChanges2Object;

static PyObject*
PyIImportDataChanges2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIImportDataChanges2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IImportDataChanges2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IImportDataChanges2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IImportDataChanges2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIImportDataChanges2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IImportDataChanges2");
            return NULL;
        }
        self->m_pIImportDataChanges2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IImportDataChanges2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IImportDataChanges2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IImportDataChanges2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IImportDataChanges2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IImportDataChanges2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIImportDataChanges2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IImportDataChanges2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIImportDataChanges2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIImportDataChanges2Object_dealloc(PyIImportDataChanges2Object* self)
{
    if (self->m_pIImportDataChanges2)
        self->m_pIImportDataChanges2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIImportDataChanges2_GetpUnk(PyIImportDataChanges2Object* self)
{
    if (!self->m_pIImportDataChanges2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIImportDataChanges2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IImportDataChanges2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIImportDataChanges2_GetPointer(PyIImportDataChanges2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIImportDataChanges2);
}

static PyObject*
PyIImportDataChanges2_GetIID(PyIImportDataChanges2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "27fa7510-e45d-49a2-8d57-7753db605d04");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIImportDataChanges2_GetHR(PyIImportDataChanges2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIImportDataChanges2_GetIgnoreFailures(PyIImportDataChanges2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIImportDataChanges2_SetIgnoreFailures(PyIImportDataChanges2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIImportDataChanges2_SupportsInterface(PyIImportDataChanges2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIImportDataChanges2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IImportDataChanges2Method_ImportDataChanges2(PyIImportDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipWorkspaceName = NULL;
    PyObject* py_WorkspaceName;
    IDeltaDataChanges* ipDeltaDataChanges = NULL;
    PyObject* py_DeltaDataChanges;
    VARIANT_BOOL b_ReconcileWithParent = VARIANT_FALSE;
    PyObject* pyvar_ReconcileWithParent = NULL;
    esriReplicaReconcilePolicyType ereconcilePolicy;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_pConflictDetected = VARIANT_FALSE;
    PyObject* pyvar_pConflictDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOiOO", &py_WorkspaceName, &py_DeltaDataChanges, &pyvar_ReconcileWithParent, (int *)&ereconcilePolicy, &pyvar_columnLevel, &pyvar_createOIDMappingTable))
      goto iimportdatachanges2_importdatachanges2_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_WorkspaceName, &IID_IWorkspaceName, (void**)&ipWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument WorkspaceName (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges2_method_cleanup;
    
    if (!IFaceFromPyObject(py_DeltaDataChanges, &IID_IDeltaDataChanges, (void**)&ipDeltaDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DeltaDataChanges (position 1) is not IDeltaDataChanges");
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges2_method_cleanup;
    
    b_ReconcileWithParent = ((PyObject_IsTrue(pyvar_ReconcileWithParent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges2_method_cleanup;
    
    // No setup for reconcilePolicy
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges2_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges2_method_cleanup;
    
    // No setup for pConflictDetected

    // Call method on actual COM interface
    hr = self->m_pIImportDataChanges2->ImportDataChanges2(ipWorkspaceName, ipDeltaDataChanges, b_ReconcileWithParent, ereconcilePolicy, b_columnLevel, b_createOIDMappingTable, &b_pConflictDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIImportDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IImportDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IImportDataChanges2.ImportDataChanges2() returned %ld", (long)hr);
        goto iimportdatachanges2_importdatachanges2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for WorkspaceName
    // No teardown for DeltaDataChanges
    // No teardown for ReconcileWithParent
    // No teardown for reconcilePolicy
    // No teardown for columnLevel
    // No teardown for createOIDMappingTable
    pyvar_pConflictDetected = ((b_pConflictDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges2_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pConflictDetected);
    goto iimportdatachanges2_importdatachanges2_method_cleanup;

    iimportdatachanges2_importdatachanges2_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspaceName)
      ipWorkspaceName->Release();
    if (ipDeltaDataChanges)
      ipDeltaDataChanges->Release();
    // No cleanup for ReconcileWithParent
    // No cleanup for reconcilePolicy
    // No cleanup for columnLevel
    // No cleanup for createOIDMappingTable
    // No cleanup for pConflictDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IImportDataChanges2.ImportDataChanges2");
    return return_tuple;
}

static PyObject*
IImportDataChanges2Method_ImportDataChanges(PyIImportDataChanges2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipWorkspaceName = NULL;
    PyObject* py_WorkspaceName;
    IDeltaDataChanges* ipDeltaDataChanges = NULL;
    PyObject* py_DeltaDataChanges;
    VARIANT_BOOL b_ReconcileWithParent = VARIANT_FALSE;
    PyObject* pyvar_ReconcileWithParent = NULL;
    VARIANT_BOOL b_acceptDefaultConflictResolution = VARIANT_FALSE;
    PyObject* pyvar_acceptDefaultConflictResolution = NULL;
    VARIANT_BOOL b_pConflictDetected = VARIANT_FALSE;
    PyObject* pyvar_pConflictDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_WorkspaceName, &py_DeltaDataChanges, &pyvar_ReconcileWithParent, &pyvar_acceptDefaultConflictResolution))
      goto iimportdatachanges2_importdatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_WorkspaceName, &IID_IWorkspaceName, (void**)&ipWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument WorkspaceName (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_DeltaDataChanges, &IID_IDeltaDataChanges, (void**)&ipDeltaDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DeltaDataChanges (position 1) is not IDeltaDataChanges");
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges_method_cleanup;
    
    b_ReconcileWithParent = ((PyObject_IsTrue(pyvar_ReconcileWithParent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges_method_cleanup;
    
    b_acceptDefaultConflictResolution = ((PyObject_IsTrue(pyvar_acceptDefaultConflictResolution) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges_method_cleanup;
    
    // No setup for pConflictDetected

    // Call method on actual COM interface
    hr = self->m_pIImportDataChanges2->ImportDataChanges(ipWorkspaceName, ipDeltaDataChanges, b_ReconcileWithParent, b_acceptDefaultConflictResolution, &b_pConflictDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIImportDataChanges2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IImportDataChanges2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IImportDataChanges2.ImportDataChanges() returned %ld", (long)hr);
        goto iimportdatachanges2_importdatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for WorkspaceName
    // No teardown for DeltaDataChanges
    // No teardown for ReconcileWithParent
    // No teardown for acceptDefaultConflictResolution
    pyvar_pConflictDetected = ((b_pConflictDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iimportdatachanges2_importdatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pConflictDetected);
    goto iimportdatachanges2_importdatachanges_method_cleanup;

    iimportdatachanges2_importdatachanges_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspaceName)
      ipWorkspaceName->Release();
    if (ipDeltaDataChanges)
      ipDeltaDataChanges->Release();
    // No cleanup for ReconcileWithParent
    // No cleanup for acceptDefaultConflictResolution
    // No cleanup for pConflictDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IImportDataChanges2.ImportDataChanges");
    return return_tuple;
}


PyMethodDef PyIImportDataChanges2Methods[] = {
    {"supports", (PyCFunction)PyIImportDataChanges2_SupportsInterface, METH_O, ""},
    {"ImportDataChanges2", (PyCFunction)IImportDataChanges2Method_ImportDataChanges2, METH_VARARGS, ""},
    {"ImportDataChanges", (PyCFunction)IImportDataChanges2Method_ImportDataChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIImportDataChanges2GetSet[] = {
  {"_pUnk", (getter)PyIImportDataChanges2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IImportDataChanges2", NULL},
  {"_pointer", (getter)PyIImportDataChanges2_GetPointer, NULL, "Get memory address for IImportDataChanges2", NULL},
  {"_IID", (getter)PyIImportDataChanges2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIImportDataChanges2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIImportDataChanges2_GetIgnoreFailures, (setter)PyIImportDataChanges2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIImportDataChanges2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IImportDataChanges2Object",                          
                                              /* tp_name */
  sizeof(PyIImportDataChanges2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIImportDataChanges2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIImportDataChanges2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIImportDataChanges2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIImportDataChanges2Object_new,                      
                                              /* tp_new */
};

// Interface IImportDataChanges3

typedef struct PyIImportDataChanges3Object {
    PyObject_HEAD
    IImportDataChanges3* m_pIImportDataChanges3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIImportDataChanges3Object;

static PyObject*
PyIImportDataChanges3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIImportDataChanges3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IImportDataChanges3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IImportDataChanges3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IImportDataChanges3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIImportDataChanges3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IImportDataChanges3");
            return NULL;
        }
        self->m_pIImportDataChanges3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IImportDataChanges3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IImportDataChanges3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IImportDataChanges3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IImportDataChanges3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IImportDataChanges3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIImportDataChanges3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IImportDataChanges3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIImportDataChanges3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIImportDataChanges3Object_dealloc(PyIImportDataChanges3Object* self)
{
    if (self->m_pIImportDataChanges3)
        self->m_pIImportDataChanges3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIImportDataChanges3_GetpUnk(PyIImportDataChanges3Object* self)
{
    if (!self->m_pIImportDataChanges3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIImportDataChanges3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IImportDataChanges3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIImportDataChanges3_GetPointer(PyIImportDataChanges3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIImportDataChanges3);
}

static PyObject*
PyIImportDataChanges3_GetIID(PyIImportDataChanges3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a2f2dba2-0515-4fa3-882c-3633480bd24a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIImportDataChanges3_GetHR(PyIImportDataChanges3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIImportDataChanges3_GetIgnoreFailures(PyIImportDataChanges3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIImportDataChanges3_SetIgnoreFailures(PyIImportDataChanges3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIImportDataChanges3_SupportsInterface(PyIImportDataChanges3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIImportDataChanges3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IImportDataChanges3Method_ImportDataChanges3(PyIImportDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipWorkspaceName = NULL;
    PyObject* py_WorkspaceName;
    IDataChanges* ipDataChanges = NULL;
    PyObject* py_DataChanges;
    VARIANT_BOOL b_ReconcileWithParent = VARIANT_FALSE;
    PyObject* pyvar_ReconcileWithParent = NULL;
    esriReplicaReconcilePolicyType ereconcilePolicy;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_PreserveGlobalIDs = VARIANT_FALSE;
    PyObject* pyvar_PreserveGlobalIDs = NULL;
    VARIANT_BOOL b_pConflictDetected = VARIANT_FALSE;
    PyObject* pyvar_pConflictDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOiOOO", &py_WorkspaceName, &py_DataChanges, &pyvar_ReconcileWithParent, (int *)&ereconcilePolicy, &pyvar_columnLevel, &pyvar_createOIDMappingTable, &pyvar_PreserveGlobalIDs))
      goto iimportdatachanges3_importdatachanges3_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_WorkspaceName, &IID_IWorkspaceName, (void**)&ipWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument WorkspaceName (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges3_method_cleanup;
    
    if (!IFaceFromPyObject(py_DataChanges, &IID_IDataChanges, (void**)&ipDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DataChanges (position 1) is not IDataChanges");
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges3_method_cleanup;
    
    b_ReconcileWithParent = ((PyObject_IsTrue(pyvar_ReconcileWithParent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges3_method_cleanup;
    
    // No setup for reconcilePolicy
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges3_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges3_method_cleanup;
    
    b_PreserveGlobalIDs = ((PyObject_IsTrue(pyvar_PreserveGlobalIDs) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges3_method_cleanup;
    
    // No setup for pConflictDetected

    // Call method on actual COM interface
    hr = self->m_pIImportDataChanges3->ImportDataChanges3(ipWorkspaceName, ipDataChanges, b_ReconcileWithParent, ereconcilePolicy, b_columnLevel, b_createOIDMappingTable, b_PreserveGlobalIDs, &b_pConflictDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIImportDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IImportDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IImportDataChanges3.ImportDataChanges3() returned %ld", (long)hr);
        goto iimportdatachanges3_importdatachanges3_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for WorkspaceName
    // No teardown for DataChanges
    // No teardown for ReconcileWithParent
    // No teardown for reconcilePolicy
    // No teardown for columnLevel
    // No teardown for createOIDMappingTable
    // No teardown for PreserveGlobalIDs
    pyvar_pConflictDetected = ((b_pConflictDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges3_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pConflictDetected);
    goto iimportdatachanges3_importdatachanges3_method_cleanup;

    iimportdatachanges3_importdatachanges3_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspaceName)
      ipWorkspaceName->Release();
    if (ipDataChanges)
      ipDataChanges->Release();
    // No cleanup for ReconcileWithParent
    // No cleanup for reconcilePolicy
    // No cleanup for columnLevel
    // No cleanup for createOIDMappingTable
    // No cleanup for PreserveGlobalIDs
    // No cleanup for pConflictDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IImportDataChanges3.ImportDataChanges3");
    return return_tuple;
}

static PyObject*
IImportDataChanges3Method_ImportDataChanges2(PyIImportDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipWorkspaceName = NULL;
    PyObject* py_WorkspaceName;
    IDeltaDataChanges* ipDeltaDataChanges = NULL;
    PyObject* py_DeltaDataChanges;
    VARIANT_BOOL b_ReconcileWithParent = VARIANT_FALSE;
    PyObject* pyvar_ReconcileWithParent = NULL;
    esriReplicaReconcilePolicyType ereconcilePolicy;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_pConflictDetected = VARIANT_FALSE;
    PyObject* pyvar_pConflictDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOiOO", &py_WorkspaceName, &py_DeltaDataChanges, &pyvar_ReconcileWithParent, (int *)&ereconcilePolicy, &pyvar_columnLevel, &pyvar_createOIDMappingTable))
      goto iimportdatachanges3_importdatachanges2_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_WorkspaceName, &IID_IWorkspaceName, (void**)&ipWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument WorkspaceName (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges2_method_cleanup;
    
    if (!IFaceFromPyObject(py_DeltaDataChanges, &IID_IDeltaDataChanges, (void**)&ipDeltaDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DeltaDataChanges (position 1) is not IDeltaDataChanges");
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges2_method_cleanup;
    
    b_ReconcileWithParent = ((PyObject_IsTrue(pyvar_ReconcileWithParent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges2_method_cleanup;
    
    // No setup for reconcilePolicy
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges2_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges2_method_cleanup;
    
    // No setup for pConflictDetected

    // Call method on actual COM interface
    hr = self->m_pIImportDataChanges3->ImportDataChanges2(ipWorkspaceName, ipDeltaDataChanges, b_ReconcileWithParent, ereconcilePolicy, b_columnLevel, b_createOIDMappingTable, &b_pConflictDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIImportDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IImportDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IImportDataChanges3.ImportDataChanges2() returned %ld", (long)hr);
        goto iimportdatachanges3_importdatachanges2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for WorkspaceName
    // No teardown for DeltaDataChanges
    // No teardown for ReconcileWithParent
    // No teardown for reconcilePolicy
    // No teardown for columnLevel
    // No teardown for createOIDMappingTable
    pyvar_pConflictDetected = ((b_pConflictDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges2_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pConflictDetected);
    goto iimportdatachanges3_importdatachanges2_method_cleanup;

    iimportdatachanges3_importdatachanges2_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspaceName)
      ipWorkspaceName->Release();
    if (ipDeltaDataChanges)
      ipDeltaDataChanges->Release();
    // No cleanup for ReconcileWithParent
    // No cleanup for reconcilePolicy
    // No cleanup for columnLevel
    // No cleanup for createOIDMappingTable
    // No cleanup for pConflictDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IImportDataChanges3.ImportDataChanges2");
    return return_tuple;
}

static PyObject*
IImportDataChanges3Method_ImportDataChanges(PyIImportDataChanges3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipWorkspaceName = NULL;
    PyObject* py_WorkspaceName;
    IDeltaDataChanges* ipDeltaDataChanges = NULL;
    PyObject* py_DeltaDataChanges;
    VARIANT_BOOL b_ReconcileWithParent = VARIANT_FALSE;
    PyObject* pyvar_ReconcileWithParent = NULL;
    VARIANT_BOOL b_acceptDefaultConflictResolution = VARIANT_FALSE;
    PyObject* pyvar_acceptDefaultConflictResolution = NULL;
    VARIANT_BOOL b_pConflictDetected = VARIANT_FALSE;
    PyObject* pyvar_pConflictDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_WorkspaceName, &py_DeltaDataChanges, &pyvar_ReconcileWithParent, &pyvar_acceptDefaultConflictResolution))
      goto iimportdatachanges3_importdatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_WorkspaceName, &IID_IWorkspaceName, (void**)&ipWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument WorkspaceName (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_DeltaDataChanges, &IID_IDeltaDataChanges, (void**)&ipDeltaDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DeltaDataChanges (position 1) is not IDeltaDataChanges");
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges_method_cleanup;
    
    b_ReconcileWithParent = ((PyObject_IsTrue(pyvar_ReconcileWithParent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges_method_cleanup;
    
    b_acceptDefaultConflictResolution = ((PyObject_IsTrue(pyvar_acceptDefaultConflictResolution) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges_method_cleanup;
    
    // No setup for pConflictDetected

    // Call method on actual COM interface
    hr = self->m_pIImportDataChanges3->ImportDataChanges(ipWorkspaceName, ipDeltaDataChanges, b_ReconcileWithParent, b_acceptDefaultConflictResolution, &b_pConflictDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIImportDataChanges3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IImportDataChanges3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IImportDataChanges3.ImportDataChanges() returned %ld", (long)hr);
        goto iimportdatachanges3_importdatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for WorkspaceName
    // No teardown for DeltaDataChanges
    // No teardown for ReconcileWithParent
    // No teardown for acceptDefaultConflictResolution
    pyvar_pConflictDetected = ((b_pConflictDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iimportdatachanges3_importdatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pConflictDetected);
    goto iimportdatachanges3_importdatachanges_method_cleanup;

    iimportdatachanges3_importdatachanges_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspaceName)
      ipWorkspaceName->Release();
    if (ipDeltaDataChanges)
      ipDeltaDataChanges->Release();
    // No cleanup for ReconcileWithParent
    // No cleanup for acceptDefaultConflictResolution
    // No cleanup for pConflictDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IImportDataChanges3.ImportDataChanges");
    return return_tuple;
}


PyMethodDef PyIImportDataChanges3Methods[] = {
    {"supports", (PyCFunction)PyIImportDataChanges3_SupportsInterface, METH_O, ""},
    {"ImportDataChanges3", (PyCFunction)IImportDataChanges3Method_ImportDataChanges3, METH_VARARGS, ""},
    {"ImportDataChanges2", (PyCFunction)IImportDataChanges3Method_ImportDataChanges2, METH_VARARGS, ""},
    {"ImportDataChanges", (PyCFunction)IImportDataChanges3Method_ImportDataChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIImportDataChanges3GetSet[] = {
  {"_pUnk", (getter)PyIImportDataChanges3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IImportDataChanges3", NULL},
  {"_pointer", (getter)PyIImportDataChanges3_GetPointer, NULL, "Get memory address for IImportDataChanges3", NULL},
  {"_IID", (getter)PyIImportDataChanges3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIImportDataChanges3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIImportDataChanges3_GetIgnoreFailures, (setter)PyIImportDataChanges3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIImportDataChanges3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IImportDataChanges3Object",                          
                                              /* tp_name */
  sizeof(PyIImportDataChanges3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIImportDataChanges3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIImportDataChanges3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIImportDataChanges3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIImportDataChanges3Object_new,                      
                                              /* tp_new */
};

// Interface IReplicasExporter

typedef struct PyIReplicasExporterObject {
    PyObject_HEAD
    IReplicasExporter* m_pIReplicasExporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicasExporterObject;

static PyObject*
PyIReplicasExporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicasExporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicasExporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicasExporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicasExporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicasExporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicasExporter");
            return NULL;
        }
        self->m_pIReplicasExporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicasExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicasExporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicasExporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicasExporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicasExporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicasExporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicasExporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicasExporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicasExporterObject_dealloc(PyIReplicasExporterObject* self)
{
    if (self->m_pIReplicasExporter)
        self->m_pIReplicasExporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicasExporter_GetpUnk(PyIReplicasExporterObject* self)
{
    if (!self->m_pIReplicasExporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicasExporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicasExporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicasExporter_GetPointer(PyIReplicasExporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicasExporter);
}

static PyObject*
PyIReplicasExporter_GetIID(PyIReplicasExporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "28c7af79-0a93-4ed1-832b-d1e1aec0ff75");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicasExporter_GetHR(PyIReplicasExporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicasExporter_GetIgnoreFailures(PyIReplicasExporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicasExporter_SetIgnoreFailures(PyIReplicasExporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicasExporter_SupportsInterface(PyIReplicasExporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicasExporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicasExporterMethod_ExportReplicasInfo(PyIReplicasExporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspace* ippFromWS = NULL;
    PyObject* py_pFromWS;
    IWorkspace* ippDestWS = NULL;
    PyObject* py_pDestWS;
    BSTR bsfcName = 0;
    PyObject* pyvar_fcName;
    PyObject* unicodefcName = NULL;
    ISpatialReference* ipSR = NULL;
    PyObject* py_SR;
    IFeatureClass* ipppFC = NULL;
    PyObject* py_ppFC = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_pFromWS, &py_pDestWS, &pyvar_fcName, &py_SR))
      goto ireplicasexporter_exportreplicasinfo_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pFromWS, &IID_IWorkspace, (void**)&ippFromWS))
        PyErr_SetString(PyExc_TypeError, "Argument pFromWS (position 0) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto ireplicasexporter_exportreplicasinfo_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDestWS, &IID_IWorkspace, (void**)&ippDestWS))
        PyErr_SetString(PyExc_TypeError, "Argument pDestWS (position 1) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto ireplicasexporter_exportreplicasinfo_method_cleanup;
    
    if (PyString_Check(pyvar_fcName))
        unicodefcName = PyUnicode_FromObject(pyvar_fcName);
    else if (PyUnicode_Check(pyvar_fcName))
    {
        unicodefcName = pyvar_fcName;
        Py_INCREF(unicodefcName);
    }
    else if (pyvar_fcName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fcName at index 2");
    if (unicodefcName)
        bsfcName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefcName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefcName));
    
    if (PyErr_Occurred())
      goto ireplicasexporter_exportreplicasinfo_method_cleanup;
    
    if (!IFaceFromPyObject(py_SR, &IID_ISpatialReference, (void**)&ipSR))
        PyErr_SetString(PyExc_TypeError, "Argument SR (position 3) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto ireplicasexporter_exportreplicasinfo_method_cleanup;
    
    // No setup for ppFC

    // Call method on actual COM interface
    hr = self->m_pIReplicasExporter->ExportReplicasInfo(ippFromWS, ippDestWS, bsfcName, ipSR, &ipppFC);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicasExporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicasExporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicasExporter.ExportReplicasInfo() returned %ld", (long)hr);
        goto ireplicasexporter_exportreplicasinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFromWS
    // No teardown for pDestWS
    // No teardown for fcName
    // No teardown for SR
    Py_XDECREF(py_ppFC);
    if (ipppFC)
    {
        IUnknown* pUnk = NULL;
        ipppFC->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFC = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFC)
    {
        if (py_ppFC)
           Py_DECREF(py_ppFC);
        py_ppFC = Py_None;
        Py_INCREF(py_ppFC);
    }
    if (PyErr_Occurred())
      goto ireplicasexporter_exportreplicasinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppFC);
    goto ireplicasexporter_exportreplicasinfo_method_cleanup;

    ireplicasexporter_exportreplicasinfo_method_cleanup:
    self->m_HR = hr;
    if (ippFromWS)
      ippFromWS->Release();
    if (ippDestWS)
      ippDestWS->Release();
    if (bsfcName)
        ::SysFreeString(bsfcName);
    
    if (ipSR)
      ipSR->Release();
    Py_XDECREF(py_ppFC);
    if (ipppFC)
      ipppFC->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicasExporter.ExportReplicasInfo");
    return return_tuple;
}


PyMethodDef PyIReplicasExporterMethods[] = {
    {"supports", (PyCFunction)PyIReplicasExporter_SupportsInterface, METH_O, ""},
    {"ExportReplicasInfo", (PyCFunction)IReplicasExporterMethod_ExportReplicasInfo, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicasExporterGetSet[] = {
  {"_pUnk", (getter)PyIReplicasExporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicasExporter", NULL},
  {"_pointer", (getter)PyIReplicasExporter_GetPointer, NULL, "Get memory address for IReplicasExporter", NULL},
  {"_IID", (getter)PyIReplicasExporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicasExporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicasExporter_GetIgnoreFailures, (setter)PyIReplicasExporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicasExporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicasExporterObject",                          
                                              /* tp_name */
  sizeof(PyIReplicasExporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicasExporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicasExporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicasExporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicasExporterObject_new,                      
                                              /* tp_new */
};

// Interface ITableDataChangesInfo

typedef struct PyITableDataChangesInfoObject {
    PyObject_HEAD
    ITableDataChangesInfo* m_pITableDataChangesInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITableDataChangesInfoObject;

static PyObject*
PyITableDataChangesInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITableDataChangesInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITableDataChangesInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITableDataChangesInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITableDataChangesInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITableDataChangesInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITableDataChangesInfo");
            return NULL;
        }
        self->m_pITableDataChangesInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITableDataChangesInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITableDataChangesInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITableDataChangesInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITableDataChangesInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITableDataChangesInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITableDataChangesInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITableDataChangesInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITableDataChangesInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITableDataChangesInfoObject_dealloc(PyITableDataChangesInfoObject* self)
{
    if (self->m_pITableDataChangesInfo)
        self->m_pITableDataChangesInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITableDataChangesInfo_GetpUnk(PyITableDataChangesInfoObject* self)
{
    if (!self->m_pITableDataChangesInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITableDataChangesInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITableDataChangesInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITableDataChangesInfo_GetPointer(PyITableDataChangesInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITableDataChangesInfo);
}

static PyObject*
PyITableDataChangesInfo_GetIID(PyITableDataChangesInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "387adb2e-328b-464d-b6d6-548d0fd4447d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITableDataChangesInfo_GetHR(PyITableDataChangesInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITableDataChangesInfo_GetIgnoreFailures(PyITableDataChangesInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITableDataChangesInfo_SetIgnoreFailures(PyITableDataChangesInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITableDataChangesInfo_SupportsInterface(PyITableDataChangesInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITableDataChangesInfoMethod_Init(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTargetName = 0;
    PyObject* pyvar_TargetName;
    PyObject* unicodeTargetName = NULL;
    ITable* ipInserts = NULL;
    PyObject* py_Inserts;
    ITable* ipUpdates = NULL;
    PyObject* py_Updates;
    ITable* ipDeletes = NULL;
    PyObject* py_Deletes;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_TargetName, &py_Inserts, &py_Updates, &py_Deletes))
      goto itabledatachangesinfo_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_TargetName))
        unicodeTargetName = PyUnicode_FromObject(pyvar_TargetName);
    else if (PyUnicode_Check(pyvar_TargetName))
    {
        unicodeTargetName = pyvar_TargetName;
        Py_INCREF(unicodeTargetName);
    }
    else if (pyvar_TargetName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter TargetName at index 0");
    if (unicodeTargetName)
        bsTargetName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTargetName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTargetName));
    
    if (PyErr_Occurred())
      goto itabledatachangesinfo_init_method_cleanup;
    
    if (!IFaceFromPyObject(py_Inserts, &IID_ITable, (void**)&ipInserts))
        PyErr_SetString(PyExc_TypeError, "Argument Inserts (position 1) is not ITable");
    
    if (PyErr_Occurred())
      goto itabledatachangesinfo_init_method_cleanup;
    
    if (!IFaceFromPyObject(py_Updates, &IID_ITable, (void**)&ipUpdates))
        PyErr_SetString(PyExc_TypeError, "Argument Updates (position 2) is not ITable");
    
    if (PyErr_Occurred())
      goto itabledatachangesinfo_init_method_cleanup;
    
    if (!IFaceFromPyObject(py_Deletes, &IID_ITable, (void**)&ipDeletes))
        PyErr_SetString(PyExc_TypeError, "Argument Deletes (position 3) is not ITable");
    
    if (PyErr_Occurred())
      goto itabledatachangesinfo_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->Init(bsTargetName, ipInserts, ipUpdates, ipDeletes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.Init() returned %ld", (long)hr);
        goto itabledatachangesinfo_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TargetName
    // No teardown for Inserts
    // No teardown for Updates
    // No teardown for Deletes

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itabledatachangesinfo_init_method_cleanup;

    itabledatachangesinfo_init_method_cleanup:
    self->m_HR = hr;
    if (bsTargetName)
        ::SysFreeString(bsTargetName);
    
    if (ipInserts)
      ipInserts->Release();
    if (ipUpdates)
      ipUpdates->Release();
    if (ipDeletes)
      ipDeletes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.Init");
    return return_tuple;
}

static PyObject*
ITableDataChangesInfoMethod_SetFilter(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDataChangeType echangeType;
    IQueryFilter* ipFilter = NULL;
    PyObject* py_Filter;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&echangeType, &py_Filter))
      goto itabledatachangesinfo_setfilter_method_cleanup;

    // Set up initial variable values as needed
    // No setup for changeType
    if (!IFaceFromPyObject(py_Filter, &IID_IQueryFilter, (void**)&ipFilter))
        PyErr_SetString(PyExc_TypeError, "Argument Filter (position 1) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itabledatachangesinfo_setfilter_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->SetFilter(echangeType, ipFilter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.SetFilter() returned %ld", (long)hr);
        goto itabledatachangesinfo_setfilter_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for changeType
    // No teardown for Filter

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itabledatachangesinfo_setfilter_method_cleanup;

    itabledatachangesinfo_setfilter_method_cleanup:
    self->m_HR = hr;
    // No cleanup for changeType
    if (ipFilter)
      ipFilter->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.SetFilter");
    return return_tuple;
}

static PyObject*
ITableDataChangesInfoMethod_GetFilter(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDataChangeType echangeType;
    IQueryFilter* ipFilter = NULL;
    PyObject* py_Filter = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&echangeType))
      goto itabledatachangesinfo_getfilter_method_cleanup;

    // Set up initial variable values as needed
    // No setup for changeType
    // No setup for Filter

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->GetFilter(echangeType, &ipFilter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.GetFilter() returned %ld", (long)hr);
        goto itabledatachangesinfo_getfilter_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for changeType
    Py_XDECREF(py_Filter);
    if (ipFilter)
    {
        IUnknown* pUnk = NULL;
        ipFilter->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Filter = IUnknownToPythonIIDObject(pUnk, &IID_IQueryFilter);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Filter)
    {
        if (py_Filter)
           Py_DECREF(py_Filter);
        py_Filter = Py_None;
        Py_INCREF(py_Filter);
    }
    if (PyErr_Occurred())
      goto itabledatachangesinfo_getfilter_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Filter);
    goto itabledatachangesinfo_getfilter_method_cleanup;

    itabledatachangesinfo_getfilter_method_cleanup:
    self->m_HR = hr;
    // No cleanup for changeType
    Py_XDECREF(py_Filter);
    if (ipFilter)
      ipFilter->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.GetFilter");
    return return_tuple;
}

static PyObject*
ITableDataChangesInfoMethod_get_TargetName(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTargetName;
    PyObject* pyvar_TargetName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for TargetName

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->get_TargetName(&bsTargetName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.get_TargetName() returned %ld", (long)hr);
        goto itabledatachangesinfo_get_targetname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_TargetName = PyUnicode_FromWideChar(bsTargetName,::SysStringLen(bsTargetName));
    ::SysFreeString(bsTargetName);
    
    if (PyErr_Occurred())
      goto itabledatachangesinfo_get_targetname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_TargetName);
    goto itabledatachangesinfo_get_targetname_method_cleanup;

    itabledatachangesinfo_get_targetname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_TargetName != Py_None)
        Py_XDECREF(pyvar_TargetName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.get_TargetName");
    return return_tuple;
}

static PyObject*
ITableDataChangesInfoMethod_get_Inserts(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITable* ipTable = NULL;
    PyObject* py_Table = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->get_Inserts(&ipTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.get_Inserts() returned %ld", (long)hr);
        goto itabledatachangesinfo_get_inserts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Table);
    if (ipTable)
    {
        IUnknown* pUnk = NULL;
        ipTable->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Table = IUnknownToPythonIIDObject(pUnk, &IID_ITable);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Table)
    {
        if (py_Table)
           Py_DECREF(py_Table);
        py_Table = Py_None;
        Py_INCREF(py_Table);
    }
    if (PyErr_Occurred())
      goto itabledatachangesinfo_get_inserts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Table);
    goto itabledatachangesinfo_get_inserts_method_cleanup;

    itabledatachangesinfo_get_inserts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Table);
    if (ipTable)
      ipTable->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.get_Inserts");
    return return_tuple;
}

static PyObject*
ITableDataChangesInfoMethod_get_Updates(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITable* ipTable = NULL;
    PyObject* py_Table = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->get_Updates(&ipTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.get_Updates() returned %ld", (long)hr);
        goto itabledatachangesinfo_get_updates_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Table);
    if (ipTable)
    {
        IUnknown* pUnk = NULL;
        ipTable->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Table = IUnknownToPythonIIDObject(pUnk, &IID_ITable);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Table)
    {
        if (py_Table)
           Py_DECREF(py_Table);
        py_Table = Py_None;
        Py_INCREF(py_Table);
    }
    if (PyErr_Occurred())
      goto itabledatachangesinfo_get_updates_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Table);
    goto itabledatachangesinfo_get_updates_method_cleanup;

    itabledatachangesinfo_get_updates_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Table);
    if (ipTable)
      ipTable->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.get_Updates");
    return return_tuple;
}

static PyObject*
ITableDataChangesInfoMethod_get_Deletes(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITable* ipDeletes = NULL;
    PyObject* py_Deletes = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Deletes

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->get_Deletes(&ipDeletes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.get_Deletes() returned %ld", (long)hr);
        goto itabledatachangesinfo_get_deletes_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Deletes);
    if (ipDeletes)
    {
        IUnknown* pUnk = NULL;
        ipDeletes->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Deletes = IUnknownToPythonIIDObject(pUnk, &IID_ITable);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Deletes)
    {
        if (py_Deletes)
           Py_DECREF(py_Deletes);
        py_Deletes = Py_None;
        Py_INCREF(py_Deletes);
    }
    if (PyErr_Occurred())
      goto itabledatachangesinfo_get_deletes_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Deletes);
    goto itabledatachangesinfo_get_deletes_method_cleanup;

    itabledatachangesinfo_get_deletes_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Deletes);
    if (ipDeletes)
      ipDeletes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.get_Deletes");
    return return_tuple;
}

static PyObject*
ITableDataChangesInfoMethod_SetDeletedIDs(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipDeletedIDs = NULL;
    PyObject* py_DeletedIDs;
    IStringArray* ipDeletedGIDs = NULL;
    PyObject* py_DeletedGIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_DeletedIDs, &py_DeletedGIDs))
      goto itabledatachangesinfo_setdeletedids_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_DeletedIDs, &IID_ILongArray, (void**)&ipDeletedIDs))
        PyErr_SetString(PyExc_TypeError, "Argument DeletedIDs (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto itabledatachangesinfo_setdeletedids_method_cleanup;
    
    if (!IFaceFromPyObject(py_DeletedGIDs, &IID_IStringArray, (void**)&ipDeletedGIDs))
        PyErr_SetString(PyExc_TypeError, "Argument DeletedGIDs (position 1) is not IStringArray");
    
    if (PyErr_Occurred())
      goto itabledatachangesinfo_setdeletedids_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->SetDeletedIDs(ipDeletedIDs, ipDeletedGIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.SetDeletedIDs() returned %ld", (long)hr);
        goto itabledatachangesinfo_setdeletedids_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for DeletedIDs
    // No teardown for DeletedGIDs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itabledatachangesinfo_setdeletedids_method_cleanup;

    itabledatachangesinfo_setdeletedids_method_cleanup:
    self->m_HR = hr;
    if (ipDeletedIDs)
      ipDeletedIDs->Release();
    if (ipDeletedGIDs)
      ipDeletedGIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.SetDeletedIDs");
    return return_tuple;
}

static PyObject*
ITableDataChangesInfoMethod_GetDeletedIDs(PyITableDataChangesInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipDeletedIDs = NULL;
    PyObject* py_DeletedIDs = NULL;
    IStringArray* ipDeletedGIDs = NULL;
    PyObject* py_DeletedGIDs = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for DeletedIDs
    // No setup for DeletedGIDs

    // Call method on actual COM interface
    hr = self->m_pITableDataChangesInfo->GetDeletedIDs(&ipDeletedIDs, &ipDeletedGIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITableDataChangesInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITableDataChangesInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITableDataChangesInfo.GetDeletedIDs() returned %ld", (long)hr);
        goto itabledatachangesinfo_getdeletedids_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_DeletedIDs);
    if (ipDeletedIDs)
    {
        IUnknown* pUnk = NULL;
        ipDeletedIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_DeletedIDs = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_DeletedIDs)
    {
        if (py_DeletedIDs)
           Py_DECREF(py_DeletedIDs);
        py_DeletedIDs = Py_None;
        Py_INCREF(py_DeletedIDs);
    }
    if (PyErr_Occurred())
      goto itabledatachangesinfo_getdeletedids_method_cleanup;
    
    Py_XDECREF(py_DeletedGIDs);
    if (ipDeletedGIDs)
    {
        IUnknown* pUnk = NULL;
        ipDeletedGIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_DeletedGIDs = IUnknownToPythonIIDObject(pUnk, &IID_IStringArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_DeletedGIDs)
    {
        if (py_DeletedGIDs)
           Py_DECREF(py_DeletedGIDs);
        py_DeletedGIDs = Py_None;
        Py_INCREF(py_DeletedGIDs);
    }
    if (PyErr_Occurred())
      goto itabledatachangesinfo_getdeletedids_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_DeletedIDs, py_DeletedGIDs);
    goto itabledatachangesinfo_getdeletedids_method_cleanup;

    itabledatachangesinfo_getdeletedids_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_DeletedIDs);
    if (ipDeletedIDs)
      ipDeletedIDs->Release();
    Py_XDECREF(py_DeletedGIDs);
    if (ipDeletedGIDs)
      ipDeletedGIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITableDataChangesInfo.GetDeletedIDs");
    return return_tuple;
}


PyMethodDef PyITableDataChangesInfoMethods[] = {
    {"supports", (PyCFunction)PyITableDataChangesInfo_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)ITableDataChangesInfoMethod_Init, METH_VARARGS, ""},
    {"SetFilter", (PyCFunction)ITableDataChangesInfoMethod_SetFilter, METH_VARARGS, ""},
    {"GetFilter", (PyCFunction)ITableDataChangesInfoMethod_GetFilter, METH_VARARGS, ""},
    {"get_TargetName", (PyCFunction)ITableDataChangesInfoMethod_get_TargetName, METH_VARARGS, ""},
    {"get_Inserts", (PyCFunction)ITableDataChangesInfoMethod_get_Inserts, METH_VARARGS, ""},
    {"get_Updates", (PyCFunction)ITableDataChangesInfoMethod_get_Updates, METH_VARARGS, ""},
    {"get_Deletes", (PyCFunction)ITableDataChangesInfoMethod_get_Deletes, METH_VARARGS, ""},
    {"SetDeletedIDs", (PyCFunction)ITableDataChangesInfoMethod_SetDeletedIDs, METH_VARARGS, ""},
    {"GetDeletedIDs", (PyCFunction)ITableDataChangesInfoMethod_GetDeletedIDs, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITableDataChangesInfoGetSet[] = {
  {"_pUnk", (getter)PyITableDataChangesInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITableDataChangesInfo", NULL},
  {"_pointer", (getter)PyITableDataChangesInfo_GetPointer, NULL, "Get memory address for ITableDataChangesInfo", NULL},
  {"_IID", (getter)PyITableDataChangesInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITableDataChangesInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITableDataChangesInfo_GetIgnoreFailures, (setter)PyITableDataChangesInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITableDataChangesInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ITableDataChangesInfoObject",                          
                                              /* tp_name */
  sizeof(PyITableDataChangesInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITableDataChangesInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITableDataChangesInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITableDataChangesInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITableDataChangesInfoObject_new,                      
                                              /* tp_new */
};

// Interface ITablesDataChanges

typedef struct PyITablesDataChangesObject {
    PyObject_HEAD
    ITablesDataChanges* m_pITablesDataChanges;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITablesDataChangesObject;

static PyObject*
PyITablesDataChangesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITablesDataChangesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITablesDataChanges* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITablesDataChanges, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITablesDataChanges with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITablesDataChangesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITablesDataChanges");
            return NULL;
        }
        self->m_pITablesDataChanges = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITablesDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITablesDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITablesDataChanges* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITablesDataChanges, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITablesDataChanges");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITablesDataChangesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITablesDataChanges");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITablesDataChanges = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITablesDataChangesObject_dealloc(PyITablesDataChangesObject* self)
{
    if (self->m_pITablesDataChanges)
        self->m_pITablesDataChanges->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITablesDataChanges_GetpUnk(PyITablesDataChangesObject* self)
{
    if (!self->m_pITablesDataChanges)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITablesDataChanges->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITablesDataChanges to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITablesDataChanges_GetPointer(PyITablesDataChangesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITablesDataChanges);
}

static PyObject*
PyITablesDataChanges_GetIID(PyITablesDataChangesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "244f9cd3-873d-42af-88a9-3f740079d4f9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITablesDataChanges_GetHR(PyITablesDataChangesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITablesDataChanges_GetIgnoreFailures(PyITablesDataChangesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITablesDataChanges_SetIgnoreFailures(PyITablesDataChangesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITablesDataChanges_SupportsInterface(PyITablesDataChangesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITablesDataChanges->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITablesDataChangesMethod_Init(PyITablesDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaModelType eModelType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eModelType))
      goto itablesdatachanges_init_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ModelType

    // Call method on actual COM interface
    hr = self->m_pITablesDataChanges->Init(eModelType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITablesDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITablesDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITablesDataChanges.Init() returned %ld", (long)hr);
        goto itablesdatachanges_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ModelType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itablesdatachanges_init_method_cleanup;

    itablesdatachanges_init_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ModelType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITablesDataChanges.Init");
    return return_tuple;
}

static PyObject*
ITablesDataChangesMethod_Add(PyITablesDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITableDataChangesInfo* ipTableDataChanges = NULL;
    PyObject* py_TableDataChanges;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_TableDataChanges))
      goto itablesdatachanges_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_TableDataChanges, &IID_ITableDataChangesInfo, (void**)&ipTableDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument TableDataChanges (position 0) is not ITableDataChangesInfo");
    
    if (PyErr_Occurred())
      goto itablesdatachanges_add_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITablesDataChanges->Add(ipTableDataChanges);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITablesDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITablesDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITablesDataChanges.Add() returned %ld", (long)hr);
        goto itablesdatachanges_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TableDataChanges

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itablesdatachanges_add_method_cleanup;

    itablesdatachanges_add_method_cleanup:
    self->m_HR = hr;
    if (ipTableDataChanges)
      ipTableDataChanges->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITablesDataChanges.Add");
    return return_tuple;
}

static PyObject*
ITablesDataChangesMethod_Remove(PyITablesDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTargetName = 0;
    PyObject* pyvar_TargetName;
    PyObject* unicodeTargetName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_TargetName))
      goto itablesdatachanges_remove_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_TargetName))
        unicodeTargetName = PyUnicode_FromObject(pyvar_TargetName);
    else if (PyUnicode_Check(pyvar_TargetName))
    {
        unicodeTargetName = pyvar_TargetName;
        Py_INCREF(unicodeTargetName);
    }
    else if (pyvar_TargetName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter TargetName at index 0");
    if (unicodeTargetName)
        bsTargetName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTargetName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTargetName));
    
    if (PyErr_Occurred())
      goto itablesdatachanges_remove_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITablesDataChanges->Remove(bsTargetName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITablesDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITablesDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITablesDataChanges.Remove() returned %ld", (long)hr);
        goto itablesdatachanges_remove_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TargetName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itablesdatachanges_remove_method_cleanup;

    itablesdatachanges_remove_method_cleanup:
    self->m_HR = hr;
    if (bsTargetName)
        ::SysFreeString(bsTargetName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITablesDataChanges.Remove");
    return return_tuple;
}

static PyObject*
ITablesDataChangesMethod_FindTableChangesInfo(PyITablesDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTargetName = 0;
    PyObject* pyvar_TargetName;
    PyObject* unicodeTargetName = NULL;
    ITableDataChangesInfo* ipTableDataChanges = NULL;
    PyObject* py_TableDataChanges = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_TargetName))
      goto itablesdatachanges_findtablechangesinfo_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_TargetName))
        unicodeTargetName = PyUnicode_FromObject(pyvar_TargetName);
    else if (PyUnicode_Check(pyvar_TargetName))
    {
        unicodeTargetName = pyvar_TargetName;
        Py_INCREF(unicodeTargetName);
    }
    else if (pyvar_TargetName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter TargetName at index 0");
    if (unicodeTargetName)
        bsTargetName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTargetName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTargetName));
    
    if (PyErr_Occurred())
      goto itablesdatachanges_findtablechangesinfo_method_cleanup;
    
    // No setup for TableDataChanges

    // Call method on actual COM interface
    hr = self->m_pITablesDataChanges->FindTableChangesInfo(bsTargetName, &ipTableDataChanges);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITablesDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITablesDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITablesDataChanges.FindTableChangesInfo() returned %ld", (long)hr);
        goto itablesdatachanges_findtablechangesinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TargetName
    Py_XDECREF(py_TableDataChanges);
    if (ipTableDataChanges)
    {
        IUnknown* pUnk = NULL;
        ipTableDataChanges->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_TableDataChanges = IUnknownToPythonIIDObject(pUnk, &IID_ITableDataChangesInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_TableDataChanges)
    {
        if (py_TableDataChanges)
           Py_DECREF(py_TableDataChanges);
        py_TableDataChanges = Py_None;
        Py_INCREF(py_TableDataChanges);
    }
    if (PyErr_Occurred())
      goto itablesdatachanges_findtablechangesinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_TableDataChanges);
    goto itablesdatachanges_findtablechangesinfo_method_cleanup;

    itablesdatachanges_findtablechangesinfo_method_cleanup:
    self->m_HR = hr;
    if (bsTargetName)
        ::SysFreeString(bsTargetName);
    
    Py_XDECREF(py_TableDataChanges);
    if (ipTableDataChanges)
      ipTableDataChanges->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITablesDataChanges.FindTableChangesInfo");
    return return_tuple;
}

static PyObject*
ITablesDataChangesMethod_get_Count(PyITablesDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pITablesDataChanges->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITablesDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITablesDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITablesDataChanges.get_Count() returned %ld", (long)hr);
        goto itablesdatachanges_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto itablesdatachanges_get_count_method_cleanup;

    itablesdatachanges_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITablesDataChanges.get_Count");
    return return_tuple;
}


PyMethodDef PyITablesDataChangesMethods[] = {
    {"supports", (PyCFunction)PyITablesDataChanges_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)ITablesDataChangesMethod_Init, METH_VARARGS, ""},
    {"Add", (PyCFunction)ITablesDataChangesMethod_Add, METH_VARARGS, ""},
    {"Remove", (PyCFunction)ITablesDataChangesMethod_Remove, METH_VARARGS, ""},
    {"FindTableChangesInfo", (PyCFunction)ITablesDataChangesMethod_FindTableChangesInfo, METH_VARARGS, ""},
    {"get_Count", (PyCFunction)ITablesDataChangesMethod_get_Count, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITablesDataChangesGetSet[] = {
  {"_pUnk", (getter)PyITablesDataChanges_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITablesDataChanges", NULL},
  {"_pointer", (getter)PyITablesDataChanges_GetPointer, NULL, "Get memory address for ITablesDataChanges", NULL},
  {"_IID", (getter)PyITablesDataChanges_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITablesDataChanges_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITablesDataChanges_GetIgnoreFailures, (setter)PyITablesDataChanges_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITablesDataChangesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ITablesDataChangesObject",                          
                                              /* tp_name */
  sizeof(PyITablesDataChangesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITablesDataChangesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITablesDataChangesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITablesDataChangesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITablesDataChangesObject_new,                      
                                              /* tp_new */
};

// Interface IEnumTableDataChanges

typedef struct PyIEnumTableDataChangesObject {
    PyObject_HEAD
    IEnumTableDataChanges* m_pIEnumTableDataChanges;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIEnumTableDataChangesObject;

static PyObject*
PyIEnumTableDataChangesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIEnumTableDataChangesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IEnumTableDataChanges* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IEnumTableDataChanges, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IEnumTableDataChanges with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIEnumTableDataChangesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumTableDataChanges");
            return NULL;
        }
        self->m_pIEnumTableDataChanges = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IEnumTableDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IEnumTableDataChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IEnumTableDataChanges* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IEnumTableDataChanges, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IEnumTableDataChanges");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIEnumTableDataChangesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumTableDataChanges");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIEnumTableDataChanges = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIEnumTableDataChangesObject_dealloc(PyIEnumTableDataChangesObject* self)
{
    if (self->m_pIEnumTableDataChanges)
        self->m_pIEnumTableDataChanges->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIEnumTableDataChanges_GetpUnk(PyIEnumTableDataChangesObject* self)
{
    if (!self->m_pIEnumTableDataChanges)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIEnumTableDataChanges->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IEnumTableDataChanges to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIEnumTableDataChanges_GetPointer(PyIEnumTableDataChangesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIEnumTableDataChanges);
}

static PyObject*
PyIEnumTableDataChanges_GetIID(PyIEnumTableDataChangesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b2573e22-0229-4f28-b33e-85573f974240");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIEnumTableDataChanges_GetHR(PyIEnumTableDataChangesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIEnumTableDataChanges_GetIgnoreFailures(PyIEnumTableDataChangesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIEnumTableDataChanges_SetIgnoreFailures(PyIEnumTableDataChangesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIEnumTableDataChanges_SupportsInterface(PyIEnumTableDataChangesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIEnumTableDataChanges->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IEnumTableDataChangesMethod_Next(PyIEnumTableDataChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITableDataChangesInfo* ipTableDataChanges = NULL;
    PyObject* py_TableDataChanges = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for TableDataChanges

    // Call method on actual COM interface
    hr = self->m_pIEnumTableDataChanges->Next(&ipTableDataChanges);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumTableDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumTableDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumTableDataChanges.Next() returned %ld", (long)hr);
        goto ienumtabledatachanges_next_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_TableDataChanges);
    if (ipTableDataChanges)
    {
        IUnknown* pUnk = NULL;
        ipTableDataChanges->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_TableDataChanges = IUnknownToPythonIIDObject(pUnk, &IID_ITableDataChangesInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_TableDataChanges)
    {
        if (py_TableDataChanges)
           Py_DECREF(py_TableDataChanges);
        py_TableDataChanges = Py_None;
        Py_INCREF(py_TableDataChanges);
    }
    if (PyErr_Occurred())
      goto ienumtabledatachanges_next_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_TableDataChanges);
    goto ienumtabledatachanges_next_method_cleanup;

    ienumtabledatachanges_next_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_TableDataChanges);
    if (ipTableDataChanges)
      ipTableDataChanges->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumTableDataChanges.Next");
    return return_tuple;
}

static PyObject*
IEnumTableDataChangesMethod_Reset(PyIEnumTableDataChangesObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIEnumTableDataChanges->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumTableDataChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumTableDataChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumTableDataChanges.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIEnumTableDataChangesMethods[] = {
    {"supports", (PyCFunction)PyIEnumTableDataChanges_SupportsInterface, METH_O, ""},
    {"Next", (PyCFunction)IEnumTableDataChangesMethod_Next, METH_VARARGS, ""},
    {"Reset", (PyCFunction)IEnumTableDataChangesMethod_Reset, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIEnumTableDataChangesGetSet[] = {
  {"_pUnk", (getter)PyIEnumTableDataChanges_GetpUnk, NULL, "Get opaque pointer to an Unknown from IEnumTableDataChanges", NULL},
  {"_pointer", (getter)PyIEnumTableDataChanges_GetPointer, NULL, "Get memory address for IEnumTableDataChanges", NULL},
  {"_IID", (getter)PyIEnumTableDataChanges_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIEnumTableDataChanges_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIEnumTableDataChanges_GetIgnoreFailures, (setter)PyIEnumTableDataChanges_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIEnumTableDataChangesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IEnumTableDataChangesObject",                          
                                              /* tp_name */
  sizeof(PyIEnumTableDataChangesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIEnumTableDataChangesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIEnumTableDataChangesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIEnumTableDataChangesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIEnumTableDataChangesObject_new,                      
                                              /* tp_new */
};

// Interface ICheckOut

typedef struct PyICheckOutObject {
    PyObject_HEAD
    ICheckOut* m_pICheckOut;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICheckOutObject;

static PyObject*
PyICheckOutObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICheckOutObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICheckOut* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICheckOut, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICheckOut with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICheckOutObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckOut");
            return NULL;
        }
        self->m_pICheckOut = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICheckOut");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICheckOut");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICheckOut* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICheckOut, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICheckOut");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICheckOutObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckOut");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICheckOut = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICheckOutObject_dealloc(PyICheckOutObject* self)
{
    if (self->m_pICheckOut)
        self->m_pICheckOut->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICheckOut_GetpUnk(PyICheckOutObject* self)
{
    if (!self->m_pICheckOut)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICheckOut->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICheckOut to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICheckOut_GetPointer(PyICheckOutObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICheckOut);
}

static PyObject*
PyICheckOut_GetIID(PyICheckOutObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d0571ebd-d55c-46ef-90a1-246c40486dca");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICheckOut_GetHR(PyICheckOutObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICheckOut_GetIgnoreFailures(PyICheckOutObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICheckOut_SetIgnoreFailures(PyICheckOutObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICheckOut_SupportsInterface(PyICheckOutObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICheckOut->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICheckOutMethod_CheckOutData(PyICheckOutObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplicaDescription* iprDDescriptions = NULL;
    PyObject* py_rDDescriptions;
    VARIANT_BOOL b_transferRelObjects = VARIANT_FALSE;
    PyObject* pyvar_transferRelObjects = NULL;
    BSTR bscheckoutName = 0;
    PyObject* pyvar_checkoutName;
    PyObject* unicodecheckoutName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_rDDescriptions, &pyvar_transferRelObjects, &pyvar_checkoutName))
      goto icheckout_checkoutdata_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_rDDescriptions, &IID_IReplicaDescription, (void**)&iprDDescriptions))
        PyErr_SetString(PyExc_TypeError, "Argument rDDescriptions (position 0) is not IReplicaDescription");
    
    if (PyErr_Occurred())
      goto icheckout_checkoutdata_method_cleanup;
    
    b_transferRelObjects = ((PyObject_IsTrue(pyvar_transferRelObjects) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckout_checkoutdata_method_cleanup;
    
    if (PyString_Check(pyvar_checkoutName))
        unicodecheckoutName = PyUnicode_FromObject(pyvar_checkoutName);
    else if (PyUnicode_Check(pyvar_checkoutName))
    {
        unicodecheckoutName = pyvar_checkoutName;
        Py_INCREF(unicodecheckoutName);
    }
    else if (pyvar_checkoutName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter checkoutName at index 2");
    if (unicodecheckoutName)
        bscheckoutName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecheckoutName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecheckoutName));
    
    if (PyErr_Occurred())
      goto icheckout_checkoutdata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICheckOut->CheckOutData(iprDDescriptions, b_transferRelObjects, bscheckoutName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckOut->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckOut) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckOut.CheckOutData() returned %ld", (long)hr);
        goto icheckout_checkoutdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for rDDescriptions
    // No teardown for transferRelObjects
    // No teardown for checkoutName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icheckout_checkoutdata_method_cleanup;

    icheckout_checkoutdata_method_cleanup:
    self->m_HR = hr;
    if (iprDDescriptions)
      iprDDescriptions->Release();
    // No cleanup for transferRelObjects
    if (bscheckoutName)
        ::SysFreeString(bscheckoutName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckOut.CheckOutData");
    return return_tuple;
}

static PyObject*
ICheckOutMethod_CheckOutSchema(PyICheckOutObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplicaDescription* iprDDescription = NULL;
    PyObject* py_rDDescription;
    BSTR bscheckoutName = 0;
    PyObject* pyvar_checkoutName;
    PyObject* unicodecheckoutName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_rDDescription, &pyvar_checkoutName))
      goto icheckout_checkoutschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_rDDescription, &IID_IReplicaDescription, (void**)&iprDDescription))
        PyErr_SetString(PyExc_TypeError, "Argument rDDescription (position 0) is not IReplicaDescription");
    
    if (PyErr_Occurred())
      goto icheckout_checkoutschema_method_cleanup;
    
    if (PyString_Check(pyvar_checkoutName))
        unicodecheckoutName = PyUnicode_FromObject(pyvar_checkoutName);
    else if (PyUnicode_Check(pyvar_checkoutName))
    {
        unicodecheckoutName = pyvar_checkoutName;
        Py_INCREF(unicodecheckoutName);
    }
    else if (pyvar_checkoutName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter checkoutName at index 1");
    if (unicodecheckoutName)
        bscheckoutName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecheckoutName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecheckoutName));
    
    if (PyErr_Occurred())
      goto icheckout_checkoutschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICheckOut->CheckOutSchema(iprDDescription, bscheckoutName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckOut->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckOut) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckOut.CheckOutSchema() returned %ld", (long)hr);
        goto icheckout_checkoutschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for rDDescription
    // No teardown for checkoutName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icheckout_checkoutschema_method_cleanup;

    icheckout_checkoutschema_method_cleanup:
    self->m_HR = hr;
    if (iprDDescription)
      iprDDescription->Release();
    if (bscheckoutName)
        ::SysFreeString(bscheckoutName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckOut.CheckOutSchema");
    return return_tuple;
}


PyMethodDef PyICheckOutMethods[] = {
    {"supports", (PyCFunction)PyICheckOut_SupportsInterface, METH_O, ""},
    {"CheckOutData", (PyCFunction)ICheckOutMethod_CheckOutData, METH_VARARGS, ""},
    {"CheckOutSchema", (PyCFunction)ICheckOutMethod_CheckOutSchema, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICheckOutGetSet[] = {
  {"_pUnk", (getter)PyICheckOut_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICheckOut", NULL},
  {"_pointer", (getter)PyICheckOut_GetPointer, NULL, "Get memory address for ICheckOut", NULL},
  {"_IID", (getter)PyICheckOut_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICheckOut_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICheckOut_GetIgnoreFailures, (setter)PyICheckOut_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICheckOutObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ICheckOutObject",                          
                                              /* tp_name */
  sizeof(PyICheckOutObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICheckOutObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICheckOutMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICheckOutGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICheckOutObject_new,                      
                                              /* tp_new */
};

// Interface ICheckIn

typedef struct PyICheckInObject {
    PyObject_HEAD
    ICheckIn* m_pICheckIn;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICheckInObject;

static PyObject*
PyICheckInObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICheckInObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICheckIn* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICheckIn, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICheckIn with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICheckInObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckIn");
            return NULL;
        }
        self->m_pICheckIn = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICheckIn");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICheckIn");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICheckIn* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICheckIn, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICheckIn");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICheckInObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckIn");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICheckIn = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICheckInObject_dealloc(PyICheckInObject* self)
{
    if (self->m_pICheckIn)
        self->m_pICheckIn->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICheckIn_GetpUnk(PyICheckInObject* self)
{
    if (!self->m_pICheckIn)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICheckIn->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICheckIn to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICheckIn_GetPointer(PyICheckInObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICheckIn);
}

static PyObject*
PyICheckIn_GetIID(PyICheckInObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "15c5f91a-a992-42c6-a64e-53b4965fca46");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICheckIn_GetHR(PyICheckInObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICheckIn_GetIgnoreFailures(PyICheckInObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICheckIn_SetIgnoreFailures(PyICheckInObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICheckIn_SupportsInterface(PyICheckInObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICheckIn->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICheckInMethod_CheckInFromGDB(PyICheckInObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bscheckoutName = 0;
    PyObject* pyvar_checkoutName;
    PyObject* unicodecheckoutName = NULL;
    IWorkspaceName* ipcheckOutDB = NULL;
    PyObject* py_checkOutDB;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflicts_detected = VARIANT_FALSE;
    PyObject* pyvar_conflicts_detected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOO", &py_parentDB, &pyvar_checkoutName, &py_checkOutDB, &pyvar_reconcileCheckout, &pyvar_createOIDMappingTable))
      goto icheckin_checkinfromgdb_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromgdb_method_cleanup;
    
    if (PyString_Check(pyvar_checkoutName))
        unicodecheckoutName = PyUnicode_FromObject(pyvar_checkoutName);
    else if (PyUnicode_Check(pyvar_checkoutName))
    {
        unicodecheckoutName = pyvar_checkoutName;
        Py_INCREF(unicodecheckoutName);
    }
    else if (pyvar_checkoutName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter checkoutName at index 1");
    if (unicodecheckoutName)
        bscheckoutName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecheckoutName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecheckoutName));
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromgdb_method_cleanup;
    
    if (!IFaceFromPyObject(py_checkOutDB, &IID_IWorkspaceName, (void**)&ipcheckOutDB))
        PyErr_SetString(PyExc_TypeError, "Argument checkOutDB (position 2) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromgdb_method_cleanup;
    
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromgdb_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromgdb_method_cleanup;
    
    // No setup for conflicts_detected

    // Call method on actual COM interface
    hr = self->m_pICheckIn->CheckInFromGDB(ipparentDB, bscheckoutName, ipcheckOutDB, b_reconcileCheckout, b_createOIDMappingTable, &b_conflicts_detected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckIn->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckIn) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckIn.CheckInFromGDB() returned %ld", (long)hr);
        goto icheckin_checkinfromgdb_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for checkoutName
    // No teardown for checkOutDB
    // No teardown for reconcileCheckout
    // No teardown for createOIDMappingTable
    pyvar_conflicts_detected = ((b_conflicts_detected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckin_checkinfromgdb_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflicts_detected);
    goto icheckin_checkinfromgdb_method_cleanup;

    icheckin_checkinfromgdb_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bscheckoutName)
        ::SysFreeString(bscheckoutName);
    
    if (ipcheckOutDB)
      ipcheckOutDB->Release();
    // No cleanup for reconcileCheckout
    // No cleanup for createOIDMappingTable
    // No cleanup for conflicts_detected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckIn.CheckInFromGDB");
    return return_tuple;
}

static PyObject*
ICheckInMethod_CheckInFromDeltaFile(PyICheckInObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bscheckoutName = 0;
    PyObject* pyvar_checkoutName;
    PyObject* unicodecheckoutName = NULL;
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;
    esriExportDataChangesOption edcOption;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflicts_detected = VARIANT_FALSE;
    PyObject* pyvar_conflicts_detected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOiOO", &py_parentDB, &pyvar_checkoutName, &pyvar_fileName, (int *)&edcOption, &pyvar_reconcileCheckout, &pyvar_createOIDMappingTable))
      goto icheckin_checkinfromdeltafile_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromdeltafile_method_cleanup;
    
    if (PyString_Check(pyvar_checkoutName))
        unicodecheckoutName = PyUnicode_FromObject(pyvar_checkoutName);
    else if (PyUnicode_Check(pyvar_checkoutName))
    {
        unicodecheckoutName = pyvar_checkoutName;
        Py_INCREF(unicodecheckoutName);
    }
    else if (pyvar_checkoutName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter checkoutName at index 1");
    if (unicodecheckoutName)
        bscheckoutName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecheckoutName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecheckoutName));
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromdeltafile_method_cleanup;
    
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 2");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromdeltafile_method_cleanup;
    
    // No setup for dcOption
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromdeltafile_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin_checkinfromdeltafile_method_cleanup;
    
    // No setup for conflicts_detected

    // Call method on actual COM interface
    hr = self->m_pICheckIn->CheckInFromDeltaFile(ipparentDB, bscheckoutName, bsfileName, edcOption, b_reconcileCheckout, b_createOIDMappingTable, &b_conflicts_detected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckIn->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckIn) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckIn.CheckInFromDeltaFile() returned %ld", (long)hr);
        goto icheckin_checkinfromdeltafile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for checkoutName
    // No teardown for fileName
    // No teardown for dcOption
    // No teardown for reconcileCheckout
    // No teardown for createOIDMappingTable
    pyvar_conflicts_detected = ((b_conflicts_detected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckin_checkinfromdeltafile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflicts_detected);
    goto icheckin_checkinfromdeltafile_method_cleanup;

    icheckin_checkinfromdeltafile_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bscheckoutName)
        ::SysFreeString(bscheckoutName);
    
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    // No cleanup for dcOption
    // No cleanup for reconcileCheckout
    // No cleanup for createOIDMappingTable
    // No cleanup for conflicts_detected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckIn.CheckInFromDeltaFile");
    return return_tuple;
}


PyMethodDef PyICheckInMethods[] = {
    {"supports", (PyCFunction)PyICheckIn_SupportsInterface, METH_O, ""},
    {"CheckInFromGDB", (PyCFunction)ICheckInMethod_CheckInFromGDB, METH_VARARGS, ""},
    {"CheckInFromDeltaFile", (PyCFunction)ICheckInMethod_CheckInFromDeltaFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICheckInGetSet[] = {
  {"_pUnk", (getter)PyICheckIn_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICheckIn", NULL},
  {"_pointer", (getter)PyICheckIn_GetPointer, NULL, "Get memory address for ICheckIn", NULL},
  {"_IID", (getter)PyICheckIn_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICheckIn_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICheckIn_GetIgnoreFailures, (setter)PyICheckIn_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICheckInObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ICheckInObject",                          
                                              /* tp_name */
  sizeof(PyICheckInObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICheckInObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICheckInMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICheckInGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICheckInObject_new,                      
                                              /* tp_new */
};

// Interface ICheckIn2

typedef struct PyICheckIn2Object {
    PyObject_HEAD
    ICheckIn2* m_pICheckIn2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICheckIn2Object;

static PyObject*
PyICheckIn2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICheckIn2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICheckIn2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICheckIn2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICheckIn2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICheckIn2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckIn2");
            return NULL;
        }
        self->m_pICheckIn2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICheckIn2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICheckIn2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICheckIn2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICheckIn2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICheckIn2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICheckIn2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckIn2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICheckIn2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICheckIn2Object_dealloc(PyICheckIn2Object* self)
{
    if (self->m_pICheckIn2)
        self->m_pICheckIn2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICheckIn2_GetpUnk(PyICheckIn2Object* self)
{
    if (!self->m_pICheckIn2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICheckIn2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICheckIn2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICheckIn2_GetPointer(PyICheckIn2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICheckIn2);
}

static PyObject*
PyICheckIn2_GetIID(PyICheckIn2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "27fce3ee-891d-407d-a36f-4d37ad14b3f6");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICheckIn2_GetHR(PyICheckIn2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICheckIn2_GetIgnoreFailures(PyICheckIn2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICheckIn2_SetIgnoreFailures(PyICheckIn2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICheckIn2_SupportsInterface(PyICheckIn2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICheckIn2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICheckIn2Method_CheckInFromGDB2(PyICheckIn2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bscheckoutName = 0;
    PyObject* pyvar_checkoutName;
    PyObject* unicodecheckoutName = NULL;
    IWorkspaceName* ipcheckOutDB = NULL;
    PyObject* py_checkOutDB;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    esriReplicaReconcilePolicyType echildReconcilePolicy;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflicts_detected = VARIANT_FALSE;
    PyObject* pyvar_conflicts_detected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOiOO", &py_parentDB, &pyvar_checkoutName, &py_checkOutDB, &pyvar_reconcileCheckout, (int *)&echildReconcilePolicy, &pyvar_columnLevel, &pyvar_createOIDMappingTable))
      goto icheckin2_checkinfromgdb2_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb2_method_cleanup;
    
    if (PyString_Check(pyvar_checkoutName))
        unicodecheckoutName = PyUnicode_FromObject(pyvar_checkoutName);
    else if (PyUnicode_Check(pyvar_checkoutName))
    {
        unicodecheckoutName = pyvar_checkoutName;
        Py_INCREF(unicodecheckoutName);
    }
    else if (pyvar_checkoutName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter checkoutName at index 1");
    if (unicodecheckoutName)
        bscheckoutName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecheckoutName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecheckoutName));
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb2_method_cleanup;
    
    if (!IFaceFromPyObject(py_checkOutDB, &IID_IWorkspaceName, (void**)&ipcheckOutDB))
        PyErr_SetString(PyExc_TypeError, "Argument checkOutDB (position 2) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb2_method_cleanup;
    
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb2_method_cleanup;
    
    // No setup for childReconcilePolicy
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb2_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb2_method_cleanup;
    
    // No setup for conflicts_detected

    // Call method on actual COM interface
    hr = self->m_pICheckIn2->CheckInFromGDB2(ipparentDB, bscheckoutName, ipcheckOutDB, b_reconcileCheckout, echildReconcilePolicy, b_columnLevel, b_createOIDMappingTable, &b_conflicts_detected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckIn2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckIn2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckIn2.CheckInFromGDB2() returned %ld", (long)hr);
        goto icheckin2_checkinfromgdb2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for checkoutName
    // No teardown for checkOutDB
    // No teardown for reconcileCheckout
    // No teardown for childReconcilePolicy
    // No teardown for columnLevel
    // No teardown for createOIDMappingTable
    pyvar_conflicts_detected = ((b_conflicts_detected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb2_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflicts_detected);
    goto icheckin2_checkinfromgdb2_method_cleanup;

    icheckin2_checkinfromgdb2_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bscheckoutName)
        ::SysFreeString(bscheckoutName);
    
    if (ipcheckOutDB)
      ipcheckOutDB->Release();
    // No cleanup for reconcileCheckout
    // No cleanup for childReconcilePolicy
    // No cleanup for columnLevel
    // No cleanup for createOIDMappingTable
    // No cleanup for conflicts_detected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckIn2.CheckInFromGDB2");
    return return_tuple;
}

static PyObject*
ICheckIn2Method_CheckInFromDeltaFile2(PyICheckIn2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bscheckoutName = 0;
    PyObject* pyvar_checkoutName;
    PyObject* unicodecheckoutName = NULL;
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;
    esriExportDataChangesOption edcOption;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    esriReplicaReconcilePolicyType echildReconcilePolicy;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflicts_detected = VARIANT_FALSE;
    PyObject* pyvar_conflicts_detected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOiOiOO", &py_parentDB, &pyvar_checkoutName, &pyvar_fileName, (int *)&edcOption, &pyvar_reconcileCheckout, (int *)&echildReconcilePolicy, &pyvar_columnLevel, &pyvar_createOIDMappingTable))
      goto icheckin2_checkinfromdeltafile2_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile2_method_cleanup;
    
    if (PyString_Check(pyvar_checkoutName))
        unicodecheckoutName = PyUnicode_FromObject(pyvar_checkoutName);
    else if (PyUnicode_Check(pyvar_checkoutName))
    {
        unicodecheckoutName = pyvar_checkoutName;
        Py_INCREF(unicodecheckoutName);
    }
    else if (pyvar_checkoutName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter checkoutName at index 1");
    if (unicodecheckoutName)
        bscheckoutName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecheckoutName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecheckoutName));
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile2_method_cleanup;
    
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 2");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile2_method_cleanup;
    
    // No setup for dcOption
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile2_method_cleanup;
    
    // No setup for childReconcilePolicy
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile2_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile2_method_cleanup;
    
    // No setup for conflicts_detected

    // Call method on actual COM interface
    hr = self->m_pICheckIn2->CheckInFromDeltaFile2(ipparentDB, bscheckoutName, bsfileName, edcOption, b_reconcileCheckout, echildReconcilePolicy, b_columnLevel, b_createOIDMappingTable, &b_conflicts_detected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckIn2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckIn2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckIn2.CheckInFromDeltaFile2() returned %ld", (long)hr);
        goto icheckin2_checkinfromdeltafile2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for checkoutName
    // No teardown for fileName
    // No teardown for dcOption
    // No teardown for reconcileCheckout
    // No teardown for childReconcilePolicy
    // No teardown for columnLevel
    // No teardown for createOIDMappingTable
    pyvar_conflicts_detected = ((b_conflicts_detected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile2_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflicts_detected);
    goto icheckin2_checkinfromdeltafile2_method_cleanup;

    icheckin2_checkinfromdeltafile2_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bscheckoutName)
        ::SysFreeString(bscheckoutName);
    
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    // No cleanup for dcOption
    // No cleanup for reconcileCheckout
    // No cleanup for childReconcilePolicy
    // No cleanup for columnLevel
    // No cleanup for createOIDMappingTable
    // No cleanup for conflicts_detected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckIn2.CheckInFromDeltaFile2");
    return return_tuple;
}

static PyObject*
ICheckIn2Method_CheckInFromGDB(PyICheckIn2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bscheckoutName = 0;
    PyObject* pyvar_checkoutName;
    PyObject* unicodecheckoutName = NULL;
    IWorkspaceName* ipcheckOutDB = NULL;
    PyObject* py_checkOutDB;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflicts_detected = VARIANT_FALSE;
    PyObject* pyvar_conflicts_detected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOO", &py_parentDB, &pyvar_checkoutName, &py_checkOutDB, &pyvar_reconcileCheckout, &pyvar_createOIDMappingTable))
      goto icheckin2_checkinfromgdb_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb_method_cleanup;
    
    if (PyString_Check(pyvar_checkoutName))
        unicodecheckoutName = PyUnicode_FromObject(pyvar_checkoutName);
    else if (PyUnicode_Check(pyvar_checkoutName))
    {
        unicodecheckoutName = pyvar_checkoutName;
        Py_INCREF(unicodecheckoutName);
    }
    else if (pyvar_checkoutName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter checkoutName at index 1");
    if (unicodecheckoutName)
        bscheckoutName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecheckoutName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecheckoutName));
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb_method_cleanup;
    
    if (!IFaceFromPyObject(py_checkOutDB, &IID_IWorkspaceName, (void**)&ipcheckOutDB))
        PyErr_SetString(PyExc_TypeError, "Argument checkOutDB (position 2) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb_method_cleanup;
    
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb_method_cleanup;
    
    // No setup for conflicts_detected

    // Call method on actual COM interface
    hr = self->m_pICheckIn2->CheckInFromGDB(ipparentDB, bscheckoutName, ipcheckOutDB, b_reconcileCheckout, b_createOIDMappingTable, &b_conflicts_detected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckIn2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckIn2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckIn2.CheckInFromGDB() returned %ld", (long)hr);
        goto icheckin2_checkinfromgdb_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for checkoutName
    // No teardown for checkOutDB
    // No teardown for reconcileCheckout
    // No teardown for createOIDMappingTable
    pyvar_conflicts_detected = ((b_conflicts_detected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckin2_checkinfromgdb_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflicts_detected);
    goto icheckin2_checkinfromgdb_method_cleanup;

    icheckin2_checkinfromgdb_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bscheckoutName)
        ::SysFreeString(bscheckoutName);
    
    if (ipcheckOutDB)
      ipcheckOutDB->Release();
    // No cleanup for reconcileCheckout
    // No cleanup for createOIDMappingTable
    // No cleanup for conflicts_detected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckIn2.CheckInFromGDB");
    return return_tuple;
}

static PyObject*
ICheckIn2Method_CheckInFromDeltaFile(PyICheckIn2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bscheckoutName = 0;
    PyObject* pyvar_checkoutName;
    PyObject* unicodecheckoutName = NULL;
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;
    esriExportDataChangesOption edcOption;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflicts_detected = VARIANT_FALSE;
    PyObject* pyvar_conflicts_detected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOiOO", &py_parentDB, &pyvar_checkoutName, &pyvar_fileName, (int *)&edcOption, &pyvar_reconcileCheckout, &pyvar_createOIDMappingTable))
      goto icheckin2_checkinfromdeltafile_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile_method_cleanup;
    
    if (PyString_Check(pyvar_checkoutName))
        unicodecheckoutName = PyUnicode_FromObject(pyvar_checkoutName);
    else if (PyUnicode_Check(pyvar_checkoutName))
    {
        unicodecheckoutName = pyvar_checkoutName;
        Py_INCREF(unicodecheckoutName);
    }
    else if (pyvar_checkoutName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter checkoutName at index 1");
    if (unicodecheckoutName)
        bscheckoutName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecheckoutName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecheckoutName));
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile_method_cleanup;
    
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 2");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile_method_cleanup;
    
    // No setup for dcOption
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile_method_cleanup;
    
    // No setup for conflicts_detected

    // Call method on actual COM interface
    hr = self->m_pICheckIn2->CheckInFromDeltaFile(ipparentDB, bscheckoutName, bsfileName, edcOption, b_reconcileCheckout, b_createOIDMappingTable, &b_conflicts_detected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckIn2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckIn2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckIn2.CheckInFromDeltaFile() returned %ld", (long)hr);
        goto icheckin2_checkinfromdeltafile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for checkoutName
    // No teardown for fileName
    // No teardown for dcOption
    // No teardown for reconcileCheckout
    // No teardown for createOIDMappingTable
    pyvar_conflicts_detected = ((b_conflicts_detected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckin2_checkinfromdeltafile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflicts_detected);
    goto icheckin2_checkinfromdeltafile_method_cleanup;

    icheckin2_checkinfromdeltafile_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bscheckoutName)
        ::SysFreeString(bscheckoutName);
    
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    // No cleanup for dcOption
    // No cleanup for reconcileCheckout
    // No cleanup for createOIDMappingTable
    // No cleanup for conflicts_detected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckIn2.CheckInFromDeltaFile");
    return return_tuple;
}


PyMethodDef PyICheckIn2Methods[] = {
    {"supports", (PyCFunction)PyICheckIn2_SupportsInterface, METH_O, ""},
    {"CheckInFromGDB2", (PyCFunction)ICheckIn2Method_CheckInFromGDB2, METH_VARARGS, ""},
    {"CheckInFromDeltaFile2", (PyCFunction)ICheckIn2Method_CheckInFromDeltaFile2, METH_VARARGS, ""},
    {"CheckInFromGDB", (PyCFunction)ICheckIn2Method_CheckInFromGDB, METH_VARARGS, ""},
    {"CheckInFromDeltaFile", (PyCFunction)ICheckIn2Method_CheckInFromDeltaFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICheckIn2GetSet[] = {
  {"_pUnk", (getter)PyICheckIn2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICheckIn2", NULL},
  {"_pointer", (getter)PyICheckIn2_GetPointer, NULL, "Get memory address for ICheckIn2", NULL},
  {"_IID", (getter)PyICheckIn2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICheckIn2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICheckIn2_GetIgnoreFailures, (setter)PyICheckIn2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICheckIn2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ICheckIn2Object",                          
                                              /* tp_name */
  sizeof(PyICheckIn2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICheckIn2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICheckIn2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICheckIn2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICheckIn2Object_new,                      
                                              /* tp_new */
};

// Interface ICheckInDataSynchronizer

typedef struct PyICheckInDataSynchronizerObject {
    PyObject_HEAD
    ICheckInDataSynchronizer* m_pICheckInDataSynchronizer;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICheckInDataSynchronizerObject;

static PyObject*
PyICheckInDataSynchronizerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICheckInDataSynchronizerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICheckInDataSynchronizer* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICheckInDataSynchronizer, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICheckInDataSynchronizer with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICheckInDataSynchronizerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckInDataSynchronizer");
            return NULL;
        }
        self->m_pICheckInDataSynchronizer = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICheckInDataSynchronizer");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICheckInDataSynchronizer");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICheckInDataSynchronizer* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICheckInDataSynchronizer, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICheckInDataSynchronizer");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICheckInDataSynchronizerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckInDataSynchronizer");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICheckInDataSynchronizer = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICheckInDataSynchronizerObject_dealloc(PyICheckInDataSynchronizerObject* self)
{
    if (self->m_pICheckInDataSynchronizer)
        self->m_pICheckInDataSynchronizer->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICheckInDataSynchronizer_GetpUnk(PyICheckInDataSynchronizerObject* self)
{
    if (!self->m_pICheckInDataSynchronizer)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICheckInDataSynchronizer->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICheckInDataSynchronizer to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICheckInDataSynchronizer_GetPointer(PyICheckInDataSynchronizerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICheckInDataSynchronizer);
}

static PyObject*
PyICheckInDataSynchronizer_GetIID(PyICheckInDataSynchronizerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "73987267-11c4-477b-ae52-3dfb7dc62918");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICheckInDataSynchronizer_GetHR(PyICheckInDataSynchronizerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICheckInDataSynchronizer_GetIgnoreFailures(PyICheckInDataSynchronizerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICheckInDataSynchronizer_SetIgnoreFailures(PyICheckInDataSynchronizerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICheckInDataSynchronizer_SupportsInterface(PyICheckInDataSynchronizerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICheckInDataSynchronizer->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICheckInDataSynchronizerMethod_Synchronize(PyICheckInDataSynchronizerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDataChanges* ipDataChanges = NULL;
    PyObject* py_DataChanges;
    BSTR bseditVersionName = 0;
    PyObject* pyvar_editVersionName;
    PyObject* unicodeeditVersionName = NULL;
    IWorkspaceName* ipParentWorkspace = NULL;
    PyObject* py_ParentWorkspace;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflictsDetected = VARIANT_FALSE;
    PyObject* pyvar_conflictsDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOO", &py_DataChanges, &pyvar_editVersionName, &py_ParentWorkspace, &pyvar_reconcileCheckout, &pyvar_createOIDMappingTable))
      goto icheckindatasynchronizer_synchronize_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_DataChanges, &IID_IDataChanges, (void**)&ipDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DataChanges (position 0) is not IDataChanges");
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer_synchronize_method_cleanup;
    
    if (PyString_Check(pyvar_editVersionName))
        unicodeeditVersionName = PyUnicode_FromObject(pyvar_editVersionName);
    else if (PyUnicode_Check(pyvar_editVersionName))
    {
        unicodeeditVersionName = pyvar_editVersionName;
        Py_INCREF(unicodeeditVersionName);
    }
    else if (pyvar_editVersionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter editVersionName at index 1");
    if (unicodeeditVersionName)
        bseditVersionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeeditVersionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeeditVersionName));
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer_synchronize_method_cleanup;
    
    if (!IFaceFromPyObject(py_ParentWorkspace, &IID_IWorkspaceName, (void**)&ipParentWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument ParentWorkspace (position 2) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer_synchronize_method_cleanup;
    
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer_synchronize_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer_synchronize_method_cleanup;
    
    // No setup for conflictsDetected

    // Call method on actual COM interface
    hr = self->m_pICheckInDataSynchronizer->Synchronize(ipDataChanges, bseditVersionName, ipParentWorkspace, b_reconcileCheckout, b_createOIDMappingTable, &b_conflictsDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckInDataSynchronizer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckInDataSynchronizer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckInDataSynchronizer.Synchronize() returned %ld", (long)hr);
        goto icheckindatasynchronizer_synchronize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for DataChanges
    // No teardown for editVersionName
    // No teardown for ParentWorkspace
    // No teardown for reconcileCheckout
    // No teardown for createOIDMappingTable
    pyvar_conflictsDetected = ((b_conflictsDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckindatasynchronizer_synchronize_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflictsDetected);
    goto icheckindatasynchronizer_synchronize_method_cleanup;

    icheckindatasynchronizer_synchronize_method_cleanup:
    self->m_HR = hr;
    if (ipDataChanges)
      ipDataChanges->Release();
    if (bseditVersionName)
        ::SysFreeString(bseditVersionName);
    
    if (ipParentWorkspace)
      ipParentWorkspace->Release();
    // No cleanup for reconcileCheckout
    // No cleanup for createOIDMappingTable
    // No cleanup for conflictsDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckInDataSynchronizer.Synchronize");
    return return_tuple;
}


PyMethodDef PyICheckInDataSynchronizerMethods[] = {
    {"supports", (PyCFunction)PyICheckInDataSynchronizer_SupportsInterface, METH_O, ""},
    {"Synchronize", (PyCFunction)ICheckInDataSynchronizerMethod_Synchronize, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICheckInDataSynchronizerGetSet[] = {
  {"_pUnk", (getter)PyICheckInDataSynchronizer_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICheckInDataSynchronizer", NULL},
  {"_pointer", (getter)PyICheckInDataSynchronizer_GetPointer, NULL, "Get memory address for ICheckInDataSynchronizer", NULL},
  {"_IID", (getter)PyICheckInDataSynchronizer_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICheckInDataSynchronizer_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICheckInDataSynchronizer_GetIgnoreFailures, (setter)PyICheckInDataSynchronizer_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICheckInDataSynchronizerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ICheckInDataSynchronizerObject",                          
                                              /* tp_name */
  sizeof(PyICheckInDataSynchronizerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICheckInDataSynchronizerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICheckInDataSynchronizerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICheckInDataSynchronizerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICheckInDataSynchronizerObject_new,                      
                                              /* tp_new */
};

// Interface ICheckInDataSynchronizer2

typedef struct PyICheckInDataSynchronizer2Object {
    PyObject_HEAD
    ICheckInDataSynchronizer2* m_pICheckInDataSynchronizer2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICheckInDataSynchronizer2Object;

static PyObject*
PyICheckInDataSynchronizer2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICheckInDataSynchronizer2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICheckInDataSynchronizer2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICheckInDataSynchronizer2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICheckInDataSynchronizer2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICheckInDataSynchronizer2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckInDataSynchronizer2");
            return NULL;
        }
        self->m_pICheckInDataSynchronizer2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICheckInDataSynchronizer2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICheckInDataSynchronizer2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICheckInDataSynchronizer2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICheckInDataSynchronizer2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICheckInDataSynchronizer2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICheckInDataSynchronizer2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICheckInDataSynchronizer2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICheckInDataSynchronizer2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICheckInDataSynchronizer2Object_dealloc(PyICheckInDataSynchronizer2Object* self)
{
    if (self->m_pICheckInDataSynchronizer2)
        self->m_pICheckInDataSynchronizer2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICheckInDataSynchronizer2_GetpUnk(PyICheckInDataSynchronizer2Object* self)
{
    if (!self->m_pICheckInDataSynchronizer2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICheckInDataSynchronizer2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICheckInDataSynchronizer2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICheckInDataSynchronizer2_GetPointer(PyICheckInDataSynchronizer2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICheckInDataSynchronizer2);
}

static PyObject*
PyICheckInDataSynchronizer2_GetIID(PyICheckInDataSynchronizer2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "bb18b086-729b-4990-ab3e-a457cc584548");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICheckInDataSynchronizer2_GetHR(PyICheckInDataSynchronizer2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICheckInDataSynchronizer2_GetIgnoreFailures(PyICheckInDataSynchronizer2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICheckInDataSynchronizer2_SetIgnoreFailures(PyICheckInDataSynchronizer2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICheckInDataSynchronizer2_SupportsInterface(PyICheckInDataSynchronizer2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICheckInDataSynchronizer2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICheckInDataSynchronizer2Method_Synchronize2(PyICheckInDataSynchronizer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDataChanges* ipDataChanges = NULL;
    PyObject* py_DataChanges;
    BSTR bseditVersionName = 0;
    PyObject* pyvar_editVersionName;
    PyObject* unicodeeditVersionName = NULL;
    IWorkspaceName* ipParentWorkspace = NULL;
    PyObject* py_ParentWorkspace;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    esriReplicaReconcilePolicyType ereconcilePolicy;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflictsDetected = VARIANT_FALSE;
    PyObject* pyvar_conflictsDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOiOO", &py_DataChanges, &pyvar_editVersionName, &py_ParentWorkspace, &pyvar_reconcileCheckout, (int *)&ereconcilePolicy, &pyvar_columnLevel, &pyvar_createOIDMappingTable))
      goto icheckindatasynchronizer2_synchronize2_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_DataChanges, &IID_IDataChanges, (void**)&ipDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DataChanges (position 0) is not IDataChanges");
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize2_method_cleanup;
    
    if (PyString_Check(pyvar_editVersionName))
        unicodeeditVersionName = PyUnicode_FromObject(pyvar_editVersionName);
    else if (PyUnicode_Check(pyvar_editVersionName))
    {
        unicodeeditVersionName = pyvar_editVersionName;
        Py_INCREF(unicodeeditVersionName);
    }
    else if (pyvar_editVersionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter editVersionName at index 1");
    if (unicodeeditVersionName)
        bseditVersionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeeditVersionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeeditVersionName));
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize2_method_cleanup;
    
    if (!IFaceFromPyObject(py_ParentWorkspace, &IID_IWorkspaceName, (void**)&ipParentWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument ParentWorkspace (position 2) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize2_method_cleanup;
    
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize2_method_cleanup;
    
    // No setup for reconcilePolicy
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize2_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize2_method_cleanup;
    
    // No setup for conflictsDetected

    // Call method on actual COM interface
    hr = self->m_pICheckInDataSynchronizer2->Synchronize2(ipDataChanges, bseditVersionName, ipParentWorkspace, b_reconcileCheckout, ereconcilePolicy, b_columnLevel, b_createOIDMappingTable, &b_conflictsDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckInDataSynchronizer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckInDataSynchronizer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckInDataSynchronizer2.Synchronize2() returned %ld", (long)hr);
        goto icheckindatasynchronizer2_synchronize2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for DataChanges
    // No teardown for editVersionName
    // No teardown for ParentWorkspace
    // No teardown for reconcileCheckout
    // No teardown for reconcilePolicy
    // No teardown for columnLevel
    // No teardown for createOIDMappingTable
    pyvar_conflictsDetected = ((b_conflictsDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize2_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflictsDetected);
    goto icheckindatasynchronizer2_synchronize2_method_cleanup;

    icheckindatasynchronizer2_synchronize2_method_cleanup:
    self->m_HR = hr;
    if (ipDataChanges)
      ipDataChanges->Release();
    if (bseditVersionName)
        ::SysFreeString(bseditVersionName);
    
    if (ipParentWorkspace)
      ipParentWorkspace->Release();
    // No cleanup for reconcileCheckout
    // No cleanup for reconcilePolicy
    // No cleanup for columnLevel
    // No cleanup for createOIDMappingTable
    // No cleanup for conflictsDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckInDataSynchronizer2.Synchronize2");
    return return_tuple;
}

static PyObject*
ICheckInDataSynchronizer2Method_Synchronize(PyICheckInDataSynchronizer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDataChanges* ipDataChanges = NULL;
    PyObject* py_DataChanges;
    BSTR bseditVersionName = 0;
    PyObject* pyvar_editVersionName;
    PyObject* unicodeeditVersionName = NULL;
    IWorkspaceName* ipParentWorkspace = NULL;
    PyObject* py_ParentWorkspace;
    VARIANT_BOOL b_reconcileCheckout = VARIANT_FALSE;
    PyObject* pyvar_reconcileCheckout = NULL;
    VARIANT_BOOL b_createOIDMappingTable = VARIANT_FALSE;
    PyObject* pyvar_createOIDMappingTable = NULL;
    VARIANT_BOOL b_conflictsDetected = VARIANT_FALSE;
    PyObject* pyvar_conflictsDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOO", &py_DataChanges, &pyvar_editVersionName, &py_ParentWorkspace, &pyvar_reconcileCheckout, &pyvar_createOIDMappingTable))
      goto icheckindatasynchronizer2_synchronize_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_DataChanges, &IID_IDataChanges, (void**)&ipDataChanges))
        PyErr_SetString(PyExc_TypeError, "Argument DataChanges (position 0) is not IDataChanges");
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize_method_cleanup;
    
    if (PyString_Check(pyvar_editVersionName))
        unicodeeditVersionName = PyUnicode_FromObject(pyvar_editVersionName);
    else if (PyUnicode_Check(pyvar_editVersionName))
    {
        unicodeeditVersionName = pyvar_editVersionName;
        Py_INCREF(unicodeeditVersionName);
    }
    else if (pyvar_editVersionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter editVersionName at index 1");
    if (unicodeeditVersionName)
        bseditVersionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeeditVersionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeeditVersionName));
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize_method_cleanup;
    
    if (!IFaceFromPyObject(py_ParentWorkspace, &IID_IWorkspaceName, (void**)&ipParentWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument ParentWorkspace (position 2) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize_method_cleanup;
    
    b_reconcileCheckout = ((PyObject_IsTrue(pyvar_reconcileCheckout) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize_method_cleanup;
    
    b_createOIDMappingTable = ((PyObject_IsTrue(pyvar_createOIDMappingTable) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize_method_cleanup;
    
    // No setup for conflictsDetected

    // Call method on actual COM interface
    hr = self->m_pICheckInDataSynchronizer2->Synchronize(ipDataChanges, bseditVersionName, ipParentWorkspace, b_reconcileCheckout, b_createOIDMappingTable, &b_conflictsDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICheckInDataSynchronizer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICheckInDataSynchronizer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICheckInDataSynchronizer2.Synchronize() returned %ld", (long)hr);
        goto icheckindatasynchronizer2_synchronize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for DataChanges
    // No teardown for editVersionName
    // No teardown for ParentWorkspace
    // No teardown for reconcileCheckout
    // No teardown for createOIDMappingTable
    pyvar_conflictsDetected = ((b_conflictsDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icheckindatasynchronizer2_synchronize_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflictsDetected);
    goto icheckindatasynchronizer2_synchronize_method_cleanup;

    icheckindatasynchronizer2_synchronize_method_cleanup:
    self->m_HR = hr;
    if (ipDataChanges)
      ipDataChanges->Release();
    if (bseditVersionName)
        ::SysFreeString(bseditVersionName);
    
    if (ipParentWorkspace)
      ipParentWorkspace->Release();
    // No cleanup for reconcileCheckout
    // No cleanup for createOIDMappingTable
    // No cleanup for conflictsDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICheckInDataSynchronizer2.Synchronize");
    return return_tuple;
}


PyMethodDef PyICheckInDataSynchronizer2Methods[] = {
    {"supports", (PyCFunction)PyICheckInDataSynchronizer2_SupportsInterface, METH_O, ""},
    {"Synchronize2", (PyCFunction)ICheckInDataSynchronizer2Method_Synchronize2, METH_VARARGS, ""},
    {"Synchronize", (PyCFunction)ICheckInDataSynchronizer2Method_Synchronize, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICheckInDataSynchronizer2GetSet[] = {
  {"_pUnk", (getter)PyICheckInDataSynchronizer2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICheckInDataSynchronizer2", NULL},
  {"_pointer", (getter)PyICheckInDataSynchronizer2_GetPointer, NULL, "Get memory address for ICheckInDataSynchronizer2", NULL},
  {"_IID", (getter)PyICheckInDataSynchronizer2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICheckInDataSynchronizer2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICheckInDataSynchronizer2_GetIgnoreFailures, (setter)PyICheckInDataSynchronizer2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICheckInDataSynchronizer2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ICheckInDataSynchronizer2Object",                          
                                              /* tp_name */
  sizeof(PyICheckInDataSynchronizer2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICheckInDataSynchronizer2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICheckInDataSynchronizer2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICheckInDataSynchronizer2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICheckInDataSynchronizer2Object_new,                      
                                              /* tp_new */
};

// Interface IReplicaValidation

typedef struct PyIReplicaValidationObject {
    PyObject_HEAD
    IReplicaValidation* m_pIReplicaValidation;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicaValidationObject;

static PyObject*
PyIReplicaValidationObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicaValidationObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicaValidation* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicaValidation, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicaValidation with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicaValidationObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaValidation");
            return NULL;
        }
        self->m_pIReplicaValidation = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicaValidation");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicaValidation");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicaValidation* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicaValidation, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicaValidation");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicaValidationObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaValidation");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicaValidation = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicaValidationObject_dealloc(PyIReplicaValidationObject* self)
{
    if (self->m_pIReplicaValidation)
        self->m_pIReplicaValidation->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicaValidation_GetpUnk(PyIReplicaValidationObject* self)
{
    if (!self->m_pIReplicaValidation)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicaValidation->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicaValidation to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicaValidation_GetPointer(PyIReplicaValidationObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicaValidation);
}

static PyObject*
PyIReplicaValidation_GetIID(PyIReplicaValidationObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "059a0b29-8d46-475f-a4d8-77f220ec2cbb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicaValidation_GetHR(PyIReplicaValidationObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicaValidation_GetIgnoreFailures(PyIReplicaValidationObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicaValidation_SetIgnoreFailures(PyIReplicaValidationObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicaValidation_SupportsInterface(PyIReplicaValidationObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicaValidation->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicaValidationMethod_ValidateReplicaPair(PyIReplicaValidationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IWorkspaceName* ipcheckOutDB = NULL;
    PyObject* py_checkOutDB;
    VARIANT_BOOL b_isValid = VARIANT_FALSE;
    PyObject* pyvar_isValid = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_parentDB, &pyvar_ReplicaName, &py_checkOutDB))
      goto ireplicavalidation_validatereplicapair_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicavalidation_validatereplicapair_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 1");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto ireplicavalidation_validatereplicapair_method_cleanup;
    
    if (!IFaceFromPyObject(py_checkOutDB, &IID_IWorkspaceName, (void**)&ipcheckOutDB))
        PyErr_SetString(PyExc_TypeError, "Argument checkOutDB (position 2) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicavalidation_validatereplicapair_method_cleanup;
    
    // No setup for isValid

    // Call method on actual COM interface
    hr = self->m_pIReplicaValidation->ValidateReplicaPair(ipparentDB, bsReplicaName, ipcheckOutDB, &b_isValid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaValidation->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaValidation) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaValidation.ValidateReplicaPair() returned %ld", (long)hr);
        goto ireplicavalidation_validatereplicapair_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for ReplicaName
    // No teardown for checkOutDB
    pyvar_isValid = ((b_isValid == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ireplicavalidation_validatereplicapair_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isValid);
    goto ireplicavalidation_validatereplicapair_method_cleanup;

    ireplicavalidation_validatereplicapair_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipcheckOutDB)
      ipcheckOutDB->Release();
    // No cleanup for isValid
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaValidation.ValidateReplicaPair");
    return return_tuple;
}

static PyObject*
IReplicaValidationMethod_ValidateDeltaFile(PyIReplicaValidationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    BSTR bsDeltaFileName = 0;
    PyObject* pyvar_DeltaFileName;
    PyObject* unicodeDeltaFileName = NULL;
    esriCheckInSourceType esourceType;
    VARIANT_BOOL b_isValid = VARIANT_FALSE;
    PyObject* pyvar_isValid = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOi", &py_parentDB, &pyvar_ReplicaName, &pyvar_DeltaFileName, (int *)&esourceType))
      goto ireplicavalidation_validatedeltafile_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicavalidation_validatedeltafile_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 1");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto ireplicavalidation_validatedeltafile_method_cleanup;
    
    if (PyString_Check(pyvar_DeltaFileName))
        unicodeDeltaFileName = PyUnicode_FromObject(pyvar_DeltaFileName);
    else if (PyUnicode_Check(pyvar_DeltaFileName))
    {
        unicodeDeltaFileName = pyvar_DeltaFileName;
        Py_INCREF(unicodeDeltaFileName);
    }
    else if (pyvar_DeltaFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter DeltaFileName at index 2");
    if (unicodeDeltaFileName)
        bsDeltaFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDeltaFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDeltaFileName));
    
    if (PyErr_Occurred())
      goto ireplicavalidation_validatedeltafile_method_cleanup;
    
    // No setup for sourceType
    // No setup for isValid

    // Call method on actual COM interface
    hr = self->m_pIReplicaValidation->ValidateDeltaFile(ipparentDB, bsReplicaName, bsDeltaFileName, esourceType, &b_isValid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaValidation->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaValidation) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaValidation.ValidateDeltaFile() returned %ld", (long)hr);
        goto ireplicavalidation_validatedeltafile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for ReplicaName
    // No teardown for DeltaFileName
    // No teardown for sourceType
    pyvar_isValid = ((b_isValid == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ireplicavalidation_validatedeltafile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isValid);
    goto ireplicavalidation_validatedeltafile_method_cleanup;

    ireplicavalidation_validatedeltafile_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (bsDeltaFileName)
        ::SysFreeString(bsDeltaFileName);
    
    // No cleanup for sourceType
    // No cleanup for isValid
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaValidation.ValidateDeltaFile");
    return return_tuple;
}


PyMethodDef PyIReplicaValidationMethods[] = {
    {"supports", (PyCFunction)PyIReplicaValidation_SupportsInterface, METH_O, ""},
    {"ValidateReplicaPair", (PyCFunction)IReplicaValidationMethod_ValidateReplicaPair, METH_VARARGS, ""},
    {"ValidateDeltaFile", (PyCFunction)IReplicaValidationMethod_ValidateDeltaFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicaValidationGetSet[] = {
  {"_pUnk", (getter)PyIReplicaValidation_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicaValidation", NULL},
  {"_pointer", (getter)PyIReplicaValidation_GetPointer, NULL, "Get memory address for IReplicaValidation", NULL},
  {"_IID", (getter)PyIReplicaValidation_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicaValidation_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicaValidation_GetIgnoreFailures, (setter)PyIReplicaValidation_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicaValidationObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicaValidationObject",                          
                                              /* tp_name */
  sizeof(PyIReplicaValidationObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicaValidationObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicaValidationMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicaValidationGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicaValidationObject_new,                      
                                              /* tp_new */
};

// Interface IReplicaValidation2

typedef struct PyIReplicaValidation2Object {
    PyObject_HEAD
    IReplicaValidation2* m_pIReplicaValidation2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicaValidation2Object;

static PyObject*
PyIReplicaValidation2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicaValidation2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicaValidation2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicaValidation2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicaValidation2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicaValidation2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaValidation2");
            return NULL;
        }
        self->m_pIReplicaValidation2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicaValidation2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicaValidation2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicaValidation2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicaValidation2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicaValidation2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicaValidation2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaValidation2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicaValidation2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicaValidation2Object_dealloc(PyIReplicaValidation2Object* self)
{
    if (self->m_pIReplicaValidation2)
        self->m_pIReplicaValidation2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicaValidation2_GetpUnk(PyIReplicaValidation2Object* self)
{
    if (!self->m_pIReplicaValidation2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicaValidation2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicaValidation2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicaValidation2_GetPointer(PyIReplicaValidation2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicaValidation2);
}

static PyObject*
PyIReplicaValidation2_GetIID(PyIReplicaValidation2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "90b7c766-754e-47e9-bc42-7c03a336c82f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicaValidation2_GetHR(PyIReplicaValidation2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicaValidation2_GetIgnoreFailures(PyIReplicaValidation2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicaValidation2_SetIgnoreFailures(PyIReplicaValidation2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicaValidation2_SupportsInterface(PyIReplicaValidation2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicaValidation2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicaValidation2Method_ValidateReplicaSchema(PyIReplicaValidation2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplica* ipReplica = NULL;
    PyObject* py_Replica;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Replica))
      goto ireplicavalidation2_validatereplicaschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Replica, &IID_IReplica, (void**)&ipReplica))
        PyErr_SetString(PyExc_TypeError, "Argument Replica (position 0) is not IReplica");
    
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatereplicaschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicaValidation2->ValidateReplicaSchema(ipReplica);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaValidation2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaValidation2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaValidation2.ValidateReplicaSchema() returned %ld", (long)hr);
        goto ireplicavalidation2_validatereplicaschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Replica

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicavalidation2_validatereplicaschema_method_cleanup;

    ireplicavalidation2_validatereplicaschema_method_cleanup:
    self->m_HR = hr;
    if (ipReplica)
      ipReplica->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaValidation2.ValidateReplicaSchema");
    return return_tuple;
}

static PyObject*
IReplicaValidation2Method_ValidateReplicaPair(PyIReplicaValidation2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IWorkspaceName* ipcheckOutDB = NULL;
    PyObject* py_checkOutDB;
    VARIANT_BOOL b_isValid = VARIANT_FALSE;
    PyObject* pyvar_isValid = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_parentDB, &pyvar_ReplicaName, &py_checkOutDB))
      goto ireplicavalidation2_validatereplicapair_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatereplicapair_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 1");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatereplicapair_method_cleanup;
    
    if (!IFaceFromPyObject(py_checkOutDB, &IID_IWorkspaceName, (void**)&ipcheckOutDB))
        PyErr_SetString(PyExc_TypeError, "Argument checkOutDB (position 2) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatereplicapair_method_cleanup;
    
    // No setup for isValid

    // Call method on actual COM interface
    hr = self->m_pIReplicaValidation2->ValidateReplicaPair(ipparentDB, bsReplicaName, ipcheckOutDB, &b_isValid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaValidation2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaValidation2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaValidation2.ValidateReplicaPair() returned %ld", (long)hr);
        goto ireplicavalidation2_validatereplicapair_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for ReplicaName
    // No teardown for checkOutDB
    pyvar_isValid = ((b_isValid == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatereplicapair_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isValid);
    goto ireplicavalidation2_validatereplicapair_method_cleanup;

    ireplicavalidation2_validatereplicapair_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipcheckOutDB)
      ipcheckOutDB->Release();
    // No cleanup for isValid
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaValidation2.ValidateReplicaPair");
    return return_tuple;
}

static PyObject*
IReplicaValidation2Method_ValidateDeltaFile(PyIReplicaValidation2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipparentDB = NULL;
    PyObject* py_parentDB;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    BSTR bsDeltaFileName = 0;
    PyObject* pyvar_DeltaFileName;
    PyObject* unicodeDeltaFileName = NULL;
    esriCheckInSourceType esourceType;
    VARIANT_BOOL b_isValid = VARIANT_FALSE;
    PyObject* pyvar_isValid = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOi", &py_parentDB, &pyvar_ReplicaName, &pyvar_DeltaFileName, (int *)&esourceType))
      goto ireplicavalidation2_validatedeltafile_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_parentDB, &IID_IWorkspaceName, (void**)&ipparentDB))
        PyErr_SetString(PyExc_TypeError, "Argument parentDB (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatedeltafile_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 1");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatedeltafile_method_cleanup;
    
    if (PyString_Check(pyvar_DeltaFileName))
        unicodeDeltaFileName = PyUnicode_FromObject(pyvar_DeltaFileName);
    else if (PyUnicode_Check(pyvar_DeltaFileName))
    {
        unicodeDeltaFileName = pyvar_DeltaFileName;
        Py_INCREF(unicodeDeltaFileName);
    }
    else if (pyvar_DeltaFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter DeltaFileName at index 2");
    if (unicodeDeltaFileName)
        bsDeltaFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDeltaFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDeltaFileName));
    
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatedeltafile_method_cleanup;
    
    // No setup for sourceType
    // No setup for isValid

    // Call method on actual COM interface
    hr = self->m_pIReplicaValidation2->ValidateDeltaFile(ipparentDB, bsReplicaName, bsDeltaFileName, esourceType, &b_isValid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaValidation2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaValidation2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaValidation2.ValidateDeltaFile() returned %ld", (long)hr);
        goto ireplicavalidation2_validatedeltafile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentDB
    // No teardown for ReplicaName
    // No teardown for DeltaFileName
    // No teardown for sourceType
    pyvar_isValid = ((b_isValid == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ireplicavalidation2_validatedeltafile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isValid);
    goto ireplicavalidation2_validatedeltafile_method_cleanup;

    ireplicavalidation2_validatedeltafile_method_cleanup:
    self->m_HR = hr;
    if (ipparentDB)
      ipparentDB->Release();
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (bsDeltaFileName)
        ::SysFreeString(bsDeltaFileName);
    
    // No cleanup for sourceType
    // No cleanup for isValid
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaValidation2.ValidateDeltaFile");
    return return_tuple;
}


PyMethodDef PyIReplicaValidation2Methods[] = {
    {"supports", (PyCFunction)PyIReplicaValidation2_SupportsInterface, METH_O, ""},
    {"ValidateReplicaSchema", (PyCFunction)IReplicaValidation2Method_ValidateReplicaSchema, METH_VARARGS, ""},
    {"ValidateReplicaPair", (PyCFunction)IReplicaValidation2Method_ValidateReplicaPair, METH_VARARGS, ""},
    {"ValidateDeltaFile", (PyCFunction)IReplicaValidation2Method_ValidateDeltaFile, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicaValidation2GetSet[] = {
  {"_pUnk", (getter)PyIReplicaValidation2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicaValidation2", NULL},
  {"_pointer", (getter)PyIReplicaValidation2_GetPointer, NULL, "Get memory address for IReplicaValidation2", NULL},
  {"_IID", (getter)PyIReplicaValidation2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicaValidation2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicaValidation2_GetIgnoreFailures, (setter)PyIReplicaValidation2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicaValidation2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicaValidation2Object",                          
                                              /* tp_name */
  sizeof(PyIReplicaValidation2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicaValidation2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicaValidation2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicaValidation2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicaValidation2Object_new,                      
                                              /* tp_new */
};

// Interface IReplicaMessageHandler

typedef struct PyIReplicaMessageHandlerObject {
    PyObject_HEAD
    IReplicaMessageHandler* m_pIReplicaMessageHandler;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicaMessageHandlerObject;

static PyObject*
PyIReplicaMessageHandlerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicaMessageHandlerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicaMessageHandler* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicaMessageHandler, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicaMessageHandler with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicaMessageHandlerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaMessageHandler");
            return NULL;
        }
        self->m_pIReplicaMessageHandler = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicaMessageHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicaMessageHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicaMessageHandler* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicaMessageHandler, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicaMessageHandler");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicaMessageHandlerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaMessageHandler");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicaMessageHandler = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicaMessageHandlerObject_dealloc(PyIReplicaMessageHandlerObject* self)
{
    if (self->m_pIReplicaMessageHandler)
        self->m_pIReplicaMessageHandler->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicaMessageHandler_GetpUnk(PyIReplicaMessageHandlerObject* self)
{
    if (!self->m_pIReplicaMessageHandler)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicaMessageHandler->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicaMessageHandler to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicaMessageHandler_GetPointer(PyIReplicaMessageHandlerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicaMessageHandler);
}

static PyObject*
PyIReplicaMessageHandler_GetIID(PyIReplicaMessageHandlerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ce6fe713-7b5a-4e27-808f-97ecfa588f2b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicaMessageHandler_GetHR(PyIReplicaMessageHandlerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicaMessageHandler_GetIgnoreFailures(PyIReplicaMessageHandlerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicaMessageHandler_SetIgnoreFailures(PyIReplicaMessageHandlerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicaMessageHandler_SupportsInterface(PyIReplicaMessageHandlerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicaMessageHandlerMethod_Init(PyIReplicaMessageHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsMsgFileName = 0;
    PyObject* pyvar_MsgFileName;
    PyObject* unicodeMsgFileName = NULL;
    esriExportDataChangesOption eMsgExportOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_MsgFileName, (int *)&eMsgExportOption))
      goto ireplicamessagehandler_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_MsgFileName))
        unicodeMsgFileName = PyUnicode_FromObject(pyvar_MsgFileName);
    else if (PyUnicode_Check(pyvar_MsgFileName))
    {
        unicodeMsgFileName = pyvar_MsgFileName;
        Py_INCREF(unicodeMsgFileName);
    }
    else if (pyvar_MsgFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter MsgFileName at index 0");
    if (unicodeMsgFileName)
        bsMsgFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeMsgFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeMsgFileName));
    
    if (PyErr_Occurred())
      goto ireplicamessagehandler_init_method_cleanup;
    
    // No setup for MsgExportOption

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler->Init(bsMsgFileName, eMsgExportOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler.Init() returned %ld", (long)hr);
        goto ireplicamessagehandler_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MsgFileName
    // No teardown for MsgExportOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicamessagehandler_init_method_cleanup;

    ireplicamessagehandler_init_method_cleanup:
    self->m_HR = hr;
    if (bsMsgFileName)
        ::SysFreeString(bsMsgFileName);
    
    // No cleanup for MsgExportOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler.Init");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandlerMethod_get_ReplicaGuid(PyIReplicaMessageHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsGUID;
    PyObject* pyvar_GUID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for GUID

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler->get_ReplicaGuid(&bsGUID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler.get_ReplicaGuid() returned %ld", (long)hr);
        goto ireplicamessagehandler_get_replicaguid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_GUID = PyUnicode_FromWideChar(bsGUID,::SysStringLen(bsGUID));
    ::SysFreeString(bsGUID);
    
    if (PyErr_Occurred())
      goto ireplicamessagehandler_get_replicaguid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_GUID);
    goto ireplicamessagehandler_get_replicaguid_method_cleanup;

    ireplicamessagehandler_get_replicaguid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_GUID != Py_None)
        Py_XDECREF(pyvar_GUID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler.get_ReplicaGuid");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandlerMethod_get_MessageType(PyIReplicaMessageHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaMessageType eMsgType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MsgType

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler->get_MessageType(&eMsgType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler.get_MessageType() returned %ld", (long)hr);
        goto ireplicamessagehandler_get_messagetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MsgType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eMsgType);
    goto ireplicamessagehandler_get_messagetype_method_cleanup;

    ireplicamessagehandler_get_messagetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for MsgType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler.get_MessageType");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandlerMethod_get_MyGenerationNumber(PyIReplicaMessageHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lGenerationNumber = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for GenerationNumber

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler->get_MyGenerationNumber(&lGenerationNumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler.get_MyGenerationNumber() returned %ld", (long)hr);
        goto ireplicamessagehandler_get_mygenerationnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for GenerationNumber

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lGenerationNumber);
    goto ireplicamessagehandler_get_mygenerationnumber_method_cleanup;

    ireplicamessagehandler_get_mygenerationnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for GenerationNumber
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler.get_MyGenerationNumber");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandlerMethod_get_SibGenerationNumber(PyIReplicaMessageHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lSibGen = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SibGen

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler->get_SibGenerationNumber(&lSibGen);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler.get_SibGenerationNumber() returned %ld", (long)hr);
        goto ireplicamessagehandler_get_sibgenerationnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SibGen

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lSibGen);
    goto ireplicamessagehandler_get_sibgenerationnumber_method_cleanup;

    ireplicamessagehandler_get_sibgenerationnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for SibGen
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler.get_SibGenerationNumber");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandlerMethod_get_DeltaDataChanges(PyIReplicaMessageHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDeltaDataChanges* ipDeltaDC = NULL;
    PyObject* py_DeltaDC = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for DeltaDC

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler->get_DeltaDataChanges(&ipDeltaDC);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler.get_DeltaDataChanges() returned %ld", (long)hr);
        goto ireplicamessagehandler_get_deltadatachanges_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_DeltaDC);
    if (ipDeltaDC)
    {
        IUnknown* pUnk = NULL;
        ipDeltaDC->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_DeltaDC = IUnknownToPythonIIDObject(pUnk, &IID_IDeltaDataChanges);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_DeltaDC)
    {
        if (py_DeltaDC)
           Py_DECREF(py_DeltaDC);
        py_DeltaDC = Py_None;
        Py_INCREF(py_DeltaDC);
    }
    if (PyErr_Occurred())
      goto ireplicamessagehandler_get_deltadatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_DeltaDC);
    goto ireplicamessagehandler_get_deltadatachanges_method_cleanup;

    ireplicamessagehandler_get_deltadatachanges_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_DeltaDC);
    if (ipDeltaDC)
      ipDeltaDC->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler.get_DeltaDataChanges");
    return return_tuple;
}


PyMethodDef PyIReplicaMessageHandlerMethods[] = {
    {"supports", (PyCFunction)PyIReplicaMessageHandler_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)IReplicaMessageHandlerMethod_Init, METH_VARARGS, ""},
    {"get_ReplicaGuid", (PyCFunction)IReplicaMessageHandlerMethod_get_ReplicaGuid, METH_VARARGS, ""},
    {"get_MessageType", (PyCFunction)IReplicaMessageHandlerMethod_get_MessageType, METH_VARARGS, ""},
    {"get_MyGenerationNumber", (PyCFunction)IReplicaMessageHandlerMethod_get_MyGenerationNumber, METH_VARARGS, ""},
    {"get_SibGenerationNumber", (PyCFunction)IReplicaMessageHandlerMethod_get_SibGenerationNumber, METH_VARARGS, ""},
    {"get_DeltaDataChanges", (PyCFunction)IReplicaMessageHandlerMethod_get_DeltaDataChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicaMessageHandlerGetSet[] = {
  {"_pUnk", (getter)PyIReplicaMessageHandler_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicaMessageHandler", NULL},
  {"_pointer", (getter)PyIReplicaMessageHandler_GetPointer, NULL, "Get memory address for IReplicaMessageHandler", NULL},
  {"_IID", (getter)PyIReplicaMessageHandler_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicaMessageHandler_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicaMessageHandler_GetIgnoreFailures, (setter)PyIReplicaMessageHandler_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicaMessageHandlerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicaMessageHandlerObject",                          
                                              /* tp_name */
  sizeof(PyIReplicaMessageHandlerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicaMessageHandlerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicaMessageHandlerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicaMessageHandlerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicaMessageHandlerObject_new,                      
                                              /* tp_new */
};

// Interface IReplicaMessageHandler2

typedef struct PyIReplicaMessageHandler2Object {
    PyObject_HEAD
    IReplicaMessageHandler2* m_pIReplicaMessageHandler2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicaMessageHandler2Object;

static PyObject*
PyIReplicaMessageHandler2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicaMessageHandler2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicaMessageHandler2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicaMessageHandler2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicaMessageHandler2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicaMessageHandler2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaMessageHandler2");
            return NULL;
        }
        self->m_pIReplicaMessageHandler2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicaMessageHandler2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicaMessageHandler2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicaMessageHandler2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicaMessageHandler2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicaMessageHandler2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicaMessageHandler2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicaMessageHandler2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicaMessageHandler2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicaMessageHandler2Object_dealloc(PyIReplicaMessageHandler2Object* self)
{
    if (self->m_pIReplicaMessageHandler2)
        self->m_pIReplicaMessageHandler2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicaMessageHandler2_GetpUnk(PyIReplicaMessageHandler2Object* self)
{
    if (!self->m_pIReplicaMessageHandler2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicaMessageHandler2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicaMessageHandler2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicaMessageHandler2_GetPointer(PyIReplicaMessageHandler2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicaMessageHandler2);
}

static PyObject*
PyIReplicaMessageHandler2_GetIID(PyIReplicaMessageHandler2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "37d98d2a-97e0-4252-86ac-af3395581877");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicaMessageHandler2_GetHR(PyIReplicaMessageHandler2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicaMessageHandler2_GetIgnoreFailures(PyIReplicaMessageHandler2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicaMessageHandler2_SetIgnoreFailures(PyIReplicaMessageHandler2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicaMessageHandler2_SupportsInterface(PyIReplicaMessageHandler2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicaMessageHandler2Method_get_MyTime(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vMyTime;
    ::VariantInit(&vMyTime);
    PyObject* pyvar_MyTime = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MyTime

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->get_MyTime(&vMyTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.get_MyTime() returned %ld", (long)hr);
        goto ireplicamessagehandler2_get_mytime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_MyTime = Variant_AsPyObject(&vMyTime);
    if (PyErr_Occurred())
      goto ireplicamessagehandler2_get_mytime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_MyTime);
    goto ireplicamessagehandler2_get_mytime_method_cleanup;

    ireplicamessagehandler2_get_mytime_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vMyTime);
    Py_XDECREF(pyvar_MyTime);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.get_MyTime");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandler2Method_get_SibTime(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vSibTime;
    ::VariantInit(&vSibTime);
    PyObject* pyvar_SibTime = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SibTime

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->get_SibTime(&vSibTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.get_SibTime() returned %ld", (long)hr);
        goto ireplicamessagehandler2_get_sibtime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_SibTime = Variant_AsPyObject(&vSibTime);
    if (PyErr_Occurred())
      goto ireplicamessagehandler2_get_sibtime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_SibTime);
    goto ireplicamessagehandler2_get_sibtime_method_cleanup;

    ireplicamessagehandler2_get_sibtime_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vSibTime);
    Py_XDECREF(pyvar_SibTime);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.get_SibTime");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandler2Method_get_SibMyTime(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vSibMyTime;
    ::VariantInit(&vSibMyTime);
    PyObject* pyvar_SibMyTime = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SibMyTime

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->get_SibMyTime(&vSibMyTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.get_SibMyTime() returned %ld", (long)hr);
        goto ireplicamessagehandler2_get_sibmytime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_SibMyTime = Variant_AsPyObject(&vSibMyTime);
    if (PyErr_Occurred())
      goto ireplicamessagehandler2_get_sibmytime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_SibMyTime);
    goto ireplicamessagehandler2_get_sibmytime_method_cleanup;

    ireplicamessagehandler2_get_sibmytime_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vSibMyTime);
    Py_XDECREF(pyvar_SibMyTime);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.get_SibMyTime");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandler2Method_Init(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsMsgFileName = 0;
    PyObject* pyvar_MsgFileName;
    PyObject* unicodeMsgFileName = NULL;
    esriExportDataChangesOption eMsgExportOption;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_MsgFileName, (int *)&eMsgExportOption))
      goto ireplicamessagehandler2_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_MsgFileName))
        unicodeMsgFileName = PyUnicode_FromObject(pyvar_MsgFileName);
    else if (PyUnicode_Check(pyvar_MsgFileName))
    {
        unicodeMsgFileName = pyvar_MsgFileName;
        Py_INCREF(unicodeMsgFileName);
    }
    else if (pyvar_MsgFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter MsgFileName at index 0");
    if (unicodeMsgFileName)
        bsMsgFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeMsgFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeMsgFileName));
    
    if (PyErr_Occurred())
      goto ireplicamessagehandler2_init_method_cleanup;
    
    // No setup for MsgExportOption

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->Init(bsMsgFileName, eMsgExportOption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.Init() returned %ld", (long)hr);
        goto ireplicamessagehandler2_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MsgFileName
    // No teardown for MsgExportOption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicamessagehandler2_init_method_cleanup;

    ireplicamessagehandler2_init_method_cleanup:
    self->m_HR = hr;
    if (bsMsgFileName)
        ::SysFreeString(bsMsgFileName);
    
    // No cleanup for MsgExportOption
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.Init");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandler2Method_get_ReplicaGuid(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsGUID;
    PyObject* pyvar_GUID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for GUID

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->get_ReplicaGuid(&bsGUID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.get_ReplicaGuid() returned %ld", (long)hr);
        goto ireplicamessagehandler2_get_replicaguid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_GUID = PyUnicode_FromWideChar(bsGUID,::SysStringLen(bsGUID));
    ::SysFreeString(bsGUID);
    
    if (PyErr_Occurred())
      goto ireplicamessagehandler2_get_replicaguid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_GUID);
    goto ireplicamessagehandler2_get_replicaguid_method_cleanup;

    ireplicamessagehandler2_get_replicaguid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_GUID != Py_None)
        Py_XDECREF(pyvar_GUID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.get_ReplicaGuid");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandler2Method_get_MessageType(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriReplicaMessageType eMsgType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MsgType

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->get_MessageType(&eMsgType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.get_MessageType() returned %ld", (long)hr);
        goto ireplicamessagehandler2_get_messagetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MsgType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eMsgType);
    goto ireplicamessagehandler2_get_messagetype_method_cleanup;

    ireplicamessagehandler2_get_messagetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for MsgType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.get_MessageType");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandler2Method_get_MyGenerationNumber(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lGenerationNumber = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for GenerationNumber

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->get_MyGenerationNumber(&lGenerationNumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.get_MyGenerationNumber() returned %ld", (long)hr);
        goto ireplicamessagehandler2_get_mygenerationnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for GenerationNumber

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lGenerationNumber);
    goto ireplicamessagehandler2_get_mygenerationnumber_method_cleanup;

    ireplicamessagehandler2_get_mygenerationnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for GenerationNumber
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.get_MyGenerationNumber");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandler2Method_get_SibGenerationNumber(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lSibGen = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SibGen

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->get_SibGenerationNumber(&lSibGen);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.get_SibGenerationNumber() returned %ld", (long)hr);
        goto ireplicamessagehandler2_get_sibgenerationnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SibGen

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lSibGen);
    goto ireplicamessagehandler2_get_sibgenerationnumber_method_cleanup;

    ireplicamessagehandler2_get_sibgenerationnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for SibGen
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.get_SibGenerationNumber");
    return return_tuple;
}

static PyObject*
IReplicaMessageHandler2Method_get_DeltaDataChanges(PyIReplicaMessageHandler2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDeltaDataChanges* ipDeltaDC = NULL;
    PyObject* py_DeltaDC = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for DeltaDC

    // Call method on actual COM interface
    hr = self->m_pIReplicaMessageHandler2->get_DeltaDataChanges(&ipDeltaDC);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicaMessageHandler2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicaMessageHandler2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicaMessageHandler2.get_DeltaDataChanges() returned %ld", (long)hr);
        goto ireplicamessagehandler2_get_deltadatachanges_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_DeltaDC);
    if (ipDeltaDC)
    {
        IUnknown* pUnk = NULL;
        ipDeltaDC->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_DeltaDC = IUnknownToPythonIIDObject(pUnk, &IID_IDeltaDataChanges);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_DeltaDC)
    {
        if (py_DeltaDC)
           Py_DECREF(py_DeltaDC);
        py_DeltaDC = Py_None;
        Py_INCREF(py_DeltaDC);
    }
    if (PyErr_Occurred())
      goto ireplicamessagehandler2_get_deltadatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_DeltaDC);
    goto ireplicamessagehandler2_get_deltadatachanges_method_cleanup;

    ireplicamessagehandler2_get_deltadatachanges_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_DeltaDC);
    if (ipDeltaDC)
      ipDeltaDC->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicaMessageHandler2.get_DeltaDataChanges");
    return return_tuple;
}


PyMethodDef PyIReplicaMessageHandler2Methods[] = {
    {"supports", (PyCFunction)PyIReplicaMessageHandler2_SupportsInterface, METH_O, ""},
    {"get_MyTime", (PyCFunction)IReplicaMessageHandler2Method_get_MyTime, METH_VARARGS, ""},
    {"get_SibTime", (PyCFunction)IReplicaMessageHandler2Method_get_SibTime, METH_VARARGS, ""},
    {"get_SibMyTime", (PyCFunction)IReplicaMessageHandler2Method_get_SibMyTime, METH_VARARGS, ""},
    {"Init", (PyCFunction)IReplicaMessageHandler2Method_Init, METH_VARARGS, ""},
    {"get_ReplicaGuid", (PyCFunction)IReplicaMessageHandler2Method_get_ReplicaGuid, METH_VARARGS, ""},
    {"get_MessageType", (PyCFunction)IReplicaMessageHandler2Method_get_MessageType, METH_VARARGS, ""},
    {"get_MyGenerationNumber", (PyCFunction)IReplicaMessageHandler2Method_get_MyGenerationNumber, METH_VARARGS, ""},
    {"get_SibGenerationNumber", (PyCFunction)IReplicaMessageHandler2Method_get_SibGenerationNumber, METH_VARARGS, ""},
    {"get_DeltaDataChanges", (PyCFunction)IReplicaMessageHandler2Method_get_DeltaDataChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicaMessageHandler2GetSet[] = {
  {"_pUnk", (getter)PyIReplicaMessageHandler2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicaMessageHandler2", NULL},
  {"_pointer", (getter)PyIReplicaMessageHandler2_GetPointer, NULL, "Get memory address for IReplicaMessageHandler2", NULL},
  {"_IID", (getter)PyIReplicaMessageHandler2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicaMessageHandler2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicaMessageHandler2_GetIgnoreFailures, (setter)PyIReplicaMessageHandler2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicaMessageHandler2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicaMessageHandler2Object",                          
                                              /* tp_name */
  sizeof(PyIReplicaMessageHandler2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicaMessageHandler2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicaMessageHandler2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicaMessageHandler2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicaMessageHandler2Object_new,                      
                                              /* tp_new */
};

// Interface IGDSData

typedef struct PyIGDSDataObject {
    PyObject_HEAD
    IGDSData* m_pIGDSData;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGDSDataObject;

static PyObject*
PyIGDSDataObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGDSDataObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGDSData* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGDSData, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGDSData with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGDSDataObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGDSData");
            return NULL;
        }
        self->m_pIGDSData = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGDSData");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGDSData");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGDSData* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGDSData, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGDSData");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGDSDataObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGDSData");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGDSData = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGDSDataObject_dealloc(PyIGDSDataObject* self)
{
    if (self->m_pIGDSData)
        self->m_pIGDSData->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGDSData_GetpUnk(PyIGDSDataObject* self)
{
    if (!self->m_pIGDSData)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGDSData->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGDSData to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGDSData_GetPointer(PyIGDSDataObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGDSData);
}

static PyObject*
PyIGDSData_GetIID(PyIGDSDataObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "bdfd716d-e902-4907-9c97-65da73f02ae9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGDSData_GetHR(PyIGDSDataObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGDSData_GetIgnoreFailures(PyIGDSDataObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGDSData_SetIgnoreFailures(PyIGDSDataObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGDSData_SupportsInterface(PyIGDSDataObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGDSDataMethod_get_Compressed(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_comp = VARIANT_FALSE;
    PyObject* pyvar_comp = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for comp

    // Call method on actual COM interface
    hr = self->m_pIGDSData->get_Compressed(&b_comp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.get_Compressed() returned %ld", (long)hr);
        goto igdsdata_get_compressed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_comp = ((b_comp == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igdsdata_get_compressed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_comp);
    goto igdsdata_get_compressed_method_cleanup;

    igdsdata_get_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for comp
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.get_Compressed");
    return return_tuple;
}

static PyObject*
IGDSDataMethod_put_Compressed(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_comp = VARIANT_FALSE;
    PyObject* pyvar_comp = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_comp))
      goto igdsdata_put_compressed_method_cleanup;

    // Set up initial variable values as needed
    b_comp = ((PyObject_IsTrue(pyvar_comp) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdsdata_put_compressed_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSData->put_Compressed(b_comp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.put_Compressed() returned %ld", (long)hr);
        goto igdsdata_put_compressed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for comp

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata_put_compressed_method_cleanup;

    igdsdata_put_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for comp
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.put_Compressed");
    return return_tuple;
}

static PyObject*
IGDSDataMethod_get_TransportType(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGDSTransportType epTransport;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pTransport

    // Call method on actual COM interface
    hr = self->m_pIGDSData->get_TransportType(&epTransport);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.get_TransportType() returned %ld", (long)hr);
        goto igdsdata_get_transporttype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTransport

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epTransport);
    goto igdsdata_get_transporttype_method_cleanup;

    igdsdata_get_transporttype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTransport
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.get_TransportType");
    return return_tuple;
}

static PyObject*
IGDSDataMethod_put_TransportType(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGDSTransportType epTransport;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epTransport))
      goto igdsdata_put_transporttype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pTransport

    // Call method on actual COM interface
    hr = self->m_pIGDSData->put_TransportType(epTransport);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.put_TransportType() returned %ld", (long)hr);
        goto igdsdata_put_transporttype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTransport

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata_put_transporttype_method_cleanup;

    igdsdata_put_transporttype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTransport
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.put_TransportType");
    return return_tuple;
}

static PyObject*
IGDSDataMethod_get_URL(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL;
    PyObject* pyvar_URL = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for URL

    // Call method on actual COM interface
    hr = self->m_pIGDSData->get_URL(&bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.get_URL() returned %ld", (long)hr);
        goto igdsdata_get_url_method_cleanup;
    }

    // Set up return values as needed
    pyvar_URL = PyUnicode_FromWideChar(bsURL,::SysStringLen(bsURL));
    ::SysFreeString(bsURL);
    
    if (PyErr_Occurred())
      goto igdsdata_get_url_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_URL);
    goto igdsdata_get_url_method_cleanup;

    igdsdata_get_url_method_cleanup:
    self->m_HR = hr;
    if (pyvar_URL != Py_None)
        Py_XDECREF(pyvar_URL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.get_URL");
    return return_tuple;
}

static PyObject*
IGDSDataMethod_put_URL(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_URL))
      goto igdsdata_put_url_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 0");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto igdsdata_put_url_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSData->put_URL(bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.put_URL() returned %ld", (long)hr);
        goto igdsdata_put_url_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for URL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata_put_url_method_cleanup;

    igdsdata_put_url_method_cleanup:
    self->m_HR = hr;
    if (bsURL)
        ::SysFreeString(bsURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.put_URL");
    return return_tuple;
}

static PyObject*
IGDSDataMethod_get_EmbeddedData(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    SAFEARRAY* padata = NULL;
    PyObject* py_data = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for data

    // Call method on actual COM interface
    hr = self->m_pIGDSData->get_EmbeddedData(&padata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.get_EmbeddedData() returned %ld", (long)hr);
        goto igdsdata_get_embeddeddata_method_cleanup;
    }

    // Set up return values as needed
    py_data = SAFEARRAYToPyObject(padata, VT_NULL);
    if (PyErr_Occurred())
      goto igdsdata_get_embeddeddata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_data);
    goto igdsdata_get_embeddeddata_method_cleanup;

    igdsdata_get_embeddeddata_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_data);
    if(padata)
      SafeArrayDestroy(padata);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.get_EmbeddedData");
    return return_tuple;
}

static PyObject*
IGDSDataMethod_put_EmbeddedData(PyIGDSDataObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'SAFEARRAY', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IGDSData.put_EmbeddedData not implemented.");
    return NULL;
}

static PyObject*
IGDSDataMethod_putref_ConnectionProperties(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipconnProps = NULL;
    PyObject* py_connProps;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_connProps))
      goto igdsdata_putref_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_connProps, &IID_IPropertySet, (void**)&ipconnProps))
        PyErr_SetString(PyExc_TypeError, "Argument connProps (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto igdsdata_putref_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSData->putref_ConnectionProperties(ipconnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.putref_ConnectionProperties() returned %ld", (long)hr);
        goto igdsdata_putref_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for connProps

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata_putref_connectionproperties_method_cleanup;

    igdsdata_putref_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipconnProps)
      ipconnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.putref_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IGDSDataMethod_get_ConnectionProperties(PyIGDSDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipconnProps = NULL;
    PyObject* py_connProps = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for connProps

    // Call method on actual COM interface
    hr = self->m_pIGDSData->get_ConnectionProperties(&ipconnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData.get_ConnectionProperties() returned %ld", (long)hr);
        goto igdsdata_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_connProps);
    if (ipconnProps)
    {
        IUnknown* pUnk = NULL;
        ipconnProps->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_connProps = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_connProps)
    {
        if (py_connProps)
           Py_DECREF(py_connProps);
        py_connProps = Py_None;
        Py_INCREF(py_connProps);
    }
    if (PyErr_Occurred())
      goto igdsdata_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_connProps);
    goto igdsdata_get_connectionproperties_method_cleanup;

    igdsdata_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_connProps);
    if (ipconnProps)
      ipconnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData.get_ConnectionProperties");
    return return_tuple;
}


PyMethodDef PyIGDSDataMethods[] = {
    {"supports", (PyCFunction)PyIGDSData_SupportsInterface, METH_O, ""},
    {"get_Compressed", (PyCFunction)IGDSDataMethod_get_Compressed, METH_VARARGS, ""},
    {"put_Compressed", (PyCFunction)IGDSDataMethod_put_Compressed, METH_VARARGS, ""},
    {"get_TransportType", (PyCFunction)IGDSDataMethod_get_TransportType, METH_VARARGS, ""},
    {"put_TransportType", (PyCFunction)IGDSDataMethod_put_TransportType, METH_VARARGS, ""},
    {"get_URL", (PyCFunction)IGDSDataMethod_get_URL, METH_VARARGS, ""},
    {"put_URL", (PyCFunction)IGDSDataMethod_put_URL, METH_VARARGS, ""},
    {"get_EmbeddedData", (PyCFunction)IGDSDataMethod_get_EmbeddedData, METH_VARARGS, ""},
    {"put_EmbeddedData", (PyCFunction)IGDSDataMethod_put_EmbeddedData, METH_VARARGS, ""},
    {"putref_ConnectionProperties", (PyCFunction)IGDSDataMethod_putref_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IGDSDataMethod_get_ConnectionProperties, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGDSDataGetSet[] = {
  {"_pUnk", (getter)PyIGDSData_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGDSData", NULL},
  {"_pointer", (getter)PyIGDSData_GetPointer, NULL, "Get memory address for IGDSData", NULL},
  {"_IID", (getter)PyIGDSData_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGDSData_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGDSData_GetIgnoreFailures, (setter)PyIGDSData_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGDSDataObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGDSDataObject",                          
                                              /* tp_name */
  sizeof(PyIGDSDataObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGDSDataObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGDSDataMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGDSDataGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGDSDataObject_new,                      
                                              /* tp_new */
};

// Interface IGDSExportOptions

typedef struct PyIGDSExportOptionsObject {
    PyObject_HEAD
    IGDSExportOptions* m_pIGDSExportOptions;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGDSExportOptionsObject;

static PyObject*
PyIGDSExportOptionsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGDSExportOptionsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGDSExportOptions* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGDSExportOptions, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGDSExportOptions with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGDSExportOptionsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGDSExportOptions");
            return NULL;
        }
        self->m_pIGDSExportOptions = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGDSExportOptions");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGDSExportOptions");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGDSExportOptions* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGDSExportOptions, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGDSExportOptions");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGDSExportOptionsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGDSExportOptions");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGDSExportOptions = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGDSExportOptionsObject_dealloc(PyIGDSExportOptionsObject* self)
{
    if (self->m_pIGDSExportOptions)
        self->m_pIGDSExportOptions->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGDSExportOptions_GetpUnk(PyIGDSExportOptionsObject* self)
{
    if (!self->m_pIGDSExportOptions)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGDSExportOptions->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGDSExportOptions to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGDSExportOptions_GetPointer(PyIGDSExportOptionsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGDSExportOptions);
}

static PyObject*
PyIGDSExportOptions_GetIID(PyIGDSExportOptionsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fc23fbc0-dc6a-41fc-8914-36677fba6855");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGDSExportOptions_GetHR(PyIGDSExportOptionsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGDSExportOptions_GetIgnoreFailures(PyIGDSExportOptionsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGDSExportOptions_SetIgnoreFailures(PyIGDSExportOptionsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGDSExportOptions_SupportsInterface(PyIGDSExportOptionsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGDSExportOptions->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGDSExportOptionsMethod_get_ExportFormat(PyIGDSExportOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGDSExportFormat eExportFormat;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ExportFormat

    // Call method on actual COM interface
    hr = self->m_pIGDSExportOptions->get_ExportFormat(&eExportFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSExportOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSExportOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSExportOptions.get_ExportFormat() returned %ld", (long)hr);
        goto igdsexportoptions_get_exportformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ExportFormat

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eExportFormat);
    goto igdsexportoptions_get_exportformat_method_cleanup;

    igdsexportoptions_get_exportformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ExportFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSExportOptions.get_ExportFormat");
    return return_tuple;
}

static PyObject*
IGDSExportOptionsMethod_put_ExportFormat(PyIGDSExportOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGDSExportFormat eExportFormat;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eExportFormat))
      goto igdsexportoptions_put_exportformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ExportFormat

    // Call method on actual COM interface
    hr = self->m_pIGDSExportOptions->put_ExportFormat(eExportFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSExportOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSExportOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSExportOptions.put_ExportFormat() returned %ld", (long)hr);
        goto igdsexportoptions_put_exportformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ExportFormat

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsexportoptions_put_exportformat_method_cleanup;

    igdsexportoptions_put_exportformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ExportFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSExportOptions.put_ExportFormat");
    return return_tuple;
}

static PyObject*
IGDSExportOptionsMethod_get_Compressed(PyIGDSExportOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_comp = VARIANT_FALSE;
    PyObject* pyvar_comp = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for comp

    // Call method on actual COM interface
    hr = self->m_pIGDSExportOptions->get_Compressed(&b_comp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSExportOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSExportOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSExportOptions.get_Compressed() returned %ld", (long)hr);
        goto igdsexportoptions_get_compressed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_comp = ((b_comp == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igdsexportoptions_get_compressed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_comp);
    goto igdsexportoptions_get_compressed_method_cleanup;

    igdsexportoptions_get_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for comp
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSExportOptions.get_Compressed");
    return return_tuple;
}

static PyObject*
IGDSExportOptionsMethod_put_Compressed(PyIGDSExportOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_comp = VARIANT_FALSE;
    PyObject* pyvar_comp = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_comp))
      goto igdsexportoptions_put_compressed_method_cleanup;

    // Set up initial variable values as needed
    b_comp = ((PyObject_IsTrue(pyvar_comp) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdsexportoptions_put_compressed_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSExportOptions->put_Compressed(b_comp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSExportOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSExportOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSExportOptions.put_Compressed() returned %ld", (long)hr);
        goto igdsexportoptions_put_compressed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for comp

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsexportoptions_put_compressed_method_cleanup;

    igdsexportoptions_put_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for comp
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSExportOptions.put_Compressed");
    return return_tuple;
}

static PyObject*
IGDSExportOptionsMethod_get_BinaryGeometry(PyIGDSExportOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_BinaryGeometry = VARIANT_FALSE;
    PyObject* pyvar_BinaryGeometry = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for BinaryGeometry

    // Call method on actual COM interface
    hr = self->m_pIGDSExportOptions->get_BinaryGeometry(&b_BinaryGeometry);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSExportOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSExportOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSExportOptions.get_BinaryGeometry() returned %ld", (long)hr);
        goto igdsexportoptions_get_binarygeometry_method_cleanup;
    }

    // Set up return values as needed
    pyvar_BinaryGeometry = ((b_BinaryGeometry == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igdsexportoptions_get_binarygeometry_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_BinaryGeometry);
    goto igdsexportoptions_get_binarygeometry_method_cleanup;

    igdsexportoptions_get_binarygeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for BinaryGeometry
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSExportOptions.get_BinaryGeometry");
    return return_tuple;
}

static PyObject*
IGDSExportOptionsMethod_put_BinaryGeometry(PyIGDSExportOptionsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_BinaryGeometry = VARIANT_FALSE;
    PyObject* pyvar_BinaryGeometry = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_BinaryGeometry))
      goto igdsexportoptions_put_binarygeometry_method_cleanup;

    // Set up initial variable values as needed
    b_BinaryGeometry = ((PyObject_IsTrue(pyvar_BinaryGeometry) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdsexportoptions_put_binarygeometry_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSExportOptions->put_BinaryGeometry(b_BinaryGeometry);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSExportOptions->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSExportOptions) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSExportOptions.put_BinaryGeometry() returned %ld", (long)hr);
        goto igdsexportoptions_put_binarygeometry_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for BinaryGeometry

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsexportoptions_put_binarygeometry_method_cleanup;

    igdsexportoptions_put_binarygeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for BinaryGeometry
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSExportOptions.put_BinaryGeometry");
    return return_tuple;
}


PyMethodDef PyIGDSExportOptionsMethods[] = {
    {"supports", (PyCFunction)PyIGDSExportOptions_SupportsInterface, METH_O, ""},
    {"get_ExportFormat", (PyCFunction)IGDSExportOptionsMethod_get_ExportFormat, METH_VARARGS, ""},
    {"put_ExportFormat", (PyCFunction)IGDSExportOptionsMethod_put_ExportFormat, METH_VARARGS, ""},
    {"get_Compressed", (PyCFunction)IGDSExportOptionsMethod_get_Compressed, METH_VARARGS, ""},
    {"put_Compressed", (PyCFunction)IGDSExportOptionsMethod_put_Compressed, METH_VARARGS, ""},
    {"get_BinaryGeometry", (PyCFunction)IGDSExportOptionsMethod_get_BinaryGeometry, METH_VARARGS, ""},
    {"put_BinaryGeometry", (PyCFunction)IGDSExportOptionsMethod_put_BinaryGeometry, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGDSExportOptionsGetSet[] = {
  {"_pUnk", (getter)PyIGDSExportOptions_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGDSExportOptions", NULL},
  {"_pointer", (getter)PyIGDSExportOptions_GetPointer, NULL, "Get memory address for IGDSExportOptions", NULL},
  {"_IID", (getter)PyIGDSExportOptions_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGDSExportOptions_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGDSExportOptions_GetIgnoreFailures, (setter)PyIGDSExportOptions_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGDSExportOptionsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGDSExportOptionsObject",                          
                                              /* tp_name */
  sizeof(PyIGDSExportOptionsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGDSExportOptionsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGDSExportOptionsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGDSExportOptionsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGDSExportOptionsObject_new,                      
                                              /* tp_new */
};

// Interface IGDSQueryResultPortion

typedef struct PyIGDSQueryResultPortionObject {
    PyObject_HEAD
    IGDSQueryResultPortion* m_pIGDSQueryResultPortion;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGDSQueryResultPortionObject;

static PyObject*
PyIGDSQueryResultPortionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGDSQueryResultPortionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGDSQueryResultPortion* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGDSQueryResultPortion, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGDSQueryResultPortion with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGDSQueryResultPortionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGDSQueryResultPortion");
            return NULL;
        }
        self->m_pIGDSQueryResultPortion = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGDSQueryResultPortion");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGDSQueryResultPortion");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGDSQueryResultPortion* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGDSQueryResultPortion, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGDSQueryResultPortion");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGDSQueryResultPortionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGDSQueryResultPortion");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGDSQueryResultPortion = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGDSQueryResultPortionObject_dealloc(PyIGDSQueryResultPortionObject* self)
{
    if (self->m_pIGDSQueryResultPortion)
        self->m_pIGDSQueryResultPortion->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGDSQueryResultPortion_GetpUnk(PyIGDSQueryResultPortionObject* self)
{
    if (!self->m_pIGDSQueryResultPortion)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGDSQueryResultPortion->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGDSQueryResultPortion to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGDSQueryResultPortion_GetPointer(PyIGDSQueryResultPortionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGDSQueryResultPortion);
}

static PyObject*
PyIGDSQueryResultPortion_GetIID(PyIGDSQueryResultPortionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6babaf1e-d1a3-487f-bde1-58a206503dbc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGDSQueryResultPortion_GetHR(PyIGDSQueryResultPortionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGDSQueryResultPortion_GetIgnoreFailures(PyIGDSQueryResultPortionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGDSQueryResultPortion_SetIgnoreFailures(PyIGDSQueryResultPortionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGDSQueryResultPortion_SupportsInterface(PyIGDSQueryResultPortionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGDSQueryResultPortion->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGDSQueryResultPortionMethod_get_Records(PyIGDSQueryResultPortionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRecordSet* iprecordSet = NULL;
    PyObject* py_recordSet = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for recordSet

    // Call method on actual COM interface
    hr = self->m_pIGDSQueryResultPortion->get_Records(&iprecordSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSQueryResultPortion->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSQueryResultPortion) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSQueryResultPortion.get_Records() returned %ld", (long)hr);
        goto igdsqueryresultportion_get_records_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_recordSet);
    if (iprecordSet)
    {
        IUnknown* pUnk = NULL;
        iprecordSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_recordSet = IUnknownToPythonIIDObject(pUnk, &IID_IRecordSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_recordSet)
    {
        if (py_recordSet)
           Py_DECREF(py_recordSet);
        py_recordSet = Py_None;
        Py_INCREF(py_recordSet);
    }
    if (PyErr_Occurred())
      goto igdsqueryresultportion_get_records_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_recordSet);
    goto igdsqueryresultportion_get_records_method_cleanup;

    igdsqueryresultportion_get_records_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_recordSet);
    if (iprecordSet)
      iprecordSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSQueryResultPortion.get_Records");
    return return_tuple;
}

static PyObject*
IGDSQueryResultPortionMethod_putref_Records(PyIGDSQueryResultPortionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRecordSet* iprecordSet = NULL;
    PyObject* py_recordSet;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_recordSet))
      goto igdsqueryresultportion_putref_records_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_recordSet, &IID_IRecordSet, (void**)&iprecordSet))
        PyErr_SetString(PyExc_TypeError, "Argument recordSet (position 0) is not IRecordSet");
    
    if (PyErr_Occurred())
      goto igdsqueryresultportion_putref_records_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSQueryResultPortion->putref_Records(iprecordSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSQueryResultPortion->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSQueryResultPortion) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSQueryResultPortion.putref_Records() returned %ld", (long)hr);
        goto igdsqueryresultportion_putref_records_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for recordSet

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsqueryresultportion_putref_records_method_cleanup;

    igdsqueryresultportion_putref_records_method_cleanup:
    self->m_HR = hr;
    if (iprecordSet)
      iprecordSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSQueryResultPortion.putref_Records");
    return return_tuple;
}


PyMethodDef PyIGDSQueryResultPortionMethods[] = {
    {"supports", (PyCFunction)PyIGDSQueryResultPortion_SupportsInterface, METH_O, ""},
    {"get_Records", (PyCFunction)IGDSQueryResultPortionMethod_get_Records, METH_VARARGS, ""},
    {"putref_Records", (PyCFunction)IGDSQueryResultPortionMethod_putref_Records, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGDSQueryResultPortionGetSet[] = {
  {"_pUnk", (getter)PyIGDSQueryResultPortion_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGDSQueryResultPortion", NULL},
  {"_pointer", (getter)PyIGDSQueryResultPortion_GetPointer, NULL, "Get memory address for IGDSQueryResultPortion", NULL},
  {"_IID", (getter)PyIGDSQueryResultPortion_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGDSQueryResultPortion_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGDSQueryResultPortion_GetIgnoreFailures, (setter)PyIGDSQueryResultPortion_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGDSQueryResultPortionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGDSQueryResultPortionObject",                          
                                              /* tp_name */
  sizeof(PyIGDSQueryResultPortionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGDSQueryResultPortionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGDSQueryResultPortionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGDSQueryResultPortionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGDSQueryResultPortionObject_new,                      
                                              /* tp_new */
};

// Interface IGeoDataServer

typedef struct PyIGeoDataServerObject {
    PyObject_HEAD
    IGeoDataServer* m_pIGeoDataServer;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGeoDataServerObject;

static PyObject*
PyIGeoDataServerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGeoDataServerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGeoDataServer* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGeoDataServer, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGeoDataServer with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGeoDataServerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGeoDataServer");
            return NULL;
        }
        self->m_pIGeoDataServer = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGeoDataServer");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGeoDataServer");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGeoDataServer* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGeoDataServer, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGeoDataServer");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGeoDataServerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGeoDataServer");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGeoDataServer = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGeoDataServerObject_dealloc(PyIGeoDataServerObject* self)
{
    if (self->m_pIGeoDataServer)
        self->m_pIGeoDataServer->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGeoDataServer_GetpUnk(PyIGeoDataServerObject* self)
{
    if (!self->m_pIGeoDataServer)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGeoDataServer->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGeoDataServer to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGeoDataServer_GetPointer(PyIGeoDataServerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGeoDataServer);
}

static PyObject*
PyIGeoDataServer_GetIID(PyIGeoDataServerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b59deddd-065f-4c9f-942a-af79e8ab3fbc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGeoDataServer_GetHR(PyIGeoDataServerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGeoDataServer_GetIgnoreFailures(PyIGeoDataServerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGeoDataServer_SetIgnoreFailures(PyIGeoDataServerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGeoDataServer_SupportsInterface(PyIGeoDataServerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGeoDataServerMethod_get_MaxRecordCount(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lmaxCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for maxCount

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->get_MaxRecordCount(&lmaxCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.get_MaxRecordCount() returned %ld", (long)hr);
        goto igeodataserver_get_maxrecordcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for maxCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lmaxCount);
    goto igeodataserver_get_maxrecordcount_method_cleanup;

    igeodataserver_get_maxrecordcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for maxCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.get_MaxRecordCount");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_get_DataElements(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDEBrowseOptions* ippBrowseOptions = NULL;
    PyObject* py_pBrowseOptions;
    IDataElements* ipDataElements = NULL;
    PyObject* py_DataElements = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pBrowseOptions))
      goto igeodataserver_get_dataelements_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pBrowseOptions, &IID_IDEBrowseOptions, (void**)&ippBrowseOptions))
        PyErr_SetString(PyExc_TypeError, "Argument pBrowseOptions (position 0) is not IDEBrowseOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver_get_dataelements_method_cleanup;
    
    // No setup for DataElements

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->get_DataElements(ippBrowseOptions, &ipDataElements);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.get_DataElements() returned %ld", (long)hr);
        goto igeodataserver_get_dataelements_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pBrowseOptions
    Py_XDECREF(py_DataElements);
    if (ipDataElements)
    {
        IUnknown* pUnk = NULL;
        ipDataElements->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_DataElements = IUnknownToPythonIIDObject(pUnk, &IID_IDataElements);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_DataElements)
    {
        if (py_DataElements)
           Py_DECREF(py_DataElements);
        py_DataElements = Py_None;
        Py_INCREF(py_DataElements);
    }
    if (PyErr_Occurred())
      goto igeodataserver_get_dataelements_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_DataElements);
    goto igeodataserver_get_dataelements_method_cleanup;

    igeodataserver_get_dataelements_method_cleanup:
    self->m_HR = hr;
    if (ippBrowseOptions)
      ippBrowseOptions->Release();
    Py_XDECREF(py_DataElements);
    if (ipDataElements)
      ipDataElements->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.get_DataElements");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_get_Versions(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPVersionInfos* ipversionInfos = NULL;
    PyObject* py_versionInfos = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for versionInfos

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->get_Versions(&ipversionInfos);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.get_Versions() returned %ld", (long)hr);
        goto igeodataserver_get_versions_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_versionInfos);
    if (ipversionInfos)
    {
        IUnknown* pUnk = NULL;
        ipversionInfos->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_versionInfos = IUnknownToPythonIIDObject(pUnk, &IID_IGPVersionInfos);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_versionInfos)
    {
        if (py_versionInfos)
           Py_DECREF(py_versionInfos);
        py_versionInfos = Py_None;
        Py_INCREF(py_versionInfos);
    }
    if (PyErr_Occurred())
      goto igeodataserver_get_versions_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_versionInfos);
    goto igeodataserver_get_versions_method_cleanup;

    igeodataserver_get_versions_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_versionInfos);
    if (ipversionInfos)
      ipversionInfos->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.get_Versions");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_get_Replicas(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPReplicas* ipReplicas = NULL;
    PyObject* py_Replicas = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Replicas

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->get_Replicas(&ipReplicas);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.get_Replicas() returned %ld", (long)hr);
        goto igeodataserver_get_replicas_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Replicas);
    if (ipReplicas)
    {
        IUnknown* pUnk = NULL;
        ipReplicas->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Replicas = IUnknownToPythonIIDObject(pUnk, &IID_IGPReplicas);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Replicas)
    {
        if (py_Replicas)
           Py_DECREF(py_Replicas);
        py_Replicas = Py_None;
        Py_INCREF(py_Replicas);
    }
    if (PyErr_Occurred())
      goto igeodataserver_get_replicas_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Replicas);
    goto igeodataserver_get_replicas_method_cleanup;

    igeodataserver_get_replicas_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Replicas);
    if (ipReplicas)
      ipReplicas->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.get_Replicas");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_get_DefaultWorkingVersion(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDefaultWorkingVersion;
    PyObject* pyvar_DefaultWorkingVersion = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for DefaultWorkingVersion

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->get_DefaultWorkingVersion(&bsDefaultWorkingVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.get_DefaultWorkingVersion() returned %ld", (long)hr);
        goto igeodataserver_get_defaultworkingversion_method_cleanup;
    }

    // Set up return values as needed
    pyvar_DefaultWorkingVersion = PyUnicode_FromWideChar(bsDefaultWorkingVersion,::SysStringLen(bsDefaultWorkingVersion));
    ::SysFreeString(bsDefaultWorkingVersion);
    
    if (PyErr_Occurred())
      goto igeodataserver_get_defaultworkingversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_DefaultWorkingVersion);
    goto igeodataserver_get_defaultworkingversion_method_cleanup;

    igeodataserver_get_defaultworkingversion_method_cleanup:
    self->m_HR = hr;
    if (pyvar_DefaultWorkingVersion != Py_None)
        Py_XDECREF(pyvar_DefaultWorkingVersion);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.get_DefaultWorkingVersion");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_get_WrappedWorkspaceType(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriWorkspaceType ewsType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for wsType

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->get_WrappedWorkspaceType(&ewsType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.get_WrappedWorkspaceType() returned %ld", (long)hr);
        goto igeodataserver_get_wrappedworkspacetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for wsType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)ewsType);
    goto igeodataserver_get_wrappedworkspacetype_method_cleanup;

    igeodataserver_get_wrappedworkspacetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for wsType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.get_WrappedWorkspaceType");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ExtractData(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    IGPReplicaDescription* ipreplicaDesc = NULL;
    PyObject* py_replicaDesc;
    IGDSExportOptions* ipoptions = NULL;
    PyObject* py_options;
    esriGDSTransportType eTransportType;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOi", &pyvar_versionName, &py_replicaDesc, &py_options, (int *)&eTransportType))
      goto igeodataserver_extractdata_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto igeodataserver_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_replicaDesc, &IID_IGPReplicaDescription, (void**)&ipreplicaDesc))
        PyErr_SetString(PyExc_TypeError, "Argument replicaDesc (position 1) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto igeodataserver_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_options, &IID_IGDSExportOptions, (void**)&ipoptions))
        PyErr_SetString(PyExc_TypeError, "Argument options (position 2) is not IGDSExportOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver_extractdata_method_cleanup;
    
    // No setup for TransportType
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ExtractData(bsversionName, ipreplicaDesc, ipoptions, eTransportType, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ExtractData() returned %ld", (long)hr);
        goto igeodataserver_extractdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for replicaDesc
    // No teardown for options
    // No teardown for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver_extractdata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver_extractdata_method_cleanup;

    igeodataserver_extractdata_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (ipreplicaDesc)
      ipreplicaDesc->Release();
    if (ipoptions)
      ipoptions->Release();
    // No cleanup for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ExtractData");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_CreateReplica(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsparentVersion = 0;
    PyObject* pyvar_parentVersion;
    PyObject* unicodeparentVersion = NULL;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGPReplicaDescription* ipreplicaDesc = NULL;
    PyObject* py_replicaDesc;
    IGPReplicaOptions* iprepOptions = NULL;
    PyObject* py_repOptions;
    IGDSExportOptions* ipexportOptions = NULL;
    PyObject* py_exportOptions;
    esriGDSTransportType eTransportType;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOOi", &pyvar_parentVersion, &pyvar_ReplicaName, &py_replicaDesc, &py_repOptions, &py_exportOptions, (int *)&eTransportType))
      goto igeodataserver_createreplica_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_parentVersion))
        unicodeparentVersion = PyUnicode_FromObject(pyvar_parentVersion);
    else if (PyUnicode_Check(pyvar_parentVersion))
    {
        unicodeparentVersion = pyvar_parentVersion;
        Py_INCREF(unicodeparentVersion);
    }
    else if (pyvar_parentVersion != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter parentVersion at index 0");
    if (unicodeparentVersion)
        bsparentVersion = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeparentVersion), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeparentVersion));
    
    if (PyErr_Occurred())
      goto igeodataserver_createreplica_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 1");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_replicaDesc, &IID_IGPReplicaDescription, (void**)&ipreplicaDesc))
        PyErr_SetString(PyExc_TypeError, "Argument replicaDesc (position 2) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto igeodataserver_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_repOptions, &IID_IGPReplicaOptions, (void**)&iprepOptions))
        PyErr_SetString(PyExc_TypeError, "Argument repOptions (position 3) is not IGPReplicaOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_exportOptions, &IID_IGDSExportOptions, (void**)&ipexportOptions))
        PyErr_SetString(PyExc_TypeError, "Argument exportOptions (position 4) is not IGDSExportOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver_createreplica_method_cleanup;
    
    // No setup for TransportType
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->CreateReplica(bsparentVersion, bsReplicaName, ipreplicaDesc, iprepOptions, ipexportOptions, eTransportType, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.CreateReplica() returned %ld", (long)hr);
        goto igeodataserver_createreplica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentVersion
    // No teardown for ReplicaName
    // No teardown for replicaDesc
    // No teardown for repOptions
    // No teardown for exportOptions
    // No teardown for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver_createreplica_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver_createreplica_method_cleanup;

    igeodataserver_createreplica_method_cleanup:
    self->m_HR = hr;
    if (bsparentVersion)
        ::SysFreeString(bsparentVersion);
    
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipreplicaDesc)
      ipreplicaDesc->Release();
    if (iprepOptions)
      iprepOptions->Release();
    if (ipexportOptions)
      ipexportOptions->Release();
    // No cleanup for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.CreateReplica");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ExpandReplicaDatasets(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPReplicaDatasets* iprepDatasets = NULL;
    PyObject* py_repDatasets;
    IGPReplicaDatasets* ipexpandedRepDatasets = NULL;
    PyObject* py_expandedRepDatasets = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_repDatasets))
      goto igeodataserver_expandreplicadatasets_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_repDatasets, &IID_IGPReplicaDatasets, (void**)&iprepDatasets))
        PyErr_SetString(PyExc_TypeError, "Argument repDatasets (position 0) is not IGPReplicaDatasets");
    
    if (PyErr_Occurred())
      goto igeodataserver_expandreplicadatasets_method_cleanup;
    
    // No setup for expandedRepDatasets

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ExpandReplicaDatasets(iprepDatasets, &ipexpandedRepDatasets);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ExpandReplicaDatasets() returned %ld", (long)hr);
        goto igeodataserver_expandreplicadatasets_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for repDatasets
    Py_XDECREF(py_expandedRepDatasets);
    if (ipexpandedRepDatasets)
    {
        IUnknown* pUnk = NULL;
        ipexpandedRepDatasets->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_expandedRepDatasets = IUnknownToPythonIIDObject(pUnk, &IID_IGPReplicaDatasets);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_expandedRepDatasets)
    {
        if (py_expandedRepDatasets)
           Py_DECREF(py_expandedRepDatasets);
        py_expandedRepDatasets = Py_None;
        Py_INCREF(py_expandedRepDatasets);
    }
    if (PyErr_Occurred())
      goto igeodataserver_expandreplicadatasets_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_expandedRepDatasets);
    goto igeodataserver_expandreplicadatasets_method_cleanup;

    igeodataserver_expandreplicadatasets_method_cleanup:
    self->m_HR = hr;
    if (iprepDatasets)
      iprepDatasets->Release();
    Py_XDECREF(py_expandedRepDatasets);
    if (ipexpandedRepDatasets)
      ipexpandedRepDatasets->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ExpandReplicaDatasets");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ImportData(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGDSData* ippData = NULL;
    PyObject* py_pData;
    esriGDSImportFormat efmt;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &py_pData, (int *)&efmt))
      goto igeodataserver_importdata_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pData, &IID_IGDSData, (void**)&ippData))
        PyErr_SetString(PyExc_TypeError, "Argument pData (position 0) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver_importdata_method_cleanup;
    
    // No setup for fmt

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ImportData(ippData, efmt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ImportData() returned %ld", (long)hr);
        goto igeodataserver_importdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pData
    // No teardown for fmt

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserver_importdata_method_cleanup;

    igeodataserver_importdata_method_cleanup:
    self->m_HR = hr;
    if (ippData)
      ippData->Release();
    // No cleanup for fmt
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ImportData");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ExportReplicaDataChanges(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGDSExportOptions* ipoptions = NULL;
    PyObject* py_options;
    esriGDSTransportType eTransportType;
    esriExportGenerationsOption egenerationsToExport;
    VARIANT_BOOL b_switchRole = VARIANT_FALSE;
    PyObject* pyvar_switchRole = NULL;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOiiO", &pyvar_ReplicaName, &py_options, (int *)&eTransportType, (int *)&egenerationsToExport, &pyvar_switchRole))
      goto igeodataserver_exportreplicadatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver_exportreplicadatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_options, &IID_IGDSExportOptions, (void**)&ipoptions))
        PyErr_SetString(PyExc_TypeError, "Argument options (position 1) is not IGDSExportOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver_exportreplicadatachanges_method_cleanup;
    
    // No setup for TransportType
    // No setup for generationsToExport
    b_switchRole = ((PyObject_IsTrue(pyvar_switchRole) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igeodataserver_exportreplicadatachanges_method_cleanup;
    
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ExportReplicaDataChanges(bsReplicaName, ipoptions, eTransportType, egenerationsToExport, b_switchRole, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ExportReplicaDataChanges() returned %ld", (long)hr);
        goto igeodataserver_exportreplicadatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    // No teardown for options
    // No teardown for TransportType
    // No teardown for generationsToExport
    // No teardown for switchRole
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver_exportreplicadatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver_exportreplicadatachanges_method_cleanup;

    igeodataserver_exportreplicadatachanges_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipoptions)
      ipoptions->Release();
    // No cleanup for TransportType
    // No cleanup for generationsToExport
    // No cleanup for switchRole
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ExportReplicaDataChanges");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ReExportReplicaDataChanges(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGDSExportOptions* ipoptions = NULL;
    PyObject* py_options;
    esriGDSTransportType eTransportType;
    esriReExportGenerationsOption egensToExport;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOii", &pyvar_ReplicaName, &py_options, (int *)&eTransportType, (int *)&egensToExport))
      goto igeodataserver_reexportreplicadatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver_reexportreplicadatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_options, &IID_IGDSExportOptions, (void**)&ipoptions))
        PyErr_SetString(PyExc_TypeError, "Argument options (position 1) is not IGDSExportOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver_reexportreplicadatachanges_method_cleanup;
    
    // No setup for TransportType
    // No setup for gensToExport
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ReExportReplicaDataChanges(bsReplicaName, ipoptions, eTransportType, egensToExport, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ReExportReplicaDataChanges() returned %ld", (long)hr);
        goto igeodataserver_reexportreplicadatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    // No teardown for options
    // No teardown for TransportType
    // No teardown for gensToExport
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver_reexportreplicadatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver_reexportreplicadatachanges_method_cleanup;

    igeodataserver_reexportreplicadatachanges_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipoptions)
      ipoptions->Release();
    // No cleanup for TransportType
    // No cleanup for gensToExport
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ReExportReplicaDataChanges");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ImportReplicaDataChanges(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGDSReplicaImportSource esourceType;
    esriReplicaReconcilePolicyType ereconcilePolicy;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    IGDSData* ipdata = NULL;
    PyObject* py_data;
    VARIANT_BOOL b_conflictsFound = VARIANT_FALSE;
    PyObject* pyvar_conflictsFound = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iiOO", (int *)&esourceType, (int *)&ereconcilePolicy, &pyvar_columnLevel, &py_data))
      goto igeodataserver_importreplicadatachanges_method_cleanup;

    // Set up initial variable values as needed
    // No setup for sourceType
    // No setup for reconcilePolicy
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igeodataserver_importreplicadatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_data, &IID_IGDSData, (void**)&ipdata))
        PyErr_SetString(PyExc_TypeError, "Argument data (position 3) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver_importreplicadatachanges_method_cleanup;
    
    // No setup for conflictsFound

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ImportReplicaDataChanges(esourceType, ereconcilePolicy, b_columnLevel, ipdata, &b_conflictsFound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ImportReplicaDataChanges() returned %ld", (long)hr);
        goto igeodataserver_importreplicadatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for sourceType
    // No teardown for reconcilePolicy
    // No teardown for columnLevel
    // No teardown for data
    pyvar_conflictsFound = ((b_conflictsFound == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igeodataserver_importreplicadatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflictsFound);
    goto igeodataserver_importreplicadatachanges_method_cleanup;

    igeodataserver_importreplicadatachanges_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sourceType
    // No cleanup for reconcilePolicy
    // No cleanup for columnLevel
    if (ipdata)
      ipdata->Release();
    // No cleanup for conflictsFound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ImportReplicaDataChanges");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ExportAcknowledgement(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    esriGDSTransportType eTransportType;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_ReplicaName, (int *)&eTransportType))
      goto igeodataserver_exportacknowledgement_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver_exportacknowledgement_method_cleanup;
    
    // No setup for TransportType
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ExportAcknowledgement(bsReplicaName, eTransportType, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ExportAcknowledgement() returned %ld", (long)hr);
        goto igeodataserver_exportacknowledgement_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    // No teardown for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver_exportacknowledgement_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver_exportacknowledgement_method_cleanup;

    igeodataserver_exportacknowledgement_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    // No cleanup for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ExportAcknowledgement");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ImportAcknowledgement(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGDSData* ipdata = NULL;
    PyObject* py_data;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_data))
      goto igeodataserver_importacknowledgement_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_data, &IID_IGDSData, (void**)&ipdata))
        PyErr_SetString(PyExc_TypeError, "Argument data (position 0) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver_importacknowledgement_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ImportAcknowledgement(ipdata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ImportAcknowledgement() returned %ld", (long)hr);
        goto igeodataserver_importacknowledgement_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for data

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserver_importacknowledgement_method_cleanup;

    igeodataserver_importacknowledgement_method_cleanup:
    self->m_HR = hr;
    if (ipdata)
      ipdata->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ImportAcknowledgement");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_UnregisterReplica(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ReplicaName))
      goto igeodataserver_unregisterreplica_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver_unregisterreplica_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->UnregisterReplica(bsReplicaName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.UnregisterReplica() returned %ld", (long)hr);
        goto igeodataserver_unregisterreplica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserver_unregisterreplica_method_cleanup;

    igeodataserver_unregisterreplica_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.UnregisterReplica");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_TableSearch(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    BSTR bstableName = 0;
    PyObject* pyvar_tableName;
    PyObject* unicodetableName = NULL;
    IQueryFilter* ipqueryFilter = NULL;
    PyObject* py_queryFilter;
    IResultPortionInfo* ipqueryRange = NULL;
    PyObject* py_queryRange;
    IGDSQueryResultPortion* ipresultPortion = NULL;
    PyObject* py_resultPortion = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_versionName, &pyvar_tableName, &py_queryFilter, &py_queryRange))
      goto igeodataserver_tablesearch_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto igeodataserver_tablesearch_method_cleanup;
    
    if (PyString_Check(pyvar_tableName))
        unicodetableName = PyUnicode_FromObject(pyvar_tableName);
    else if (PyUnicode_Check(pyvar_tableName))
    {
        unicodetableName = pyvar_tableName;
        Py_INCREF(unicodetableName);
    }
    else if (pyvar_tableName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter tableName at index 1");
    if (unicodetableName)
        bstableName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetableName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetableName));
    
    if (PyErr_Occurred())
      goto igeodataserver_tablesearch_method_cleanup;
    
    if (!IFaceFromPyObject(py_queryFilter, &IID_IQueryFilter, (void**)&ipqueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument queryFilter (position 2) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto igeodataserver_tablesearch_method_cleanup;
    
    if (!IFaceFromPyObject(py_queryRange, &IID_IResultPortionInfo, (void**)&ipqueryRange))
        PyErr_SetString(PyExc_TypeError, "Argument queryRange (position 3) is not IResultPortionInfo");
    
    if (PyErr_Occurred())
      goto igeodataserver_tablesearch_method_cleanup;
    
    // No setup for resultPortion

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->TableSearch(bsversionName, bstableName, ipqueryFilter, ipqueryRange, &ipresultPortion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.TableSearch() returned %ld", (long)hr);
        goto igeodataserver_tablesearch_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for tableName
    // No teardown for queryFilter
    // No teardown for queryRange
    Py_XDECREF(py_resultPortion);
    if (ipresultPortion)
    {
        IUnknown* pUnk = NULL;
        ipresultPortion->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_resultPortion = IUnknownToPythonIIDObject(pUnk, &IID_IGDSQueryResultPortion);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_resultPortion)
    {
        if (py_resultPortion)
           Py_DECREF(py_resultPortion);
        py_resultPortion = Py_None;
        Py_INCREF(py_resultPortion);
    }
    if (PyErr_Occurred())
      goto igeodataserver_tablesearch_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_resultPortion);
    goto igeodataserver_tablesearch_method_cleanup;

    igeodataserver_tablesearch_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (bstableName)
        ::SysFreeString(bstableName);
    
    if (ipqueryFilter)
      ipqueryFilter->Release();
    if (ipqueryRange)
      ipqueryRange->Release();
    Py_XDECREF(py_resultPortion);
    if (ipresultPortion)
      ipresultPortion->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.TableSearch");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_GetNextResultPortion(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IResultPortionInfo* ipdesiredRange = NULL;
    PyObject* py_desiredRange;
    IGDSQueryResultPortion* ipresultPortion = NULL;
    PyObject* py_resultPortion = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_desiredRange))
      goto igeodataserver_getnextresultportion_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_desiredRange, &IID_IResultPortionInfo, (void**)&ipdesiredRange))
        PyErr_SetString(PyExc_TypeError, "Argument desiredRange (position 0) is not IResultPortionInfo");
    
    if (PyErr_Occurred())
      goto igeodataserver_getnextresultportion_method_cleanup;
    
    // No setup for resultPortion

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->GetNextResultPortion(ipdesiredRange, &ipresultPortion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.GetNextResultPortion() returned %ld", (long)hr);
        goto igeodataserver_getnextresultportion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for desiredRange
    Py_XDECREF(py_resultPortion);
    if (ipresultPortion)
    {
        IUnknown* pUnk = NULL;
        ipresultPortion->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_resultPortion = IUnknownToPythonIIDObject(pUnk, &IID_IGDSQueryResultPortion);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_resultPortion)
    {
        if (py_resultPortion)
           Py_DECREF(py_resultPortion);
        py_resultPortion = Py_None;
        Py_INCREF(py_resultPortion);
    }
    if (PyErr_Occurred())
      goto igeodataserver_getnextresultportion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_resultPortion);
    goto igeodataserver_getnextresultportion_method_cleanup;

    igeodataserver_getnextresultportion_method_cleanup:
    self->m_HR = hr;
    if (ipdesiredRange)
      ipdesiredRange->Release();
    Py_XDECREF(py_resultPortion);
    if (ipresultPortion)
      ipresultPortion->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.GetNextResultPortion");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ExportReplicaSchema(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    esriGDSTransportType eTransportType;
    IGDSData* ipreplicaSchemaDoc = NULL;
    PyObject* py_replicaSchemaDoc = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_ReplicaName, (int *)&eTransportType))
      goto igeodataserver_exportreplicaschema_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver_exportreplicaschema_method_cleanup;
    
    // No setup for TransportType
    // No setup for replicaSchemaDoc

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ExportReplicaSchema(bsReplicaName, eTransportType, &ipreplicaSchemaDoc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ExportReplicaSchema() returned %ld", (long)hr);
        goto igeodataserver_exportreplicaschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    // No teardown for TransportType
    Py_XDECREF(py_replicaSchemaDoc);
    if (ipreplicaSchemaDoc)
    {
        IUnknown* pUnk = NULL;
        ipreplicaSchemaDoc->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_replicaSchemaDoc = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_replicaSchemaDoc)
    {
        if (py_replicaSchemaDoc)
           Py_DECREF(py_replicaSchemaDoc);
        py_replicaSchemaDoc = Py_None;
        Py_INCREF(py_replicaSchemaDoc);
    }
    if (PyErr_Occurred())
      goto igeodataserver_exportreplicaschema_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_replicaSchemaDoc);
    goto igeodataserver_exportreplicaschema_method_cleanup;

    igeodataserver_exportreplicaschema_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    // No cleanup for TransportType
    Py_XDECREF(py_replicaSchemaDoc);
    if (ipreplicaSchemaDoc)
      ipreplicaSchemaDoc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ExportReplicaSchema");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_CompareReplicaSchema(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGDSData* iprelativeReplicaSchemaDoc = NULL;
    PyObject* py_relativeReplicaSchemaDoc;
    esriGDSTransportType eTransportType;
    IGDSData* ipschemaChangesDoc = NULL;
    PyObject* py_schemaChangesDoc = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &py_relativeReplicaSchemaDoc, (int *)&eTransportType))
      goto igeodataserver_comparereplicaschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_relativeReplicaSchemaDoc, &IID_IGDSData, (void**)&iprelativeReplicaSchemaDoc))
        PyErr_SetString(PyExc_TypeError, "Argument relativeReplicaSchemaDoc (position 0) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver_comparereplicaschema_method_cleanup;
    
    // No setup for TransportType
    // No setup for schemaChangesDoc

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->CompareReplicaSchema(iprelativeReplicaSchemaDoc, eTransportType, &ipschemaChangesDoc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.CompareReplicaSchema() returned %ld", (long)hr);
        goto igeodataserver_comparereplicaschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for relativeReplicaSchemaDoc
    // No teardown for TransportType
    Py_XDECREF(py_schemaChangesDoc);
    if (ipschemaChangesDoc)
    {
        IUnknown* pUnk = NULL;
        ipschemaChangesDoc->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_schemaChangesDoc = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_schemaChangesDoc)
    {
        if (py_schemaChangesDoc)
           Py_DECREF(py_schemaChangesDoc);
        py_schemaChangesDoc = Py_None;
        Py_INCREF(py_schemaChangesDoc);
    }
    if (PyErr_Occurred())
      goto igeodataserver_comparereplicaschema_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_schemaChangesDoc);
    goto igeodataserver_comparereplicaschema_method_cleanup;

    igeodataserver_comparereplicaschema_method_cleanup:
    self->m_HR = hr;
    if (iprelativeReplicaSchemaDoc)
      iprelativeReplicaSchemaDoc->Release();
    // No cleanup for TransportType
    Py_XDECREF(py_schemaChangesDoc);
    if (ipschemaChangesDoc)
      ipschemaChangesDoc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.CompareReplicaSchema");
    return return_tuple;
}

static PyObject*
IGeoDataServerMethod_ImportReplicaSchemaChanges(PyIGeoDataServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGDSData* ipschemaChangesDoc = NULL;
    PyObject* py_schemaChangesDoc;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_schemaChangesDoc))
      goto igeodataserver_importreplicaschemachanges_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_schemaChangesDoc, &IID_IGDSData, (void**)&ipschemaChangesDoc))
        PyErr_SetString(PyExc_TypeError, "Argument schemaChangesDoc (position 0) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver_importreplicaschemachanges_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer->ImportReplicaSchemaChanges(ipschemaChangesDoc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer.ImportReplicaSchemaChanges() returned %ld", (long)hr);
        goto igeodataserver_importreplicaschemachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for schemaChangesDoc

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserver_importreplicaschemachanges_method_cleanup;

    igeodataserver_importreplicaschemachanges_method_cleanup:
    self->m_HR = hr;
    if (ipschemaChangesDoc)
      ipschemaChangesDoc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer.ImportReplicaSchemaChanges");
    return return_tuple;
}


PyMethodDef PyIGeoDataServerMethods[] = {
    {"supports", (PyCFunction)PyIGeoDataServer_SupportsInterface, METH_O, ""},
    {"get_MaxRecordCount", (PyCFunction)IGeoDataServerMethod_get_MaxRecordCount, METH_VARARGS, ""},
    {"get_DataElements", (PyCFunction)IGeoDataServerMethod_get_DataElements, METH_VARARGS, ""},
    {"get_Versions", (PyCFunction)IGeoDataServerMethod_get_Versions, METH_VARARGS, ""},
    {"get_Replicas", (PyCFunction)IGeoDataServerMethod_get_Replicas, METH_VARARGS, ""},
    {"get_DefaultWorkingVersion", (PyCFunction)IGeoDataServerMethod_get_DefaultWorkingVersion, METH_VARARGS, ""},
    {"get_WrappedWorkspaceType", (PyCFunction)IGeoDataServerMethod_get_WrappedWorkspaceType, METH_VARARGS, ""},
    {"ExtractData", (PyCFunction)IGeoDataServerMethod_ExtractData, METH_VARARGS, ""},
    {"CreateReplica", (PyCFunction)IGeoDataServerMethod_CreateReplica, METH_VARARGS, ""},
    {"ExpandReplicaDatasets", (PyCFunction)IGeoDataServerMethod_ExpandReplicaDatasets, METH_VARARGS, ""},
    {"ImportData", (PyCFunction)IGeoDataServerMethod_ImportData, METH_VARARGS, ""},
    {"ExportReplicaDataChanges", (PyCFunction)IGeoDataServerMethod_ExportReplicaDataChanges, METH_VARARGS, ""},
    {"ReExportReplicaDataChanges", (PyCFunction)IGeoDataServerMethod_ReExportReplicaDataChanges, METH_VARARGS, ""},
    {"ImportReplicaDataChanges", (PyCFunction)IGeoDataServerMethod_ImportReplicaDataChanges, METH_VARARGS, ""},
    {"ExportAcknowledgement", (PyCFunction)IGeoDataServerMethod_ExportAcknowledgement, METH_VARARGS, ""},
    {"ImportAcknowledgement", (PyCFunction)IGeoDataServerMethod_ImportAcknowledgement, METH_VARARGS, ""},
    {"UnregisterReplica", (PyCFunction)IGeoDataServerMethod_UnregisterReplica, METH_VARARGS, ""},
    {"TableSearch", (PyCFunction)IGeoDataServerMethod_TableSearch, METH_VARARGS, ""},
    {"GetNextResultPortion", (PyCFunction)IGeoDataServerMethod_GetNextResultPortion, METH_VARARGS, ""},
    {"ExportReplicaSchema", (PyCFunction)IGeoDataServerMethod_ExportReplicaSchema, METH_VARARGS, ""},
    {"CompareReplicaSchema", (PyCFunction)IGeoDataServerMethod_CompareReplicaSchema, METH_VARARGS, ""},
    {"ImportReplicaSchemaChanges", (PyCFunction)IGeoDataServerMethod_ImportReplicaSchemaChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGeoDataServerGetSet[] = {
  {"_pUnk", (getter)PyIGeoDataServer_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGeoDataServer", NULL},
  {"_pointer", (getter)PyIGeoDataServer_GetPointer, NULL, "Get memory address for IGeoDataServer", NULL},
  {"_IID", (getter)PyIGeoDataServer_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGeoDataServer_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGeoDataServer_GetIgnoreFailures, (setter)PyIGeoDataServer_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGeoDataServerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGeoDataServerObject",                          
                                              /* tp_name */
  sizeof(PyIGeoDataServerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGeoDataServerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGeoDataServerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGeoDataServerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGeoDataServerObject_new,                      
                                              /* tp_new */
};

// Interface IGeoDataServerInit

typedef struct PyIGeoDataServerInitObject {
    PyObject_HEAD
    IGeoDataServerInit* m_pIGeoDataServerInit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGeoDataServerInitObject;

static PyObject*
PyIGeoDataServerInitObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGeoDataServerInitObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGeoDataServerInit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGeoDataServerInit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGeoDataServerInit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGeoDataServerInitObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGeoDataServerInit");
            return NULL;
        }
        self->m_pIGeoDataServerInit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGeoDataServerInit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGeoDataServerInit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGeoDataServerInit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGeoDataServerInit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGeoDataServerInit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGeoDataServerInitObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGeoDataServerInit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGeoDataServerInit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGeoDataServerInitObject_dealloc(PyIGeoDataServerInitObject* self)
{
    if (self->m_pIGeoDataServerInit)
        self->m_pIGeoDataServerInit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGeoDataServerInit_GetpUnk(PyIGeoDataServerInitObject* self)
{
    if (!self->m_pIGeoDataServerInit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGeoDataServerInit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGeoDataServerInit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGeoDataServerInit_GetPointer(PyIGeoDataServerInitObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGeoDataServerInit);
}

static PyObject*
PyIGeoDataServerInit_GetIID(PyIGeoDataServerInitObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "841bdc30-fe10-46af-b67b-582252bc16b8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGeoDataServerInit_GetHR(PyIGeoDataServerInitObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGeoDataServerInit_GetIgnoreFailures(PyIGeoDataServerInitObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGeoDataServerInit_SetIgnoreFailures(PyIGeoDataServerInitObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGeoDataServerInit_SupportsInterface(PyIGeoDataServerInitObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGeoDataServerInitMethod_InitFromMap(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfilePath = 0;
    PyObject* pyvar_filePath;
    PyObject* unicodefilePath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_filePath))
      goto igeodataserverinit_initfrommap_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_filePath))
        unicodefilePath = PyUnicode_FromObject(pyvar_filePath);
    else if (PyUnicode_Check(pyvar_filePath))
    {
        unicodefilePath = pyvar_filePath;
        Py_INCREF(unicodefilePath);
    }
    else if (pyvar_filePath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter filePath at index 0");
    if (unicodefilePath)
        bsfilePath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefilePath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefilePath));
    
    if (PyErr_Occurred())
      goto igeodataserverinit_initfrommap_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->InitFromMap(bsfilePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.InitFromMap() returned %ld", (long)hr);
        goto igeodataserverinit_initfrommap_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for filePath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserverinit_initfrommap_method_cleanup;

    igeodataserverinit_initfrommap_method_cleanup:
    self->m_HR = hr;
    if (bsfilePath)
        ::SysFreeString(bsfilePath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.InitFromMap");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_InitFromFile(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfile = 0;
    PyObject* pyvar_file;
    PyObject* unicodefile = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_file))
      goto igeodataserverinit_initfromfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_file))
        unicodefile = PyUnicode_FromObject(pyvar_file);
    else if (PyUnicode_Check(pyvar_file))
    {
        unicodefile = pyvar_file;
        Py_INCREF(unicodefile);
    }
    else if (pyvar_file != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter file at index 0");
    if (unicodefile)
        bsfile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefile));
    
    if (PyErr_Occurred())
      goto igeodataserverinit_initfromfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->InitFromFile(bsfile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.InitFromFile() returned %ld", (long)hr);
        goto igeodataserverinit_initfromfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for file

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserverinit_initfromfile_method_cleanup;

    igeodataserverinit_initfromfile_method_cleanup:
    self->m_HR = hr;
    if (bsfile)
        ::SysFreeString(bsfile);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.InitFromFile");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_InitFromConnectionString(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsconnectionString = 0;
    PyObject* pyvar_connectionString;
    PyObject* unicodeconnectionString = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_connectionString))
      goto igeodataserverinit_initfromconnectionstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_connectionString))
        unicodeconnectionString = PyUnicode_FromObject(pyvar_connectionString);
    else if (PyUnicode_Check(pyvar_connectionString))
    {
        unicodeconnectionString = pyvar_connectionString;
        Py_INCREF(unicodeconnectionString);
    }
    else if (pyvar_connectionString != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter connectionString at index 0");
    if (unicodeconnectionString)
        bsconnectionString = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeconnectionString), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeconnectionString));
    
    if (PyErr_Occurred())
      goto igeodataserverinit_initfromconnectionstring_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->InitFromConnectionString(bsconnectionString);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.InitFromConnectionString() returned %ld", (long)hr);
        goto igeodataserverinit_initfromconnectionstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for connectionString

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserverinit_initfromconnectionstring_method_cleanup;

    igeodataserverinit_initfromconnectionstring_method_cleanup:
    self->m_HR = hr;
    if (bsconnectionString)
        ::SysFreeString(bsconnectionString);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.InitFromConnectionString");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_InitWithWorkspace(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspace* ippWorkspace = NULL;
    PyObject* py_pWorkspace;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pWorkspace))
      goto igeodataserverinit_initwithworkspace_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pWorkspace, &IID_IWorkspace, (void**)&ippWorkspace))
        PyErr_SetString(PyExc_TypeError, "Argument pWorkspace (position 0) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto igeodataserverinit_initwithworkspace_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->InitWithWorkspace(ippWorkspace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.InitWithWorkspace() returned %ld", (long)hr);
        goto igeodataserverinit_initwithworkspace_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWorkspace

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserverinit_initwithworkspace_method_cleanup;

    igeodataserverinit_initwithworkspace_method_cleanup:
    self->m_HR = hr;
    if (ippWorkspace)
      ippWorkspace->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.InitWithWorkspace");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_put_PhysicalOutputDirectory(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdirPath = 0;
    PyObject* pyvar_dirPath;
    PyObject* unicodedirPath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_dirPath))
      goto igeodataserverinit_put_physicaloutputdirectory_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_dirPath))
        unicodedirPath = PyUnicode_FromObject(pyvar_dirPath);
    else if (PyUnicode_Check(pyvar_dirPath))
    {
        unicodedirPath = pyvar_dirPath;
        Py_INCREF(unicodedirPath);
    }
    else if (pyvar_dirPath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter dirPath at index 0");
    if (unicodedirPath)
        bsdirPath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedirPath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedirPath));
    
    if (PyErr_Occurred())
      goto igeodataserverinit_put_physicaloutputdirectory_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->put_PhysicalOutputDirectory(bsdirPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.put_PhysicalOutputDirectory() returned %ld", (long)hr);
        goto igeodataserverinit_put_physicaloutputdirectory_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dirPath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserverinit_put_physicaloutputdirectory_method_cleanup;

    igeodataserverinit_put_physicaloutputdirectory_method_cleanup:
    self->m_HR = hr;
    if (bsdirPath)
        ::SysFreeString(bsdirPath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.put_PhysicalOutputDirectory");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_get_PhysicalOutputDirectory(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdirPath;
    PyObject* pyvar_dirPath = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for dirPath

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->get_PhysicalOutputDirectory(&bsdirPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.get_PhysicalOutputDirectory() returned %ld", (long)hr);
        goto igeodataserverinit_get_physicaloutputdirectory_method_cleanup;
    }

    // Set up return values as needed
    pyvar_dirPath = PyUnicode_FromWideChar(bsdirPath,::SysStringLen(bsdirPath));
    ::SysFreeString(bsdirPath);
    
    if (PyErr_Occurred())
      goto igeodataserverinit_get_physicaloutputdirectory_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_dirPath);
    goto igeodataserverinit_get_physicaloutputdirectory_method_cleanup;

    igeodataserverinit_get_physicaloutputdirectory_method_cleanup:
    self->m_HR = hr;
    if (pyvar_dirPath != Py_None)
        Py_XDECREF(pyvar_dirPath);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.get_PhysicalOutputDirectory");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_put_VirtualOutputDirectory(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdirPath = 0;
    PyObject* pyvar_dirPath;
    PyObject* unicodedirPath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_dirPath))
      goto igeodataserverinit_put_virtualoutputdirectory_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_dirPath))
        unicodedirPath = PyUnicode_FromObject(pyvar_dirPath);
    else if (PyUnicode_Check(pyvar_dirPath))
    {
        unicodedirPath = pyvar_dirPath;
        Py_INCREF(unicodedirPath);
    }
    else if (pyvar_dirPath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter dirPath at index 0");
    if (unicodedirPath)
        bsdirPath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedirPath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedirPath));
    
    if (PyErr_Occurred())
      goto igeodataserverinit_put_virtualoutputdirectory_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->put_VirtualOutputDirectory(bsdirPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.put_VirtualOutputDirectory() returned %ld", (long)hr);
        goto igeodataserverinit_put_virtualoutputdirectory_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dirPath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserverinit_put_virtualoutputdirectory_method_cleanup;

    igeodataserverinit_put_virtualoutputdirectory_method_cleanup:
    self->m_HR = hr;
    if (bsdirPath)
        ::SysFreeString(bsdirPath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.put_VirtualOutputDirectory");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_get_VirtualOutputDirectory(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdirPath;
    PyObject* pyvar_dirPath = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for dirPath

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->get_VirtualOutputDirectory(&bsdirPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.get_VirtualOutputDirectory() returned %ld", (long)hr);
        goto igeodataserverinit_get_virtualoutputdirectory_method_cleanup;
    }

    // Set up return values as needed
    pyvar_dirPath = PyUnicode_FromWideChar(bsdirPath,::SysStringLen(bsdirPath));
    ::SysFreeString(bsdirPath);
    
    if (PyErr_Occurred())
      goto igeodataserverinit_get_virtualoutputdirectory_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_dirPath);
    goto igeodataserverinit_get_virtualoutputdirectory_method_cleanup;

    igeodataserverinit_get_virtualoutputdirectory_method_cleanup:
    self->m_HR = hr;
    if (pyvar_dirPath != Py_None)
        Py_XDECREF(pyvar_dirPath);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.get_VirtualOutputDirectory");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_get_MaxRecordCount(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->get_MaxRecordCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.get_MaxRecordCount() returned %ld", (long)hr);
        goto igeodataserverinit_get_maxrecordcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto igeodataserverinit_get_maxrecordcount_method_cleanup;

    igeodataserverinit_get_maxrecordcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.get_MaxRecordCount");
    return return_tuple;
}

static PyObject*
IGeoDataServerInitMethod_put_MaxRecordCount(PyIGeoDataServerInitObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lCount))
      goto igeodataserverinit_put_maxrecordcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerInit->put_MaxRecordCount(lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerInit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerInit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerInit.put_MaxRecordCount() returned %ld", (long)hr);
        goto igeodataserverinit_put_maxrecordcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserverinit_put_maxrecordcount_method_cleanup;

    igeodataserverinit_put_maxrecordcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerInit.put_MaxRecordCount");
    return return_tuple;
}


PyMethodDef PyIGeoDataServerInitMethods[] = {
    {"supports", (PyCFunction)PyIGeoDataServerInit_SupportsInterface, METH_O, ""},
    {"InitFromMap", (PyCFunction)IGeoDataServerInitMethod_InitFromMap, METH_VARARGS, ""},
    {"InitFromFile", (PyCFunction)IGeoDataServerInitMethod_InitFromFile, METH_VARARGS, ""},
    {"InitFromConnectionString", (PyCFunction)IGeoDataServerInitMethod_InitFromConnectionString, METH_VARARGS, ""},
    {"InitWithWorkspace", (PyCFunction)IGeoDataServerInitMethod_InitWithWorkspace, METH_VARARGS, ""},
    {"put_PhysicalOutputDirectory", (PyCFunction)IGeoDataServerInitMethod_put_PhysicalOutputDirectory, METH_VARARGS, ""},
    {"get_PhysicalOutputDirectory", (PyCFunction)IGeoDataServerInitMethod_get_PhysicalOutputDirectory, METH_VARARGS, ""},
    {"put_VirtualOutputDirectory", (PyCFunction)IGeoDataServerInitMethod_put_VirtualOutputDirectory, METH_VARARGS, ""},
    {"get_VirtualOutputDirectory", (PyCFunction)IGeoDataServerInitMethod_get_VirtualOutputDirectory, METH_VARARGS, ""},
    {"get_MaxRecordCount", (PyCFunction)IGeoDataServerInitMethod_get_MaxRecordCount, METH_VARARGS, ""},
    {"put_MaxRecordCount", (PyCFunction)IGeoDataServerInitMethod_put_MaxRecordCount, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGeoDataServerInitGetSet[] = {
  {"_pUnk", (getter)PyIGeoDataServerInit_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGeoDataServerInit", NULL},
  {"_pointer", (getter)PyIGeoDataServerInit_GetPointer, NULL, "Get memory address for IGeoDataServerInit", NULL},
  {"_IID", (getter)PyIGeoDataServerInit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGeoDataServerInit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGeoDataServerInit_GetIgnoreFailures, (setter)PyIGeoDataServerInit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGeoDataServerInitObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGeoDataServerInitObject",                          
                                              /* tp_name */
  sizeof(PyIGeoDataServerInitObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGeoDataServerInitObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGeoDataServerInitMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGeoDataServerInitGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGeoDataServerInitObject_new,                      
                                              /* tp_new */
};

// Interface IGeoDataServerObjects

typedef struct PyIGeoDataServerObjectsObject {
    PyObject_HEAD
    IGeoDataServerObjects* m_pIGeoDataServerObjects;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGeoDataServerObjectsObject;

static PyObject*
PyIGeoDataServerObjectsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGeoDataServerObjectsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGeoDataServerObjects* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGeoDataServerObjects, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGeoDataServerObjects with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGeoDataServerObjectsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGeoDataServerObjects");
            return NULL;
        }
        self->m_pIGeoDataServerObjects = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGeoDataServerObjects");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGeoDataServerObjects");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGeoDataServerObjects* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGeoDataServerObjects, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGeoDataServerObjects");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGeoDataServerObjectsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGeoDataServerObjects");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGeoDataServerObjects = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGeoDataServerObjectsObject_dealloc(PyIGeoDataServerObjectsObject* self)
{
    if (self->m_pIGeoDataServerObjects)
        self->m_pIGeoDataServerObjects->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGeoDataServerObjects_GetpUnk(PyIGeoDataServerObjectsObject* self)
{
    if (!self->m_pIGeoDataServerObjects)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGeoDataServerObjects->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGeoDataServerObjects to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGeoDataServerObjects_GetPointer(PyIGeoDataServerObjectsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGeoDataServerObjects);
}

static PyObject*
PyIGeoDataServerObjects_GetIID(PyIGeoDataServerObjectsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f3b8e8ca-fdcc-4f3b-a581-ab11258cb801");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGeoDataServerObjects_GetHR(PyIGeoDataServerObjectsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGeoDataServerObjects_GetIgnoreFailures(PyIGeoDataServerObjectsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGeoDataServerObjects_SetIgnoreFailures(PyIGeoDataServerObjectsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGeoDataServerObjects_SupportsInterface(PyIGeoDataServerObjectsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGeoDataServerObjects->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGeoDataServerObjectsMethod_get_DefaultWorkingWorkspace(PyIGeoDataServerObjectsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspace* ipWorkspace = NULL;
    PyObject* py_Workspace = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Workspace

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServerObjects->get_DefaultWorkingWorkspace(&ipWorkspace);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServerObjects->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServerObjects) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServerObjects.get_DefaultWorkingWorkspace() returned %ld", (long)hr);
        goto igeodataserverobjects_get_defaultworkingworkspace_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Workspace);
    if (ipWorkspace)
    {
        IUnknown* pUnk = NULL;
        ipWorkspace->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Workspace = IUnknownToPythonIIDObject(pUnk, &IID_IWorkspace);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Workspace)
    {
        if (py_Workspace)
           Py_DECREF(py_Workspace);
        py_Workspace = Py_None;
        Py_INCREF(py_Workspace);
    }
    if (PyErr_Occurred())
      goto igeodataserverobjects_get_defaultworkingworkspace_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Workspace);
    goto igeodataserverobjects_get_defaultworkingworkspace_method_cleanup;

    igeodataserverobjects_get_defaultworkingworkspace_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Workspace);
    if (ipWorkspace)
      ipWorkspace->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServerObjects.get_DefaultWorkingWorkspace");
    return return_tuple;
}


PyMethodDef PyIGeoDataServerObjectsMethods[] = {
    {"supports", (PyCFunction)PyIGeoDataServerObjects_SupportsInterface, METH_O, ""},
    {"get_DefaultWorkingWorkspace", (PyCFunction)IGeoDataServerObjectsMethod_get_DefaultWorkingWorkspace, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGeoDataServerObjectsGetSet[] = {
  {"_pUnk", (getter)PyIGeoDataServerObjects_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGeoDataServerObjects", NULL},
  {"_pointer", (getter)PyIGeoDataServerObjects_GetPointer, NULL, "Get memory address for IGeoDataServerObjects", NULL},
  {"_IID", (getter)PyIGeoDataServerObjects_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGeoDataServerObjects_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGeoDataServerObjects_GetIgnoreFailures, (setter)PyIGeoDataServerObjects_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGeoDataServerObjectsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGeoDataServerObjectsObject",                          
                                              /* tp_name */
  sizeof(PyIGeoDataServerObjectsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGeoDataServerObjectsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGeoDataServerObjectsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGeoDataServerObjectsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGeoDataServerObjectsObject_new,                      
                                              /* tp_new */
};

// Interface IReplicationAgent

typedef struct PyIReplicationAgentObject {
    PyObject_HEAD
    IReplicationAgent* m_pIReplicationAgent;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicationAgentObject;

static PyObject*
PyIReplicationAgentObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicationAgentObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicationAgent* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicationAgent, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicationAgent with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicationAgentObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicationAgent");
            return NULL;
        }
        self->m_pIReplicationAgent = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicationAgent");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicationAgent");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicationAgent* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicationAgent, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicationAgent");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicationAgentObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicationAgent");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicationAgent = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicationAgentObject_dealloc(PyIReplicationAgentObject* self)
{
    if (self->m_pIReplicationAgent)
        self->m_pIReplicationAgent->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicationAgent_GetpUnk(PyIReplicationAgentObject* self)
{
    if (!self->m_pIReplicationAgent)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicationAgent->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicationAgent to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicationAgent_GetPointer(PyIReplicationAgentObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicationAgent);
}

static PyObject*
PyIReplicationAgent_GetIID(PyIReplicationAgentObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ab9f2c3d-9298-480b-a57c-4afcc8d7c498");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicationAgent_GetHR(PyIReplicationAgentObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicationAgent_GetIgnoreFailures(PyIReplicationAgentObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicationAgent_SetIgnoreFailures(PyIReplicationAgentObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicationAgent_SupportsInterface(PyIReplicationAgentObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicationAgent->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicationAgentMethod_CreateReplica(PyIReplicationAgentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    IGeoDataServer* ipsrcGDS = NULL;
    PyObject* py_srcGDS;
    IGeoDataServer* ipdestGDS = NULL;
    PyObject* py_destGDS;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGPReplicaDescription* ipdesc = NULL;
    PyObject* py_desc;
    IGPReplicaOptions* iprepOptions = NULL;
    PyObject* py_repOptions;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOOO", &pyvar_versionName, &py_srcGDS, &py_destGDS, &pyvar_ReplicaName, &py_desc, &py_repOptions))
      goto ireplicationagent_createreplica_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto ireplicationagent_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_srcGDS, &IID_IGeoDataServer, (void**)&ipsrcGDS))
        PyErr_SetString(PyExc_TypeError, "Argument srcGDS (position 1) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_destGDS, &IID_IGeoDataServer, (void**)&ipdestGDS))
        PyErr_SetString(PyExc_TypeError, "Argument destGDS (position 2) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent_createreplica_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 3");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto ireplicationagent_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_desc, &IID_IGPReplicaDescription, (void**)&ipdesc))
        PyErr_SetString(PyExc_TypeError, "Argument desc (position 4) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto ireplicationagent_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_repOptions, &IID_IGPReplicaOptions, (void**)&iprepOptions))
        PyErr_SetString(PyExc_TypeError, "Argument repOptions (position 5) is not IGPReplicaOptions");
    
    if (PyErr_Occurred())
      goto ireplicationagent_createreplica_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicationAgent->CreateReplica(bsversionName, ipsrcGDS, ipdestGDS, bsReplicaName, ipdesc, iprepOptions);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicationAgent->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicationAgent) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicationAgent.CreateReplica() returned %ld", (long)hr);
        goto ireplicationagent_createreplica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for srcGDS
    // No teardown for destGDS
    // No teardown for ReplicaName
    // No teardown for desc
    // No teardown for repOptions

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicationagent_createreplica_method_cleanup;

    ireplicationagent_createreplica_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (ipsrcGDS)
      ipsrcGDS->Release();
    if (ipdestGDS)
      ipdestGDS->Release();
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipdesc)
      ipdesc->Release();
    if (iprepOptions)
      iprepOptions->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicationAgent.CreateReplica");
    return return_tuple;
}

static PyObject*
IReplicationAgentMethod_SynchronizeReplica(PyIReplicationAgentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeoDataServer* ipgds1 = NULL;
    PyObject* py_gds1;
    IGeoDataServer* ipgds2 = NULL;
    PyObject* py_gds2;
    IGPReplica* iprep1 = NULL;
    PyObject* py_rep1;
    IGPReplica* iprep2 = NULL;
    PyObject* py_rep2;
    esriReplicationAgentReconcilePolicy epol;
    esriReplicaSynchronizeDirection edir;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    VARIANT_BOOL b_conflictsDetected = VARIANT_FALSE;
    PyObject* pyvar_conflictsDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOiiO", &py_gds1, &py_gds2, &py_rep1, &py_rep2, (int *)&epol, (int *)&edir, &pyvar_columnLevel))
      goto ireplicationagent_synchronizereplica_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_gds1, &IID_IGeoDataServer, (void**)&ipgds1))
        PyErr_SetString(PyExc_TypeError, "Argument gds1 (position 0) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent_synchronizereplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_gds2, &IID_IGeoDataServer, (void**)&ipgds2))
        PyErr_SetString(PyExc_TypeError, "Argument gds2 (position 1) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent_synchronizereplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_rep1, &IID_IGPReplica, (void**)&iprep1))
        PyErr_SetString(PyExc_TypeError, "Argument rep1 (position 2) is not IGPReplica");
    
    if (PyErr_Occurred())
      goto ireplicationagent_synchronizereplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_rep2, &IID_IGPReplica, (void**)&iprep2))
        PyErr_SetString(PyExc_TypeError, "Argument rep2 (position 3) is not IGPReplica");
    
    if (PyErr_Occurred())
      goto ireplicationagent_synchronizereplica_method_cleanup;
    
    // No setup for pol
    // No setup for dir
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ireplicationagent_synchronizereplica_method_cleanup;
    
    // No setup for conflictsDetected

    // Call method on actual COM interface
    hr = self->m_pIReplicationAgent->SynchronizeReplica(ipgds1, ipgds2, iprep1, iprep2, epol, edir, b_columnLevel, &b_conflictsDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicationAgent->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicationAgent) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicationAgent.SynchronizeReplica() returned %ld", (long)hr);
        goto ireplicationagent_synchronizereplica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for gds1
    // No teardown for gds2
    // No teardown for rep1
    // No teardown for rep2
    // No teardown for pol
    // No teardown for dir
    // No teardown for columnLevel
    pyvar_conflictsDetected = ((b_conflictsDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ireplicationagent_synchronizereplica_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflictsDetected);
    goto ireplicationagent_synchronizereplica_method_cleanup;

    ireplicationagent_synchronizereplica_method_cleanup:
    self->m_HR = hr;
    if (ipgds1)
      ipgds1->Release();
    if (ipgds2)
      ipgds2->Release();
    if (iprep1)
      iprep1->Release();
    if (iprep2)
      iprep2->Release();
    // No cleanup for pol
    // No cleanup for dir
    // No cleanup for columnLevel
    // No cleanup for conflictsDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicationAgent.SynchronizeReplica");
    return return_tuple;
}

static PyObject*
IReplicationAgentMethod_ExtractData(PyIReplicationAgentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    IGeoDataServer* ipsrcGDS = NULL;
    PyObject* py_srcGDS;
    IGeoDataServer* ipdestGDS = NULL;
    PyObject* py_destGDS;
    IGPReplicaDescription* ipdesc = NULL;
    PyObject* py_desc;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_versionName, &py_srcGDS, &py_destGDS, &py_desc))
      goto ireplicationagent_extractdata_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto ireplicationagent_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_srcGDS, &IID_IGeoDataServer, (void**)&ipsrcGDS))
        PyErr_SetString(PyExc_TypeError, "Argument srcGDS (position 1) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_destGDS, &IID_IGeoDataServer, (void**)&ipdestGDS))
        PyErr_SetString(PyExc_TypeError, "Argument destGDS (position 2) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_desc, &IID_IGPReplicaDescription, (void**)&ipdesc))
        PyErr_SetString(PyExc_TypeError, "Argument desc (position 3) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto ireplicationagent_extractdata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicationAgent->ExtractData(bsversionName, ipsrcGDS, ipdestGDS, ipdesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicationAgent->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicationAgent) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicationAgent.ExtractData() returned %ld", (long)hr);
        goto ireplicationagent_extractdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for srcGDS
    // No teardown for destGDS
    // No teardown for desc

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicationagent_extractdata_method_cleanup;

    ireplicationagent_extractdata_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (ipsrcGDS)
      ipsrcGDS->Release();
    if (ipdestGDS)
      ipdestGDS->Release();
    if (ipdesc)
      ipdesc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicationAgent.ExtractData");
    return return_tuple;
}


PyMethodDef PyIReplicationAgentMethods[] = {
    {"supports", (PyCFunction)PyIReplicationAgent_SupportsInterface, METH_O, ""},
    {"CreateReplica", (PyCFunction)IReplicationAgentMethod_CreateReplica, METH_VARARGS, ""},
    {"SynchronizeReplica", (PyCFunction)IReplicationAgentMethod_SynchronizeReplica, METH_VARARGS, ""},
    {"ExtractData", (PyCFunction)IReplicationAgentMethod_ExtractData, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicationAgentGetSet[] = {
  {"_pUnk", (getter)PyIReplicationAgent_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicationAgent", NULL},
  {"_pointer", (getter)PyIReplicationAgent_GetPointer, NULL, "Get memory address for IReplicationAgent", NULL},
  {"_IID", (getter)PyIReplicationAgent_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicationAgent_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicationAgent_GetIgnoreFailures, (setter)PyIReplicationAgent_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicationAgentObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicationAgentObject",                          
                                              /* tp_name */
  sizeof(PyIReplicationAgentObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicationAgentObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicationAgentMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicationAgentGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicationAgentObject_new,                      
                                              /* tp_new */
};

// Interface IReplicationAgentCancelControl

typedef struct PyIReplicationAgentCancelControlObject {
    PyObject_HEAD
    IReplicationAgentCancelControl* m_pIReplicationAgentCancelControl;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicationAgentCancelControlObject;

static PyObject*
PyIReplicationAgentCancelControlObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicationAgentCancelControlObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicationAgentCancelControl* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicationAgentCancelControl, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicationAgentCancelControl with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicationAgentCancelControlObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicationAgentCancelControl");
            return NULL;
        }
        self->m_pIReplicationAgentCancelControl = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicationAgentCancelControl");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicationAgentCancelControl");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicationAgentCancelControl* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicationAgentCancelControl, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicationAgentCancelControl");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicationAgentCancelControlObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicationAgentCancelControl");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicationAgentCancelControl = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicationAgentCancelControlObject_dealloc(PyIReplicationAgentCancelControlObject* self)
{
    if (self->m_pIReplicationAgentCancelControl)
        self->m_pIReplicationAgentCancelControl->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicationAgentCancelControl_GetpUnk(PyIReplicationAgentCancelControlObject* self)
{
    if (!self->m_pIReplicationAgentCancelControl)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicationAgentCancelControl->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicationAgentCancelControl to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicationAgentCancelControl_GetPointer(PyIReplicationAgentCancelControlObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicationAgentCancelControl);
}

static PyObject*
PyIReplicationAgentCancelControl_GetIID(PyIReplicationAgentCancelControlObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fe61bef1-7ae3-45c6-84de-a9d6019a4d77");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicationAgentCancelControl_GetHR(PyIReplicationAgentCancelControlObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicationAgentCancelControl_GetIgnoreFailures(PyIReplicationAgentCancelControlObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicationAgentCancelControl_SetIgnoreFailures(PyIReplicationAgentCancelControlObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicationAgentCancelControl_SupportsInterface(PyIReplicationAgentCancelControlObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicationAgentCancelControl->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicationAgentCancelControlMethod_putref_CancelTracker(PyIReplicationAgentCancelControlObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto ireplicationagentcancelcontrol_putref_canceltracker_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_ITrackCancel, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ireplicationagentcancelcontrol_putref_canceltracker_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicationAgentCancelControl->putref_CancelTracker(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicationAgentCancelControl->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicationAgentCancelControl) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicationAgentCancelControl.putref_CancelTracker() returned %ld", (long)hr);
        goto ireplicationagentcancelcontrol_putref_canceltracker_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicationagentcancelcontrol_putref_canceltracker_method_cleanup;

    ireplicationagentcancelcontrol_putref_canceltracker_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicationAgentCancelControl.putref_CancelTracker");
    return return_tuple;
}


PyMethodDef PyIReplicationAgentCancelControlMethods[] = {
    {"supports", (PyCFunction)PyIReplicationAgentCancelControl_SupportsInterface, METH_O, ""},
    {"putref_CancelTracker", (PyCFunction)IReplicationAgentCancelControlMethod_putref_CancelTracker, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicationAgentCancelControlGetSet[] = {
  {"_pUnk", (getter)PyIReplicationAgentCancelControl_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicationAgentCancelControl", NULL},
  {"_pointer", (getter)PyIReplicationAgentCancelControl_GetPointer, NULL, "Get memory address for IReplicationAgentCancelControl", NULL},
  {"_IID", (getter)PyIReplicationAgentCancelControl_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicationAgentCancelControl_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicationAgentCancelControl_GetIgnoreFailures, (setter)PyIReplicationAgentCancelControl_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicationAgentCancelControlObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicationAgentCancelControlObject",                          
                                              /* tp_name */
  sizeof(PyIReplicationAgentCancelControlObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicationAgentCancelControlObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicationAgentCancelControlMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicationAgentCancelControlGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicationAgentCancelControlObject_new,                      
                                              /* tp_new */
};

// Interface IGDSData2

typedef struct PyIGDSData2Object {
    PyObject_HEAD
    IGDSData2* m_pIGDSData2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGDSData2Object;

static PyObject*
PyIGDSData2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGDSData2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGDSData2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGDSData2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGDSData2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGDSData2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGDSData2");
            return NULL;
        }
        self->m_pIGDSData2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGDSData2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGDSData2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGDSData2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGDSData2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGDSData2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGDSData2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGDSData2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGDSData2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGDSData2Object_dealloc(PyIGDSData2Object* self)
{
    if (self->m_pIGDSData2)
        self->m_pIGDSData2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGDSData2_GetpUnk(PyIGDSData2Object* self)
{
    if (!self->m_pIGDSData2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGDSData2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGDSData2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGDSData2_GetPointer(PyIGDSData2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGDSData2);
}

static PyObject*
PyIGDSData2_GetIID(PyIGDSData2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "74a172d5-7d99-41e1-9840-415193b5f58c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGDSData2_GetHR(PyIGDSData2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGDSData2_GetIgnoreFailures(PyIGDSData2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGDSData2_SetIgnoreFailures(PyIGDSData2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGDSData2_SupportsInterface(PyIGDSData2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGDSData2Method_get_UploadID(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsUploadID;
    PyObject* pyvar_UploadID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for UploadID

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->get_UploadID(&bsUploadID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.get_UploadID() returned %ld", (long)hr);
        goto igdsdata2_get_uploadid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_UploadID = PyUnicode_FromWideChar(bsUploadID,::SysStringLen(bsUploadID));
    ::SysFreeString(bsUploadID);
    
    if (PyErr_Occurred())
      goto igdsdata2_get_uploadid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_UploadID);
    goto igdsdata2_get_uploadid_method_cleanup;

    igdsdata2_get_uploadid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_UploadID != Py_None)
        Py_XDECREF(pyvar_UploadID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.get_UploadID");
    return return_tuple;
}

static PyObject*
IGDSData2Method_put_UploadID(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsUploadID = 0;
    PyObject* pyvar_UploadID;
    PyObject* unicodeUploadID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_UploadID))
      goto igdsdata2_put_uploadid_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_UploadID))
        unicodeUploadID = PyUnicode_FromObject(pyvar_UploadID);
    else if (PyUnicode_Check(pyvar_UploadID))
    {
        unicodeUploadID = pyvar_UploadID;
        Py_INCREF(unicodeUploadID);
    }
    else if (pyvar_UploadID != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter UploadID at index 0");
    if (unicodeUploadID)
        bsUploadID = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeUploadID), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeUploadID));
    
    if (PyErr_Occurred())
      goto igdsdata2_put_uploadid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->put_UploadID(bsUploadID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.put_UploadID() returned %ld", (long)hr);
        goto igdsdata2_put_uploadid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for UploadID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata2_put_uploadid_method_cleanup;

    igdsdata2_put_uploadid_method_cleanup:
    self->m_HR = hr;
    if (bsUploadID)
        ::SysFreeString(bsUploadID);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.put_UploadID");
    return return_tuple;
}

static PyObject*
IGDSData2Method_get_Compressed(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_comp = VARIANT_FALSE;
    PyObject* pyvar_comp = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for comp

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->get_Compressed(&b_comp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.get_Compressed() returned %ld", (long)hr);
        goto igdsdata2_get_compressed_method_cleanup;
    }

    // Set up return values as needed
    pyvar_comp = ((b_comp == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igdsdata2_get_compressed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_comp);
    goto igdsdata2_get_compressed_method_cleanup;

    igdsdata2_get_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for comp
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.get_Compressed");
    return return_tuple;
}

static PyObject*
IGDSData2Method_put_Compressed(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_comp = VARIANT_FALSE;
    PyObject* pyvar_comp = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_comp))
      goto igdsdata2_put_compressed_method_cleanup;

    // Set up initial variable values as needed
    b_comp = ((PyObject_IsTrue(pyvar_comp) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igdsdata2_put_compressed_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->put_Compressed(b_comp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.put_Compressed() returned %ld", (long)hr);
        goto igdsdata2_put_compressed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for comp

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata2_put_compressed_method_cleanup;

    igdsdata2_put_compressed_method_cleanup:
    self->m_HR = hr;
    // No cleanup for comp
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.put_Compressed");
    return return_tuple;
}

static PyObject*
IGDSData2Method_get_TransportType(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGDSTransportType epTransport;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pTransport

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->get_TransportType(&epTransport);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.get_TransportType() returned %ld", (long)hr);
        goto igdsdata2_get_transporttype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTransport

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epTransport);
    goto igdsdata2_get_transporttype_method_cleanup;

    igdsdata2_get_transporttype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTransport
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.get_TransportType");
    return return_tuple;
}

static PyObject*
IGDSData2Method_put_TransportType(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGDSTransportType epTransport;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epTransport))
      goto igdsdata2_put_transporttype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pTransport

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->put_TransportType(epTransport);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.put_TransportType() returned %ld", (long)hr);
        goto igdsdata2_put_transporttype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTransport

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata2_put_transporttype_method_cleanup;

    igdsdata2_put_transporttype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTransport
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.put_TransportType");
    return return_tuple;
}

static PyObject*
IGDSData2Method_get_URL(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL;
    PyObject* pyvar_URL = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for URL

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->get_URL(&bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.get_URL() returned %ld", (long)hr);
        goto igdsdata2_get_url_method_cleanup;
    }

    // Set up return values as needed
    pyvar_URL = PyUnicode_FromWideChar(bsURL,::SysStringLen(bsURL));
    ::SysFreeString(bsURL);
    
    if (PyErr_Occurred())
      goto igdsdata2_get_url_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_URL);
    goto igdsdata2_get_url_method_cleanup;

    igdsdata2_get_url_method_cleanup:
    self->m_HR = hr;
    if (pyvar_URL != Py_None)
        Py_XDECREF(pyvar_URL);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.get_URL");
    return return_tuple;
}

static PyObject*
IGDSData2Method_put_URL(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsURL = 0;
    PyObject* pyvar_URL;
    PyObject* unicodeURL = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_URL))
      goto igdsdata2_put_url_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_URL))
        unicodeURL = PyUnicode_FromObject(pyvar_URL);
    else if (PyUnicode_Check(pyvar_URL))
    {
        unicodeURL = pyvar_URL;
        Py_INCREF(unicodeURL);
    }
    else if (pyvar_URL != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter URL at index 0");
    if (unicodeURL)
        bsURL = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeURL), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeURL));
    
    if (PyErr_Occurred())
      goto igdsdata2_put_url_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->put_URL(bsURL);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.put_URL() returned %ld", (long)hr);
        goto igdsdata2_put_url_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for URL

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata2_put_url_method_cleanup;

    igdsdata2_put_url_method_cleanup:
    self->m_HR = hr;
    if (bsURL)
        ::SysFreeString(bsURL);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.put_URL");
    return return_tuple;
}

static PyObject*
IGDSData2Method_get_EmbeddedData(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    SAFEARRAY* padata = NULL;
    PyObject* py_data = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for data

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->get_EmbeddedData(&padata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.get_EmbeddedData() returned %ld", (long)hr);
        goto igdsdata2_get_embeddeddata_method_cleanup;
    }

    // Set up return values as needed
    py_data = SAFEARRAYToPyObject(padata, VT_NULL);
    if (PyErr_Occurred())
      goto igdsdata2_get_embeddeddata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_data);
    goto igdsdata2_get_embeddeddata_method_cleanup;

    igdsdata2_get_embeddeddata_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_data);
    if(padata)
      SafeArrayDestroy(padata);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.get_EmbeddedData");
    return return_tuple;
}

static PyObject*
IGDSData2Method_put_EmbeddedData(PyIGDSData2Object* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'SAFEARRAY', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IGDSData2.put_EmbeddedData not implemented.");
    return NULL;
}

static PyObject*
IGDSData2Method_putref_ConnectionProperties(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipconnProps = NULL;
    PyObject* py_connProps;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_connProps))
      goto igdsdata2_putref_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_connProps, &IID_IPropertySet, (void**)&ipconnProps))
        PyErr_SetString(PyExc_TypeError, "Argument connProps (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto igdsdata2_putref_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->putref_ConnectionProperties(ipconnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.putref_ConnectionProperties() returned %ld", (long)hr);
        goto igdsdata2_putref_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for connProps

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igdsdata2_putref_connectionproperties_method_cleanup;

    igdsdata2_putref_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipconnProps)
      ipconnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.putref_ConnectionProperties");
    return return_tuple;
}

static PyObject*
IGDSData2Method_get_ConnectionProperties(PyIGDSData2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipconnProps = NULL;
    PyObject* py_connProps = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for connProps

    // Call method on actual COM interface
    hr = self->m_pIGDSData2->get_ConnectionProperties(&ipconnProps);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGDSData2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGDSData2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGDSData2.get_ConnectionProperties() returned %ld", (long)hr);
        goto igdsdata2_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_connProps);
    if (ipconnProps)
    {
        IUnknown* pUnk = NULL;
        ipconnProps->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_connProps = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_connProps)
    {
        if (py_connProps)
           Py_DECREF(py_connProps);
        py_connProps = Py_None;
        Py_INCREF(py_connProps);
    }
    if (PyErr_Occurred())
      goto igdsdata2_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_connProps);
    goto igdsdata2_get_connectionproperties_method_cleanup;

    igdsdata2_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_connProps);
    if (ipconnProps)
      ipconnProps->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGDSData2.get_ConnectionProperties");
    return return_tuple;
}


PyMethodDef PyIGDSData2Methods[] = {
    {"supports", (PyCFunction)PyIGDSData2_SupportsInterface, METH_O, ""},
    {"get_UploadID", (PyCFunction)IGDSData2Method_get_UploadID, METH_VARARGS, ""},
    {"put_UploadID", (PyCFunction)IGDSData2Method_put_UploadID, METH_VARARGS, ""},
    {"get_Compressed", (PyCFunction)IGDSData2Method_get_Compressed, METH_VARARGS, ""},
    {"put_Compressed", (PyCFunction)IGDSData2Method_put_Compressed, METH_VARARGS, ""},
    {"get_TransportType", (PyCFunction)IGDSData2Method_get_TransportType, METH_VARARGS, ""},
    {"put_TransportType", (PyCFunction)IGDSData2Method_put_TransportType, METH_VARARGS, ""},
    {"get_URL", (PyCFunction)IGDSData2Method_get_URL, METH_VARARGS, ""},
    {"put_URL", (PyCFunction)IGDSData2Method_put_URL, METH_VARARGS, ""},
    {"get_EmbeddedData", (PyCFunction)IGDSData2Method_get_EmbeddedData, METH_VARARGS, ""},
    {"put_EmbeddedData", (PyCFunction)IGDSData2Method_put_EmbeddedData, METH_VARARGS, ""},
    {"putref_ConnectionProperties", (PyCFunction)IGDSData2Method_putref_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)IGDSData2Method_get_ConnectionProperties, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGDSData2GetSet[] = {
  {"_pUnk", (getter)PyIGDSData2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGDSData2", NULL},
  {"_pointer", (getter)PyIGDSData2_GetPointer, NULL, "Get memory address for IGDSData2", NULL},
  {"_IID", (getter)PyIGDSData2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGDSData2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGDSData2_GetIgnoreFailures, (setter)PyIGDSData2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGDSData2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGDSData2Object",                          
                                              /* tp_name */
  sizeof(PyIGDSData2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGDSData2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGDSData2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGDSData2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGDSData2Object_new,                      
                                              /* tp_new */
};

// Interface IGeoDataServer2

typedef struct PyIGeoDataServer2Object {
    PyObject_HEAD
    IGeoDataServer2* m_pIGeoDataServer2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGeoDataServer2Object;

static PyObject*
PyIGeoDataServer2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGeoDataServer2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGeoDataServer2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGeoDataServer2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGeoDataServer2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGeoDataServer2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGeoDataServer2");
            return NULL;
        }
        self->m_pIGeoDataServer2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGeoDataServer2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGeoDataServer2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGeoDataServer2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGeoDataServer2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGeoDataServer2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGeoDataServer2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGeoDataServer2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGeoDataServer2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGeoDataServer2Object_dealloc(PyIGeoDataServer2Object* self)
{
    if (self->m_pIGeoDataServer2)
        self->m_pIGeoDataServer2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGeoDataServer2_GetpUnk(PyIGeoDataServer2Object* self)
{
    if (!self->m_pIGeoDataServer2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGeoDataServer2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGeoDataServer2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGeoDataServer2_GetPointer(PyIGeoDataServer2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGeoDataServer2);
}

static PyObject*
PyIGeoDataServer2_GetIID(PyIGeoDataServer2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5906a736-62ed-4fb6-b84f-191131dfab07");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGeoDataServer2_GetHR(PyIGeoDataServer2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGeoDataServer2_GetIgnoreFailures(PyIGeoDataServer2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGeoDataServer2_SetIgnoreFailures(PyIGeoDataServer2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGeoDataServer2_SupportsInterface(PyIGeoDataServer2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGeoDataServer2Method_ExpandReplicaDatasets2(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPReplicaDatasets* ipGPReplicaDatasets = NULL;
    PyObject* py_GPReplicaDatasets;
    IGPReplicaOptions* ipReplicaOptions = NULL;
    PyObject* py_ReplicaOptions;
    IGPReplicaDatasets* ipExpandGPReplicaDatasets = NULL;
    PyObject* py_ExpandGPReplicaDatasets = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_GPReplicaDatasets, &py_ReplicaOptions))
      goto igeodataserver2_expandreplicadatasets2_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_GPReplicaDatasets, &IID_IGPReplicaDatasets, (void**)&ipGPReplicaDatasets))
        PyErr_SetString(PyExc_TypeError, "Argument GPReplicaDatasets (position 0) is not IGPReplicaDatasets");
    
    if (PyErr_Occurred())
      goto igeodataserver2_expandreplicadatasets2_method_cleanup;
    
    if (!IFaceFromPyObject(py_ReplicaOptions, &IID_IGPReplicaOptions, (void**)&ipReplicaOptions))
        PyErr_SetString(PyExc_TypeError, "Argument ReplicaOptions (position 1) is not IGPReplicaOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver2_expandreplicadatasets2_method_cleanup;
    
    // No setup for ExpandGPReplicaDatasets

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ExpandReplicaDatasets2(ipGPReplicaDatasets, ipReplicaOptions, &ipExpandGPReplicaDatasets);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ExpandReplicaDatasets2() returned %ld", (long)hr);
        goto igeodataserver2_expandreplicadatasets2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for GPReplicaDatasets
    // No teardown for ReplicaOptions
    Py_XDECREF(py_ExpandGPReplicaDatasets);
    if (ipExpandGPReplicaDatasets)
    {
        IUnknown* pUnk = NULL;
        ipExpandGPReplicaDatasets->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ExpandGPReplicaDatasets = IUnknownToPythonIIDObject(pUnk, &IID_IGPReplicaDatasets);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ExpandGPReplicaDatasets)
    {
        if (py_ExpandGPReplicaDatasets)
           Py_DECREF(py_ExpandGPReplicaDatasets);
        py_ExpandGPReplicaDatasets = Py_None;
        Py_INCREF(py_ExpandGPReplicaDatasets);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_expandreplicadatasets2_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ExpandGPReplicaDatasets);
    goto igeodataserver2_expandreplicadatasets2_method_cleanup;

    igeodataserver2_expandreplicadatasets2_method_cleanup:
    self->m_HR = hr;
    if (ipGPReplicaDatasets)
      ipGPReplicaDatasets->Release();
    if (ipReplicaOptions)
      ipReplicaOptions->Release();
    Py_XDECREF(py_ExpandGPReplicaDatasets);
    if (ipExpandGPReplicaDatasets)
      ipExpandGPReplicaDatasets->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ExpandReplicaDatasets2");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_get_Replica(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGPReplica* ipGPReplica = NULL;
    PyObject* py_GPReplica = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ReplicaName))
      goto igeodataserver2_get_replica_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_get_replica_method_cleanup;
    
    // No setup for GPReplica

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->get_Replica(bsReplicaName, &ipGPReplica);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.get_Replica() returned %ld", (long)hr);
        goto igeodataserver2_get_replica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    Py_XDECREF(py_GPReplica);
    if (ipGPReplica)
    {
        IUnknown* pUnk = NULL;
        ipGPReplica->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_GPReplica = IUnknownToPythonIIDObject(pUnk, &IID_IGPReplica);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_GPReplica)
    {
        if (py_GPReplica)
           Py_DECREF(py_GPReplica);
        py_GPReplica = Py_None;
        Py_INCREF(py_GPReplica);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_get_replica_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_GPReplica);
    goto igeodataserver2_get_replica_method_cleanup;

    igeodataserver2_get_replica_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    Py_XDECREF(py_GPReplica);
    if (ipGPReplica)
      ipGPReplica->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.get_Replica");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_get_MaxRecordCount(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lmaxCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for maxCount

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->get_MaxRecordCount(&lmaxCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.get_MaxRecordCount() returned %ld", (long)hr);
        goto igeodataserver2_get_maxrecordcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for maxCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lmaxCount);
    goto igeodataserver2_get_maxrecordcount_method_cleanup;

    igeodataserver2_get_maxrecordcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for maxCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.get_MaxRecordCount");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_get_DataElements(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDEBrowseOptions* ippBrowseOptions = NULL;
    PyObject* py_pBrowseOptions;
    IDataElements* ipDataElements = NULL;
    PyObject* py_DataElements = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pBrowseOptions))
      goto igeodataserver2_get_dataelements_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pBrowseOptions, &IID_IDEBrowseOptions, (void**)&ippBrowseOptions))
        PyErr_SetString(PyExc_TypeError, "Argument pBrowseOptions (position 0) is not IDEBrowseOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver2_get_dataelements_method_cleanup;
    
    // No setup for DataElements

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->get_DataElements(ippBrowseOptions, &ipDataElements);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.get_DataElements() returned %ld", (long)hr);
        goto igeodataserver2_get_dataelements_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pBrowseOptions
    Py_XDECREF(py_DataElements);
    if (ipDataElements)
    {
        IUnknown* pUnk = NULL;
        ipDataElements->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_DataElements = IUnknownToPythonIIDObject(pUnk, &IID_IDataElements);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_DataElements)
    {
        if (py_DataElements)
           Py_DECREF(py_DataElements);
        py_DataElements = Py_None;
        Py_INCREF(py_DataElements);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_get_dataelements_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_DataElements);
    goto igeodataserver2_get_dataelements_method_cleanup;

    igeodataserver2_get_dataelements_method_cleanup:
    self->m_HR = hr;
    if (ippBrowseOptions)
      ippBrowseOptions->Release();
    Py_XDECREF(py_DataElements);
    if (ipDataElements)
      ipDataElements->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.get_DataElements");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_get_Versions(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPVersionInfos* ipversionInfos = NULL;
    PyObject* py_versionInfos = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for versionInfos

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->get_Versions(&ipversionInfos);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.get_Versions() returned %ld", (long)hr);
        goto igeodataserver2_get_versions_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_versionInfos);
    if (ipversionInfos)
    {
        IUnknown* pUnk = NULL;
        ipversionInfos->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_versionInfos = IUnknownToPythonIIDObject(pUnk, &IID_IGPVersionInfos);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_versionInfos)
    {
        if (py_versionInfos)
           Py_DECREF(py_versionInfos);
        py_versionInfos = Py_None;
        Py_INCREF(py_versionInfos);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_get_versions_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_versionInfos);
    goto igeodataserver2_get_versions_method_cleanup;

    igeodataserver2_get_versions_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_versionInfos);
    if (ipversionInfos)
      ipversionInfos->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.get_Versions");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_get_Replicas(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPReplicas* ipReplicas = NULL;
    PyObject* py_Replicas = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Replicas

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->get_Replicas(&ipReplicas);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.get_Replicas() returned %ld", (long)hr);
        goto igeodataserver2_get_replicas_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Replicas);
    if (ipReplicas)
    {
        IUnknown* pUnk = NULL;
        ipReplicas->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Replicas = IUnknownToPythonIIDObject(pUnk, &IID_IGPReplicas);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Replicas)
    {
        if (py_Replicas)
           Py_DECREF(py_Replicas);
        py_Replicas = Py_None;
        Py_INCREF(py_Replicas);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_get_replicas_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Replicas);
    goto igeodataserver2_get_replicas_method_cleanup;

    igeodataserver2_get_replicas_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Replicas);
    if (ipReplicas)
      ipReplicas->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.get_Replicas");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_get_DefaultWorkingVersion(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDefaultWorkingVersion;
    PyObject* pyvar_DefaultWorkingVersion = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for DefaultWorkingVersion

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->get_DefaultWorkingVersion(&bsDefaultWorkingVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.get_DefaultWorkingVersion() returned %ld", (long)hr);
        goto igeodataserver2_get_defaultworkingversion_method_cleanup;
    }

    // Set up return values as needed
    pyvar_DefaultWorkingVersion = PyUnicode_FromWideChar(bsDefaultWorkingVersion,::SysStringLen(bsDefaultWorkingVersion));
    ::SysFreeString(bsDefaultWorkingVersion);
    
    if (PyErr_Occurred())
      goto igeodataserver2_get_defaultworkingversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_DefaultWorkingVersion);
    goto igeodataserver2_get_defaultworkingversion_method_cleanup;

    igeodataserver2_get_defaultworkingversion_method_cleanup:
    self->m_HR = hr;
    if (pyvar_DefaultWorkingVersion != Py_None)
        Py_XDECREF(pyvar_DefaultWorkingVersion);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.get_DefaultWorkingVersion");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_get_WrappedWorkspaceType(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriWorkspaceType ewsType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for wsType

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->get_WrappedWorkspaceType(&ewsType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.get_WrappedWorkspaceType() returned %ld", (long)hr);
        goto igeodataserver2_get_wrappedworkspacetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for wsType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)ewsType);
    goto igeodataserver2_get_wrappedworkspacetype_method_cleanup;

    igeodataserver2_get_wrappedworkspacetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for wsType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.get_WrappedWorkspaceType");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ExtractData(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    IGPReplicaDescription* ipreplicaDesc = NULL;
    PyObject* py_replicaDesc;
    IGDSExportOptions* ipoptions = NULL;
    PyObject* py_options;
    esriGDSTransportType eTransportType;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOi", &pyvar_versionName, &py_replicaDesc, &py_options, (int *)&eTransportType))
      goto igeodataserver2_extractdata_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_replicaDesc, &IID_IGPReplicaDescription, (void**)&ipreplicaDesc))
        PyErr_SetString(PyExc_TypeError, "Argument replicaDesc (position 1) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto igeodataserver2_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_options, &IID_IGDSExportOptions, (void**)&ipoptions))
        PyErr_SetString(PyExc_TypeError, "Argument options (position 2) is not IGDSExportOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver2_extractdata_method_cleanup;
    
    // No setup for TransportType
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ExtractData(bsversionName, ipreplicaDesc, ipoptions, eTransportType, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ExtractData() returned %ld", (long)hr);
        goto igeodataserver2_extractdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for replicaDesc
    // No teardown for options
    // No teardown for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_extractdata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver2_extractdata_method_cleanup;

    igeodataserver2_extractdata_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (ipreplicaDesc)
      ipreplicaDesc->Release();
    if (ipoptions)
      ipoptions->Release();
    // No cleanup for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ExtractData");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_CreateReplica(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsparentVersion = 0;
    PyObject* pyvar_parentVersion;
    PyObject* unicodeparentVersion = NULL;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGPReplicaDescription* ipreplicaDesc = NULL;
    PyObject* py_replicaDesc;
    IGPReplicaOptions* iprepOptions = NULL;
    PyObject* py_repOptions;
    IGDSExportOptions* ipexportOptions = NULL;
    PyObject* py_exportOptions;
    esriGDSTransportType eTransportType;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOOi", &pyvar_parentVersion, &pyvar_ReplicaName, &py_replicaDesc, &py_repOptions, &py_exportOptions, (int *)&eTransportType))
      goto igeodataserver2_createreplica_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_parentVersion))
        unicodeparentVersion = PyUnicode_FromObject(pyvar_parentVersion);
    else if (PyUnicode_Check(pyvar_parentVersion))
    {
        unicodeparentVersion = pyvar_parentVersion;
        Py_INCREF(unicodeparentVersion);
    }
    else if (pyvar_parentVersion != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter parentVersion at index 0");
    if (unicodeparentVersion)
        bsparentVersion = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeparentVersion), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeparentVersion));
    
    if (PyErr_Occurred())
      goto igeodataserver2_createreplica_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 1");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_replicaDesc, &IID_IGPReplicaDescription, (void**)&ipreplicaDesc))
        PyErr_SetString(PyExc_TypeError, "Argument replicaDesc (position 2) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto igeodataserver2_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_repOptions, &IID_IGPReplicaOptions, (void**)&iprepOptions))
        PyErr_SetString(PyExc_TypeError, "Argument repOptions (position 3) is not IGPReplicaOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver2_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_exportOptions, &IID_IGDSExportOptions, (void**)&ipexportOptions))
        PyErr_SetString(PyExc_TypeError, "Argument exportOptions (position 4) is not IGDSExportOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver2_createreplica_method_cleanup;
    
    // No setup for TransportType
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->CreateReplica(bsparentVersion, bsReplicaName, ipreplicaDesc, iprepOptions, ipexportOptions, eTransportType, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.CreateReplica() returned %ld", (long)hr);
        goto igeodataserver2_createreplica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentVersion
    // No teardown for ReplicaName
    // No teardown for replicaDesc
    // No teardown for repOptions
    // No teardown for exportOptions
    // No teardown for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_createreplica_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver2_createreplica_method_cleanup;

    igeodataserver2_createreplica_method_cleanup:
    self->m_HR = hr;
    if (bsparentVersion)
        ::SysFreeString(bsparentVersion);
    
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipreplicaDesc)
      ipreplicaDesc->Release();
    if (iprepOptions)
      iprepOptions->Release();
    if (ipexportOptions)
      ipexportOptions->Release();
    // No cleanup for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.CreateReplica");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ExpandReplicaDatasets(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPReplicaDatasets* iprepDatasets = NULL;
    PyObject* py_repDatasets;
    IGPReplicaDatasets* ipexpandedRepDatasets = NULL;
    PyObject* py_expandedRepDatasets = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_repDatasets))
      goto igeodataserver2_expandreplicadatasets_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_repDatasets, &IID_IGPReplicaDatasets, (void**)&iprepDatasets))
        PyErr_SetString(PyExc_TypeError, "Argument repDatasets (position 0) is not IGPReplicaDatasets");
    
    if (PyErr_Occurred())
      goto igeodataserver2_expandreplicadatasets_method_cleanup;
    
    // No setup for expandedRepDatasets

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ExpandReplicaDatasets(iprepDatasets, &ipexpandedRepDatasets);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ExpandReplicaDatasets() returned %ld", (long)hr);
        goto igeodataserver2_expandreplicadatasets_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for repDatasets
    Py_XDECREF(py_expandedRepDatasets);
    if (ipexpandedRepDatasets)
    {
        IUnknown* pUnk = NULL;
        ipexpandedRepDatasets->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_expandedRepDatasets = IUnknownToPythonIIDObject(pUnk, &IID_IGPReplicaDatasets);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_expandedRepDatasets)
    {
        if (py_expandedRepDatasets)
           Py_DECREF(py_expandedRepDatasets);
        py_expandedRepDatasets = Py_None;
        Py_INCREF(py_expandedRepDatasets);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_expandreplicadatasets_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_expandedRepDatasets);
    goto igeodataserver2_expandreplicadatasets_method_cleanup;

    igeodataserver2_expandreplicadatasets_method_cleanup:
    self->m_HR = hr;
    if (iprepDatasets)
      iprepDatasets->Release();
    Py_XDECREF(py_expandedRepDatasets);
    if (ipexpandedRepDatasets)
      ipexpandedRepDatasets->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ExpandReplicaDatasets");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ImportData(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGDSData* ippData = NULL;
    PyObject* py_pData;
    esriGDSImportFormat efmt;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &py_pData, (int *)&efmt))
      goto igeodataserver2_importdata_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pData, &IID_IGDSData, (void**)&ippData))
        PyErr_SetString(PyExc_TypeError, "Argument pData (position 0) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver2_importdata_method_cleanup;
    
    // No setup for fmt

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ImportData(ippData, efmt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ImportData() returned %ld", (long)hr);
        goto igeodataserver2_importdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pData
    // No teardown for fmt

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserver2_importdata_method_cleanup;

    igeodataserver2_importdata_method_cleanup:
    self->m_HR = hr;
    if (ippData)
      ippData->Release();
    // No cleanup for fmt
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ImportData");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ExportReplicaDataChanges(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGDSExportOptions* ipoptions = NULL;
    PyObject* py_options;
    esriGDSTransportType eTransportType;
    esriExportGenerationsOption egenerationsToExport;
    VARIANT_BOOL b_switchRole = VARIANT_FALSE;
    PyObject* pyvar_switchRole = NULL;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOiiO", &pyvar_ReplicaName, &py_options, (int *)&eTransportType, (int *)&egenerationsToExport, &pyvar_switchRole))
      goto igeodataserver2_exportreplicadatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_exportreplicadatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_options, &IID_IGDSExportOptions, (void**)&ipoptions))
        PyErr_SetString(PyExc_TypeError, "Argument options (position 1) is not IGDSExportOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver2_exportreplicadatachanges_method_cleanup;
    
    // No setup for TransportType
    // No setup for generationsToExport
    b_switchRole = ((PyObject_IsTrue(pyvar_switchRole) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igeodataserver2_exportreplicadatachanges_method_cleanup;
    
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ExportReplicaDataChanges(bsReplicaName, ipoptions, eTransportType, egenerationsToExport, b_switchRole, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ExportReplicaDataChanges() returned %ld", (long)hr);
        goto igeodataserver2_exportreplicadatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    // No teardown for options
    // No teardown for TransportType
    // No teardown for generationsToExport
    // No teardown for switchRole
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_exportreplicadatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver2_exportreplicadatachanges_method_cleanup;

    igeodataserver2_exportreplicadatachanges_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipoptions)
      ipoptions->Release();
    // No cleanup for TransportType
    // No cleanup for generationsToExport
    // No cleanup for switchRole
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ExportReplicaDataChanges");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ReExportReplicaDataChanges(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGDSExportOptions* ipoptions = NULL;
    PyObject* py_options;
    esriGDSTransportType eTransportType;
    esriReExportGenerationsOption egensToExport;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOii", &pyvar_ReplicaName, &py_options, (int *)&eTransportType, (int *)&egensToExport))
      goto igeodataserver2_reexportreplicadatachanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_reexportreplicadatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_options, &IID_IGDSExportOptions, (void**)&ipoptions))
        PyErr_SetString(PyExc_TypeError, "Argument options (position 1) is not IGDSExportOptions");
    
    if (PyErr_Occurred())
      goto igeodataserver2_reexportreplicadatachanges_method_cleanup;
    
    // No setup for TransportType
    // No setup for gensToExport
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ReExportReplicaDataChanges(bsReplicaName, ipoptions, eTransportType, egensToExport, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ReExportReplicaDataChanges() returned %ld", (long)hr);
        goto igeodataserver2_reexportreplicadatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    // No teardown for options
    // No teardown for TransportType
    // No teardown for gensToExport
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_reexportreplicadatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver2_reexportreplicadatachanges_method_cleanup;

    igeodataserver2_reexportreplicadatachanges_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipoptions)
      ipoptions->Release();
    // No cleanup for TransportType
    // No cleanup for gensToExport
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ReExportReplicaDataChanges");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ImportReplicaDataChanges(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGDSReplicaImportSource esourceType;
    esriReplicaReconcilePolicyType ereconcilePolicy;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    IGDSData* ipdata = NULL;
    PyObject* py_data;
    VARIANT_BOOL b_conflictsFound = VARIANT_FALSE;
    PyObject* pyvar_conflictsFound = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iiOO", (int *)&esourceType, (int *)&ereconcilePolicy, &pyvar_columnLevel, &py_data))
      goto igeodataserver2_importreplicadatachanges_method_cleanup;

    // Set up initial variable values as needed
    // No setup for sourceType
    // No setup for reconcilePolicy
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto igeodataserver2_importreplicadatachanges_method_cleanup;
    
    if (!IFaceFromPyObject(py_data, &IID_IGDSData, (void**)&ipdata))
        PyErr_SetString(PyExc_TypeError, "Argument data (position 3) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver2_importreplicadatachanges_method_cleanup;
    
    // No setup for conflictsFound

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ImportReplicaDataChanges(esourceType, ereconcilePolicy, b_columnLevel, ipdata, &b_conflictsFound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ImportReplicaDataChanges() returned %ld", (long)hr);
        goto igeodataserver2_importreplicadatachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for sourceType
    // No teardown for reconcilePolicy
    // No teardown for columnLevel
    // No teardown for data
    pyvar_conflictsFound = ((b_conflictsFound == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igeodataserver2_importreplicadatachanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflictsFound);
    goto igeodataserver2_importreplicadatachanges_method_cleanup;

    igeodataserver2_importreplicadatachanges_method_cleanup:
    self->m_HR = hr;
    // No cleanup for sourceType
    // No cleanup for reconcilePolicy
    // No cleanup for columnLevel
    if (ipdata)
      ipdata->Release();
    // No cleanup for conflictsFound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ImportReplicaDataChanges");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ExportAcknowledgement(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    esriGDSTransportType eTransportType;
    IGDSData* ipresult = NULL;
    PyObject* py_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_ReplicaName, (int *)&eTransportType))
      goto igeodataserver2_exportacknowledgement_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_exportacknowledgement_method_cleanup;
    
    // No setup for TransportType
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ExportAcknowledgement(bsReplicaName, eTransportType, &ipresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ExportAcknowledgement() returned %ld", (long)hr);
        goto igeodataserver2_exportacknowledgement_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    // No teardown for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
    {
        IUnknown* pUnk = NULL;
        ipresult->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_result = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_result)
    {
        if (py_result)
           Py_DECREF(py_result);
        py_result = Py_None;
        Py_INCREF(py_result);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_exportacknowledgement_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_result);
    goto igeodataserver2_exportacknowledgement_method_cleanup;

    igeodataserver2_exportacknowledgement_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    // No cleanup for TransportType
    Py_XDECREF(py_result);
    if (ipresult)
      ipresult->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ExportAcknowledgement");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ImportAcknowledgement(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGDSData* ipdata = NULL;
    PyObject* py_data;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_data))
      goto igeodataserver2_importacknowledgement_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_data, &IID_IGDSData, (void**)&ipdata))
        PyErr_SetString(PyExc_TypeError, "Argument data (position 0) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver2_importacknowledgement_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ImportAcknowledgement(ipdata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ImportAcknowledgement() returned %ld", (long)hr);
        goto igeodataserver2_importacknowledgement_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for data

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserver2_importacknowledgement_method_cleanup;

    igeodataserver2_importacknowledgement_method_cleanup:
    self->m_HR = hr;
    if (ipdata)
      ipdata->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ImportAcknowledgement");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_UnregisterReplica(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ReplicaName))
      goto igeodataserver2_unregisterreplica_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_unregisterreplica_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->UnregisterReplica(bsReplicaName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.UnregisterReplica() returned %ld", (long)hr);
        goto igeodataserver2_unregisterreplica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserver2_unregisterreplica_method_cleanup;

    igeodataserver2_unregisterreplica_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.UnregisterReplica");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_TableSearch(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    BSTR bstableName = 0;
    PyObject* pyvar_tableName;
    PyObject* unicodetableName = NULL;
    IQueryFilter* ipqueryFilter = NULL;
    PyObject* py_queryFilter;
    IResultPortionInfo* ipqueryRange = NULL;
    PyObject* py_queryRange;
    IGDSQueryResultPortion* ipresultPortion = NULL;
    PyObject* py_resultPortion = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_versionName, &pyvar_tableName, &py_queryFilter, &py_queryRange))
      goto igeodataserver2_tablesearch_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_tablesearch_method_cleanup;
    
    if (PyString_Check(pyvar_tableName))
        unicodetableName = PyUnicode_FromObject(pyvar_tableName);
    else if (PyUnicode_Check(pyvar_tableName))
    {
        unicodetableName = pyvar_tableName;
        Py_INCREF(unicodetableName);
    }
    else if (pyvar_tableName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter tableName at index 1");
    if (unicodetableName)
        bstableName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetableName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetableName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_tablesearch_method_cleanup;
    
    if (!IFaceFromPyObject(py_queryFilter, &IID_IQueryFilter, (void**)&ipqueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument queryFilter (position 2) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto igeodataserver2_tablesearch_method_cleanup;
    
    if (!IFaceFromPyObject(py_queryRange, &IID_IResultPortionInfo, (void**)&ipqueryRange))
        PyErr_SetString(PyExc_TypeError, "Argument queryRange (position 3) is not IResultPortionInfo");
    
    if (PyErr_Occurred())
      goto igeodataserver2_tablesearch_method_cleanup;
    
    // No setup for resultPortion

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->TableSearch(bsversionName, bstableName, ipqueryFilter, ipqueryRange, &ipresultPortion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.TableSearch() returned %ld", (long)hr);
        goto igeodataserver2_tablesearch_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for tableName
    // No teardown for queryFilter
    // No teardown for queryRange
    Py_XDECREF(py_resultPortion);
    if (ipresultPortion)
    {
        IUnknown* pUnk = NULL;
        ipresultPortion->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_resultPortion = IUnknownToPythonIIDObject(pUnk, &IID_IGDSQueryResultPortion);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_resultPortion)
    {
        if (py_resultPortion)
           Py_DECREF(py_resultPortion);
        py_resultPortion = Py_None;
        Py_INCREF(py_resultPortion);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_tablesearch_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_resultPortion);
    goto igeodataserver2_tablesearch_method_cleanup;

    igeodataserver2_tablesearch_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (bstableName)
        ::SysFreeString(bstableName);
    
    if (ipqueryFilter)
      ipqueryFilter->Release();
    if (ipqueryRange)
      ipqueryRange->Release();
    Py_XDECREF(py_resultPortion);
    if (ipresultPortion)
      ipresultPortion->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.TableSearch");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_GetNextResultPortion(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IResultPortionInfo* ipdesiredRange = NULL;
    PyObject* py_desiredRange;
    IGDSQueryResultPortion* ipresultPortion = NULL;
    PyObject* py_resultPortion = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_desiredRange))
      goto igeodataserver2_getnextresultportion_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_desiredRange, &IID_IResultPortionInfo, (void**)&ipdesiredRange))
        PyErr_SetString(PyExc_TypeError, "Argument desiredRange (position 0) is not IResultPortionInfo");
    
    if (PyErr_Occurred())
      goto igeodataserver2_getnextresultportion_method_cleanup;
    
    // No setup for resultPortion

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->GetNextResultPortion(ipdesiredRange, &ipresultPortion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.GetNextResultPortion() returned %ld", (long)hr);
        goto igeodataserver2_getnextresultportion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for desiredRange
    Py_XDECREF(py_resultPortion);
    if (ipresultPortion)
    {
        IUnknown* pUnk = NULL;
        ipresultPortion->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_resultPortion = IUnknownToPythonIIDObject(pUnk, &IID_IGDSQueryResultPortion);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_resultPortion)
    {
        if (py_resultPortion)
           Py_DECREF(py_resultPortion);
        py_resultPortion = Py_None;
        Py_INCREF(py_resultPortion);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_getnextresultportion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_resultPortion);
    goto igeodataserver2_getnextresultportion_method_cleanup;

    igeodataserver2_getnextresultportion_method_cleanup:
    self->m_HR = hr;
    if (ipdesiredRange)
      ipdesiredRange->Release();
    Py_XDECREF(py_resultPortion);
    if (ipresultPortion)
      ipresultPortion->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.GetNextResultPortion");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ExportReplicaSchema(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    esriGDSTransportType eTransportType;
    IGDSData* ipreplicaSchemaDoc = NULL;
    PyObject* py_replicaSchemaDoc = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_ReplicaName, (int *)&eTransportType))
      goto igeodataserver2_exportreplicaschema_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 0");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto igeodataserver2_exportreplicaschema_method_cleanup;
    
    // No setup for TransportType
    // No setup for replicaSchemaDoc

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ExportReplicaSchema(bsReplicaName, eTransportType, &ipreplicaSchemaDoc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ExportReplicaSchema() returned %ld", (long)hr);
        goto igeodataserver2_exportreplicaschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReplicaName
    // No teardown for TransportType
    Py_XDECREF(py_replicaSchemaDoc);
    if (ipreplicaSchemaDoc)
    {
        IUnknown* pUnk = NULL;
        ipreplicaSchemaDoc->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_replicaSchemaDoc = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_replicaSchemaDoc)
    {
        if (py_replicaSchemaDoc)
           Py_DECREF(py_replicaSchemaDoc);
        py_replicaSchemaDoc = Py_None;
        Py_INCREF(py_replicaSchemaDoc);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_exportreplicaschema_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_replicaSchemaDoc);
    goto igeodataserver2_exportreplicaschema_method_cleanup;

    igeodataserver2_exportreplicaschema_method_cleanup:
    self->m_HR = hr;
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    // No cleanup for TransportType
    Py_XDECREF(py_replicaSchemaDoc);
    if (ipreplicaSchemaDoc)
      ipreplicaSchemaDoc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ExportReplicaSchema");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_CompareReplicaSchema(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGDSData* iprelativeReplicaSchemaDoc = NULL;
    PyObject* py_relativeReplicaSchemaDoc;
    esriGDSTransportType eTransportType;
    IGDSData* ipschemaChangesDoc = NULL;
    PyObject* py_schemaChangesDoc = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &py_relativeReplicaSchemaDoc, (int *)&eTransportType))
      goto igeodataserver2_comparereplicaschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_relativeReplicaSchemaDoc, &IID_IGDSData, (void**)&iprelativeReplicaSchemaDoc))
        PyErr_SetString(PyExc_TypeError, "Argument relativeReplicaSchemaDoc (position 0) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver2_comparereplicaschema_method_cleanup;
    
    // No setup for TransportType
    // No setup for schemaChangesDoc

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->CompareReplicaSchema(iprelativeReplicaSchemaDoc, eTransportType, &ipschemaChangesDoc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.CompareReplicaSchema() returned %ld", (long)hr);
        goto igeodataserver2_comparereplicaschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for relativeReplicaSchemaDoc
    // No teardown for TransportType
    Py_XDECREF(py_schemaChangesDoc);
    if (ipschemaChangesDoc)
    {
        IUnknown* pUnk = NULL;
        ipschemaChangesDoc->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_schemaChangesDoc = IUnknownToPythonIIDObject(pUnk, &IID_IGDSData);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_schemaChangesDoc)
    {
        if (py_schemaChangesDoc)
           Py_DECREF(py_schemaChangesDoc);
        py_schemaChangesDoc = Py_None;
        Py_INCREF(py_schemaChangesDoc);
    }
    if (PyErr_Occurred())
      goto igeodataserver2_comparereplicaschema_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_schemaChangesDoc);
    goto igeodataserver2_comparereplicaschema_method_cleanup;

    igeodataserver2_comparereplicaschema_method_cleanup:
    self->m_HR = hr;
    if (iprelativeReplicaSchemaDoc)
      iprelativeReplicaSchemaDoc->Release();
    // No cleanup for TransportType
    Py_XDECREF(py_schemaChangesDoc);
    if (ipschemaChangesDoc)
      ipschemaChangesDoc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.CompareReplicaSchema");
    return return_tuple;
}

static PyObject*
IGeoDataServer2Method_ImportReplicaSchemaChanges(PyIGeoDataServer2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGDSData* ipschemaChangesDoc = NULL;
    PyObject* py_schemaChangesDoc;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_schemaChangesDoc))
      goto igeodataserver2_importreplicaschemachanges_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_schemaChangesDoc, &IID_IGDSData, (void**)&ipschemaChangesDoc))
        PyErr_SetString(PyExc_TypeError, "Argument schemaChangesDoc (position 0) is not IGDSData");
    
    if (PyErr_Occurred())
      goto igeodataserver2_importreplicaschemachanges_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGeoDataServer2->ImportReplicaSchemaChanges(ipschemaChangesDoc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGeoDataServer2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGeoDataServer2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGeoDataServer2.ImportReplicaSchemaChanges() returned %ld", (long)hr);
        goto igeodataserver2_importreplicaschemachanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for schemaChangesDoc

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igeodataserver2_importreplicaschemachanges_method_cleanup;

    igeodataserver2_importreplicaschemachanges_method_cleanup:
    self->m_HR = hr;
    if (ipschemaChangesDoc)
      ipschemaChangesDoc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGeoDataServer2.ImportReplicaSchemaChanges");
    return return_tuple;
}


PyMethodDef PyIGeoDataServer2Methods[] = {
    {"supports", (PyCFunction)PyIGeoDataServer2_SupportsInterface, METH_O, ""},
    {"ExpandReplicaDatasets2", (PyCFunction)IGeoDataServer2Method_ExpandReplicaDatasets2, METH_VARARGS, ""},
    {"get_Replica", (PyCFunction)IGeoDataServer2Method_get_Replica, METH_VARARGS, ""},
    {"get_MaxRecordCount", (PyCFunction)IGeoDataServer2Method_get_MaxRecordCount, METH_VARARGS, ""},
    {"get_DataElements", (PyCFunction)IGeoDataServer2Method_get_DataElements, METH_VARARGS, ""},
    {"get_Versions", (PyCFunction)IGeoDataServer2Method_get_Versions, METH_VARARGS, ""},
    {"get_Replicas", (PyCFunction)IGeoDataServer2Method_get_Replicas, METH_VARARGS, ""},
    {"get_DefaultWorkingVersion", (PyCFunction)IGeoDataServer2Method_get_DefaultWorkingVersion, METH_VARARGS, ""},
    {"get_WrappedWorkspaceType", (PyCFunction)IGeoDataServer2Method_get_WrappedWorkspaceType, METH_VARARGS, ""},
    {"ExtractData", (PyCFunction)IGeoDataServer2Method_ExtractData, METH_VARARGS, ""},
    {"CreateReplica", (PyCFunction)IGeoDataServer2Method_CreateReplica, METH_VARARGS, ""},
    {"ExpandReplicaDatasets", (PyCFunction)IGeoDataServer2Method_ExpandReplicaDatasets, METH_VARARGS, ""},
    {"ImportData", (PyCFunction)IGeoDataServer2Method_ImportData, METH_VARARGS, ""},
    {"ExportReplicaDataChanges", (PyCFunction)IGeoDataServer2Method_ExportReplicaDataChanges, METH_VARARGS, ""},
    {"ReExportReplicaDataChanges", (PyCFunction)IGeoDataServer2Method_ReExportReplicaDataChanges, METH_VARARGS, ""},
    {"ImportReplicaDataChanges", (PyCFunction)IGeoDataServer2Method_ImportReplicaDataChanges, METH_VARARGS, ""},
    {"ExportAcknowledgement", (PyCFunction)IGeoDataServer2Method_ExportAcknowledgement, METH_VARARGS, ""},
    {"ImportAcknowledgement", (PyCFunction)IGeoDataServer2Method_ImportAcknowledgement, METH_VARARGS, ""},
    {"UnregisterReplica", (PyCFunction)IGeoDataServer2Method_UnregisterReplica, METH_VARARGS, ""},
    {"TableSearch", (PyCFunction)IGeoDataServer2Method_TableSearch, METH_VARARGS, ""},
    {"GetNextResultPortion", (PyCFunction)IGeoDataServer2Method_GetNextResultPortion, METH_VARARGS, ""},
    {"ExportReplicaSchema", (PyCFunction)IGeoDataServer2Method_ExportReplicaSchema, METH_VARARGS, ""},
    {"CompareReplicaSchema", (PyCFunction)IGeoDataServer2Method_CompareReplicaSchema, METH_VARARGS, ""},
    {"ImportReplicaSchemaChanges", (PyCFunction)IGeoDataServer2Method_ImportReplicaSchemaChanges, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGeoDataServer2GetSet[] = {
  {"_pUnk", (getter)PyIGeoDataServer2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGeoDataServer2", NULL},
  {"_pointer", (getter)PyIGeoDataServer2_GetPointer, NULL, "Get memory address for IGeoDataServer2", NULL},
  {"_IID", (getter)PyIGeoDataServer2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGeoDataServer2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGeoDataServer2_GetIgnoreFailures, (setter)PyIGeoDataServer2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGeoDataServer2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IGeoDataServer2Object",                          
                                              /* tp_name */
  sizeof(PyIGeoDataServer2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGeoDataServer2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGeoDataServer2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGeoDataServer2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGeoDataServer2Object_new,                      
                                              /* tp_new */
};

// Interface IReplicationAgent2

typedef struct PyIReplicationAgent2Object {
    PyObject_HEAD
    IReplicationAgent2* m_pIReplicationAgent2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIReplicationAgent2Object;

static PyObject*
PyIReplicationAgent2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIReplicationAgent2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IReplicationAgent2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IReplicationAgent2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IReplicationAgent2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIReplicationAgent2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicationAgent2");
            return NULL;
        }
        self->m_pIReplicationAgent2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IReplicationAgent2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IReplicationAgent2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IReplicationAgent2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IReplicationAgent2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IReplicationAgent2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIReplicationAgent2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IReplicationAgent2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIReplicationAgent2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIReplicationAgent2Object_dealloc(PyIReplicationAgent2Object* self)
{
    if (self->m_pIReplicationAgent2)
        self->m_pIReplicationAgent2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIReplicationAgent2_GetpUnk(PyIReplicationAgent2Object* self)
{
    if (!self->m_pIReplicationAgent2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIReplicationAgent2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IReplicationAgent2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIReplicationAgent2_GetPointer(PyIReplicationAgent2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIReplicationAgent2);
}

static PyObject*
PyIReplicationAgent2_GetIID(PyIReplicationAgent2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fc1d0cbb-38ee-44b7-be6e-80049e06f855");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIReplicationAgent2_GetHR(PyIReplicationAgent2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIReplicationAgent2_GetIgnoreFailures(PyIReplicationAgent2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIReplicationAgent2_SetIgnoreFailures(PyIReplicationAgent2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIReplicationAgent2_SupportsInterface(PyIReplicationAgent2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIReplicationAgent2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IReplicationAgent2Method_CreateReplica2(PyIReplicationAgent2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    IGeoDataServer* ipsrcGDS = NULL;
    PyObject* py_srcGDS;
    IGeoDataServer* ipdestGDS = NULL;
    PyObject* py_destGDS;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGPReplicaDescription* ipdesc = NULL;
    PyObject* py_desc;
    IGPReplicaOptions* iprepOptions = NULL;
    PyObject* py_repOptions;
    BSTR bslayersFolder = 0;
    PyObject* pyvar_layersFolder;
    PyObject* unicodelayersFolder = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOOOO", &pyvar_versionName, &py_srcGDS, &py_destGDS, &pyvar_ReplicaName, &py_desc, &py_repOptions, &pyvar_layersFolder))
      goto ireplicationagent2_createreplica2_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica2_method_cleanup;
    
    if (!IFaceFromPyObject(py_srcGDS, &IID_IGeoDataServer, (void**)&ipsrcGDS))
        PyErr_SetString(PyExc_TypeError, "Argument srcGDS (position 1) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica2_method_cleanup;
    
    if (!IFaceFromPyObject(py_destGDS, &IID_IGeoDataServer, (void**)&ipdestGDS))
        PyErr_SetString(PyExc_TypeError, "Argument destGDS (position 2) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica2_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 3");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica2_method_cleanup;
    
    if (!IFaceFromPyObject(py_desc, &IID_IGPReplicaDescription, (void**)&ipdesc))
        PyErr_SetString(PyExc_TypeError, "Argument desc (position 4) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica2_method_cleanup;
    
    if (!IFaceFromPyObject(py_repOptions, &IID_IGPReplicaOptions, (void**)&iprepOptions))
        PyErr_SetString(PyExc_TypeError, "Argument repOptions (position 5) is not IGPReplicaOptions");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica2_method_cleanup;
    
    if (PyString_Check(pyvar_layersFolder))
        unicodelayersFolder = PyUnicode_FromObject(pyvar_layersFolder);
    else if (PyUnicode_Check(pyvar_layersFolder))
    {
        unicodelayersFolder = pyvar_layersFolder;
        Py_INCREF(unicodelayersFolder);
    }
    else if (pyvar_layersFolder != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter layersFolder at index 6");
    if (unicodelayersFolder)
        bslayersFolder = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodelayersFolder), 
                                            (UINT)PyUnicode_GET_SIZE(unicodelayersFolder));
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicationAgent2->CreateReplica2(bsversionName, ipsrcGDS, ipdestGDS, bsReplicaName, ipdesc, iprepOptions, bslayersFolder);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicationAgent2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicationAgent2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicationAgent2.CreateReplica2() returned %ld", (long)hr);
        goto ireplicationagent2_createreplica2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for srcGDS
    // No teardown for destGDS
    // No teardown for ReplicaName
    // No teardown for desc
    // No teardown for repOptions
    // No teardown for layersFolder

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicationagent2_createreplica2_method_cleanup;

    ireplicationagent2_createreplica2_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (ipsrcGDS)
      ipsrcGDS->Release();
    if (ipdestGDS)
      ipdestGDS->Release();
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipdesc)
      ipdesc->Release();
    if (iprepOptions)
      iprepOptions->Release();
    if (bslayersFolder)
        ::SysFreeString(bslayersFolder);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicationAgent2.CreateReplica2");
    return return_tuple;
}

static PyObject*
IReplicationAgent2Method_CreateReplica(PyIReplicationAgent2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    IGeoDataServer* ipsrcGDS = NULL;
    PyObject* py_srcGDS;
    IGeoDataServer* ipdestGDS = NULL;
    PyObject* py_destGDS;
    BSTR bsReplicaName = 0;
    PyObject* pyvar_ReplicaName;
    PyObject* unicodeReplicaName = NULL;
    IGPReplicaDescription* ipdesc = NULL;
    PyObject* py_desc;
    IGPReplicaOptions* iprepOptions = NULL;
    PyObject* py_repOptions;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOOO", &pyvar_versionName, &py_srcGDS, &py_destGDS, &pyvar_ReplicaName, &py_desc, &py_repOptions))
      goto ireplicationagent2_createreplica_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_srcGDS, &IID_IGeoDataServer, (void**)&ipsrcGDS))
        PyErr_SetString(PyExc_TypeError, "Argument srcGDS (position 1) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_destGDS, &IID_IGeoDataServer, (void**)&ipdestGDS))
        PyErr_SetString(PyExc_TypeError, "Argument destGDS (position 2) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica_method_cleanup;
    
    if (PyString_Check(pyvar_ReplicaName))
        unicodeReplicaName = PyUnicode_FromObject(pyvar_ReplicaName);
    else if (PyUnicode_Check(pyvar_ReplicaName))
    {
        unicodeReplicaName = pyvar_ReplicaName;
        Py_INCREF(unicodeReplicaName);
    }
    else if (pyvar_ReplicaName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter ReplicaName at index 3");
    if (unicodeReplicaName)
        bsReplicaName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeReplicaName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeReplicaName));
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_desc, &IID_IGPReplicaDescription, (void**)&ipdesc))
        PyErr_SetString(PyExc_TypeError, "Argument desc (position 4) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_repOptions, &IID_IGPReplicaOptions, (void**)&iprepOptions))
        PyErr_SetString(PyExc_TypeError, "Argument repOptions (position 5) is not IGPReplicaOptions");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_createreplica_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicationAgent2->CreateReplica(bsversionName, ipsrcGDS, ipdestGDS, bsReplicaName, ipdesc, iprepOptions);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicationAgent2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicationAgent2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicationAgent2.CreateReplica() returned %ld", (long)hr);
        goto ireplicationagent2_createreplica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for srcGDS
    // No teardown for destGDS
    // No teardown for ReplicaName
    // No teardown for desc
    // No teardown for repOptions

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicationagent2_createreplica_method_cleanup;

    ireplicationagent2_createreplica_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (ipsrcGDS)
      ipsrcGDS->Release();
    if (ipdestGDS)
      ipdestGDS->Release();
    if (bsReplicaName)
        ::SysFreeString(bsReplicaName);
    
    if (ipdesc)
      ipdesc->Release();
    if (iprepOptions)
      iprepOptions->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicationAgent2.CreateReplica");
    return return_tuple;
}

static PyObject*
IReplicationAgent2Method_SynchronizeReplica(PyIReplicationAgent2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeoDataServer* ipgds1 = NULL;
    PyObject* py_gds1;
    IGeoDataServer* ipgds2 = NULL;
    PyObject* py_gds2;
    IGPReplica* iprep1 = NULL;
    PyObject* py_rep1;
    IGPReplica* iprep2 = NULL;
    PyObject* py_rep2;
    esriReplicationAgentReconcilePolicy epol;
    esriReplicaSynchronizeDirection edir;
    VARIANT_BOOL b_columnLevel = VARIANT_FALSE;
    PyObject* pyvar_columnLevel = NULL;
    VARIANT_BOOL b_conflictsDetected = VARIANT_FALSE;
    PyObject* pyvar_conflictsDetected = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOiiO", &py_gds1, &py_gds2, &py_rep1, &py_rep2, (int *)&epol, (int *)&edir, &pyvar_columnLevel))
      goto ireplicationagent2_synchronizereplica_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_gds1, &IID_IGeoDataServer, (void**)&ipgds1))
        PyErr_SetString(PyExc_TypeError, "Argument gds1 (position 0) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_synchronizereplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_gds2, &IID_IGeoDataServer, (void**)&ipgds2))
        PyErr_SetString(PyExc_TypeError, "Argument gds2 (position 1) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_synchronizereplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_rep1, &IID_IGPReplica, (void**)&iprep1))
        PyErr_SetString(PyExc_TypeError, "Argument rep1 (position 2) is not IGPReplica");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_synchronizereplica_method_cleanup;
    
    if (!IFaceFromPyObject(py_rep2, &IID_IGPReplica, (void**)&iprep2))
        PyErr_SetString(PyExc_TypeError, "Argument rep2 (position 3) is not IGPReplica");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_synchronizereplica_method_cleanup;
    
    // No setup for pol
    // No setup for dir
    b_columnLevel = ((PyObject_IsTrue(pyvar_columnLevel) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ireplicationagent2_synchronizereplica_method_cleanup;
    
    // No setup for conflictsDetected

    // Call method on actual COM interface
    hr = self->m_pIReplicationAgent2->SynchronizeReplica(ipgds1, ipgds2, iprep1, iprep2, epol, edir, b_columnLevel, &b_conflictsDetected);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicationAgent2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicationAgent2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicationAgent2.SynchronizeReplica() returned %ld", (long)hr);
        goto ireplicationagent2_synchronizereplica_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for gds1
    // No teardown for gds2
    // No teardown for rep1
    // No teardown for rep2
    // No teardown for pol
    // No teardown for dir
    // No teardown for columnLevel
    pyvar_conflictsDetected = ((b_conflictsDetected == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ireplicationagent2_synchronizereplica_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_conflictsDetected);
    goto ireplicationagent2_synchronizereplica_method_cleanup;

    ireplicationagent2_synchronizereplica_method_cleanup:
    self->m_HR = hr;
    if (ipgds1)
      ipgds1->Release();
    if (ipgds2)
      ipgds2->Release();
    if (iprep1)
      iprep1->Release();
    if (iprep2)
      iprep2->Release();
    // No cleanup for pol
    // No cleanup for dir
    // No cleanup for columnLevel
    // No cleanup for conflictsDetected
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicationAgent2.SynchronizeReplica");
    return return_tuple;
}

static PyObject*
IReplicationAgent2Method_ExtractData(PyIReplicationAgent2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsversionName = 0;
    PyObject* pyvar_versionName;
    PyObject* unicodeversionName = NULL;
    IGeoDataServer* ipsrcGDS = NULL;
    PyObject* py_srcGDS;
    IGeoDataServer* ipdestGDS = NULL;
    PyObject* py_destGDS;
    IGPReplicaDescription* ipdesc = NULL;
    PyObject* py_desc;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_versionName, &py_srcGDS, &py_destGDS, &py_desc))
      goto ireplicationagent2_extractdata_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_versionName))
        unicodeversionName = PyUnicode_FromObject(pyvar_versionName);
    else if (PyUnicode_Check(pyvar_versionName))
    {
        unicodeversionName = pyvar_versionName;
        Py_INCREF(unicodeversionName);
    }
    else if (pyvar_versionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter versionName at index 0");
    if (unicodeversionName)
        bsversionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeversionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeversionName));
    
    if (PyErr_Occurred())
      goto ireplicationagent2_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_srcGDS, &IID_IGeoDataServer, (void**)&ipsrcGDS))
        PyErr_SetString(PyExc_TypeError, "Argument srcGDS (position 1) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_destGDS, &IID_IGeoDataServer, (void**)&ipdestGDS))
        PyErr_SetString(PyExc_TypeError, "Argument destGDS (position 2) is not IGeoDataServer");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_extractdata_method_cleanup;
    
    if (!IFaceFromPyObject(py_desc, &IID_IGPReplicaDescription, (void**)&ipdesc))
        PyErr_SetString(PyExc_TypeError, "Argument desc (position 3) is not IGPReplicaDescription");
    
    if (PyErr_Occurred())
      goto ireplicationagent2_extractdata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIReplicationAgent2->ExtractData(bsversionName, ipsrcGDS, ipdestGDS, ipdesc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIReplicationAgent2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IReplicationAgent2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IReplicationAgent2.ExtractData() returned %ld", (long)hr);
        goto ireplicationagent2_extractdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for versionName
    // No teardown for srcGDS
    // No teardown for destGDS
    // No teardown for desc

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ireplicationagent2_extractdata_method_cleanup;

    ireplicationagent2_extractdata_method_cleanup:
    self->m_HR = hr;
    if (bsversionName)
        ::SysFreeString(bsversionName);
    
    if (ipsrcGDS)
      ipsrcGDS->Release();
    if (ipdestGDS)
      ipdestGDS->Release();
    if (ipdesc)
      ipdesc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IReplicationAgent2.ExtractData");
    return return_tuple;
}


PyMethodDef PyIReplicationAgent2Methods[] = {
    {"supports", (PyCFunction)PyIReplicationAgent2_SupportsInterface, METH_O, ""},
    {"CreateReplica2", (PyCFunction)IReplicationAgent2Method_CreateReplica2, METH_VARARGS, ""},
    {"CreateReplica", (PyCFunction)IReplicationAgent2Method_CreateReplica, METH_VARARGS, ""},
    {"SynchronizeReplica", (PyCFunction)IReplicationAgent2Method_SynchronizeReplica, METH_VARARGS, ""},
    {"ExtractData", (PyCFunction)IReplicationAgent2Method_ExtractData, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIReplicationAgent2GetSet[] = {
  {"_pUnk", (getter)PyIReplicationAgent2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IReplicationAgent2", NULL},
  {"_pointer", (getter)PyIReplicationAgent2_GetPointer, NULL, "Get memory address for IReplicationAgent2", NULL},
  {"_IID", (getter)PyIReplicationAgent2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIReplicationAgent2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIReplicationAgent2_GetIgnoreFailures, (setter)PyIReplicationAgent2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIReplicationAgent2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IReplicationAgent2Object",                          
                                              /* tp_name */
  sizeof(PyIReplicationAgent2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIReplicationAgent2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIReplicationAgent2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIReplicationAgent2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIReplicationAgent2Object_new,                      
                                              /* tp_new */
};

// Interface IWFSServer

typedef struct PyIWFSServerObject {
    PyObject_HEAD
    IWFSServer* m_pIWFSServer;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWFSServerObject;

static PyObject*
PyIWFSServerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWFSServerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWFSServer* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWFSServer, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWFSServer with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWFSServerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWFSServer");
            return NULL;
        }
        self->m_pIWFSServer = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWFSServer");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWFSServer");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWFSServer* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWFSServer, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWFSServer");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWFSServerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWFSServer");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWFSServer = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWFSServerObject_dealloc(PyIWFSServerObject* self)
{
    if (self->m_pIWFSServer)
        self->m_pIWFSServer->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWFSServer_GetpUnk(PyIWFSServerObject* self)
{
    if (!self->m_pIWFSServer)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWFSServer->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWFSServer to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWFSServer_GetPointer(PyIWFSServerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWFSServer);
}

static PyObject*
PyIWFSServer_GetIID(PyIWFSServerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ca2b76eb-ffe1-46d7-9e13-99a7184ab450");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWFSServer_GetHR(PyIWFSServerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWFSServer_GetIgnoreFailures(PyIWFSServerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWFSServer_SetIgnoreFailures(PyIWFSServerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWFSServer_SupportsInterface(PyIWFSServerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWFSServer->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWFSServerMethod_GetData(PyIWFSServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriWFSHttpVerb ehttpVerb;
    BSTR bsrequest = 0;
    PyObject* pyvar_request;
    PyObject* unicoderequest = NULL;
    BSTR bsresponseUrl;
    PyObject* pyvar_responseUrl = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&ehttpVerb, &pyvar_request))
      goto iwfsserver_getdata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for httpVerb
    if (PyString_Check(pyvar_request))
        unicoderequest = PyUnicode_FromObject(pyvar_request);
    else if (PyUnicode_Check(pyvar_request))
    {
        unicoderequest = pyvar_request;
        Py_INCREF(unicoderequest);
    }
    else if (pyvar_request != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter request at index 1");
    if (unicoderequest)
        bsrequest = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicoderequest), 
                                            (UINT)PyUnicode_GET_SIZE(unicoderequest));
    
    if (PyErr_Occurred())
      goto iwfsserver_getdata_method_cleanup;
    
    // No setup for responseUrl

    // Call method on actual COM interface
    hr = self->m_pIWFSServer->GetData(ehttpVerb, bsrequest, &bsresponseUrl);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWFSServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWFSServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWFSServer.GetData() returned %ld", (long)hr);
        goto iwfsserver_getdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for httpVerb
    // No teardown for request
    pyvar_responseUrl = PyUnicode_FromWideChar(bsresponseUrl,::SysStringLen(bsresponseUrl));
    ::SysFreeString(bsresponseUrl);
    
    if (PyErr_Occurred())
      goto iwfsserver_getdata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_responseUrl);
    goto iwfsserver_getdata_method_cleanup;

    iwfsserver_getdata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for httpVerb
    if (bsrequest)
        ::SysFreeString(bsrequest);
    
    if (pyvar_responseUrl != Py_None)
        Py_XDECREF(pyvar_responseUrl);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWFSServer.GetData");
    return return_tuple;
}

static PyObject*
IWFSServerMethod_SetParameter(PyIWFSServerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    BSTR bsvalue = 0;
    PyObject* pyvar_value;
    PyObject* unicodevalue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_Name, &pyvar_value))
      goto iwfsserver_setparameter_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iwfsserver_setparameter_method_cleanup;
    
    if (PyString_Check(pyvar_value))
        unicodevalue = PyUnicode_FromObject(pyvar_value);
    else if (PyUnicode_Check(pyvar_value))
    {
        unicodevalue = pyvar_value;
        Py_INCREF(unicodevalue);
    }
    else if (pyvar_value != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter value at index 1");
    if (unicodevalue)
        bsvalue = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodevalue), 
                                            (UINT)PyUnicode_GET_SIZE(unicodevalue));
    
    if (PyErr_Occurred())
      goto iwfsserver_setparameter_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIWFSServer->SetParameter(bsName, bsvalue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWFSServer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWFSServer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWFSServer.SetParameter() returned %ld", (long)hr);
        goto iwfsserver_setparameter_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for value

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwfsserver_setparameter_method_cleanup;

    iwfsserver_setparameter_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (bsvalue)
        ::SysFreeString(bsvalue);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWFSServer.SetParameter");
    return return_tuple;
}


PyMethodDef PyIWFSServerMethods[] = {
    {"supports", (PyCFunction)PyIWFSServer_SupportsInterface, METH_O, ""},
    {"GetData", (PyCFunction)IWFSServerMethod_GetData, METH_VARARGS, ""},
    {"SetParameter", (PyCFunction)IWFSServerMethod_SetParameter, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWFSServerGetSet[] = {
  {"_pUnk", (getter)PyIWFSServer_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWFSServer", NULL},
  {"_pointer", (getter)PyIWFSServer_GetPointer, NULL, "Get memory address for IWFSServer", NULL},
  {"_IID", (getter)PyIWFSServer_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWFSServer_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWFSServer_GetIgnoreFailures, (setter)PyIWFSServer_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWFSServerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IWFSServerObject",                          
                                              /* tp_name */
  sizeof(PyIWFSServerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWFSServerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWFSServerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWFSServerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWFSServerObject_new,                      
                                              /* tp_new */
};

// Interface IExportSchema

typedef struct PyIExportSchemaObject {
    PyObject_HEAD
    IExportSchema* m_pIExportSchema;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExportSchemaObject;

static PyObject*
PyIExportSchemaObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExportSchemaObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExportSchema* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExportSchema, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExportSchema with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExportSchemaObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportSchema");
            return NULL;
        }
        self->m_pIExportSchema = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExportSchema");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExportSchema");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExportSchema* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExportSchema, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExportSchema");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExportSchemaObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExportSchema");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExportSchema = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExportSchemaObject_dealloc(PyIExportSchemaObject* self)
{
    if (self->m_pIExportSchema)
        self->m_pIExportSchema->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExportSchema_GetpUnk(PyIExportSchemaObject* self)
{
    if (!self->m_pIExportSchema)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExportSchema->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExportSchema to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExportSchema_GetPointer(PyIExportSchemaObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExportSchema);
}

static PyObject*
PyIExportSchema_GetIID(PyIExportSchemaObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "bfd3912e-421e-477b-b324-5e66c552ac1b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExportSchema_GetHR(PyIExportSchemaObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExportSchema_GetIgnoreFailures(PyIExportSchemaObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExportSchema_SetIgnoreFailures(PyIExportSchemaObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExportSchema_SupportsInterface(PyIExportSchemaObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExportSchema->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExportSchemaMethod_ExportSchema(PyIExportSchemaObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsexportFileName = 0;
    PyObject* pyvar_exportFileName;
    PyObject* unicodeexportFileName = NULL;
    IReplica* ipReplica = NULL;
    PyObject* py_Replica;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_exportFileName, &py_Replica))
      goto iexportschema_exportschema_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_exportFileName))
        unicodeexportFileName = PyUnicode_FromObject(pyvar_exportFileName);
    else if (PyUnicode_Check(pyvar_exportFileName))
    {
        unicodeexportFileName = pyvar_exportFileName;
        Py_INCREF(unicodeexportFileName);
    }
    else if (pyvar_exportFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter exportFileName at index 0");
    if (unicodeexportFileName)
        bsexportFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeexportFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeexportFileName));
    
    if (PyErr_Occurred())
      goto iexportschema_exportschema_method_cleanup;
    
    if (!IFaceFromPyObject(py_Replica, &IID_IReplica, (void**)&ipReplica))
        PyErr_SetString(PyExc_TypeError, "Argument Replica (position 1) is not IReplica");
    
    if (PyErr_Occurred())
      goto iexportschema_exportschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportSchema->ExportSchema(bsexportFileName, ipReplica);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportSchema->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportSchema) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportSchema.ExportSchema() returned %ld", (long)hr);
        goto iexportschema_exportschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for exportFileName
    // No teardown for Replica

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportschema_exportschema_method_cleanup;

    iexportschema_exportschema_method_cleanup:
    self->m_HR = hr;
    if (bsexportFileName)
        ::SysFreeString(bsexportFileName);
    
    if (ipReplica)
      ipReplica->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportSchema.ExportSchema");
    return return_tuple;
}

static PyObject*
IExportSchemaMethod_ExportSchemaDifferences(PyIExportSchemaObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsexportFileName = 0;
    PyObject* pyvar_exportFileName;
    PyObject* unicodeexportFileName = NULL;
    ISchemaChanges* ipSchemaChanges = NULL;
    PyObject* py_SchemaChanges;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_exportFileName, &py_SchemaChanges))
      goto iexportschema_exportschemadifferences_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_exportFileName))
        unicodeexportFileName = PyUnicode_FromObject(pyvar_exportFileName);
    else if (PyUnicode_Check(pyvar_exportFileName))
    {
        unicodeexportFileName = pyvar_exportFileName;
        Py_INCREF(unicodeexportFileName);
    }
    else if (pyvar_exportFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter exportFileName at index 0");
    if (unicodeexportFileName)
        bsexportFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeexportFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeexportFileName));
    
    if (PyErr_Occurred())
      goto iexportschema_exportschemadifferences_method_cleanup;
    
    if (!IFaceFromPyObject(py_SchemaChanges, &IID_ISchemaChanges, (void**)&ipSchemaChanges))
        PyErr_SetString(PyExc_TypeError, "Argument SchemaChanges (position 1) is not ISchemaChanges");
    
    if (PyErr_Occurred())
      goto iexportschema_exportschemadifferences_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExportSchema->ExportSchemaDifferences(bsexportFileName, ipSchemaChanges);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExportSchema->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExportSchema) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExportSchema.ExportSchemaDifferences() returned %ld", (long)hr);
        goto iexportschema_exportschemadifferences_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for exportFileName
    // No teardown for SchemaChanges

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexportschema_exportschemadifferences_method_cleanup;

    iexportschema_exportschemadifferences_method_cleanup:
    self->m_HR = hr;
    if (bsexportFileName)
        ::SysFreeString(bsexportFileName);
    
    if (ipSchemaChanges)
      ipSchemaChanges->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExportSchema.ExportSchemaDifferences");
    return return_tuple;
}


PyMethodDef PyIExportSchemaMethods[] = {
    {"supports", (PyCFunction)PyIExportSchema_SupportsInterface, METH_O, ""},
    {"ExportSchema", (PyCFunction)IExportSchemaMethod_ExportSchema, METH_VARARGS, ""},
    {"ExportSchemaDifferences", (PyCFunction)IExportSchemaMethod_ExportSchemaDifferences, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExportSchemaGetSet[] = {
  {"_pUnk", (getter)PyIExportSchema_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExportSchema", NULL},
  {"_pointer", (getter)PyIExportSchema_GetPointer, NULL, "Get memory address for IExportSchema", NULL},
  {"_IID", (getter)PyIExportSchema_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExportSchema_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExportSchema_GetIgnoreFailures, (setter)PyIExportSchema_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExportSchemaObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IExportSchemaObject",                          
                                              /* tp_name */
  sizeof(PyIExportSchemaObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExportSchemaObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExportSchemaMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExportSchemaGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExportSchemaObject_new,                      
                                              /* tp_new */
};

// Interface ISchemaChanges

typedef struct PyISchemaChangesObject {
    PyObject_HEAD
    ISchemaChanges* m_pISchemaChanges;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISchemaChangesObject;

static PyObject*
PyISchemaChangesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISchemaChangesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISchemaChanges* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISchemaChanges, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISchemaChanges with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISchemaChangesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISchemaChanges");
            return NULL;
        }
        self->m_pISchemaChanges = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISchemaChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISchemaChanges");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISchemaChanges* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISchemaChanges, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISchemaChanges");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISchemaChangesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISchemaChanges");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISchemaChanges = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISchemaChangesObject_dealloc(PyISchemaChangesObject* self)
{
    if (self->m_pISchemaChanges)
        self->m_pISchemaChanges->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISchemaChanges_GetpUnk(PyISchemaChangesObject* self)
{
    if (!self->m_pISchemaChanges)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISchemaChanges->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISchemaChanges to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISchemaChanges_GetPointer(PyISchemaChangesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISchemaChanges);
}

static PyObject*
PyISchemaChanges_GetIID(PyISchemaChangesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d14b724a-ac95-4cd2-9242-7235f4fb5587");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISchemaChanges_GetHR(PyISchemaChangesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISchemaChanges_GetIgnoreFailures(PyISchemaChangesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISchemaChanges_SetIgnoreFailures(PyISchemaChangesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISchemaChanges_SupportsInterface(PyISchemaChangesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISchemaChanges->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISchemaChangesMethod_GetChanges(PyISchemaChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumSchemaChange* ipSchemaChanges = NULL;
    PyObject* py_SchemaChanges = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SchemaChanges

    // Call method on actual COM interface
    hr = self->m_pISchemaChanges->GetChanges(&ipSchemaChanges);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChanges.GetChanges() returned %ld", (long)hr);
        goto ischemachanges_getchanges_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_SchemaChanges);
    if (ipSchemaChanges)
    {
        IUnknown* pUnk = NULL;
        ipSchemaChanges->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_SchemaChanges = IUnknownToPythonIIDObject(pUnk, &IID_IEnumSchemaChange);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_SchemaChanges)
    {
        if (py_SchemaChanges)
           Py_DECREF(py_SchemaChanges);
        py_SchemaChanges = Py_None;
        Py_INCREF(py_SchemaChanges);
    }
    if (PyErr_Occurred())
      goto ischemachanges_getchanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_SchemaChanges);
    goto ischemachanges_getchanges_method_cleanup;

    ischemachanges_getchanges_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_SchemaChanges);
    if (ipSchemaChanges)
      ipSchemaChanges->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChanges.GetChanges");
    return return_tuple;
}

static PyObject*
ISchemaChangesMethod_get_FromReplica(PyISchemaChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPReplica* ipFromReplica = NULL;
    PyObject* py_FromReplica = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FromReplica

    // Call method on actual COM interface
    hr = self->m_pISchemaChanges->get_FromReplica(&ipFromReplica);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChanges.get_FromReplica() returned %ld", (long)hr);
        goto ischemachanges_get_fromreplica_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_FromReplica);
    if (ipFromReplica)
    {
        IUnknown* pUnk = NULL;
        ipFromReplica->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FromReplica = IUnknownToPythonIIDObject(pUnk, &IID_IGPReplica);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FromReplica)
    {
        if (py_FromReplica)
           Py_DECREF(py_FromReplica);
        py_FromReplica = Py_None;
        Py_INCREF(py_FromReplica);
    }
    if (PyErr_Occurred())
      goto ischemachanges_get_fromreplica_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FromReplica);
    goto ischemachanges_get_fromreplica_method_cleanup;

    ischemachanges_get_fromreplica_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_FromReplica);
    if (ipFromReplica)
      ipFromReplica->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChanges.get_FromReplica");
    return return_tuple;
}

static PyObject*
ISchemaChangesMethod_get_ToReplica(PyISchemaChangesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGPReplica* ipToReplica = NULL;
    PyObject* py_ToReplica = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ToReplica

    // Call method on actual COM interface
    hr = self->m_pISchemaChanges->get_ToReplica(&ipToReplica);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChanges->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChanges) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChanges.get_ToReplica() returned %ld", (long)hr);
        goto ischemachanges_get_toreplica_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ToReplica);
    if (ipToReplica)
    {
        IUnknown* pUnk = NULL;
        ipToReplica->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ToReplica = IUnknownToPythonIIDObject(pUnk, &IID_IGPReplica);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ToReplica)
    {
        if (py_ToReplica)
           Py_DECREF(py_ToReplica);
        py_ToReplica = Py_None;
        Py_INCREF(py_ToReplica);
    }
    if (PyErr_Occurred())
      goto ischemachanges_get_toreplica_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ToReplica);
    goto ischemachanges_get_toreplica_method_cleanup;

    ischemachanges_get_toreplica_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ToReplica);
    if (ipToReplica)
      ipToReplica->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChanges.get_ToReplica");
    return return_tuple;
}


PyMethodDef PyISchemaChangesMethods[] = {
    {"supports", (PyCFunction)PyISchemaChanges_SupportsInterface, METH_O, ""},
    {"GetChanges", (PyCFunction)ISchemaChangesMethod_GetChanges, METH_VARARGS, ""},
    {"get_FromReplica", (PyCFunction)ISchemaChangesMethod_get_FromReplica, METH_VARARGS, ""},
    {"get_ToReplica", (PyCFunction)ISchemaChangesMethod_get_ToReplica, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISchemaChangesGetSet[] = {
  {"_pUnk", (getter)PyISchemaChanges_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISchemaChanges", NULL},
  {"_pointer", (getter)PyISchemaChanges_GetPointer, NULL, "Get memory address for ISchemaChanges", NULL},
  {"_IID", (getter)PyISchemaChanges_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISchemaChanges_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISchemaChanges_GetIgnoreFailures, (setter)PyISchemaChanges_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISchemaChangesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ISchemaChangesObject",                          
                                              /* tp_name */
  sizeof(PyISchemaChangesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISchemaChangesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISchemaChangesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISchemaChangesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISchemaChangesObject_new,                      
                                              /* tp_new */
};

// Interface IImportSchema

typedef struct PyIImportSchemaObject {
    PyObject_HEAD
    IImportSchema* m_pIImportSchema;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIImportSchemaObject;

static PyObject*
PyIImportSchemaObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIImportSchemaObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IImportSchema* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IImportSchema, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IImportSchema with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIImportSchemaObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IImportSchema");
            return NULL;
        }
        self->m_pIImportSchema = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IImportSchema");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IImportSchema");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IImportSchema* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IImportSchema, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IImportSchema");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIImportSchemaObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IImportSchema");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIImportSchema = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIImportSchemaObject_dealloc(PyIImportSchemaObject* self)
{
    if (self->m_pIImportSchema)
        self->m_pIImportSchema->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIImportSchema_GetpUnk(PyIImportSchemaObject* self)
{
    if (!self->m_pIImportSchema)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIImportSchema->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IImportSchema to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIImportSchema_GetPointer(PyIImportSchemaObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIImportSchema);
}

static PyObject*
PyIImportSchema_GetIID(PyIImportSchemaObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "be88729b-0719-45b6-a60b-c977e4041c7b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIImportSchema_GetHR(PyIImportSchemaObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIImportSchema_GetIgnoreFailures(PyIImportSchemaObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIImportSchema_SetIgnoreFailures(PyIImportSchemaObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIImportSchema_SupportsInterface(PyIImportSchemaObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIImportSchema->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IImportSchemaMethod_ImportSchema(PyIImportSchemaObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISchemaChanges* ipSchemaChanges = NULL;
    PyObject* py_SchemaChanges;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_SchemaChanges))
      goto iimportschema_importschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_SchemaChanges, &IID_ISchemaChanges, (void**)&ipSchemaChanges))
        PyErr_SetString(PyExc_TypeError, "Argument SchemaChanges (position 0) is not ISchemaChanges");
    
    if (PyErr_Occurred())
      goto iimportschema_importschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIImportSchema->ImportSchema(ipSchemaChanges);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIImportSchema->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IImportSchema) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IImportSchema.ImportSchema() returned %ld", (long)hr);
        goto iimportschema_importschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SchemaChanges

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iimportschema_importschema_method_cleanup;

    iimportschema_importschema_method_cleanup:
    self->m_HR = hr;
    if (ipSchemaChanges)
      ipSchemaChanges->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IImportSchema.ImportSchema");
    return return_tuple;
}


PyMethodDef PyIImportSchemaMethods[] = {
    {"supports", (PyCFunction)PyIImportSchema_SupportsInterface, METH_O, ""},
    {"ImportSchema", (PyCFunction)IImportSchemaMethod_ImportSchema, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIImportSchemaGetSet[] = {
  {"_pUnk", (getter)PyIImportSchema_GetpUnk, NULL, "Get opaque pointer to an Unknown from IImportSchema", NULL},
  {"_pointer", (getter)PyIImportSchema_GetPointer, NULL, "Get memory address for IImportSchema", NULL},
  {"_IID", (getter)PyIImportSchema_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIImportSchema_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIImportSchema_GetIgnoreFailures, (setter)PyIImportSchema_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIImportSchemaObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IImportSchemaObject",                          
                                              /* tp_name */
  sizeof(PyIImportSchemaObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIImportSchemaObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIImportSchemaMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIImportSchemaGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIImportSchemaObject_new,                      
                                              /* tp_new */
};

// Interface IEnumSchemaChange

typedef struct PyIEnumSchemaChangeObject {
    PyObject_HEAD
    IEnumSchemaChange* m_pIEnumSchemaChange;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIEnumSchemaChangeObject;

static PyObject*
PyIEnumSchemaChangeObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIEnumSchemaChangeObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IEnumSchemaChange* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IEnumSchemaChange, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IEnumSchemaChange with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIEnumSchemaChangeObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumSchemaChange");
            return NULL;
        }
        self->m_pIEnumSchemaChange = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IEnumSchemaChange");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IEnumSchemaChange");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IEnumSchemaChange* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IEnumSchemaChange, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IEnumSchemaChange");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIEnumSchemaChangeObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumSchemaChange");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIEnumSchemaChange = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIEnumSchemaChangeObject_dealloc(PyIEnumSchemaChangeObject* self)
{
    if (self->m_pIEnumSchemaChange)
        self->m_pIEnumSchemaChange->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIEnumSchemaChange_GetpUnk(PyIEnumSchemaChangeObject* self)
{
    if (!self->m_pIEnumSchemaChange)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIEnumSchemaChange->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IEnumSchemaChange to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIEnumSchemaChange_GetPointer(PyIEnumSchemaChangeObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIEnumSchemaChange);
}

static PyObject*
PyIEnumSchemaChange_GetIID(PyIEnumSchemaChangeObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "52b0879b-28c4-4904-a402-91378488b867");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIEnumSchemaChange_GetHR(PyIEnumSchemaChangeObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIEnumSchemaChange_GetIgnoreFailures(PyIEnumSchemaChangeObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIEnumSchemaChange_SetIgnoreFailures(PyIEnumSchemaChangeObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIEnumSchemaChange_SupportsInterface(PyIEnumSchemaChangeObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIEnumSchemaChange->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IEnumSchemaChangeMethod_Reset(PyIEnumSchemaChangeObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIEnumSchemaChange->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumSchemaChange->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumSchemaChange) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumSchemaChange.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IEnumSchemaChangeMethod_Next(PyIEnumSchemaChangeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISchemaChangeInfo* ipSchemaChangeInfo = NULL;
    PyObject* py_SchemaChangeInfo = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SchemaChangeInfo

    // Call method on actual COM interface
    hr = self->m_pIEnumSchemaChange->Next(&ipSchemaChangeInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumSchemaChange->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumSchemaChange) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumSchemaChange.Next() returned %ld", (long)hr);
        goto ienumschemachange_next_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_SchemaChangeInfo);
    if (ipSchemaChangeInfo)
    {
        IUnknown* pUnk = NULL;
        ipSchemaChangeInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_SchemaChangeInfo = IUnknownToPythonIIDObject(pUnk, &IID_ISchemaChangeInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_SchemaChangeInfo)
    {
        if (py_SchemaChangeInfo)
           Py_DECREF(py_SchemaChangeInfo);
        py_SchemaChangeInfo = Py_None;
        Py_INCREF(py_SchemaChangeInfo);
    }
    if (PyErr_Occurred())
      goto ienumschemachange_next_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_SchemaChangeInfo);
    goto ienumschemachange_next_method_cleanup;

    ienumschemachange_next_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_SchemaChangeInfo);
    if (ipSchemaChangeInfo)
      ipSchemaChangeInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumSchemaChange.Next");
    return return_tuple;
}

static PyObject*
IEnumSchemaChangeMethod_GetDomainChanges(PyIEnumSchemaChangeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdomainName = 0;
    PyObject* pyvar_domainName;
    PyObject* unicodedomainName = NULL;
    ISchemaChangeInfo* ipppInfo = NULL;
    PyObject* py_ppInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_domainName))
      goto ienumschemachange_getdomainchanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_domainName))
        unicodedomainName = PyUnicode_FromObject(pyvar_domainName);
    else if (PyUnicode_Check(pyvar_domainName))
    {
        unicodedomainName = pyvar_domainName;
        Py_INCREF(unicodedomainName);
    }
    else if (pyvar_domainName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter domainName at index 0");
    if (unicodedomainName)
        bsdomainName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedomainName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedomainName));
    
    if (PyErr_Occurred())
      goto ienumschemachange_getdomainchanges_method_cleanup;
    
    // No setup for ppInfo

    // Call method on actual COM interface
    hr = self->m_pIEnumSchemaChange->GetDomainChanges(bsdomainName, &ipppInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumSchemaChange->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumSchemaChange) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumSchemaChange.GetDomainChanges() returned %ld", (long)hr);
        goto ienumschemachange_getdomainchanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for domainName
    Py_XDECREF(py_ppInfo);
    if (ipppInfo)
    {
        IUnknown* pUnk = NULL;
        ipppInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppInfo = IUnknownToPythonIIDObject(pUnk, &IID_ISchemaChangeInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppInfo)
    {
        if (py_ppInfo)
           Py_DECREF(py_ppInfo);
        py_ppInfo = Py_None;
        Py_INCREF(py_ppInfo);
    }
    if (PyErr_Occurred())
      goto ienumschemachange_getdomainchanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppInfo);
    goto ienumschemachange_getdomainchanges_method_cleanup;

    ienumschemachange_getdomainchanges_method_cleanup:
    self->m_HR = hr;
    if (bsdomainName)
        ::SysFreeString(bsdomainName);
    
    Py_XDECREF(py_ppInfo);
    if (ipppInfo)
      ipppInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumSchemaChange.GetDomainChanges");
    return return_tuple;
}

static PyObject*
IEnumSchemaChangeMethod_GetDatasetChanges(PyIEnumSchemaChangeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    esriDatasetType edsType;
    ISchemaChangeInfo* ipppInfo = NULL;
    PyObject* py_ppInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_Name, (int *)&edsType))
      goto ienumschemachange_getdatasetchanges_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto ienumschemachange_getdatasetchanges_method_cleanup;
    
    // No setup for dsType
    // No setup for ppInfo

    // Call method on actual COM interface
    hr = self->m_pIEnumSchemaChange->GetDatasetChanges(bsName, edsType, &ipppInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumSchemaChange->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumSchemaChange) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumSchemaChange.GetDatasetChanges() returned %ld", (long)hr);
        goto ienumschemachange_getdatasetchanges_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for dsType
    Py_XDECREF(py_ppInfo);
    if (ipppInfo)
    {
        IUnknown* pUnk = NULL;
        ipppInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppInfo = IUnknownToPythonIIDObject(pUnk, &IID_ISchemaChangeInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppInfo)
    {
        if (py_ppInfo)
           Py_DECREF(py_ppInfo);
        py_ppInfo = Py_None;
        Py_INCREF(py_ppInfo);
    }
    if (PyErr_Occurred())
      goto ienumschemachange_getdatasetchanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppInfo);
    goto ienumschemachange_getdatasetchanges_method_cleanup;

    ienumschemachange_getdatasetchanges_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for dsType
    Py_XDECREF(py_ppInfo);
    if (ipppInfo)
      ipppInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumSchemaChange.GetDatasetChanges");
    return return_tuple;
}

static PyObject*
IEnumSchemaChangeMethod_HasChanges(PyIEnumSchemaChangeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pHasSchemaChanges = VARIANT_FALSE;
    PyObject* pyvar_pHasSchemaChanges = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pHasSchemaChanges

    // Call method on actual COM interface
    hr = self->m_pIEnumSchemaChange->HasChanges(&b_pHasSchemaChanges);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumSchemaChange->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumSchemaChange) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumSchemaChange.HasChanges() returned %ld", (long)hr);
        goto ienumschemachange_haschanges_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pHasSchemaChanges = ((b_pHasSchemaChanges == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ienumschemachange_haschanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pHasSchemaChanges);
    goto ienumschemachange_haschanges_method_cleanup;

    ienumschemachange_haschanges_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pHasSchemaChanges
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumSchemaChange.HasChanges");
    return return_tuple;
}

static PyObject*
IEnumSchemaChangeMethod_get_ToReplica(PyIEnumSchemaChangeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IReplica* ipToReplica = NULL;
    PyObject* py_ToReplica = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ToReplica

    // Call method on actual COM interface
    hr = self->m_pIEnumSchemaChange->get_ToReplica(&ipToReplica);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumSchemaChange->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumSchemaChange) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumSchemaChange.get_ToReplica() returned %ld", (long)hr);
        goto ienumschemachange_get_toreplica_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ToReplica);
    if (ipToReplica)
    {
        IUnknown* pUnk = NULL;
        ipToReplica->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ToReplica = IUnknownToPythonIIDObject(pUnk, &IID_IReplica);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ToReplica)
    {
        if (py_ToReplica)
           Py_DECREF(py_ToReplica);
        py_ToReplica = Py_None;
        Py_INCREF(py_ToReplica);
    }
    if (PyErr_Occurred())
      goto ienumschemachange_get_toreplica_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ToReplica);
    goto ienumschemachange_get_toreplica_method_cleanup;

    ienumschemachange_get_toreplica_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ToReplica);
    if (ipToReplica)
      ipToReplica->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumSchemaChange.get_ToReplica");
    return return_tuple;
}


PyMethodDef PyIEnumSchemaChangeMethods[] = {
    {"supports", (PyCFunction)PyIEnumSchemaChange_SupportsInterface, METH_O, ""},
    {"Reset", (PyCFunction)IEnumSchemaChangeMethod_Reset, METH_NOARGS, ""},
    {"Next", (PyCFunction)IEnumSchemaChangeMethod_Next, METH_VARARGS, ""},
    {"GetDomainChanges", (PyCFunction)IEnumSchemaChangeMethod_GetDomainChanges, METH_VARARGS, ""},
    {"GetDatasetChanges", (PyCFunction)IEnumSchemaChangeMethod_GetDatasetChanges, METH_VARARGS, ""},
    {"HasChanges", (PyCFunction)IEnumSchemaChangeMethod_HasChanges, METH_VARARGS, ""},
    {"get_ToReplica", (PyCFunction)IEnumSchemaChangeMethod_get_ToReplica, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIEnumSchemaChangeGetSet[] = {
  {"_pUnk", (getter)PyIEnumSchemaChange_GetpUnk, NULL, "Get opaque pointer to an Unknown from IEnumSchemaChange", NULL},
  {"_pointer", (getter)PyIEnumSchemaChange_GetPointer, NULL, "Get memory address for IEnumSchemaChange", NULL},
  {"_IID", (getter)PyIEnumSchemaChange_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIEnumSchemaChange_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIEnumSchemaChange_GetIgnoreFailures, (setter)PyIEnumSchemaChange_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIEnumSchemaChangeObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.IEnumSchemaChangeObject",                          
                                              /* tp_name */
  sizeof(PyIEnumSchemaChangeObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIEnumSchemaChangeObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIEnumSchemaChangeMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIEnumSchemaChangeGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIEnumSchemaChangeObject_new,                      
                                              /* tp_new */
};

// Interface ISchemaChangeInfo

typedef struct PyISchemaChangeInfoObject {
    PyObject_HEAD
    ISchemaChangeInfo* m_pISchemaChangeInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISchemaChangeInfoObject;

static PyObject*
PyISchemaChangeInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISchemaChangeInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISchemaChangeInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISchemaChangeInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISchemaChangeInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISchemaChangeInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISchemaChangeInfo");
            return NULL;
        }
        self->m_pISchemaChangeInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISchemaChangeInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISchemaChangeInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISchemaChangeInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISchemaChangeInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISchemaChangeInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISchemaChangeInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISchemaChangeInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISchemaChangeInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISchemaChangeInfoObject_dealloc(PyISchemaChangeInfoObject* self)
{
    if (self->m_pISchemaChangeInfo)
        self->m_pISchemaChangeInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISchemaChangeInfo_GetpUnk(PyISchemaChangeInfoObject* self)
{
    if (!self->m_pISchemaChangeInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISchemaChangeInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISchemaChangeInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISchemaChangeInfo_GetPointer(PyISchemaChangeInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISchemaChangeInfo);
}

static PyObject*
PyISchemaChangeInfo_GetIID(PyISchemaChangeInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b5ccf6d9-d034-4177-8827-f1493785de8f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISchemaChangeInfo_GetHR(PyISchemaChangeInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISchemaChangeInfo_GetIgnoreFailures(PyISchemaChangeInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISchemaChangeInfo_SetIgnoreFailures(PyISchemaChangeInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISchemaChangeInfo_SupportsInterface(PyISchemaChangeInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISchemaChangeInfoMethod_get_SchemaChangeType(PyISchemaChangeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriSchemaChangeType eSchemaChangeType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SchemaChangeType

    // Call method on actual COM interface
    hr = self->m_pISchemaChangeInfo->get_SchemaChangeType(&eSchemaChangeType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangeInfo.get_SchemaChangeType() returned %ld", (long)hr);
        goto ischemachangeinfo_get_schemachangetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for SchemaChangeType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eSchemaChangeType);
    goto ischemachangeinfo_get_schemachangetype_method_cleanup;

    ischemachangeinfo_get_schemachangetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for SchemaChangeType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangeInfo.get_SchemaChangeType");
    return return_tuple;
}

static PyObject*
ISchemaChangeInfoMethod_get_FromObject(PyISchemaChangeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ipChangedObject = NULL;
    PyObject* py_ChangedObject = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ChangedObject

    // Call method on actual COM interface
    hr = self->m_pISchemaChangeInfo->get_FromObject(&ipChangedObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangeInfo.get_FromObject() returned %ld", (long)hr);
        goto ischemachangeinfo_get_fromobject_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ChangedObject);
    if (ipChangedObject)
    {
        IUnknown* pUnk = NULL;
        ipChangedObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ChangedObject = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ChangedObject)
    {
        if (py_ChangedObject)
           Py_DECREF(py_ChangedObject);
        py_ChangedObject = Py_None;
        Py_INCREF(py_ChangedObject);
    }
    if (PyErr_Occurred())
      goto ischemachangeinfo_get_fromobject_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ChangedObject);
    goto ischemachangeinfo_get_fromobject_method_cleanup;

    ischemachangeinfo_get_fromobject_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ChangedObject);
    if (ipChangedObject)
      ipChangedObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangeInfo.get_FromObject");
    return return_tuple;
}

static PyObject*
ISchemaChangeInfoMethod_get_ToObject(PyISchemaChangeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ipTargetObject = NULL;
    PyObject* py_TargetObject = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for TargetObject

    // Call method on actual COM interface
    hr = self->m_pISchemaChangeInfo->get_ToObject(&ipTargetObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangeInfo.get_ToObject() returned %ld", (long)hr);
        goto ischemachangeinfo_get_toobject_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_TargetObject);
    if (ipTargetObject)
    {
        IUnknown* pUnk = NULL;
        ipTargetObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_TargetObject = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_TargetObject)
    {
        if (py_TargetObject)
           Py_DECREF(py_TargetObject);
        py_TargetObject = Py_None;
        Py_INCREF(py_TargetObject);
    }
    if (PyErr_Occurred())
      goto ischemachangeinfo_get_toobject_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_TargetObject);
    goto ischemachangeinfo_get_toobject_method_cleanup;

    ischemachangeinfo_get_toobject_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_TargetObject);
    if (ipTargetObject)
      ipTargetObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangeInfo.get_ToObject");
    return return_tuple;
}

static PyObject*
ISchemaChangeInfoMethod_get_ToParent(PyISchemaChangeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ipParent = NULL;
    PyObject* py_Parent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Parent

    // Call method on actual COM interface
    hr = self->m_pISchemaChangeInfo->get_ToParent(&ipParent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangeInfo.get_ToParent() returned %ld", (long)hr);
        goto ischemachangeinfo_get_toparent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Parent);
    if (ipParent)
    {
        IUnknown* pUnk = NULL;
        ipParent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Parent = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Parent)
    {
        if (py_Parent)
           Py_DECREF(py_Parent);
        py_Parent = Py_None;
        Py_INCREF(py_Parent);
    }
    if (PyErr_Occurred())
      goto ischemachangeinfo_get_toparent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Parent);
    goto ischemachangeinfo_get_toparent_method_cleanup;

    ischemachangeinfo_get_toparent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Parent);
    if (ipParent)
      ipParent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangeInfo.get_ToParent");
    return return_tuple;
}

static PyObject*
ISchemaChangeInfoMethod_get_ApplySchemaChange(PyISchemaChangeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_ApplySchemaChange = VARIANT_FALSE;
    PyObject* pyvar_ApplySchemaChange = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ApplySchemaChange

    // Call method on actual COM interface
    hr = self->m_pISchemaChangeInfo->get_ApplySchemaChange(&b_ApplySchemaChange);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangeInfo.get_ApplySchemaChange() returned %ld", (long)hr);
        goto ischemachangeinfo_get_applyschemachange_method_cleanup;
    }

    // Set up return values as needed
    pyvar_ApplySchemaChange = ((b_ApplySchemaChange == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ischemachangeinfo_get_applyschemachange_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ApplySchemaChange);
    goto ischemachangeinfo_get_applyschemachange_method_cleanup;

    ischemachangeinfo_get_applyschemachange_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ApplySchemaChange
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangeInfo.get_ApplySchemaChange");
    return return_tuple;
}

static PyObject*
ISchemaChangeInfoMethod_put_ApplySchemaChange(PyISchemaChangeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_ApplySchemaChange = VARIANT_FALSE;
    PyObject* pyvar_ApplySchemaChange = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ApplySchemaChange))
      goto ischemachangeinfo_put_applyschemachange_method_cleanup;

    // Set up initial variable values as needed
    b_ApplySchemaChange = ((PyObject_IsTrue(pyvar_ApplySchemaChange) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ischemachangeinfo_put_applyschemachange_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISchemaChangeInfo->put_ApplySchemaChange(b_ApplySchemaChange);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangeInfo.put_ApplySchemaChange() returned %ld", (long)hr);
        goto ischemachangeinfo_put_applyschemachange_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ApplySchemaChange

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ischemachangeinfo_put_applyschemachange_method_cleanup;

    ischemachangeinfo_put_applyschemachange_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ApplySchemaChange
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangeInfo.put_ApplySchemaChange");
    return return_tuple;
}

static PyObject*
ISchemaChangeInfoMethod_GetChanges(PyISchemaChangeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumSchemaChange* ipSchemaChanges = NULL;
    PyObject* py_SchemaChanges = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SchemaChanges

    // Call method on actual COM interface
    hr = self->m_pISchemaChangeInfo->GetChanges(&ipSchemaChanges);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangeInfo.GetChanges() returned %ld", (long)hr);
        goto ischemachangeinfo_getchanges_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_SchemaChanges);
    if (ipSchemaChanges)
    {
        IUnknown* pUnk = NULL;
        ipSchemaChanges->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_SchemaChanges = IUnknownToPythonIIDObject(pUnk, &IID_IEnumSchemaChange);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_SchemaChanges)
    {
        if (py_SchemaChanges)
           Py_DECREF(py_SchemaChanges);
        py_SchemaChanges = Py_None;
        Py_INCREF(py_SchemaChanges);
    }
    if (PyErr_Occurred())
      goto ischemachangeinfo_getchanges_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_SchemaChanges);
    goto ischemachangeinfo_getchanges_method_cleanup;

    ischemachangeinfo_getchanges_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_SchemaChanges);
    if (ipSchemaChanges)
      ipSchemaChanges->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangeInfo.GetChanges");
    return return_tuple;
}

static PyObject*
ISchemaChangeInfoMethod_get_ExtendedProperties(PyISchemaChangeInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipExtendedProperties = NULL;
    PyObject* py_ExtendedProperties = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ExtendedProperties

    // Call method on actual COM interface
    hr = self->m_pISchemaChangeInfo->get_ExtendedProperties(&ipExtendedProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISchemaChangeInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISchemaChangeInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISchemaChangeInfo.get_ExtendedProperties() returned %ld", (long)hr);
        goto ischemachangeinfo_get_extendedproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ExtendedProperties);
    if (ipExtendedProperties)
    {
        IUnknown* pUnk = NULL;
        ipExtendedProperties->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ExtendedProperties = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ExtendedProperties)
    {
        if (py_ExtendedProperties)
           Py_DECREF(py_ExtendedProperties);
        py_ExtendedProperties = Py_None;
        Py_INCREF(py_ExtendedProperties);
    }
    if (PyErr_Occurred())
      goto ischemachangeinfo_get_extendedproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ExtendedProperties);
    goto ischemachangeinfo_get_extendedproperties_method_cleanup;

    ischemachangeinfo_get_extendedproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ExtendedProperties);
    if (ipExtendedProperties)
      ipExtendedProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISchemaChangeInfo.get_ExtendedProperties");
    return return_tuple;
}


PyMethodDef PyISchemaChangeInfoMethods[] = {
    {"supports", (PyCFunction)PyISchemaChangeInfo_SupportsInterface, METH_O, ""},
    {"get_SchemaChangeType", (PyCFunction)ISchemaChangeInfoMethod_get_SchemaChangeType, METH_VARARGS, ""},
    {"get_FromObject", (PyCFunction)ISchemaChangeInfoMethod_get_FromObject, METH_VARARGS, ""},
    {"get_ToObject", (PyCFunction)ISchemaChangeInfoMethod_get_ToObject, METH_VARARGS, ""},
    {"get_ToParent", (PyCFunction)ISchemaChangeInfoMethod_get_ToParent, METH_VARARGS, ""},
    {"get_ApplySchemaChange", (PyCFunction)ISchemaChangeInfoMethod_get_ApplySchemaChange, METH_VARARGS, ""},
    {"put_ApplySchemaChange", (PyCFunction)ISchemaChangeInfoMethod_put_ApplySchemaChange, METH_VARARGS, ""},
    {"GetChanges", (PyCFunction)ISchemaChangeInfoMethod_GetChanges, METH_VARARGS, ""},
    {"get_ExtendedProperties", (PyCFunction)ISchemaChangeInfoMethod_get_ExtendedProperties, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISchemaChangeInfoGetSet[] = {
  {"_pUnk", (getter)PyISchemaChangeInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISchemaChangeInfo", NULL},
  {"_pointer", (getter)PyISchemaChangeInfo_GetPointer, NULL, "Get memory address for ISchemaChangeInfo", NULL},
  {"_IID", (getter)PyISchemaChangeInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISchemaChangeInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISchemaChangeInfo_GetIgnoreFailures, (setter)PyISchemaChangeInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISchemaChangeInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseDistributed.ISchemaChangeInfoObject",                          
                                              /* tp_name */
  sizeof(PyISchemaChangeInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISchemaChangeInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISchemaChangeInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISchemaChangeInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISchemaChangeInfoObject_new,                      
                                              /* tp_new */
};





static PyObject*
CoCreateDataChangesExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DataChangesExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DataChangesExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fe5e515a-fc19-45e8-8e2d-46ede0554e52")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fe5e515a-fc19-45e8-8e2d-46ede0554e52");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDataChangesImporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DataChangesImporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DataChangesImporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ce014faf-2b6d-4d74-8177-00980ba739ae")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ce014faf-2b6d-4d74-8177-00980ba739ae");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDataExtraction(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DataExtraction, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DataExtraction");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8ba238f5-aa25-423b-9c59-4ab4988e8bc6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8ba238f5-aa25-423b-9c59-4ab4988e8bc6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDataChanges(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DataChanges, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DataChanges");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a1cb6e77-022b-4886-a41a-7f97aa08a722")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a1cb6e77-022b-4886-a41a-7f97aa08a722");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCheckOutDataChanges(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CheckOutDataChanges, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CheckOutDataChanges");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9fe24070-7df5-4f93-a52d-eb32bcb8bf88")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9fe24070-7df5-4f93-a52d-eb32bcb8bf88");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDeltaDataChanges(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DeltaDataChanges, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DeltaDataChanges");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("50ffe4dc-0e25-4d5b-9bdf-d6a2b3169ca6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "50ffe4dc-0e25-4d5b-9bdf-d6a2b3169ca6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGdbExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GdbExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GdbExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("1143edd2-a736-4129-8345-e237f7bc1b19")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "1143edd2-a736-4129-8345-e237f7bc1b19");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGdbImporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GdbImporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GdbImporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("109ca64f-de77-46f0-9d73-720bff4111a3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "109ca64f-de77-46f0-9d73-720bff4111a3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGdbSchemaCreator(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GdbSchemaCreator, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GdbSchemaCreator");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("3705e682-7e35-4a8d-b4b0-02a8e768c632")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "3705e682-7e35-4a8d-b4b0-02a8e768c632");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateVersionDataChanges(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_VersionDataChanges, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of VersionDataChanges");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("c20cf99c-7021-496b-a0c5-34afc905e5b8")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "c20cf99c-7021-496b-a0c5-34afc905e5b8");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTableDataChangesInfo(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TableDataChangesInfo, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TableDataChangesInfo");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("e7f8c959-e5d8-453d-af20-28c609ccc27d")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "e7f8c959-e5d8-453d-af20-28c609ccc27d");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTablesDataChanges(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TablesDataChanges, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TablesDataChanges");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8bb5759a-ef1f-4119-8eb4-89524aca69e0")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8bb5759a-ef1f-4119-8eb4-89524aca69e0");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateOperationProgress(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_OperationProgress, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of OperationProgress");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("06c8603d-2650-4888-b60b-258d09a46ca4")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "06c8603d-2650-4888-b60b-258d09a46ca4");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateReplicaSchemaExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ReplicaSchemaExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ReplicaSchemaExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("b3c4fbd5-e496-479a-b567-5b2d3e5790ea")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "b3c4fbd5-e496-479a-b567-5b2d3e5790ea");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateReplicaSchemaImporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ReplicaSchemaImporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ReplicaSchemaImporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("82823fc8-f978-4e83-a84e-fff5a96ae6c5")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "82823fc8-f978-4e83-a84e-fff5a96ae6c5");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSchemaChanges(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SchemaChanges, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SchemaChanges");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ed337be8-c03c-4d0b-a29f-727565609b4e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ed337be8-c03c-4d0b-a29f-727565609b4e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSchemaChangeInfo(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SchemaChangeInfo, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SchemaChangeInfo");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("26c46e0a-fea6-498d-aed9-ed0a3eb53cfd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "26c46e0a-fea6-498d-aed9-ed0a3eb53cfd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateReplicasExporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ReplicasExporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ReplicasExporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("6e482c9f-8bbb-4832-9576-ebde86f32ca0")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "6e482c9f-8bbb-4832-9576-ebde86f32ca0");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCheckOut(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CheckOut, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CheckOut");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("de0ddadd-814d-4c8a-acfe-691e499ed8f3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "de0ddadd-814d-4c8a-acfe-691e499ed8f3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCheckIn(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CheckIn, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CheckIn");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("db456bf9-03ac-4a72-9162-1e8fd73de22e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "db456bf9-03ac-4a72-9162-1e8fd73de22e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCheckInDataSynchronizer(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CheckInDataSynchronizer, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CheckInDataSynchronizer");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("0b998a30-b009-41c6-a086-6dc29ba71cd4")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "0b998a30-b009-41c6-a086-6dc29ba71cd4");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateReplicaValidator(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ReplicaValidator, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ReplicaValidator");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fd8c8ade-6425-474e-ae33-70d3f098077a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fd8c8ade-6425-474e-ae33-70d3f098077a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateReplicaProgress(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ReplicaProgress, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ReplicaProgress");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("cbd8cb96-30e1-4f82-8e90-885b86aa8ec9")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "cbd8cb96-30e1-4f82-8e90-885b86aa8ec9");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateReplicationDataChanges(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ReplicationDataChanges, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ReplicationDataChanges");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("0b2a0b89-dc53-43db-b14b-4df0f3f5c0de")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "0b2a0b89-dc53-43db-b14b-4df0f3f5c0de");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateArchivingDataChanges(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ArchivingDataChanges, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ArchivingDataChanges");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2638a9a0-c033-4714-a8ee-e8c9e1c2c0fd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2638a9a0-c033-4714-a8ee-e8c9e1c2c0fd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateReplicaMessageHandler(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ReplicaMessageHandler, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ReplicaMessageHandler");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("bf4e20ad-2bd9-47b2-8256-364dc4548326")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "bf4e20ad-2bd9-47b2-8256-364dc4548326");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGeoDataServerConfigurationFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GeoDataServerConfigurationFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GeoDataServerConfigurationFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("7d7ddcaa-3f9c-4290-9351-3b8ebcef9c65")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "7d7ddcaa-3f9c-4290-9351-3b8ebcef9c65");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGeoDataServer(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GeoDataServer, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GeoDataServer");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a61f2a53-878a-4703-ab50-50fc0b8feeef")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a61f2a53-878a-4703-ab50-50fc0b8feeef");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGDSData(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GDSData, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GDSData");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8b77e69c-2a95-42e3-88e3-22a612b69752")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8b77e69c-2a95-42e3-88e3-22a612b69752");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGDSExportOptions(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GDSExportOptions, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GDSExportOptions");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("14b1aa05-52e9-4a46-8e1f-901da5a9a4f7")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "14b1aa05-52e9-4a46-8e1f-901da5a9a4f7");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGDSQueryResultPortion(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GDSQueryResultPortion, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GDSQueryResultPortion");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a53bea9a-142f-4aa7-82ee-f8c3f7ed9f1b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a53bea9a-142f-4aa7-82ee-f8c3f7ed9f1b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateReplicationAgent(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ReplicationAgent, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ReplicationAgent");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f530afcd-d953-4a5c-a00d-4f6749357f00")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f530afcd-d953-4a5c-a00d-4f6749357f00");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGeoDataServerLP(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GeoDataServerLP, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GeoDataServerLP");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("15bcf3a2-ed45-4d22-a368-9f0123f9f8a9")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "15bcf3a2-ed45-4d22-a368-9f0123f9f8a9");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGeoDataServerIP(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GeoDataServerIP, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GeoDataServerIP");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("74f9a30c-d127-4880-88b9-d79de091b8a6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "74f9a30c-d127-4880-88b9-d79de091b8a6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGeoDataServerObjectDescription(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GeoDataServerObjectDescription, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GeoDataServerObjectDescription");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("60e1a6ae-af1b-4b41-866f-870fd2f607d9")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "60e1a6ae-af1b-4b41-866f-870fd2f607d9");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateWFSServer(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_WFSServer, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of WFSServer");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("e3743059-d297-4c6a-9a4a-30bdf5035f2d")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "e3743059-d297-4c6a-9a4a-30bdf5035f2d");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyMethodDef _esriGeoDatabaseDistributedMethods[] = {
    {"DataChangesExporter", (PyCFunction)CoCreateDataChangesExporter, METH_NOARGS,
     "Create instance of DataChangesExporter\n"},
    {"DataChangesImporter", (PyCFunction)CoCreateDataChangesImporter, METH_NOARGS,
     "Create instance of DataChangesImporter\n"},
    {"DataExtraction", (PyCFunction)CoCreateDataExtraction, METH_NOARGS,
     "Create instance of DataExtraction\n"},
    {"DataChanges", (PyCFunction)CoCreateDataChanges, METH_NOARGS,
     "Create instance of DataChanges\n"},
    {"CheckOutDataChanges", (PyCFunction)CoCreateCheckOutDataChanges, METH_NOARGS,
     "Create instance of CheckOutDataChanges\n"},
    {"DeltaDataChanges", (PyCFunction)CoCreateDeltaDataChanges, METH_NOARGS,
     "Create instance of DeltaDataChanges\n"},
    {"GdbExporter", (PyCFunction)CoCreateGdbExporter, METH_NOARGS,
     "Create instance of GdbExporter\n"},
    {"GdbImporter", (PyCFunction)CoCreateGdbImporter, METH_NOARGS,
     "Create instance of GdbImporter\n"},
    {"GdbSchemaCreator", (PyCFunction)CoCreateGdbSchemaCreator, METH_NOARGS,
     "Create instance of GdbSchemaCreator\n"},
    {"VersionDataChanges", (PyCFunction)CoCreateVersionDataChanges, METH_NOARGS,
     "Create instance of VersionDataChanges\n"},
    {"TableDataChangesInfo", (PyCFunction)CoCreateTableDataChangesInfo, METH_NOARGS,
     "Create instance of TableDataChangesInfo\n"},
    {"TablesDataChanges", (PyCFunction)CoCreateTablesDataChanges, METH_NOARGS,
     "Create instance of TablesDataChanges\n"},
    {"OperationProgress", (PyCFunction)CoCreateOperationProgress, METH_NOARGS,
     "Create instance of OperationProgress\n"},
    {"ReplicaSchemaExporter", (PyCFunction)CoCreateReplicaSchemaExporter, METH_NOARGS,
     "Create instance of ReplicaSchemaExporter\n"},
    {"ReplicaSchemaImporter", (PyCFunction)CoCreateReplicaSchemaImporter, METH_NOARGS,
     "Create instance of ReplicaSchemaImporter\n"},
    {"SchemaChanges", (PyCFunction)CoCreateSchemaChanges, METH_NOARGS,
     "Create instance of SchemaChanges\n"},
    {"SchemaChangeInfo", (PyCFunction)CoCreateSchemaChangeInfo, METH_NOARGS,
     "Create instance of SchemaChangeInfo\n"},
    {"ReplicasExporter", (PyCFunction)CoCreateReplicasExporter, METH_NOARGS,
     "Create instance of ReplicasExporter\n"},
    {"CheckOut", (PyCFunction)CoCreateCheckOut, METH_NOARGS,
     "Create instance of CheckOut\n"},
    {"CheckIn", (PyCFunction)CoCreateCheckIn, METH_NOARGS,
     "Create instance of CheckIn\n"},
    {"CheckInDataSynchronizer", (PyCFunction)CoCreateCheckInDataSynchronizer, METH_NOARGS,
     "Create instance of CheckInDataSynchronizer\n"},
    {"ReplicaValidator", (PyCFunction)CoCreateReplicaValidator, METH_NOARGS,
     "Create instance of ReplicaValidator\n"},
    {"ReplicaProgress", (PyCFunction)CoCreateReplicaProgress, METH_NOARGS,
     "Create instance of ReplicaProgress\n"},
    {"ReplicationDataChanges", (PyCFunction)CoCreateReplicationDataChanges, METH_NOARGS,
     "Create instance of ReplicationDataChanges\n"},
    {"ArchivingDataChanges", (PyCFunction)CoCreateArchivingDataChanges, METH_NOARGS,
     "Create instance of ArchivingDataChanges\n"},
    {"ReplicaMessageHandler", (PyCFunction)CoCreateReplicaMessageHandler, METH_NOARGS,
     "Create instance of ReplicaMessageHandler\n"},
    {"GeoDataServerConfigurationFactory", (PyCFunction)CoCreateGeoDataServerConfigurationFactory, METH_NOARGS,
     "Create instance of GeoDataServerConfigurationFactory\n"},
    {"GeoDataServer", (PyCFunction)CoCreateGeoDataServer, METH_NOARGS,
     "Create instance of GeoDataServer\n"},
    {"GDSData", (PyCFunction)CoCreateGDSData, METH_NOARGS,
     "Create instance of GDSData\n"},
    {"GDSExportOptions", (PyCFunction)CoCreateGDSExportOptions, METH_NOARGS,
     "Create instance of GDSExportOptions\n"},
    {"GDSQueryResultPortion", (PyCFunction)CoCreateGDSQueryResultPortion, METH_NOARGS,
     "Create instance of GDSQueryResultPortion\n"},
    {"ReplicationAgent", (PyCFunction)CoCreateReplicationAgent, METH_NOARGS,
     "Create instance of ReplicationAgent\n"},
    {"GeoDataServerLP", (PyCFunction)CoCreateGeoDataServerLP, METH_NOARGS,
     "Create instance of GeoDataServerLP\n"},
    {"GeoDataServerIP", (PyCFunction)CoCreateGeoDataServerIP, METH_NOARGS,
     "Create instance of GeoDataServerIP\n"},
    {"GeoDataServerObjectDescription", (PyCFunction)CoCreateGeoDataServerObjectDescription, METH_NOARGS,
     "Create instance of GeoDataServerObjectDescription\n"},
    {"WFSServer", (PyCFunction)CoCreateWFSServer, METH_NOARGS,
     "Create instance of WFSServer\n"},
    {NULL, NULL, 0, NULL}
};

extern "C" {

    PyMODINIT_FUNC
    init_esriGeoDatabaseDistributed(void)
    {
        // Import UUID module and keep a global pointer to the UUID object
        PyObject* uuid_module = PyImport_ImportModuleNoBlock("uuid");
        if (!uuid_module)
        {
            PyErr_SetString(PyExc_ImportError, "Could not import UUID module");
            return;
        }
        if (g_pUUID_type)
            Py_DECREF(g_pUUID_type);
        g_pUUID_type = PyObject_GetAttrString(uuid_module, "UUID");

        // Initialize module, make it show up in the right place
        PyObject* module;
        module = Py_InitModule3("cartocomutils._esriGeoDatabaseDistributed",
                                 _esriGeoDatabaseDistributedMethods,
                                "Type library");
        Py_INCREF(module);

        // Add IUnknown base type to parent module so every typelib is using the same
        // Py_Type pointer when typechecking.
        PyObject* parent = PyImport_ImportModuleNoBlock("cartocomutils");
        if (parent)
        {
            if (!PyObject_HasAttrString(parent, "IUnknown"))
            {
                // Bootstrapping
                PyType_Ready(&IUnknownObject_Type);
                PyModule_AddObject(parent, "IUnknown", (PyObject*)(&IUnknownObject_Type));
                // Also probably means we need to coinitialize
                ::CoInitialize(NULL);
            }
            g_pUnk_type = PyObject_GetAttrString(parent, "IUnknown");
            if (!PyObject_HasAttrString(parent, "_IIDMap"))
                PyModule_AddObject(parent, "_IIDMap", PyDict_New());
            if (!PyObject_HasAttrString(parent, "_CLSIDMap"))
                PyModule_AddObject(parent, "_CLSIDMap", PyDict_New());
            g_pIIDMap = PyObject_GetAttrString(parent, "_IIDMap");
            Py_XINCREF(g_pIIDMap);
            // Set global unknown object
            if (g_pUnk_type && g_pIIDMap)
                PyDict_SetItem(g_pIIDMap, PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}"), g_pUnk_type);
            g_pCLSIDMap = PyObject_GetAttrString(parent, "_CLSIDMap");
            Py_XINCREF(g_pCLSIDMap);
            g_pRecordMap = PyObject_GetAttrString(parent, "_RecordMap");
            Py_XINCREF(g_pRecordMap);
            PyErr_Clear();
        }

        // Bulk add all interfaces as objects
        // IModifiedClassInfo
        PyType_Ready(&PyIModifiedClassInfoObject_Type);
        Py_INCREF((PyObject* )&PyIModifiedClassInfoObject_Type);
        PyModule_AddObject(module, "IModifiedClassInfo", 
                           (PyObject *)&PyIModifiedClassInfoObject_Type);

        // IEnumModifiedClassInfo
        PyType_Ready(&PyIEnumModifiedClassInfoObject_Type);
        Py_INCREF((PyObject* )&PyIEnumModifiedClassInfoObject_Type);
        PyModule_AddObject(module, "IEnumModifiedClassInfo", 
                           (PyObject *)&PyIEnumModifiedClassInfoObject_Type);

        // ISchemaChangesInit
        PyType_Ready(&PyISchemaChangesInitObject_Type);
        Py_INCREF((PyObject* )&PyISchemaChangesInitObject_Type);
        PyModule_AddObject(module, "ISchemaChangesInit", 
                           (PyObject *)&PyISchemaChangesInitObject_Type);

        // IXMLDocumentVersion
        PyType_Ready(&PyIXMLDocumentVersionObject_Type);
        Py_INCREF((PyObject* )&PyIXMLDocumentVersionObject_Type);
        PyModule_AddObject(module, "IXMLDocumentVersion", 
                           (PyObject *)&PyIXMLDocumentVersionObject_Type);

        // IReplicaProgress
        PyType_Ready(&PyIReplicaProgressObject_Type);
        Py_INCREF((PyObject* )&PyIReplicaProgressObject_Type);
        PyModule_AddObject(module, "IReplicaProgress", 
                           (PyObject *)&PyIReplicaProgressObject_Type);

        // IOperationProgress
        PyType_Ready(&PyIOperationProgressObject_Type);
        Py_INCREF((PyObject* )&PyIOperationProgressObject_Type);
        PyModule_AddObject(module, "IOperationProgress", 
                           (PyObject *)&PyIOperationProgressObject_Type);

        // IDataExtraction
        PyType_Ready(&PyIDataExtractionObject_Type);
        Py_INCREF((PyObject* )&PyIDataExtractionObject_Type);
        PyModule_AddObject(module, "IDataExtraction", 
                           (PyObject *)&PyIDataExtractionObject_Type);

        // IReplicaDataChanges
        PyType_Ready(&PyIReplicaDataChangesObject_Type);
        Py_INCREF((PyObject* )&PyIReplicaDataChangesObject_Type);
        PyModule_AddObject(module, "IReplicaDataChanges", 
                           (PyObject *)&PyIReplicaDataChangesObject_Type);

        // IReplicaDataChangesInit
        PyType_Ready(&PyIReplicaDataChangesInitObject_Type);
        Py_INCREF((PyObject* )&PyIReplicaDataChangesInitObject_Type);
        PyModule_AddObject(module, "IReplicaDataChangesInit", 
                           (PyObject *)&PyIReplicaDataChangesInitObject_Type);

        // IReplicaDataChangesInit2
        PyType_Ready(&PyIReplicaDataChangesInit2Object_Type);
        Py_INCREF((PyObject* )&PyIReplicaDataChangesInit2Object_Type);
        PyModule_AddObject(module, "IReplicaDataChangesInit2", 
                           (PyObject *)&PyIReplicaDataChangesInit2Object_Type);

        // IDataChanges
        PyType_Ready(&PyIDataChangesObject_Type);
        Py_INCREF((PyObject* )&PyIDataChangesObject_Type);
        PyModule_AddObject(module, "IDataChanges", 
                           (PyObject *)&PyIDataChangesObject_Type);

        // IExportDataChanges
        PyType_Ready(&PyIExportDataChangesObject_Type);
        Py_INCREF((PyObject* )&PyIExportDataChangesObject_Type);
        PyModule_AddObject(module, "IExportDataChanges", 
                           (PyObject *)&PyIExportDataChangesObject_Type);

        // IExportDataChanges2
        PyType_Ready(&PyIExportDataChanges2Object_Type);
        Py_INCREF((PyObject* )&PyIExportDataChanges2Object_Type);
        PyModule_AddObject(module, "IExportDataChanges2", 
                           (PyObject *)&PyIExportDataChanges2Object_Type);

        // IVersionDataChangesInit
        PyType_Ready(&PyIVersionDataChangesInitObject_Type);
        Py_INCREF((PyObject* )&PyIVersionDataChangesInitObject_Type);
        PyModule_AddObject(module, "IVersionDataChangesInit", 
                           (PyObject *)&PyIVersionDataChangesInitObject_Type);

        // IDeltaDataChanges
        PyType_Ready(&PyIDeltaDataChangesObject_Type);
        Py_INCREF((PyObject* )&PyIDeltaDataChangesObject_Type);
        PyModule_AddObject(module, "IDeltaDataChanges", 
                           (PyObject *)&PyIDeltaDataChangesObject_Type);

        // IDeltaDataChanges2
        PyType_Ready(&PyIDeltaDataChanges2Object_Type);
        Py_INCREF((PyObject* )&PyIDeltaDataChanges2Object_Type);
        PyModule_AddObject(module, "IDeltaDataChanges2", 
                           (PyObject *)&PyIDeltaDataChanges2Object_Type);

        // IDeltaDataChangesInit
        PyType_Ready(&PyIDeltaDataChangesInitObject_Type);
        Py_INCREF((PyObject* )&PyIDeltaDataChangesInitObject_Type);
        PyModule_AddObject(module, "IDeltaDataChangesInit", 
                           (PyObject *)&PyIDeltaDataChangesInitObject_Type);

        // IDeltaDataChangesInit2
        PyType_Ready(&PyIDeltaDataChangesInit2Object_Type);
        Py_INCREF((PyObject* )&PyIDeltaDataChangesInit2Object_Type);
        PyModule_AddObject(module, "IDeltaDataChangesInit2", 
                           (PyObject *)&PyIDeltaDataChangesInit2Object_Type);

        // IDeltaDataChangesRelease
        PyType_Ready(&PyIDeltaDataChangesReleaseObject_Type);
        Py_INCREF((PyObject* )&PyIDeltaDataChangesReleaseObject_Type);
        PyModule_AddObject(module, "IDeltaDataChangesRelease", 
                           (PyObject *)&PyIDeltaDataChangesReleaseObject_Type);

        // IGdbXmlExport
        PyType_Ready(&PyIGdbXmlExportObject_Type);
        Py_INCREF((PyObject* )&PyIGdbXmlExportObject_Type);
        PyModule_AddObject(module, "IGdbXmlExport", 
                           (PyObject *)&PyIGdbXmlExportObject_Type);

        // IGdbXmlImport
        PyType_Ready(&PyIGdbXmlImportObject_Type);
        Py_INCREF((PyObject* )&PyIGdbXmlImportObject_Type);
        PyModule_AddObject(module, "IGdbXmlImport", 
                           (PyObject *)&PyIGdbXmlImportObject_Type);

        // IGdbXmlExportEvents
        PyType_Ready(&PyIGdbXmlExportEventsObject_Type);
        Py_INCREF((PyObject* )&PyIGdbXmlExportEventsObject_Type);
        PyModule_AddObject(module, "IGdbXmlExportEvents", 
                           (PyObject *)&PyIGdbXmlExportEventsObject_Type);

        // IGdbSchemaCreator
        PyType_Ready(&PyIGdbSchemaCreatorObject_Type);
        Py_INCREF((PyObject* )&PyIGdbSchemaCreatorObject_Type);
        PyModule_AddObject(module, "IGdbSchemaCreator", 
                           (PyObject *)&PyIGdbSchemaCreatorObject_Type);

        // IDataChanges2
        PyType_Ready(&PyIDataChanges2Object_Type);
        Py_INCREF((PyObject* )&PyIDataChanges2Object_Type);
        PyModule_AddObject(module, "IDataChanges2", 
                           (PyObject *)&PyIDataChanges2Object_Type);

        // IDataChanges3
        PyType_Ready(&PyIDataChanges3Object_Type);
        Py_INCREF((PyObject* )&PyIDataChanges3Object_Type);
        PyModule_AddObject(module, "IDataChanges3", 
                           (PyObject *)&PyIDataChanges3Object_Type);

        // IDataChangesInfo
        PyType_Ready(&PyIDataChangesInfoObject_Type);
        Py_INCREF((PyObject* )&PyIDataChangesInfoObject_Type);
        PyModule_AddObject(module, "IDataChangesInfo", 
                           (PyObject *)&PyIDataChangesInfoObject_Type);

        // IDataChangesExt
        PyType_Ready(&PyIDataChangesExtObject_Type);
        Py_INCREF((PyObject* )&PyIDataChangesExtObject_Type);
        PyModule_AddObject(module, "IDataChangesExt", 
                           (PyObject *)&PyIDataChangesExtObject_Type);

        // IImportDataChanges
        PyType_Ready(&PyIImportDataChangesObject_Type);
        Py_INCREF((PyObject* )&PyIImportDataChangesObject_Type);
        PyModule_AddObject(module, "IImportDataChanges", 
                           (PyObject *)&PyIImportDataChangesObject_Type);

        // IImportDataChanges2
        PyType_Ready(&PyIImportDataChanges2Object_Type);
        Py_INCREF((PyObject* )&PyIImportDataChanges2Object_Type);
        PyModule_AddObject(module, "IImportDataChanges2", 
                           (PyObject *)&PyIImportDataChanges2Object_Type);

        // IImportDataChanges3
        PyType_Ready(&PyIImportDataChanges3Object_Type);
        Py_INCREF((PyObject* )&PyIImportDataChanges3Object_Type);
        PyModule_AddObject(module, "IImportDataChanges3", 
                           (PyObject *)&PyIImportDataChanges3Object_Type);

        // IReplicasExporter
        PyType_Ready(&PyIReplicasExporterObject_Type);
        Py_INCREF((PyObject* )&PyIReplicasExporterObject_Type);
        PyModule_AddObject(module, "IReplicasExporter", 
                           (PyObject *)&PyIReplicasExporterObject_Type);

        // ITableDataChangesInfo
        PyType_Ready(&PyITableDataChangesInfoObject_Type);
        Py_INCREF((PyObject* )&PyITableDataChangesInfoObject_Type);
        PyModule_AddObject(module, "ITableDataChangesInfo", 
                           (PyObject *)&PyITableDataChangesInfoObject_Type);

        // ITablesDataChanges
        PyType_Ready(&PyITablesDataChangesObject_Type);
        Py_INCREF((PyObject* )&PyITablesDataChangesObject_Type);
        PyModule_AddObject(module, "ITablesDataChanges", 
                           (PyObject *)&PyITablesDataChangesObject_Type);

        // IEnumTableDataChanges
        PyType_Ready(&PyIEnumTableDataChangesObject_Type);
        Py_INCREF((PyObject* )&PyIEnumTableDataChangesObject_Type);
        PyModule_AddObject(module, "IEnumTableDataChanges", 
                           (PyObject *)&PyIEnumTableDataChangesObject_Type);

        // ICheckOut
        PyType_Ready(&PyICheckOutObject_Type);
        Py_INCREF((PyObject* )&PyICheckOutObject_Type);
        PyModule_AddObject(module, "ICheckOut", 
                           (PyObject *)&PyICheckOutObject_Type);

        // ICheckIn
        PyType_Ready(&PyICheckInObject_Type);
        Py_INCREF((PyObject* )&PyICheckInObject_Type);
        PyModule_AddObject(module, "ICheckIn", 
                           (PyObject *)&PyICheckInObject_Type);

        // ICheckIn2
        PyType_Ready(&PyICheckIn2Object_Type);
        Py_INCREF((PyObject* )&PyICheckIn2Object_Type);
        PyModule_AddObject(module, "ICheckIn2", 
                           (PyObject *)&PyICheckIn2Object_Type);

        // ICheckInDataSynchronizer
        PyType_Ready(&PyICheckInDataSynchronizerObject_Type);
        Py_INCREF((PyObject* )&PyICheckInDataSynchronizerObject_Type);
        PyModule_AddObject(module, "ICheckInDataSynchronizer", 
                           (PyObject *)&PyICheckInDataSynchronizerObject_Type);

        // ICheckInDataSynchronizer2
        PyType_Ready(&PyICheckInDataSynchronizer2Object_Type);
        Py_INCREF((PyObject* )&PyICheckInDataSynchronizer2Object_Type);
        PyModule_AddObject(module, "ICheckInDataSynchronizer2", 
                           (PyObject *)&PyICheckInDataSynchronizer2Object_Type);

        // IReplicaValidation
        PyType_Ready(&PyIReplicaValidationObject_Type);
        Py_INCREF((PyObject* )&PyIReplicaValidationObject_Type);
        PyModule_AddObject(module, "IReplicaValidation", 
                           (PyObject *)&PyIReplicaValidationObject_Type);

        // IReplicaValidation2
        PyType_Ready(&PyIReplicaValidation2Object_Type);
        Py_INCREF((PyObject* )&PyIReplicaValidation2Object_Type);
        PyModule_AddObject(module, "IReplicaValidation2", 
                           (PyObject *)&PyIReplicaValidation2Object_Type);

        // IReplicaMessageHandler
        PyType_Ready(&PyIReplicaMessageHandlerObject_Type);
        Py_INCREF((PyObject* )&PyIReplicaMessageHandlerObject_Type);
        PyModule_AddObject(module, "IReplicaMessageHandler", 
                           (PyObject *)&PyIReplicaMessageHandlerObject_Type);

        // IReplicaMessageHandler2
        PyType_Ready(&PyIReplicaMessageHandler2Object_Type);
        Py_INCREF((PyObject* )&PyIReplicaMessageHandler2Object_Type);
        PyModule_AddObject(module, "IReplicaMessageHandler2", 
                           (PyObject *)&PyIReplicaMessageHandler2Object_Type);

        // IGDSData
        PyType_Ready(&PyIGDSDataObject_Type);
        Py_INCREF((PyObject* )&PyIGDSDataObject_Type);
        PyModule_AddObject(module, "IGDSData", 
                           (PyObject *)&PyIGDSDataObject_Type);

        // IGDSExportOptions
        PyType_Ready(&PyIGDSExportOptionsObject_Type);
        Py_INCREF((PyObject* )&PyIGDSExportOptionsObject_Type);
        PyModule_AddObject(module, "IGDSExportOptions", 
                           (PyObject *)&PyIGDSExportOptionsObject_Type);

        // IGDSQueryResultPortion
        PyType_Ready(&PyIGDSQueryResultPortionObject_Type);
        Py_INCREF((PyObject* )&PyIGDSQueryResultPortionObject_Type);
        PyModule_AddObject(module, "IGDSQueryResultPortion", 
                           (PyObject *)&PyIGDSQueryResultPortionObject_Type);

        // IGeoDataServer
        PyType_Ready(&PyIGeoDataServerObject_Type);
        Py_INCREF((PyObject* )&PyIGeoDataServerObject_Type);
        PyModule_AddObject(module, "IGeoDataServer", 
                           (PyObject *)&PyIGeoDataServerObject_Type);

        // IGeoDataServerInit
        PyType_Ready(&PyIGeoDataServerInitObject_Type);
        Py_INCREF((PyObject* )&PyIGeoDataServerInitObject_Type);
        PyModule_AddObject(module, "IGeoDataServerInit", 
                           (PyObject *)&PyIGeoDataServerInitObject_Type);

        // IGeoDataServerObjects
        PyType_Ready(&PyIGeoDataServerObjectsObject_Type);
        Py_INCREF((PyObject* )&PyIGeoDataServerObjectsObject_Type);
        PyModule_AddObject(module, "IGeoDataServerObjects", 
                           (PyObject *)&PyIGeoDataServerObjectsObject_Type);

        // IReplicationAgent
        PyType_Ready(&PyIReplicationAgentObject_Type);
        Py_INCREF((PyObject* )&PyIReplicationAgentObject_Type);
        PyModule_AddObject(module, "IReplicationAgent", 
                           (PyObject *)&PyIReplicationAgentObject_Type);

        // IReplicationAgentCancelControl
        PyType_Ready(&PyIReplicationAgentCancelControlObject_Type);
        Py_INCREF((PyObject* )&PyIReplicationAgentCancelControlObject_Type);
        PyModule_AddObject(module, "IReplicationAgentCancelControl", 
                           (PyObject *)&PyIReplicationAgentCancelControlObject_Type);

        // IGDSData2
        PyType_Ready(&PyIGDSData2Object_Type);
        Py_INCREF((PyObject* )&PyIGDSData2Object_Type);
        PyModule_AddObject(module, "IGDSData2", 
                           (PyObject *)&PyIGDSData2Object_Type);

        // IGeoDataServer2
        PyType_Ready(&PyIGeoDataServer2Object_Type);
        Py_INCREF((PyObject* )&PyIGeoDataServer2Object_Type);
        PyModule_AddObject(module, "IGeoDataServer2", 
                           (PyObject *)&PyIGeoDataServer2Object_Type);

        // IReplicationAgent2
        PyType_Ready(&PyIReplicationAgent2Object_Type);
        Py_INCREF((PyObject* )&PyIReplicationAgent2Object_Type);
        PyModule_AddObject(module, "IReplicationAgent2", 
                           (PyObject *)&PyIReplicationAgent2Object_Type);

        // IWFSServer
        PyType_Ready(&PyIWFSServerObject_Type);
        Py_INCREF((PyObject* )&PyIWFSServerObject_Type);
        PyModule_AddObject(module, "IWFSServer", 
                           (PyObject *)&PyIWFSServerObject_Type);

        // IExportSchema
        PyType_Ready(&PyIExportSchemaObject_Type);
        Py_INCREF((PyObject* )&PyIExportSchemaObject_Type);
        PyModule_AddObject(module, "IExportSchema", 
                           (PyObject *)&PyIExportSchemaObject_Type);

        // ISchemaChanges
        PyType_Ready(&PyISchemaChangesObject_Type);
        Py_INCREF((PyObject* )&PyISchemaChangesObject_Type);
        PyModule_AddObject(module, "ISchemaChanges", 
                           (PyObject *)&PyISchemaChangesObject_Type);

        // IImportSchema
        PyType_Ready(&PyIImportSchemaObject_Type);
        Py_INCREF((PyObject* )&PyIImportSchemaObject_Type);
        PyModule_AddObject(module, "IImportSchema", 
                           (PyObject *)&PyIImportSchemaObject_Type);

        // IEnumSchemaChange
        PyType_Ready(&PyIEnumSchemaChangeObject_Type);
        Py_INCREF((PyObject* )&PyIEnumSchemaChangeObject_Type);
        PyModule_AddObject(module, "IEnumSchemaChange", 
                           (PyObject *)&PyIEnumSchemaChangeObject_Type);

        // ISchemaChangeInfo
        PyType_Ready(&PyISchemaChangeInfoObject_Type);
        Py_INCREF((PyObject* )&PyISchemaChangeInfoObject_Type);
        PyModule_AddObject(module, "ISchemaChangeInfo", 
                           (PyObject *)&PyISchemaChangeInfoObject_Type);


        // Bulk add all the IID_* CLSID_* from this type lib
        if (g_pUUID_type)
        {
            // guids registration for interfaces
            if (g_pIIDMap)
            {
// Disabled for now, done in the .py file
            }

            // clsids registration for known coclasses
            if (g_pCLSIDMap)
            {
// Disabled for now, done in the .py file
            }
        }
        Py_XDECREF(g_pIIDMap);
        Py_XDECREF(g_pCLSIDMap);
    }

}
